!% $ZCODE_LESS_DICT_DATA=1;
!% $OMIT_UNUSED_ROUTINES=1;
!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=1000000
!% $MAX_STATIC_DATA=500000
!% $MAX_NUM_STATIC_STRINGS=500000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256
!% $DICT_WORD_SIZE=15
Constant Grammar__Version 2;
Global debug_flag;
Global or_tmp_var;
Attribute absent;
Attribute animate;
Attribute clothing;
Attribute concealed;
Attribute container;
Attribute door;
Attribute edible;
Attribute enterable;
Attribute light;
Attribute lockable;
Attribute locked;
Attribute moved;
Attribute on;
Attribute open;
Attribute openable;
Attribute scenery;
Attribute static;
Attribute supporter;
Attribute switchable;
Attribute talkable;
Attribute transparent;
Attribute visited;
Attribute worn;
Attribute male;
Attribute female;
Attribute neuter;
Attribute pluralname;
Attribute ambigpluralname;
Attribute proper;
Attribute remove_proper;
Attribute privately_named;
Attribute mentioned;
Attribute pushable;
Attribute mark_as_room;
Attribute mark_as_thing;
Attribute workflag;
Attribute workflag2;
Attribute P_scored;
Attribute P_indoors;
Attribute P_broken;
Attribute P_seen;
Attribute P_filled;
Attribute P_lost;
Property add_to_scope;
Property article;
Property capacity;
Property component_child;
Property component_parent;
Property component_sibling;
Property description;
Property door_dir;
Property door_to;
Property found_in;
Property initial;
Property list_together;
Property map_region;
Property parse_name;
Property plural;
Property regional_found_in;
Property room_index;
Property short_name;
Property saved_short_name;
Property vector;
Property with_key;
Property KD_Count;
Property IK1_Count;
Property IK2_Count;
Property IK4_Count;
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;
Property IK3_Count;
Property IK1_link;
Property IK2_link;
Property IK5_link;
Property IK6_link;
Property IK8_link;
Property articles;
Property grammar;
Property inside_description;
Property short_name_indef;
Global right_alignment_depth = 14;
Global unicode_gestalt_ok = 0;
Global formal_rv = 0;
Global formal_par0 = 0;
Global formal_par1 = 0;
Global formal_par2 = 0;
Global formal_par3 = 0;
Global formal_par4 = 0;
Global formal_par5 = 0;
Global formal_par6 = 0;
Global formal_par7 = 0;
Global unicode_temp = 0;
Global I7SFRAME = 0;
Global TEXT_TY_RE_Err = 0;
Global prior_named_noun = 0;
Global prior_named_list = 0;
Global prior_named_list_gender = 0;
Global story_tense = 1;
Global story_viewpoint = 2;
Global say__p = 1;
Global say__pc = 0;
Global say__pc_save = 0;
Global say__n = 0;
Global say__comp = 0;
Global los_rv = 0;
Global parameter_object = 0;
Global parameter_value = 0;
Global property_to_be_totalled = 0;
Global property_loop_sign = 0;
Global suppress_scope_loops = 0;
Global temporary_value = 0;
Global clr_fg = 1;
Global clr_bg = 1;
Global clr_fgstatus = 1;
Global clr_bgstatus = 1;
Global clr_on = 0;
Global statuswin_current = 0;
Global suppress_text_substitution = 0;
Global deadflag = 0;
Global statuswin_cursize = 0;
Global statuswin_size = 1;
Global debug_rules = 0;
Global debug_rule_nesting = 0;
Global reason_the_action_failed = 0;
Global indef_mode = 0;
Global standard_interpreter = 0;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;
Global I7S_Tab = 0;
Global I7S_Col = 0;
Global I7S_Dir = 0;
Global I7S_Swap = 0;
Global I7S_Comp = 0;
Global MStack_Top = 0;
Global MStack_Frame_Extent = 0;
Global process_rulebook_count = 0;
Global debugging_rules = 0;
Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;
Global TEXT_TY_CastPrimitiveNesting = 0;
Global TEXT_TY_RE_Trace = 0;
Global TEXT_TY_RE_RewindCount = 0;
Global LIST_OF_TY_Sort_cf = 0;
Global location = 0;
Global sline1 = 0;
Global sline2 = 0;
Global undo_flag = 0;
Global story_complete = 0;
Global resurrect_please = 0;
Global not_yet_in_play = 1;
Global turns = 1;
Global the_time = NULL;
Global time_rate = 1;
Global score = 0;
Global last_score = 0;
Global notify_mode = 1;
Global left_hand_status_line = T_SL_Location;
Global right_hand_status_line = T_SL_Score_Moves;
Global player = 0;
Global real_location = 0;
Global visibility_ceiling = 0;
Global visibility_levels = 0;
Global SACK_OBJECT = 0;
Global act_requester = 0;
Global actor = 0;
Global actors_location = 0;
Global actor_location = 0;
Global action = 0;
Global meta = 0;
Global inp1 = 0;
Global inp2 = 0;
Global toomany_flag = 0;
Global multiflag = 0;
Global multiple_object_item = 0;
Global noun = 0;
Global second = 0;
Global keep_silent = 0;
Global trace_actions = 0;
Global untouchable_object = 0;
Global untouchable_silence = 0;
Global touch_persona = 0;
Global special_word = 0;
Global consult_from = 0;
Global consult_words = 0;
Global parsed_number = 0;
Global special_number1 = 0;
Global special_number2 = 0;
Global parser_trace = 0;
Global pronoun_word = 0;
Global pronoun_obj = 0;
Global players_command = 100;
Global matched_text = 0;
Global understand_as_mistake_number = 0;
Global particular_possession = 0;
Global parser_action = 0;
Global parser_one = 0;
Global parser_two = 0;
Global parameters = 0;
Global action_to_be = 0;
Global action_reversed = 0;
Global wn = 0;
Global num_words = 0;
Global verb_word = 0;
Global verb_wordnum = 0;
Global scope_reason = PARSING_REASON;
Global scope_token = 0;
Global scope_error = 0;
Global scope_stage = 0;
Global advance_warning = 0;
Global reason_code = NULL;
Global ats_flag = 0;
Global ats_hls = 0;
Global move_pushing = 0;
Global move_from = 0;
Global move_to = 0;
Global move_by = 0;
Global move_through = 0;
Global lookmode = KIT_CONFIGURATION_LOOKMODE;
Global c_style = 0;
Global c_depth = 0;
Global c_iterator = 0;
Global lt_value = EMPTY_TEXT_VALUE;
Global listing_together = 0;
Global listing_size = 0;
Global c_margin = 0;
Global inventory_stage = 1;
Global debug_scenes = 0;
Global MAX_SCORE = INITIAL_MAX_SCORE;
Global lightflag = 0;
Global requisition_stack_pointer = 0;
Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;
Global list_filter_routine = 0;
Global EarlyInTurnSequence = 0;
Global IterationsOfTurnSequence = 0;
Global time_step = 0;
Global converted_action_outcome = -1;
Global activities_sp = 0;
Global inhibit_flag = 0;
Global saved_debug_rules = 0;
Global pending_boxed_quotation = 0;
Global caps_mode = 0;
Global short_name_case = 0;
Global map_has_changed = 1;
Global last_filter = 0;
Global last_use_doors = 0;
Global etype = 0;
Global best_etype = 0;
Global nextbest_etype = 0;
Global parser_inflection = 0;
Global indirect_parser_inflection = 0;
Global pcount = 0;
Global pcount2 = 0;
Global nsns = 0;
Global params_wanted = 0;
Global inferfrom = 0;
Global inferword = 0;
Global dont_infer_pronoun = 0;
Global dont_infer = 0;
Global cobj_flag = 0;
Global oops_from = 0;
Global saved_oops = 0;
Global held_back_mode = 0;
Global hb_wn = 0;
Global usual_grammar_after = 0;
Global found_ttype = 0;
Global found_tdata = 0;
Global token_filter = 0;
Global length_of_noun = 0;
Global lookahead = 0;
Global multi_mode = 0;
Global multi_wanted = 0;
Global multi_had = 0;
Global multi_context = 0;
Global indef_type = 0;
Global indef_wanted = 0;
Global indef_guess_p = 0;
Global indef_owner = 0;
Global indef_cases = 0;
Global indef_possambig = 0;
Global indef_nspec_at = 0;
Global allow_plurals = 0;
Global take_all_rule = 0;
Global dict_flags_of_noun = 0;
Global pronoun__word = 0;
Global pronoun__obj = 0;
Global number_matched = 0;
Global number_of_classes = 0;
Global match_length = 0;
Global match_from = 0;
Global parsetoken_nesting = 0;
Array Global_Vars --> 0
  (0) ! -->1 = V74_number_understood (V74_number_understood)
  (0) ! -->2 = V75_real_number_understood (V75_real_number_understood)
  (0) ! -->3 = V76_truth_state_understood (V76_truth_state_understood)
  (0) ! -->4 = V77_external_file_understood (V77_external_file_understood)
  (540) ! -->5 = V78_time_understood (V78_time_understood)
  (I_entire_game_U1) ! -->6 = V79_scene_understood (V79_scene_understood)
  (I_figure_of_cover_U1) ! -->7 = V80_figure_name_understood (V80_figure_name_understood)
  (I_sound_of_strongman_bell_U1) ! -->8 = V81_sound_name_understood (V81_sound_name_understood)
  (I_english_language_U1) ! -->9 = V82_natural_language_understo (V82_natural_language_understo)
  (I_present_tense_U1) ! -->10 = V83_grammatical_tense_underst (V83_grammatical_tense_underst)
  (I_first_person_singular_U1) ! -->11 = V84_narrative_viewpoint_under (V84_narrative_viewpoint_under)
  (I_nominative_U1) ! -->12 = V85_grammatical_case_understo (V85_grammatical_case_understo)
  (I_neuter_gender_U1) ! -->13 = V86_grammatical_gender_unders (V86_grammatical_gender_unders)
  (I_didn_t_understand_error_U1) ! -->14 = V87_command_parser_error_unde (V87_command_parser_error_unde)
  (I_brief_U1) ! -->15 = V88_verbosity_understood (V88_verbosity_understood)
  (0) ! -->16 = V89_price_understood (V89_price_understood)
  (0) ! -->17 = V90_volume_understood (V90_volume_understood)
  (I_water_U1) ! -->18 = V91_liquid_understood (V91_liquid_understood)
  (I_weakling_U1) ! -->19 = V92_strength_pattern_understo (V92_strength_pattern_understo)
  (I_english_language_U1) ! -->20 = V1_language_of_play (V1_language_of_play)
  (0) ! -->21 = V12_darkness_witnessed (V12_darkness_witnessed)
  (bc_U152) ! -->22 = V26_command_prompt (V26_command_prompt)
  (bc_U153) ! -->23 = V31_story_author (V31_story_author)
  (bc_U154) ! -->24 = V32_story_headline (V32_story_headline)
  (bc_U155) ! -->25 = V33_story_genre (V33_story_genre)
  (bc_U156) ! -->26 = V34_story_description (V34_story_description)
  (104) ! -->27 = V35_release_number (V35_release_number)
  (2024) ! -->28 = V36_story_creation_year (V36_story_creation_year)
  (0) ! -->29 = V43_locale_paragraph_count (V43_locale_paragraph_count)
  (I_parking_lot_U1) ! -->30 = V44_room_gone_from (V44_room_gone_from)
  (0) ! -->31 = V45_room_gone_to (V45_room_gone_to)
  (0) ! -->32 = V46_door_gone_through (V46_door_gone_through)
  (0) ! -->33 = V47_vehicle_gone_by (V47_vehicle_gone_by)
  (0) ! -->34 = V48_thing_gone_with (V48_thing_gone_with)
  (0) ! -->35 = V49_container_exited_from (V49_container_exited_from)
  (##Wait) ! -->36 = V50_room_describing_action (V50_room_describing_action)
  (0) ! -->37 = V51_abbreviated_form_allowed (V51_abbreviated_form_allowed)
  (0) ! -->38 = V52_visibility_level_count (V52_visibility_level_count)
  (0) ! -->39 = V53_visibility_ceiling (V53_visibility_ceiling)
  (0) ! -->40 = V54_examine_text_printed (V54_examine_text_printed)
  (selfobj) ! -->41 = V93_actor (V93_actor)
  (0) ! -->42 = V94_action_in_world (V94_action_in_world)
  (0) ! -->43 = V95_action_keeping_silent (V95_action_keeping_silent)
  (0) ! -->44 = V96_specific_check_rulebook (V96_specific_check_rulebook)
  (0) ! -->45 = V97_specific_carry_out_rulebo (V97_specific_carry_out_rulebo)
  (0) ! -->46 = V98_specific_report_rulebook (V98_specific_report_rulebook)
  (0) ! -->47 = V99_within_the_player_s_sight (V99_within_the_player_s_sight)
  (0) ! -->48 = V56_key_unlocked_with (V56_key_unlocked_with)
  (0) ! -->49 = V57_key_locked_with (V57_key_locked_with)
  (table_data_U3) ! -->50 = V58_status_bar_table (V58_status_bar_table)
  (0) ! -->51 = V60_menu_depth (V60_menu_depth)
  (0) ! -->52 = V61_endnode_flag (V61_endnode_flag)
  (bc_U175) ! -->53 = V62_current_menu_title (V62_current_menu_title)
  (table_data_U4) ! -->54 = V63_current_menu (V63_current_menu)
  (1) ! -->55 = V64_current_menu_selection (V64_current_menu_selection)
  (0) ! -->56 = V65_dark_terminus_count (V65_dark_terminus_count)
  (0) ! -->57 = V66_points_awarded_eleven (V66_points_awarded_eleven)
  (0) ! -->58 = V67_points_awarded_nine (V67_points_awarded_nine)
  (0) ! -->59 = V68_points_awarded_seven (V68_points_awarded_seven)
  (0) ! -->60 = V69_points_awarded_five (V69_points_awarded_five)
  (0) ! -->61 = V70_points_awarded_three (V70_points_awarded_three)
  (0) ! -->62 = V71_points_awarded_one (V71_points_awarded_one)
  (0) ! -->63 = V72_switch_count (V72_switch_count)
  (0) ! -->64 = V73_dial_count (V73_dial_count)
;
Constant subterfuge_1 = absent;
Constant subterfuge_2 = animate;
Constant subterfuge_3 = clothing;
Constant subterfuge_4 = concealed;
Constant subterfuge_5 = container;
Constant subterfuge_6 = door;
Constant subterfuge_7 = edible;
Constant subterfuge_8 = enterable;
Constant subterfuge_9 = light;
Constant subterfuge_10 = lockable;
Constant subterfuge_11 = locked;
Constant subterfuge_12 = moved;
Constant subterfuge_13 = on;
Constant subterfuge_14 = open;
Constant subterfuge_15 = openable;
Constant subterfuge_16 = scenery;
Constant subterfuge_17 = static;
Constant subterfuge_18 = supporter;
Constant subterfuge_19 = switchable;
Constant subterfuge_20 = talkable;
Constant subterfuge_21 = transparent;
Constant subterfuge_22 = visited;
Constant subterfuge_23 = worn;
Constant subterfuge_24 = male;
Constant subterfuge_25 = female;
Constant subterfuge_26 = neuter;
Constant subterfuge_27 = pluralname;
Constant subterfuge_28 = ambigpluralname;
Constant subterfuge_29 = proper;
Constant subterfuge_30 = remove_proper;
Constant subterfuge_31 = privately_named;
Constant subterfuge_32 = mentioned;
Constant subterfuge_33 = pushable;
Constant subterfuge_34 = mark_as_room;
Constant subterfuge_35 = mark_as_thing;
Constant subterfuge_36 = workflag;
Constant subterfuge_37 = workflag2;
Constant subterfuge_38 = add_to_scope;
Constant subterfuge_39 = article;
Constant subterfuge_40 = capacity;
Constant subterfuge_41 = component_child;
Constant subterfuge_42 = component_parent;
Constant subterfuge_43 = component_sibling;
Constant subterfuge_44 = description;
Constant subterfuge_45 = door_dir;
Constant subterfuge_46 = door_to;
Constant subterfuge_47 = found_in;
Constant subterfuge_48 = initial;
Constant subterfuge_49 = list_together;
Constant subterfuge_50 = map_region;
Constant subterfuge_51 = parse_name;
Constant subterfuge_52 = plural;
Constant subterfuge_53 = regional_found_in;
Constant subterfuge_54 = room_index;
Constant subterfuge_55 = short_name;
Constant subterfuge_56 = saved_short_name;
Constant subterfuge_57 = vector;
Constant subterfuge_58 = with_key;
Constant subterfuge_59 = KD_Count;
Constant subterfuge_60 = IK1_Count;
Constant subterfuge_61 = IK2_Count;
Constant subterfuge_62 = IK4_Count;
Constant subterfuge_63 = IK5_Count;
Constant subterfuge_64 = IK6_Count;
Constant subterfuge_65 = IK8_Count;
Constant subterfuge_66 = IK3_Count;
Constant subterfuge_67 = IK1_link;
Constant subterfuge_68 = IK2_link;
Constant subterfuge_69 = IK5_link;
Constant subterfuge_70 = IK6_link;
Constant subterfuge_71 = IK8_link;
Constant subterfuge_72 = articles;
Constant subterfuge_73 = grammar;
Constant subterfuge_74 = inside_description;
Constant subterfuge_75 = short_name_indef;
Constant subterfuge_76 = cap_short_name;
Constant subterfuge_77 = before;
Constant subterfuge_78 = action_bitmap;
Constant subterfuge_79 = name;
Constant subterfuge_80 = P_variable_initial_value;
Constant subterfuge_81 = P_specification;
Constant subterfuge_82 = P_indefinite_appearance_text;
Constant subterfuge_83 = P_adaptive_text_viewpoint;
Constant subterfuge_84 = P_opposite;
Constant subterfuge_85 = P_recurring;
Constant subterfuge_86 = K1_room_Next;
Constant subterfuge_87 = K2_thing_Next;
Constant subterfuge_88 = K3_direction_Next;
Constant subterfuge_89 = K4_door_Next;
Constant subterfuge_90 = K5_container_Next;
Constant subterfuge_91 = K6_supporter_Next;
Constant subterfuge_92 = IK7_Count;
Constant subterfuge_93 = K7_backdrop_Next;
Constant subterfuge_94 = K8_person_Next;
Constant subterfuge_95 = IK9_Count;
Constant subterfuge_96 = K9_region_Next;
Constant subterfuge_97 = IK10_Count;
Constant subterfuge_98 = K10_man_Next;
Constant subterfuge_99 = K11_woman_Count;
Constant subterfuge_100 = K11_woman_Next;
Constant subterfuge_101 = K12_animal_Count;
Constant subterfuge_102 = K12_animal_Next;
Constant subterfuge_103 = K13_device_Count;
Constant subterfuge_104 = K13_device_Next;
Constant subterfuge_105 = K14_vehicle_Count;
Constant subterfuge_106 = K14_vehicle_Next;
Constant subterfuge_107 = K15_player_s_holdall_Count;
Constant subterfuge_108 = K15_player_s_holdall_Next;
Constant subterfuge_109 = K16_passkey_Count;
Constant subterfuge_110 = K16_passkey_Next;
Constant subterfuge_111 = K17_keychain_Count;
Constant subterfuge_112 = K17_keychain_Next;
Constant subterfuge_113 = P_unbolting_relation_storage;
Constant subterfuge_114 = K18_rideable_animal_Count;
Constant subterfuge_115 = K18_rideable_animal_Next;
Constant subterfuge_116 = K19_rideable_vehicle_Count;
Constant subterfuge_117 = K19_rideable_vehicle_Next;
Constant subterfuge_118 = K20_fluid_container_Count;
Constant subterfuge_119 = K20_fluid_container_Next;
Constant subterfuge_120 = K21_electric_lamp_Count;
Constant subterfuge_121 = K21_electric_lamp_Next;
Constant subterfuge_122 = K22_switch_Count;
Constant subterfuge_123 = K22_switch_Next;
Constant subterfuge_124 = K23_socket_Count;
Constant subterfuge_125 = K23_socket_Next;
Constant subterfuge_126 = K24_colored_fuse_Count;
Constant subterfuge_127 = K24_colored_fuse_Next;
Constant subterfuge_128 = K25_colored_light_Count;
Constant subterfuge_129 = K25_colored_light_Next;
Constant subterfuge_130 = K26_colored_button_Count;
Constant subterfuge_131 = K26_colored_button_Next;
Constant subterfuge_132 = K27_colored_dial_Count;
Constant subterfuge_133 = K27_colored_dial_Next;
Constant subterfuge_134 = P_scored;
Constant subterfuge_135 = P_indoors;
Constant subterfuge_136 = P_price;
Constant subterfuge_137 = P_broken;
Constant subterfuge_138 = P_seen;
Constant subterfuge_139 = P_fluid_capacity;
Constant subterfuge_140 = P_current_volume;
Constant subterfuge_141 = P_liquid;
Constant subterfuge_142 = P_filled;
Constant subterfuge_143 = P_lost;
Constant subterfuge_144 = P_dial_setting;
Constant subterfuge_145 = P_underlying_relation_storag;
Constant I_english_language_U1 = 1;
Constant I_french_language_U1 = 2;
Constant I_german_language_U1 = 3;
Constant I_italian_language_U1 = 4;
Constant I_spanish_language_U1 = 5;
Constant I_swedish_language_U1 = 6;
Constant I_present_tense_U1 = 1;
Constant I_past_tense_U1 = 2;
Constant I_perfect_tense_U1 = 3;
Constant I_past_perfect_tense_U1 = 4;
Constant I_future_tense_U1 = 5;
Constant I_first_person_singular_U1 = 1;
Constant I_second_person_singular_U1 = 2;
Constant I_third_person_singular_U1 = 3;
Constant I_first_person_plural_U1 = 4;
Constant I_second_person_plural_U1 = 5;
Constant I_third_person_plural_U1 = 6;
Constant I_nominative_U1 = 1;
Constant I_accusative_U1 = 2;
Constant I_neuter_gender_U1 = 1;
Constant I_masculine_gender_U1 = 2;
Constant I_feminine_gender_U1 = 3;
Constant I_figure_of_cover_U1 = 1;
Constant I_entire_game_U1 = 1;
Constant I_didn_t_understand_error_U1 = 1;
Constant I_only_understood_as_far_as__U1 = 2;
Constant I_didn_t_understand_that_num_U1 = 3;
Constant I_can_only_do_that_to_someth_U1 = 4;
Constant I_can_t_see_any_such_thing_e_U1 = 5;
Constant I_said_too_little_error_U1 = 6;
Constant I_aren_t_holding_that_error_U1 = 7;
Constant I_can_t_use_multiple_objects_U1 = 8;
Constant I_can_only_use_multiple_obje_U1 = 9;
Constant I_not_sure_what_it_refers_to_U1 = 10;
Constant I_excepted_something_not_inc_U1 = 11;
Constant I_not_a_verb_i_recognise_err_U1 = 12;
Constant I_not_something_you_need_to__U1 = 13;
Constant I_can_t_see_it_at_the_moment_U1 = 14;
Constant I_didn_t_understand_the_way__U1 = 15;
Constant I_not_enough_of_those_availa_U1 = 16;
Constant I_nothing_to_do_error_U1 = 17;
Constant I_referred_to_a_determinatio_U1 = 18;
Constant I_noun_did_not_make_sense_in_U1 = 19;
Constant I_i_beg_your_pardon_error_U1 = 20;
Constant I_can_t_again_the_addressee__U1 = 21;
Constant I_comma_can_t_begin_error_U1 = 22;
Constant I_can_t_see_whom_to_talk_to__U1 = 23;
Constant I_can_t_talk_to_inanimate_th_U1 = 24;
Constant I_didn_t_understand_addresse_U1 = 25;
Constant I_brief_U1 = 1;
Constant I_verbose_U1 = 2;
Constant I_superbrief_U1 = 3;
Constant I_water_U1 = 1;
Constant I_cola_U1 = 2;
Constant I_milk_U1 = 3;
Constant I_lemonade_U1 = 4;
Constant I_iced_tea_U1 = 5;
Constant I_figure_of_hell_ride_U1 = 2;
Constant I_figure_of_midway_U1 = 3;
Constant I_figure_of_ticketbooth_U1 = 4;
Constant I_figure_of_concessionstand_U1 = 5;
Constant I_figure_of_littleegyptfacad_U1 = 6;
Constant I_figure_of_littleegyptshow_U1 = 7;
Constant I_figure_of_highstriker_U1 = 8;
Constant I_figure_of_hellrideentrance_U1 = 9;
Constant I_figure_of_controlpanel_U1 = 10;
Constant I_figure_of_controlpanelstoc_U1 = 11;
Constant I_figure_of_controlpanelgall_U1 = 12;
Constant I_figure_of_controlpanelstak_U1 = 13;
Constant I_figure_of_controlpaneldung_U1 = 14;
Constant I_figure_of_controlpanelguil_U1 = 15;
Constant I_figure_of_controlpanelexit_U1 = 16;
Constant I_figure_of_coupon_U1 = 17;
Constant I_sound_of_strongman_bell_U1 = 1;
Constant I_weakling_U1 = 1;
Constant I_getting_stronger_U1 = 2;
Constant I_average_U1 = 3;
Constant I_almost_there_U1 = 4;
Constant I_muscle_man_U1 = 5;
Constant I_littleegyptauto_U1 = 2;
Constant I_hellrideauto_U1 = 3;
Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
Constant REPARSE_CODE = 1073741824;
Constant VERB_DIRECTIVE_META = 1;
Constant VERB_DIRECTIVE_NOUN_FILTER = 1;
Constant VERB_DIRECTIVE_SCOPE_FILTER = 1;
Constant VERB_DIRECTIVE_REVERSE = 1;
Constant VERB_DIRECTIVE_SLASH = 1;
Constant VERB_DIRECTIVE_DIVIDER = 1;
Constant VERB_DIRECTIVE_RESULT = 2;
Constant VERB_DIRECTIVE_SPECIAL = 3;
Constant VERB_DIRECTIVE_NUMBER = 4;
Constant VERB_DIRECTIVE_NOUN = 5;
Constant VERB_DIRECTIVE_MULTI = 6;
Constant VERB_DIRECTIVE_MULTIINSIDE = 7;
Constant VERB_DIRECTIVE_MULTIHELD = 8;
Constant VERB_DIRECTIVE_HELD = 9;
Constant VERB_DIRECTIVE_CREATURE = 10;
Constant VERB_DIRECTIVE_TOPIC = 11;
Constant VERB_DIRECTIVE_MULTIEXCEPT = 12;
#ifndef DICT_WORD_SIZE;
Constant DICT_WORD_SIZE = 15;
#endif;
Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DIALECT_US = 0;
Constant SERIAL_COMMA = 0;
Constant DynamicMemoryAllocation = 65536;
Constant Computed_Constant_Value_0_U1 = 4096;
Constant Computed_Constant_Value_1_U1 = 3;
Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50;
Constant USE_SCORING = 1;
Constant MATCH_LIST_WORDS = 200;
Constant DONE_INIS = 4;
Constant RELS_SYMMETRIC = 32768;
Constant RELS_EQUIVALENCE = 16384;
Constant RELS_X_UNIQUE = 8192;
Constant RELS_Y_UNIQUE = 4096;
Constant RELS_TEST = 2048;
Constant RELS_ASSERT_TRUE = 1024;
Constant RELS_ASSERT_FALSE = 512;
Constant RELS_SHOW = 256;
Constant RELS_ROUTE_FIND = 128;
Constant RELS_ROUTE_FIND_COUNT = 64;
Constant RELS_LOOKUP_ANY = 8;
Constant RELS_LOOKUP_ALL_X = 4;
Constant RELS_LOOKUP_ALL_Y = 2;
Constant RELS_LIST = 1;
Constant TTF_sum = 3584;
Constant REL_BLOCK_HEADER = 101515264;
Constant relation_id_U1 = 149;
Constant relation_id_U2 = 150;
Constant relation_id_U3 = 151;
Constant relation_id_U4 = 152;
Constant relation_id_U5 = 153;
Constant relation_id_U6 = 154;
Constant relation_id_U7 = 155;
Constant relation_id_U8 = 156;
Constant relation_id_U9 = 157;
Constant relation_id_U10 = 158;
Constant relation_id_U11 = 159;
Constant relation_id_U12 = 160;
Constant relation_id_U13 = 161;
Constant relation_id_U14 = 162;
Constant relation_id_U15 = 163;
Constant relation_id_U16 = 164;
Constant relation_id_U17 = 165;
Constant relation_id_U18 = 166;
Constant relation_id_U19 = 167;
Constant relation_id_U20 = 168;
Constant relation_id_U21 = 169;
Constant relation_id_U22 = 170;
Constant relation_id_U23 = 171;
Constant kind_ref_U1 = 561;
Constant OBJECT_TY = 40;
Constant ICOUNT_OBJECT = 179;
Constant kind_ref_U2 = 561;
Constant SCENE_TY = 41;
Constant ICOUNT_SCENE = 3;
Constant kind_ref_U3 = 561;
Constant NUMBER_TY = 42;
Constant call_U8 = DecimalNumber;
Constant kind_ref_U4 = 561;
Constant REAL_NUMBER_TY = 43;
Constant call_U11 = REAL_NUMBER_TY_Say;
Constant kind_ref_U5 = 561;
Constant TRUTH_STATE_TY = 44;
Constant kind_ref_U6 = 561;
Constant TEXT_TY = 45;
Constant kind_ref_U7 = 561;
Constant SNIPPET_TY = 46;
Constant kind_ref_U8 = 561;
Constant UNICODE_CHARACTER_TY = 47;
Constant kind_ref_U9 = 561;
Constant USE_OPTION_TY = 48;
Constant kind_ref_U10 = 561;
Constant RESPONSE_TY = 49;
Constant kind_ref_U11 = 561;
Constant VERB_TY = 50;
Constant kind_ref_U12 = 561;
Constant TABLE_TY = 51;
Constant kind_ref_U13 = 561;
Constant EQUATION_TY = 52;
Constant kind_ref_U14 = 561;
Constant RULEBOOK_OUTCOME_TY = 53;
Constant kind_ref_U15 = 561;
Constant EXTERNAL_FILE_TY = 54;
Constant ICOUNT_EXTERNAL_FILE = 0;
Constant kind_ref_U16 = 561;
Constant DESCRIPTION_OF_ACTION_TY = 55;
Constant kind_ref_U17 = 561;
Constant STORED_ACTION_TY = 56;
Constant kind_ref_U18 = 561;
Constant ACTION_NAME_TY = 57;
Constant kind_ref_U19 = 561;
Constant TIME_TY = 58;
Constant call_U30 = PrintTimeOfDay;
Constant kind_ref_U20 = 561;
Constant FIGURE_NAME_TY = 59;
Constant ICOUNT_FIGURE_NAME = 17;
Constant kind_ref_U21 = 561;
Constant SOUND_NAME_TY = 60;
Constant ICOUNT_SOUND_NAME = 1;
Constant kind_ref_U22 = 561;
Constant UNDERSTANDING_TY = 61;
Constant kind_ref_U23 = 561;
Constant LIST_OF_TY = 62;
Constant kind_ref_U24 = 561;
Constant VALUE_TY = 63;
Constant kind_ref_U25 = 561;
Constant STORED_VALUE_TY = 64;
Constant kind_ref_U26 = 561;
Constant SAYABLE_VALUE_TY = 65;
Constant kind_ref_U27 = 561;
Constant UNDERSTANDABLE_VALUE_TY = 66;
Constant kind_ref_U28 = 561;
Constant ARITHMETIC_VALUE_TY = 67;
Constant kind_ref_U29 = 561;
Constant REAL_ARITHMETIC_VALUE_TY = 68;
Constant kind_ref_U30 = 561;
Constant ENUMERATED_VALUE_TY = 69;
Constant kind_ref_U31 = 561;
Constant POINTER_VALUE_TY = 70;
Constant kind_ref_U32 = 561;
Constant PHRASE_TY = 71;
Constant kind_ref_U33 = 561;
Constant VARIABLE_TY = 72;
Constant kind_ref_U34 = 561;
Constant RELATION_TY = 73;
Constant kind_ref_U35 = 561;
Constant RULE_TY = 74;
Constant kind_ref_U36 = 561;
Constant RULEBOOK_TY = 75;
Constant kind_ref_U37 = 561;
Constant ACTIVITY_TY = 76;
Constant kind_ref_U38 = 561;
Constant DESCRIPTION_OF_TY = 77;
Constant kind_ref_U39 = 561;
Constant PROPERTY_TY = 78;
Constant kind_ref_U40 = 561;
Constant TABLE_COLUMN_TY = 79;
Constant kind_ref_U41 = 561;
Constant COMBINATION_TY = 80;
Constant kind_ref_U42 = 561;
Constant NIL_TY = 81;
Constant kind_ref_U43 = 561;
Constant UNKNOWN_TY = 82;
Constant kind_ref_U44 = 561;
Constant VOID_TY = 83;
Constant kind_ref_U45 = 561;
Constant TUPLE_ENTRY_TY = 84;
Constant property_id_U1 = 54;
Constant property_id_U2 = 55;
Constant property_id_U3 = 56;
Constant property_id_U4 = 57;
Constant property_id_U5 = 58;
Constant property_id_U6 = 59;
Constant property_id_U7 = 60;
Constant property_id_U8 = 61;
Constant property_id_U9 = 62;
Constant property_id_U10 = 63;
Constant property_id_U11 = 64;
Constant property_id_U12 = 65;
Constant property_id_U13 = 66;
Constant property_id_U14 = 67;
Constant property_id_U15 = 68;
Constant property_id_U16 = 69;
Constant property_id_U17 = 70;
Constant property_id_U18 = 71;
Constant property_id_U19 = 72;
Constant property_id_U20 = 73;
Constant property_id_U21 = 74;
Constant property_id_U22 = 75;
Constant property_id_U23 = 76;
Constant property_id_U24 = 77;
Constant property_id_U25 = 78;
Constant property_id_U26 = 79;
Constant property_id_U27 = 80;
Constant property_id_U28 = 81;
Constant property_id_U29 = 82;
Constant property_id_U30 = 83;
Constant property_id_U31 = 84;
Constant property_id_U32 = 85;
Constant property_id_U33 = 86;
Constant property_id_U34 = 87;
Constant property_id_U35 = 88;
Constant property_id_U36 = 89;
Constant property_id_U37 = 90;
Constant property_id_U38 = 91;
Constant property_id_U39 = 92;
Constant property_id_U40 = 93;
Constant property_id_U41 = 94;
Constant property_id_U42 = 95;
Constant property_id_U43 = 96;
Constant property_id_U44 = 97;
Constant property_id_U45 = 98;
Constant property_id_U46 = 99;
Constant property_id_U47 = 100;
Constant property_id_U48 = 101;
Constant property_id_U49 = 102;
Constant property_id_U50 = 103;
Constant property_id_U51 = 104;
Constant property_id_U52 = 105;
Constant property_id_U53 = 106;
Constant property_id_U54 = 107;
Constant property_id_U55 = 108;
Constant property_id_U56 = 109;
Constant property_id_U57 = 110;
Constant property_id_U58 = 111;
Constant property_id_U59 = 112;
Constant property_id_U60 = 113;
Constant property_id_U61 = 114;
Constant property_id_U62 = 115;
Constant property_id_U63 = 116;
Constant property_id_U64 = 117;
Constant property_id_U65 = 118;
Constant property_id_U66 = 119;
Constant property_id_U67 = 120;
Constant property_id_U68 = 121;
Constant property_id_U69 = 122;
Constant property_id_U70 = 123;
Constant property_id_U71 = 124;
Constant property_id_U72 = 125;
Constant property_id_U73 = 126;
Constant property_id_U74 = 127;
Constant property_id_U75 = 128;
Constant property_id_U76 = 129;
Constant property_id_U77 = 130;
Constant property_id_U78 = 131;
Constant CCOUNT_ACTION_NAME = 91;
Constant AD_RECORDS = 91;
Constant NO_PAST_TENSE_CONDS = 2;
Constant NO_PAST_TENSE_ACTIONS = 4;
Constant BASE_KIND_HWM = 85;
Constant RUCKSACK_CLASS = K15_player_s_holdall;
Constant NO_EXTERNAL_FILES = 0;
Constant CCOUNT_PROPERTY = 207;
Constant CCOUNT_BINARY_PREDICATE = 172;
Constant NUMBER_RULEBOOKS_CREATED = 420;
Constant NO_RESPONSES = 419;
Constant RANKING_TABLE = 0;
Constant NO_USE_OPTIONS = 29;
#ifndef WORDSIZE;
Constant WORDSIZE = 4;
#endif;
Constant NULL = -1;
Constant WORD_HIGHBIT = -2147483648;
Constant WORD_NEXTTOHIGHBIT = 1073741824;
Constant IMPROBABLE_VALUE = -559034863;
Constant MAX_POSITIVE_NUMBER = 2147483647;
Constant MIN_NEGATIVE_NUMBER = -2147483648;
#ifndef TARGET_GLULX;
Constant TARGET_GLULX = 1;
#endif;
Constant use_option_id_U1 = 0;
Constant use_option_id_U2 = 1;
Constant use_option_id_U3 = 2;
Constant use_option_id_U4 = 3;
Constant use_option_id_U5 = 4;
Constant use_option_id_U6 = 5;
Constant use_option_id_U7 = 6;
Constant use_option_id_U8 = 7;
Constant use_option_id_U9 = 8;
Constant use_option_id_U10 = 9;
Constant use_option_id_U11 = 10;
Constant use_option_id_U12 = 11;
Constant use_option_id_U13 = 12;
Constant use_option_id_U14 = 13;
Constant use_option_id_U15 = 14;
Constant use_option_id_U16 = 15;
Constant use_option_id_U17 = 16;
Constant property_id_U79 = 0;
Constant property_id_U80 = 1;
Constant property_id_U81 = 2;
Constant property_id_U82 = 3;
Constant property_id_U83 = 4;
Constant property_id_U84 = 5;
Constant property_id_U85 = 6;
Constant property_id_U86 = 7;
Constant property_id_U87 = 8;
Constant rulebook_id_U1 = 0;
Constant rulebook_id_U2 = 1;
Constant call_U117 = EMPTY_RULEBOOK;
Constant rulebook_id_U3 = 2;
Constant rulebook_id_U4 = 3;
Constant call_U119 = EMPTY_RULEBOOK;
Constant rulebook_id_U5 = 4;
Constant activity_id_U1 = 0;
Constant var_id_U1 = 10000;
Constant rulebook_id_U6 = 5;
Constant rulebook_id_U7 = 6;
Constant rulebook_id_U8 = 7;
Constant activity_id_U2 = 1;
Constant var_id_U2 = 10001;
Constant call_U123 = EMPTY_RULEBOOK;
Constant rulebook_id_U9 = 8;
Constant rulebook_id_U10 = 9;
Constant call_U125 = EMPTY_RULEBOOK;
Constant rulebook_id_U11 = 10;
Constant activity_id_U3 = 2;
Constant var_id_U3 = 10002;
Constant kind_ref_U46 = 561;
Constant WEAK_ID_47 = 2;
Constant ICOUNT_NATURAL_LANGUAGE = 6;
Constant extension_id_U1 = 1;
Constant anchor_U1 = 1105;
Constant anchor_U2 = 1105;
Constant anchor_U3 = 1105;
Constant relation_id_U24 = 0;
Constant relation_id_U25 = 1;
Constant relation_id_U26 = 2;
Constant relation_id_U27 = 3;
Constant relation_id_U28 = 4;
Constant relation_id_U29 = 5;
Constant kind_ref_U47 = 561;
Constant WEAK_ID_48 = 19;
Constant ICOUNT_GRAMMATICAL_TENSE = 5;
Constant kind_ref_U48 = 561;
Constant WEAK_ID_49 = 20;
Constant ICOUNT_NARRATIVE_VIEWPOINT = 6;
Constant kind_ref_U49 = 561;
Constant WEAK_ID_50 = 21;
Constant ICOUNT_GRAMMATICAL_CASE = 2;
Constant kind_ref_U50 = 561;
Constant WEAK_ID_51 = 22;
Constant ICOUNT_GRAMMATICAL_GENDER = 3;
Constant property_id_U88 = 40;
Constant extension_id_U2 = 2;
Constant relation_id_U30 = 98;
Constant property_id_U89 = 9;
Constant property_id_U90 = 10;
Constant property_id_U91 = 11;
Constant property_id_U92 = 12;
Constant property_id_U93 = 13;
Constant property_id_U94 = 14;
Constant property_id_U95 = 15;
Constant property_id_U96 = 16;
Constant property_id_U97 = 17;
Constant property_id_U98 = 18;
Constant property_id_U99 = 19;
Constant property_id_U100 = 20;
Constant property_id_U101 = 21;
Constant property_id_U102 = 22;
Constant property_id_U103 = 23;
Constant property_id_U104 = 24;
Constant property_id_U105 = 25;
Constant property_id_U106 = 26;
Constant property_id_U107 = 27;
Constant property_id_U108 = 28;
Constant property_id_U109 = 29;
Constant property_id_U110 = 30;
Constant property_id_U111 = 31;
Constant property_id_U112 = 32;
Constant property_id_U113 = 33;
Constant property_id_U114 = 34;
Constant property_id_U115 = 35;
Constant property_id_U116 = 36;
Constant property_id_U117 = 37;
Constant property_id_U118 = 38;
Constant property_id_U119 = 39;
Constant table_column_id_U1 = 100;
Constant table_column_id_U2 = 101;
Constant table_column_id_U3 = 102;
Constant table_column_id_U4 = 103;
Constant table_column_id_U5 = 104;
Constant table_column_id_U6 = 105;
Constant table_column_id_U7 = 106;
Constant use_option_id_U18 = 17;
Constant use_option_id_U19 = 18;
Constant use_option_id_U20 = 19;
Constant use_option_id_U21 = 20;
Constant use_option_id_U22 = 21;
Constant use_option_id_U23 = 22;
Constant use_option_id_U24 = 23;
Constant use_option_id_U25 = 24;
Constant use_option_id_U26 = 25;
Constant use_option_id_U27 = 26;
Constant use_option_id_U28 = 27;
Constant relation_id_U31 = 6;
Constant relation_id_U32 = 7;
Constant relation_id_U33 = 8;
Constant relation_id_U34 = 9;
Constant relation_id_U35 = 10;
Constant relation_id_U36 = 11;
Constant relation_id_U37 = 12;
Constant relation_id_U38 = 13;
Constant relation_id_U39 = 14;
Constant relation_id_U40 = 15;
Constant relation_id_U41 = 16;
Constant relation_id_U42 = 17;
Constant relation_id_U43 = 18;
Constant relation_id_U44 = 19;
Constant relation_id_U45 = 20;
Constant relation_id_U46 = 21;
Constant relation_id_U47 = 22;
Constant relation_id_U48 = 23;
Constant relation_id_U49 = 24;
Constant relation_id_U50 = 25;
Constant relation_id_U51 = 26;
Constant relation_id_U52 = 27;
Constant relation_id_U53 = 28;
Constant relation_id_U54 = 29;
Constant relation_id_U55 = 30;
Constant relation_id_U56 = 31;
Constant relation_id_U57 = 32;
Constant relation_id_U58 = 33;
Constant relation_id_U59 = 34;
Constant relation_id_U60 = 35;
Constant relation_id_U61 = 36;
Constant relation_id_U62 = 37;
Constant relation_id_U63 = 38;
Constant relation_id_U64 = 39;
Constant relation_id_U65 = 40;
Constant relation_id_U66 = 41;
Constant relation_id_U67 = 42;
Constant relation_id_U68 = 43;
Constant relation_id_U69 = 44;
Constant relation_id_U70 = 45;
Constant relation_id_U71 = 46;
Constant relation_id_U72 = 47;
Constant relation_id_U73 = 48;
Constant relation_id_U74 = 49;
Constant relation_id_U75 = 50;
Constant relation_id_U76 = 51;
Constant relation_id_U77 = 52;
Constant relation_id_U78 = 53;
Constant relation_id_U79 = 54;
Constant relation_id_U80 = 55;
Constant relation_id_U81 = 56;
Constant relation_id_U82 = 57;
Constant relation_id_U83 = 58;
Constant relation_id_U84 = 59;
Constant relation_id_U85 = 60;
Constant relation_id_U86 = 61;
Constant relation_id_U87 = 62;
Constant relation_id_U88 = 63;
Constant relation_id_U89 = 64;
Constant relation_id_U90 = 65;
Constant relation_id_U91 = 66;
Constant relation_id_U92 = 67;
Constant relation_id_U93 = 68;
Constant relation_id_U94 = 69;
Constant relation_id_U95 = 70;
Constant relation_id_U96 = 71;
Constant relation_id_U97 = 72;
Constant relation_id_U98 = 73;
Constant relation_id_U99 = 74;
Constant relation_id_U100 = 75;
Constant relation_id_U101 = 76;
Constant relation_id_U102 = 77;
Constant relation_id_U103 = 78;
Constant relation_id_U104 = 79;
Constant relation_id_U105 = 80;
Constant relation_id_U106 = 81;
Constant relation_id_U107 = 82;
Constant relation_id_U108 = 83;
Constant relation_id_U109 = 84;
Constant relation_id_U110 = 85;
Constant relation_id_U111 = 86;
Constant relation_id_U112 = 87;
Constant relation_id_U113 = 88;
Constant relation_id_U114 = 89;
Constant relation_id_U115 = 90;
Constant relation_id_U116 = 91;
Constant relation_id_U117 = 92;
Constant relation_id_U118 = 93;
Constant relation_id_U119 = 94;
Constant relation_id_U120 = 95;
Constant relation_id_U121 = 96;
Constant relation_id_U122 = 97;
Constant rulebook_id_U12 = 11;
Constant rulebook_id_U13 = 12;
Constant rulebook_id_U14 = 13;
Constant call_U367 = EMPTY_RULEBOOK;
Constant rulebook_id_U15 = 14;
Constant rulebook_id_U16 = 15;
Constant call_U369 = EMPTY_RULEBOOK;
Constant rulebook_id_U17 = 16;
Constant rulebook_id_U18 = 17;
Constant rulebook_id_U19 = 18;
Constant rulebook_id_U20 = 19;
Constant rulebook_id_U21 = 20;
Constant rulebook_id_U22 = 21;
Constant rulebook_id_U23 = 22;
Constant rulebook_id_U24 = 23;
Constant rulebook_id_U25 = 24;
Constant rulebook_id_U26 = 25;
Constant call_U381 = EMPTY_RULEBOOK;
Constant rulebook_id_U27 = 26;
Constant rulebook_id_U28 = 27;
Constant rulebook_id_U29 = 28;
Constant rulebook_id_U30 = 29;
Constant call_U385 = EMPTY_RULEBOOK;
Constant rulebook_id_U31 = 30;
Constant call_U386 = EMPTY_RULEBOOK;
Constant rulebook_id_U32 = 31;
Constant rulebook_id_U33 = 32;
Constant call_U388 = EMPTY_RULEBOOK;
Constant rulebook_id_U34 = 33;
Constant rulebook_id_U35 = 34;
Constant call_U390 = EMPTY_RULEBOOK;
Constant rulebook_id_U36 = 35;
Constant call_U391 = EMPTY_RULEBOOK;
Constant rulebook_id_U37 = 36;
Constant call_U392 = EMPTY_RULEBOOK;
Constant rulebook_id_U38 = 37;
Constant call_U393 = EMPTY_RULEBOOK;
Constant rulebook_id_U39 = 38;
Constant rulebook_id_U40 = 39;
Constant call_U395 = EMPTY_RULEBOOK;
Constant rulebook_id_U41 = 40;
Constant activity_id_U4 = 3;
Constant var_id_U4 = 10003;
Constant call_U396 = EMPTY_RULEBOOK;
Constant rulebook_id_U42 = 41;
Constant rulebook_id_U43 = 42;
Constant call_U398 = EMPTY_RULEBOOK;
Constant rulebook_id_U44 = 43;
Constant activity_id_U5 = 4;
Constant var_id_U5 = 10004;
Constant call_U399 = EMPTY_RULEBOOK;
Constant rulebook_id_U45 = 44;
Constant call_U400 = EMPTY_RULEBOOK;
Constant rulebook_id_U46 = 45;
Constant call_U401 = EMPTY_RULEBOOK;
Constant rulebook_id_U47 = 46;
Constant activity_id_U6 = 5;
Constant var_id_U6 = 10005;
Constant call_U402 = EMPTY_RULEBOOK;
Constant rulebook_id_U48 = 47;
Constant call_U403 = EMPTY_RULEBOOK;
Constant rulebook_id_U49 = 48;
Constant call_U404 = EMPTY_RULEBOOK;
Constant rulebook_id_U50 = 49;
Constant activity_id_U7 = 6;
Constant var_id_U7 = 10006;
Constant call_U405 = EMPTY_RULEBOOK;
Constant rulebook_id_U51 = 50;
Constant rulebook_id_U52 = 51;
Constant call_U407 = EMPTY_RULEBOOK;
Constant rulebook_id_U53 = 52;
Constant activity_id_U8 = 7;
Constant var_id_U8 = 10007;
Constant call_U408 = EMPTY_RULEBOOK;
Constant rulebook_id_U54 = 53;
Constant call_U409 = EMPTY_RULEBOOK;
Constant rulebook_id_U55 = 54;
Constant call_U410 = EMPTY_RULEBOOK;
Constant rulebook_id_U56 = 55;
Constant activity_id_U9 = 8;
Constant var_id_U9 = 10008;
Constant call_U411 = EMPTY_RULEBOOK;
Constant rulebook_id_U57 = 56;
Constant call_U412 = EMPTY_RULEBOOK;
Constant rulebook_id_U58 = 57;
Constant call_U413 = EMPTY_RULEBOOK;
Constant rulebook_id_U59 = 58;
Constant activity_id_U10 = 9;
Constant var_id_U10 = 10009;
Constant call_U414 = EMPTY_RULEBOOK;
Constant rulebook_id_U60 = 59;
Constant call_U415 = EMPTY_RULEBOOK;
Constant rulebook_id_U61 = 60;
Constant call_U416 = EMPTY_RULEBOOK;
Constant rulebook_id_U62 = 61;
Constant activity_id_U11 = 10;
Constant var_id_U11 = 10010;
Constant call_U417 = EMPTY_RULEBOOK;
Constant rulebook_id_U63 = 62;
Constant call_U418 = EMPTY_RULEBOOK;
Constant rulebook_id_U64 = 63;
Constant call_U419 = EMPTY_RULEBOOK;
Constant rulebook_id_U65 = 64;
Constant activity_id_U12 = 11;
Constant var_id_U12 = 10011;
Constant call_U420 = EMPTY_RULEBOOK;
Constant rulebook_id_U66 = 65;
Constant rulebook_id_U67 = 66;
Constant call_U422 = EMPTY_RULEBOOK;
Constant rulebook_id_U68 = 67;
Constant activity_id_U13 = 12;
Constant var_id_U13 = 10012;
Constant call_U423 = EMPTY_RULEBOOK;
Constant rulebook_id_U69 = 68;
Constant call_U424 = EMPTY_RULEBOOK;
Constant rulebook_id_U70 = 69;
Constant call_U425 = EMPTY_RULEBOOK;
Constant rulebook_id_U71 = 70;
Constant activity_id_U14 = 13;
Constant var_id_U14 = 10013;
Constant call_U426 = EMPTY_RULEBOOK;
Constant rulebook_id_U72 = 71;
Constant rulebook_id_U73 = 72;
Constant call_U428 = EMPTY_RULEBOOK;
Constant rulebook_id_U74 = 73;
Constant activity_id_U15 = 14;
Constant var_id_U15 = 10014;
Constant call_U429 = EMPTY_RULEBOOK;
Constant rulebook_id_U75 = 74;
Constant rulebook_id_U76 = 75;
Constant call_U431 = EMPTY_RULEBOOK;
Constant rulebook_id_U77 = 76;
Constant activity_id_U16 = 15;
Constant var_id_U16 = 10015;
Constant call_U432 = EMPTY_RULEBOOK;
Constant rulebook_id_U78 = 77;
Constant rulebook_id_U79 = 78;
Constant call_U434 = EMPTY_RULEBOOK;
Constant rulebook_id_U80 = 79;
Constant activity_id_U17 = 16;
Constant var_id_U17 = 10016;
Constant call_U435 = EMPTY_RULEBOOK;
Constant rulebook_id_U81 = 80;
Constant call_U436 = EMPTY_RULEBOOK;
Constant rulebook_id_U82 = 81;
Constant call_U437 = EMPTY_RULEBOOK;
Constant rulebook_id_U83 = 82;
Constant activity_id_U18 = 17;
Constant var_id_U18 = 10017;
Constant call_U438 = EMPTY_RULEBOOK;
Constant rulebook_id_U84 = 83;
Constant call_U439 = EMPTY_RULEBOOK;
Constant rulebook_id_U85 = 84;
Constant rulebook_id_U86 = 85;
Constant activity_id_U19 = 18;
Constant var_id_U19 = 10018;
Constant call_U441 = EMPTY_RULEBOOK;
Constant rulebook_id_U87 = 86;
Constant call_U442 = EMPTY_RULEBOOK;
Constant rulebook_id_U88 = 87;
Constant call_U443 = EMPTY_RULEBOOK;
Constant rulebook_id_U89 = 88;
Constant activity_id_U20 = 19;
Constant var_id_U20 = 10019;
Constant call_U444 = EMPTY_RULEBOOK;
Constant rulebook_id_U90 = 89;
Constant call_U445 = EMPTY_RULEBOOK;
Constant rulebook_id_U91 = 90;
Constant call_U446 = EMPTY_RULEBOOK;
Constant rulebook_id_U92 = 91;
Constant activity_id_U21 = 20;
Constant var_id_U21 = 10020;
Constant call_U447 = EMPTY_RULEBOOK;
Constant rulebook_id_U93 = 92;
Constant rulebook_id_U94 = 93;
Constant call_U449 = EMPTY_RULEBOOK;
Constant rulebook_id_U95 = 94;
Constant activity_id_U22 = 21;
Constant var_id_U22 = 10021;
Constant call_U450 = EMPTY_RULEBOOK;
Constant rulebook_id_U96 = 95;
Constant call_U451 = EMPTY_RULEBOOK;
Constant rulebook_id_U97 = 96;
Constant call_U452 = EMPTY_RULEBOOK;
Constant rulebook_id_U98 = 97;
Constant activity_id_U23 = 22;
Constant var_id_U23 = 10022;
Constant call_U453 = EMPTY_RULEBOOK;
Constant rulebook_id_U99 = 98;
Constant call_U454 = EMPTY_RULEBOOK;
Constant rulebook_id_U100 = 99;
Constant call_U455 = EMPTY_RULEBOOK;
Constant rulebook_id_U101 = 100;
Constant activity_id_U24 = 23;
Constant var_id_U24 = 10023;
Constant call_U456 = EMPTY_RULEBOOK;
Constant rulebook_id_U102 = 101;
Constant call_U457 = EMPTY_RULEBOOK;
Constant rulebook_id_U103 = 102;
Constant call_U458 = EMPTY_RULEBOOK;
Constant rulebook_id_U104 = 103;
Constant activity_id_U25 = 24;
Constant var_id_U25 = 10024;
Constant call_U459 = EMPTY_RULEBOOK;
Constant rulebook_id_U105 = 104;
Constant rulebook_id_U106 = 105;
Constant call_U461 = EMPTY_RULEBOOK;
Constant rulebook_id_U107 = 106;
Constant activity_id_U26 = 25;
Constant var_id_U26 = 10025;
Constant call_U462 = EMPTY_RULEBOOK;
Constant rulebook_id_U108 = 107;
Constant call_U463 = EMPTY_RULEBOOK;
Constant rulebook_id_U109 = 108;
Constant call_U464 = EMPTY_RULEBOOK;
Constant rulebook_id_U110 = 109;
Constant activity_id_U27 = 26;
Constant var_id_U27 = 10026;
Constant call_U465 = EMPTY_RULEBOOK;
Constant rulebook_id_U111 = 110;
Constant rulebook_id_U112 = 111;
Constant call_U467 = EMPTY_RULEBOOK;
Constant rulebook_id_U113 = 112;
Constant activity_id_U28 = 27;
Constant var_id_U28 = 10027;
Constant call_U468 = EMPTY_RULEBOOK;
Constant rulebook_id_U114 = 113;
Constant call_U469 = EMPTY_RULEBOOK;
Constant rulebook_id_U115 = 114;
Constant call_U470 = EMPTY_RULEBOOK;
Constant rulebook_id_U116 = 115;
Constant activity_id_U29 = 28;
Constant var_id_U29 = 10028;
Constant call_U471 = EMPTY_RULEBOOK;
Constant rulebook_id_U117 = 116;
Constant rulebook_id_U118 = 117;
Constant call_U473 = EMPTY_RULEBOOK;
Constant rulebook_id_U119 = 118;
Constant activity_id_U30 = 29;
Constant var_id_U30 = 10029;
Constant rulebook_id_U120 = 119;
Constant rulebook_id_U121 = 120;
Constant call_U476 = EMPTY_RULEBOOK;
Constant rulebook_id_U122 = 121;
Constant activity_id_U31 = 30;
Constant var_id_U31 = 10030;
Constant rulebook_id_U123 = 122;
Constant rulebook_id_U124 = 123;
Constant call_U479 = EMPTY_RULEBOOK;
Constant rulebook_id_U125 = 124;
Constant activity_id_U32 = 31;
Constant var_id_U32 = 10031;
Constant call_U480 = EMPTY_RULEBOOK;
Constant rulebook_id_U126 = 125;
Constant rulebook_id_U127 = 126;
Constant call_U482 = EMPTY_RULEBOOK;
Constant rulebook_id_U128 = 127;
Constant activity_id_U33 = 32;
Constant var_id_U33 = 10032;
Constant call_U483 = EMPTY_RULEBOOK;
Constant rulebook_id_U129 = 128;
Constant rulebook_id_U130 = 129;
Constant call_U485 = EMPTY_RULEBOOK;
Constant rulebook_id_U131 = 130;
Constant activity_id_U34 = 33;
Constant var_id_U34 = 10033;
Constant call_U486 = EMPTY_RULEBOOK;
Constant rulebook_id_U132 = 131;
Constant rulebook_id_U133 = 132;
Constant rulebook_id_U134 = 133;
Constant action_id_U1 = 0;
Constant var_id_U35 = 20000;
Constant rulebook_id_U135 = 134;
Constant rulebook_id_U136 = 135;
Constant rulebook_id_U137 = 136;
Constant action_id_U2 = 1;
Constant var_id_U36 = 20001;
Constant rulebook_id_U138 = 137;
Constant call_U493 = EMPTY_RULEBOOK;
Constant rulebook_id_U139 = 138;
Constant call_U494 = EMPTY_RULEBOOK;
Constant rulebook_id_U140 = 139;
Constant action_id_U3 = 2;
Constant var_id_U37 = 20002;
Constant rulebook_id_U141 = 140;
Constant rulebook_id_U142 = 141;
Constant rulebook_id_U143 = 142;
Constant action_id_U4 = 3;
Constant var_id_U38 = 20003;
Constant rulebook_id_U144 = 143;
Constant rulebook_id_U145 = 144;
Constant rulebook_id_U146 = 145;
Constant action_id_U5 = 4;
Constant var_id_U39 = 20004;
Constant rulebook_id_U147 = 146;
Constant rulebook_id_U148 = 147;
Constant rulebook_id_U149 = 148;
Constant action_id_U6 = 5;
Constant var_id_U40 = 20005;
Constant rulebook_id_U150 = 149;
Constant rulebook_id_U151 = 150;
Constant rulebook_id_U152 = 151;
Constant action_id_U7 = 6;
Constant var_id_U41 = 20006;
Constant rulebook_id_U153 = 152;
Constant rulebook_id_U154 = 153;
Constant rulebook_id_U155 = 154;
Constant action_id_U8 = 7;
Constant var_id_U42 = 20007;
Constant rulebook_id_U156 = 155;
Constant rulebook_id_U157 = 156;
Constant rulebook_id_U158 = 157;
Constant action_id_U9 = 8;
Constant var_id_U43 = 20008;
Constant rulebook_id_U159 = 158;
Constant rulebook_id_U160 = 159;
Constant rulebook_id_U161 = 160;
Constant action_id_U10 = 9;
Constant var_id_U44 = 20009;
Constant rulebook_id_U162 = 161;
Constant rulebook_id_U163 = 162;
Constant rulebook_id_U164 = 163;
Constant action_id_U11 = 10;
Constant var_id_U45 = 20010;
Constant call_U521 = EMPTY_RULEBOOK;
Constant rulebook_id_U165 = 164;
Constant rulebook_id_U166 = 165;
Constant rulebook_id_U167 = 166;
Constant action_id_U12 = 11;
Constant var_id_U46 = 20011;
Constant call_U525 = EMPTY_RULEBOOK;
Constant rulebook_id_U168 = 167;
Constant rulebook_id_U169 = 168;
Constant rulebook_id_U170 = 169;
Constant action_id_U13 = 12;
Constant var_id_U47 = 20012;
Constant call_U529 = EMPTY_RULEBOOK;
Constant rulebook_id_U171 = 170;
Constant rulebook_id_U172 = 171;
Constant rulebook_id_U173 = 172;
Constant action_id_U14 = 13;
Constant var_id_U48 = 20013;
Constant rulebook_id_U174 = 173;
Constant call_U533 = EMPTY_RULEBOOK;
Constant rulebook_id_U175 = 174;
Constant rulebook_id_U176 = 175;
Constant action_id_U15 = 14;
Constant var_id_U49 = 20014;
Constant call_U535 = EMPTY_RULEBOOK;
Constant rulebook_id_U177 = 176;
Constant call_U536 = EMPTY_RULEBOOK;
Constant rulebook_id_U178 = 177;
Constant rulebook_id_U179 = 178;
Constant action_id_U16 = 15;
Constant var_id_U50 = 20015;
Constant rulebook_id_U180 = 179;
Constant rulebook_id_U181 = 180;
Constant rulebook_id_U182 = 181;
Constant action_id_U17 = 16;
Constant var_id_U51 = 20016;
Constant rulebook_id_U183 = 182;
Constant rulebook_id_U184 = 183;
Constant rulebook_id_U185 = 184;
Constant action_id_U18 = 17;
Constant var_id_U52 = 20017;
Constant rulebook_id_U186 = 185;
Constant rulebook_id_U187 = 186;
Constant rulebook_id_U188 = 187;
Constant action_id_U19 = 18;
Constant var_id_U53 = 20018;
Constant rulebook_id_U189 = 188;
Constant rulebook_id_U190 = 189;
Constant rulebook_id_U191 = 190;
Constant action_id_U20 = 19;
Constant var_id_U54 = 20019;
Constant rulebook_id_U192 = 191;
Constant rulebook_id_U193 = 192;
Constant rulebook_id_U194 = 193;
Constant action_id_U21 = 20;
Constant var_id_U55 = 20020;
Constant rulebook_id_U195 = 194;
Constant rulebook_id_U196 = 195;
Constant rulebook_id_U197 = 196;
Constant action_id_U22 = 21;
Constant var_id_U56 = 20021;
Constant rulebook_id_U198 = 197;
Constant rulebook_id_U199 = 198;
Constant rulebook_id_U200 = 199;
Constant action_id_U23 = 22;
Constant var_id_U57 = 20022;
Constant rulebook_id_U201 = 200;
Constant rulebook_id_U202 = 201;
Constant rulebook_id_U203 = 202;
Constant action_id_U24 = 23;
Constant var_id_U58 = 20023;
Constant rulebook_id_U204 = 203;
Constant rulebook_id_U205 = 204;
Constant rulebook_id_U206 = 205;
Constant action_id_U25 = 24;
Constant var_id_U59 = 20024;
Constant rulebook_id_U207 = 206;
Constant call_U566 = EMPTY_RULEBOOK;
Constant rulebook_id_U208 = 207;
Constant call_U567 = EMPTY_RULEBOOK;
Constant rulebook_id_U209 = 208;
Constant action_id_U26 = 25;
Constant var_id_U60 = 20025;
Constant rulebook_id_U210 = 209;
Constant call_U569 = EMPTY_RULEBOOK;
Constant rulebook_id_U211 = 210;
Constant call_U570 = EMPTY_RULEBOOK;
Constant rulebook_id_U212 = 211;
Constant action_id_U27 = 26;
Constant var_id_U61 = 20026;
Constant rulebook_id_U213 = 212;
Constant call_U572 = EMPTY_RULEBOOK;
Constant rulebook_id_U214 = 213;
Constant call_U573 = EMPTY_RULEBOOK;
Constant rulebook_id_U215 = 214;
Constant action_id_U28 = 27;
Constant var_id_U62 = 20027;
Constant rulebook_id_U216 = 215;
Constant call_U575 = EMPTY_RULEBOOK;
Constant rulebook_id_U217 = 216;
Constant call_U576 = EMPTY_RULEBOOK;
Constant rulebook_id_U218 = 217;
Constant action_id_U29 = 28;
Constant var_id_U63 = 20028;
Constant rulebook_id_U219 = 218;
Constant call_U578 = EMPTY_RULEBOOK;
Constant rulebook_id_U220 = 219;
Constant call_U579 = EMPTY_RULEBOOK;
Constant rulebook_id_U221 = 220;
Constant action_id_U30 = 29;
Constant var_id_U64 = 20029;
Constant call_U580 = EMPTY_RULEBOOK;
Constant rulebook_id_U222 = 221;
Constant call_U581 = EMPTY_RULEBOOK;
Constant rulebook_id_U223 = 222;
Constant rulebook_id_U224 = 223;
Constant action_id_U31 = 30;
Constant var_id_U65 = 20030;
Constant rulebook_id_U225 = 224;
Constant call_U584 = EMPTY_RULEBOOK;
Constant rulebook_id_U226 = 225;
Constant rulebook_id_U227 = 226;
Constant action_id_U32 = 31;
Constant var_id_U66 = 20031;
Constant call_U586 = EMPTY_RULEBOOK;
Constant rulebook_id_U228 = 227;
Constant call_U587 = EMPTY_RULEBOOK;
Constant rulebook_id_U229 = 228;
Constant rulebook_id_U230 = 229;
Constant action_id_U33 = 32;
Constant var_id_U67 = 20032;
Constant rulebook_id_U231 = 230;
Constant call_U590 = EMPTY_RULEBOOK;
Constant rulebook_id_U232 = 231;
Constant call_U591 = EMPTY_RULEBOOK;
Constant rulebook_id_U233 = 232;
Constant action_id_U34 = 33;
Constant var_id_U68 = 20033;
Constant call_U592 = EMPTY_RULEBOOK;
Constant rulebook_id_U234 = 233;
Constant call_U593 = EMPTY_RULEBOOK;
Constant rulebook_id_U235 = 234;
Constant rulebook_id_U236 = 235;
Constant action_id_U35 = 34;
Constant var_id_U69 = 20034;
Constant call_U595 = EMPTY_RULEBOOK;
Constant rulebook_id_U237 = 236;
Constant call_U596 = EMPTY_RULEBOOK;
Constant rulebook_id_U238 = 237;
Constant rulebook_id_U239 = 238;
Constant action_id_U36 = 35;
Constant var_id_U70 = 20035;
Constant rulebook_id_U240 = 239;
Constant call_U599 = EMPTY_RULEBOOK;
Constant rulebook_id_U241 = 240;
Constant rulebook_id_U242 = 241;
Constant action_id_U37 = 36;
Constant var_id_U71 = 20036;
Constant rulebook_id_U243 = 242;
Constant call_U602 = EMPTY_RULEBOOK;
Constant rulebook_id_U244 = 243;
Constant rulebook_id_U245 = 244;
Constant action_id_U38 = 37;
Constant var_id_U72 = 20037;
Constant rulebook_id_U246 = 245;
Constant call_U605 = EMPTY_RULEBOOK;
Constant rulebook_id_U247 = 246;
Constant rulebook_id_U248 = 247;
Constant action_id_U39 = 38;
Constant var_id_U73 = 20038;
Constant rulebook_id_U249 = 248;
Constant call_U608 = EMPTY_RULEBOOK;
Constant rulebook_id_U250 = 249;
Constant rulebook_id_U251 = 250;
Constant action_id_U40 = 39;
Constant var_id_U74 = 20039;
Constant rulebook_id_U252 = 251;
Constant call_U611 = EMPTY_RULEBOOK;
Constant rulebook_id_U253 = 252;
Constant call_U612 = EMPTY_RULEBOOK;
Constant rulebook_id_U254 = 253;
Constant action_id_U41 = 40;
Constant var_id_U75 = 20040;
Constant rulebook_id_U255 = 254;
Constant call_U614 = EMPTY_RULEBOOK;
Constant rulebook_id_U256 = 255;
Constant rulebook_id_U257 = 256;
Constant action_id_U42 = 41;
Constant var_id_U76 = 20041;
Constant rulebook_id_U258 = 257;
Constant call_U617 = EMPTY_RULEBOOK;
Constant rulebook_id_U259 = 258;
Constant call_U618 = EMPTY_RULEBOOK;
Constant rulebook_id_U260 = 259;
Constant action_id_U43 = 42;
Constant var_id_U77 = 20042;
Constant rulebook_id_U261 = 260;
Constant call_U620 = EMPTY_RULEBOOK;
Constant rulebook_id_U262 = 261;
Constant call_U621 = EMPTY_RULEBOOK;
Constant rulebook_id_U263 = 262;
Constant action_id_U44 = 43;
Constant var_id_U78 = 20043;
Constant rulebook_id_U264 = 263;
Constant call_U623 = EMPTY_RULEBOOK;
Constant rulebook_id_U265 = 264;
Constant call_U624 = EMPTY_RULEBOOK;
Constant rulebook_id_U266 = 265;
Constant action_id_U45 = 44;
Constant var_id_U79 = 20044;
Constant rulebook_id_U267 = 266;
Constant call_U626 = EMPTY_RULEBOOK;
Constant rulebook_id_U268 = 267;
Constant call_U627 = EMPTY_RULEBOOK;
Constant rulebook_id_U269 = 268;
Constant action_id_U46 = 45;
Constant var_id_U80 = 20045;
Constant rulebook_id_U270 = 269;
Constant call_U629 = EMPTY_RULEBOOK;
Constant rulebook_id_U271 = 270;
Constant call_U630 = EMPTY_RULEBOOK;
Constant rulebook_id_U272 = 271;
Constant action_id_U47 = 46;
Constant var_id_U81 = 20046;
Constant call_U631 = EMPTY_RULEBOOK;
Constant rulebook_id_U273 = 272;
Constant call_U632 = EMPTY_RULEBOOK;
Constant rulebook_id_U274 = 273;
Constant rulebook_id_U275 = 274;
Constant action_id_U48 = 47;
Constant var_id_U82 = 20047;
Constant call_U634 = EMPTY_RULEBOOK;
Constant rulebook_id_U276 = 275;
Constant call_U635 = EMPTY_RULEBOOK;
Constant rulebook_id_U277 = 276;
Constant rulebook_id_U278 = 277;
Constant action_id_U49 = 48;
Constant var_id_U83 = 20048;
Constant call_U637 = EMPTY_RULEBOOK;
Constant rulebook_id_U279 = 278;
Constant call_U638 = EMPTY_RULEBOOK;
Constant rulebook_id_U280 = 279;
Constant rulebook_id_U281 = 280;
Constant action_id_U50 = 49;
Constant var_id_U84 = 20049;
Constant rulebook_id_U282 = 281;
Constant call_U641 = EMPTY_RULEBOOK;
Constant rulebook_id_U283 = 282;
Constant call_U642 = EMPTY_RULEBOOK;
Constant rulebook_id_U284 = 283;
Constant action_id_U51 = 50;
Constant var_id_U85 = 20050;
Constant call_U643 = EMPTY_RULEBOOK;
Constant rulebook_id_U285 = 284;
Constant call_U644 = EMPTY_RULEBOOK;
Constant rulebook_id_U286 = 285;
Constant rulebook_id_U287 = 286;
Constant action_id_U52 = 51;
Constant var_id_U86 = 20051;
Constant rulebook_id_U288 = 287;
Constant call_U647 = EMPTY_RULEBOOK;
Constant rulebook_id_U289 = 288;
Constant call_U648 = EMPTY_RULEBOOK;
Constant rulebook_id_U290 = 289;
Constant action_id_U53 = 52;
Constant var_id_U87 = 20052;
Constant rulebook_id_U291 = 290;
Constant call_U650 = EMPTY_RULEBOOK;
Constant rulebook_id_U292 = 291;
Constant call_U651 = EMPTY_RULEBOOK;
Constant rulebook_id_U293 = 292;
Constant action_id_U54 = 53;
Constant var_id_U88 = 20053;
Constant rulebook_id_U294 = 293;
Constant call_U653 = EMPTY_RULEBOOK;
Constant rulebook_id_U295 = 294;
Constant call_U654 = EMPTY_RULEBOOK;
Constant rulebook_id_U296 = 295;
Constant action_id_U55 = 54;
Constant var_id_U89 = 20054;
Constant rulebook_id_U297 = 296;
Constant call_U656 = EMPTY_RULEBOOK;
Constant rulebook_id_U298 = 297;
Constant call_U657 = EMPTY_RULEBOOK;
Constant rulebook_id_U299 = 298;
Constant action_id_U56 = 55;
Constant var_id_U90 = 20055;
Constant rulebook_id_U300 = 299;
Constant call_U659 = EMPTY_RULEBOOK;
Constant rulebook_id_U301 = 300;
Constant rulebook_id_U302 = 301;
Constant action_id_U57 = 56;
Constant var_id_U91 = 20056;
Constant rulebook_id_U303 = 302;
Constant call_U662 = EMPTY_RULEBOOK;
Constant rulebook_id_U304 = 303;
Constant call_U663 = EMPTY_RULEBOOK;
Constant rulebook_id_U305 = 304;
Constant action_id_U58 = 57;
Constant var_id_U92 = 20057;
Constant call_U664 = EMPTY_RULEBOOK;
Constant rulebook_id_U306 = 305;
Constant call_U665 = EMPTY_RULEBOOK;
Constant rulebook_id_U307 = 306;
Constant rulebook_id_U308 = 307;
Constant action_id_U59 = 58;
Constant var_id_U93 = 20058;
Constant rulebook_id_U309 = 308;
Constant call_U668 = EMPTY_RULEBOOK;
Constant rulebook_id_U310 = 309;
Constant call_U669 = EMPTY_RULEBOOK;
Constant rulebook_id_U311 = 310;
Constant action_id_U60 = 59;
Constant var_id_U94 = 20059;
Constant rulebook_id_U312 = 311;
Constant call_U671 = EMPTY_RULEBOOK;
Constant rulebook_id_U313 = 312;
Constant call_U672 = EMPTY_RULEBOOK;
Constant rulebook_id_U314 = 313;
Constant action_id_U61 = 60;
Constant var_id_U95 = 20060;
Constant rulebook_id_U315 = 314;
Constant call_U674 = EMPTY_RULEBOOK;
Constant rulebook_id_U316 = 315;
Constant call_U675 = EMPTY_RULEBOOK;
Constant rulebook_id_U317 = 316;
Constant action_id_U62 = 61;
Constant var_id_U96 = 20061;
Constant call_U676 = EMPTY_RULEBOOK;
Constant rulebook_id_U318 = 317;
Constant rulebook_id_U319 = 318;
Constant call_U678 = EMPTY_RULEBOOK;
Constant rulebook_id_U320 = 319;
Constant action_id_U63 = 62;
Constant var_id_U97 = 20062;
Constant call_U679 = EMPTY_RULEBOOK;
Constant rulebook_id_U321 = 320;
Constant rulebook_id_U322 = 321;
Constant call_U681 = EMPTY_RULEBOOK;
Constant rulebook_id_U323 = 322;
Constant action_id_U64 = 63;
Constant var_id_U98 = 20063;
Constant call_U682 = EMPTY_RULEBOOK;
Constant rulebook_id_U324 = 323;
Constant rulebook_id_U325 = 324;
Constant call_U684 = EMPTY_RULEBOOK;
Constant rulebook_id_U326 = 325;
Constant action_id_U65 = 64;
Constant var_id_U99 = 20064;
Constant call_U685 = EMPTY_RULEBOOK;
Constant rulebook_id_U327 = 326;
Constant rulebook_id_U328 = 327;
Constant call_U687 = EMPTY_RULEBOOK;
Constant rulebook_id_U329 = 328;
Constant action_id_U66 = 65;
Constant var_id_U100 = 20065;
Constant call_U688 = EMPTY_RULEBOOK;
Constant rulebook_id_U330 = 329;
Constant rulebook_id_U331 = 330;
Constant call_U690 = EMPTY_RULEBOOK;
Constant rulebook_id_U332 = 331;
Constant action_id_U67 = 66;
Constant var_id_U101 = 20066;
Constant call_U691 = EMPTY_RULEBOOK;
Constant rulebook_id_U333 = 332;
Constant rulebook_id_U334 = 333;
Constant call_U693 = EMPTY_RULEBOOK;
Constant rulebook_id_U335 = 334;
Constant action_id_U68 = 67;
Constant var_id_U102 = 20067;
Constant call_U694 = EMPTY_RULEBOOK;
Constant rulebook_id_U336 = 335;
Constant rulebook_id_U337 = 336;
Constant call_U696 = EMPTY_RULEBOOK;
Constant rulebook_id_U338 = 337;
Constant action_id_U69 = 68;
Constant var_id_U103 = 20068;
Constant call_U697 = EMPTY_RULEBOOK;
Constant rulebook_id_U339 = 338;
Constant rulebook_id_U340 = 339;
Constant call_U699 = EMPTY_RULEBOOK;
Constant rulebook_id_U341 = 340;
Constant action_id_U70 = 69;
Constant var_id_U104 = 20069;
Constant call_U700 = EMPTY_RULEBOOK;
Constant rulebook_id_U342 = 341;
Constant rulebook_id_U343 = 342;
Constant call_U702 = EMPTY_RULEBOOK;
Constant rulebook_id_U344 = 343;
Constant action_id_U71 = 70;
Constant var_id_U105 = 20070;
Constant call_U703 = EMPTY_RULEBOOK;
Constant rulebook_id_U345 = 344;
Constant rulebook_id_U346 = 345;
Constant rulebook_id_U347 = 346;
Constant action_id_U72 = 71;
Constant var_id_U106 = 20071;
Constant call_U706 = EMPTY_RULEBOOK;
Constant rulebook_id_U348 = 347;
Constant rulebook_id_U349 = 348;
Constant rulebook_id_U350 = 349;
Constant action_id_U73 = 72;
Constant var_id_U107 = 20072;
Constant call_U709 = EMPTY_RULEBOOK;
Constant rulebook_id_U351 = 350;
Constant rulebook_id_U352 = 351;
Constant rulebook_id_U353 = 352;
Constant action_id_U74 = 73;
Constant var_id_U108 = 20073;
Constant call_U712 = EMPTY_RULEBOOK;
Constant rulebook_id_U354 = 353;
Constant rulebook_id_U355 = 354;
Constant rulebook_id_U356 = 355;
Constant action_id_U75 = 74;
Constant var_id_U109 = 20074;
Constant call_U715 = EMPTY_RULEBOOK;
Constant rulebook_id_U357 = 356;
Constant rulebook_id_U358 = 357;
Constant rulebook_id_U359 = 358;
Constant action_id_U76 = 75;
Constant var_id_U110 = 20075;
Constant call_U718 = EMPTY_RULEBOOK;
Constant rulebook_id_U360 = 359;
Constant rulebook_id_U361 = 360;
Constant call_U720 = EMPTY_RULEBOOK;
Constant rulebook_id_U362 = 361;
Constant action_id_U77 = 76;
Constant var_id_U111 = 20076;
Constant response_id_U1 = 1;
Constant anchor_U4 = 1105;
Constant response_id_U2 = 2;
Constant response_id_U3 = 3;
Constant anchor_U5 = 1105;
Constant response_id_U4 = 4;
Constant anchor_U6 = 1105;
Constant response_id_U5 = 5;
Constant anchor_U7 = 1105;
Constant response_id_U6 = 6;
Constant anchor_U8 = 1105;
Constant response_id_U7 = 7;
Constant anchor_U9 = 1105;
Constant response_id_U8 = 8;
Constant anchor_U10 = 1105;
Constant response_id_U9 = 9;
Constant anchor_U11 = 1105;
Constant response_id_U10 = 10;
Constant anchor_U12 = 1105;
Constant response_id_U11 = 11;
Constant anchor_U13 = 1105;
Constant response_id_U12 = 12;
Constant response_id_U13 = 13;
Constant response_id_U14 = 14;
Constant response_id_U15 = 15;
Constant response_id_U16 = 16;
Constant response_id_U17 = 17;
Constant response_id_U18 = 18;
Constant response_id_U19 = 19;
Constant response_id_U20 = 20;
Constant response_id_U21 = 21;
Constant response_id_U22 = 22;
Constant response_id_U23 = 23;
Constant response_id_U24 = 24;
Constant response_id_U25 = 25;
Constant response_id_U26 = 26;
Constant response_id_U27 = 27;
Constant response_id_U28 = 28;
Constant response_id_U29 = 29;
Constant response_id_U30 = 30;
Constant response_id_U31 = 31;
Constant response_id_U32 = 32;
Constant response_id_U33 = 33;
Constant response_id_U34 = 34;
Constant response_id_U35 = 35;
Constant response_id_U36 = 36;
Constant anchor_U14 = 1105;
Constant response_id_U37 = 37;
Constant response_id_U38 = 38;
Constant response_id_U39 = 39;
Constant response_id_U40 = 40;
Constant response_id_U41 = 41;
Constant response_id_U42 = 42;
Constant response_id_U43 = 43;
Constant response_id_U44 = 44;
Constant response_id_U45 = 45;
Constant response_id_U46 = 46;
Constant response_id_U47 = 47;
Constant anchor_U15 = 1105;
Constant response_id_U48 = 48;
Constant response_id_U49 = 49;
Constant response_id_U50 = 50;
Constant response_id_U51 = 51;
Constant response_id_U52 = 52;
Constant response_id_U53 = 53;
Constant response_id_U54 = 54;
Constant response_id_U55 = 55;
Constant response_id_U56 = 56;
Constant response_id_U57 = 57;
Constant response_id_U58 = 58;
Constant response_id_U59 = 59;
Constant response_id_U60 = 60;
Constant response_id_U61 = 61;
Constant response_id_U62 = 62;
Constant response_id_U63 = 63;
Constant response_id_U64 = 64;
Constant response_id_U65 = 65;
Constant response_id_U66 = 66;
Constant response_id_U67 = 67;
Constant response_id_U68 = 68;
Constant response_id_U69 = 69;
Constant response_id_U70 = 70;
Constant response_id_U71 = 71;
Constant anchor_U16 = 1105;
Constant response_id_U72 = 72;
Constant response_id_U73 = 73;
Constant response_id_U74 = 74;
Constant response_id_U75 = 75;
Constant response_id_U76 = 76;
Constant response_id_U77 = 77;
Constant anchor_U17 = 1105;
Constant response_id_U78 = 78;
Constant anchor_U18 = 1105;
Constant response_id_U79 = 79;
Constant response_id_U80 = 80;
Constant response_id_U81 = 81;
Constant response_id_U82 = 82;
Constant anchor_U19 = 1105;
Constant response_id_U83 = 83;
Constant response_id_U84 = 84;
Constant response_id_U85 = 85;
Constant response_id_U86 = 86;
Constant response_id_U87 = 87;
Constant response_id_U88 = 88;
Constant response_id_U89 = 89;
Constant response_id_U90 = 90;
Constant anchor_U20 = 1105;
Constant response_id_U91 = 91;
Constant anchor_U21 = 1105;
Constant response_id_U92 = 92;
Constant response_id_U93 = 93;
Constant response_id_U94 = 94;
Constant anchor_U22 = 1105;
Constant response_id_U95 = 95;
Constant response_id_U96 = 96;
Constant anchor_U23 = 1105;
Constant response_id_U97 = 97;
Constant response_id_U98 = 98;
Constant response_id_U99 = 99;
Constant anchor_U24 = 1105;
Constant response_id_U100 = 100;
Constant response_id_U101 = 101;
Constant response_id_U102 = 102;
Constant response_id_U103 = 103;
Constant response_id_U104 = 104;
Constant response_id_U105 = 105;
Constant anchor_U25 = 1105;
Constant response_id_U106 = 106;
Constant anchor_U26 = 1105;
Constant response_id_U107 = 107;
Constant response_id_U108 = 108;
Constant anchor_U27 = 1105;
Constant response_id_U109 = 109;
Constant response_id_U110 = 110;
Constant anchor_U28 = 1105;
Constant response_id_U111 = 111;
Constant response_id_U112 = 112;
Constant anchor_U29 = 1105;
Constant response_id_U113 = 113;
Constant response_id_U114 = 114;
Constant anchor_U30 = 1105;
Constant response_id_U115 = 115;
Constant response_id_U116 = 116;
Constant response_id_U117 = 117;
Constant anchor_U31 = 1105;
Constant response_id_U118 = 118;
Constant response_id_U119 = 119;
Constant response_id_U120 = 120;
Constant anchor_U32 = 1105;
Constant response_id_U121 = 121;
Constant response_id_U122 = 122;
Constant response_id_U123 = 123;
Constant response_id_U124 = 124;
Constant response_id_U125 = 125;
Constant anchor_U33 = 1105;
Constant response_id_U126 = 126;
Constant anchor_U34 = 1105;
Constant response_id_U127 = 127;
Constant anchor_U35 = 1105;
Constant response_id_U128 = 128;
Constant anchor_U36 = 1105;
Constant response_id_U129 = 129;
Constant anchor_U37 = 1105;
Constant response_id_U130 = 130;
Constant anchor_U38 = 1105;
Constant response_id_U131 = 131;
Constant response_id_U132 = 132;
Constant response_id_U133 = 133;
Constant response_id_U134 = 134;
Constant anchor_U39 = 1105;
Constant anchor_U40 = 1105;
Constant anchor_U41 = 1105;
Constant anchor_U42 = 1105;
Constant anchor_U43 = 1105;
Constant anchor_U44 = 1105;
Constant anchor_U45 = 1105;
Constant anchor_U46 = 1105;
Constant anchor_U47 = 1105;
Constant anchor_U48 = 1105;
Constant anchor_U49 = 1105;
Constant anchor_U50 = 1105;
Constant anchor_U51 = 1105;
Constant anchor_U52 = 1105;
Constant anchor_U53 = 1105;
Constant response_id_U135 = 135;
Constant anchor_U54 = 1105;
Constant anchor_U55 = 1105;
Constant anchor_U56 = 1105;
Constant anchor_U57 = 1105;
Constant anchor_U58 = 1105;
Constant anchor_U59 = 1105;
Constant anchor_U60 = 1105;
Constant anchor_U61 = 1105;
Constant anchor_U62 = 1105;
Constant anchor_U63 = 1105;
Constant anchor_U64 = 1105;
Constant anchor_U65 = 1105;
Constant anchor_U66 = 1105;
Constant anchor_U67 = 1105;
Constant anchor_U68 = 1105;
Constant anchor_U69 = 1105;
Constant anchor_U70 = 1105;
Constant anchor_U71 = 1105;
Constant anchor_U72 = 1105;
Constant anchor_U73 = 1105;
Constant anchor_U74 = 1105;
Constant anchor_U75 = 1105;
Constant anchor_U76 = 1105;
Constant anchor_U77 = 1105;
Constant anchor_U78 = 1105;
Constant anchor_U79 = 1105;
Constant anchor_U80 = 1105;
Constant anchor_U81 = 1105;
Constant response_id_U136 = 136;
Constant anchor_U82 = 1105;
Constant response_id_U137 = 137;
Constant anchor_U83 = 1105;
Constant response_id_U138 = 138;
Constant response_id_U139 = 139;
Constant anchor_U84 = 1105;
Constant response_id_U140 = 140;
Constant anchor_U85 = 1105;
Constant anchor_U86 = 1105;
Constant anchor_U87 = 1105;
Constant anchor_U88 = 1105;
Constant response_id_U141 = 141;
Constant response_id_U142 = 142;
Constant response_id_U143 = 143;
Constant response_id_U144 = 144;
Constant response_id_U145 = 145;
Constant response_id_U146 = 146;
Constant anchor_U89 = 1105;
Constant anchor_U90 = 1105;
Constant anchor_U91 = 1105;
Constant anchor_U92 = 1105;
Constant anchor_U93 = 1105;
Constant anchor_U94 = 1105;
Constant anchor_U95 = 1105;
Constant response_id_U147 = 147;
Constant anchor_U96 = 1105;
Constant anchor_U97 = 1105;
Constant response_id_U148 = 148;
Constant anchor_U98 = 1105;
Constant response_id_U149 = 149;
Constant anchor_U99 = 1105;
Constant response_id_U150 = 150;
Constant anchor_U100 = 1105;
Constant response_id_U151 = 151;
Constant anchor_U101 = 1105;
Constant response_id_U152 = 152;
Constant anchor_U102 = 1105;
Constant response_id_U153 = 153;
Constant anchor_U103 = 1105;
Constant response_id_U154 = 154;
Constant anchor_U104 = 1105;
Constant response_id_U155 = 155;
Constant anchor_U105 = 1105;
Constant response_id_U156 = 156;
Constant anchor_U106 = 1105;
Constant response_id_U157 = 157;
Constant anchor_U107 = 1105;
Constant response_id_U158 = 158;
Constant anchor_U108 = 1105;
Constant response_id_U159 = 159;
Constant anchor_U109 = 1105;
Constant response_id_U160 = 160;
Constant anchor_U110 = 1105;
Constant response_id_U161 = 161;
Constant anchor_U111 = 1105;
Constant response_id_U162 = 162;
Constant anchor_U112 = 1105;
Constant response_id_U163 = 163;
Constant anchor_U113 = 1105;
Constant response_id_U164 = 164;
Constant anchor_U114 = 1105;
Constant anchor_U115 = 1105;
Constant response_id_U165 = 165;
Constant response_id_U166 = 166;
Constant anchor_U116 = 1105;
Constant response_id_U167 = 167;
Constant anchor_U117 = 1105;
Constant response_id_U168 = 168;
Constant anchor_U118 = 1105;
Constant anchor_U119 = 1105;
Constant response_id_U169 = 169;
Constant anchor_U120 = 1105;
Constant response_id_U170 = 170;
Constant anchor_U121 = 1105;
Constant response_id_U171 = 171;
Constant anchor_U122 = 1105;
Constant response_id_U172 = 172;
Constant anchor_U123 = 1105;
Constant response_id_U173 = 173;
Constant anchor_U124 = 1105;
Constant response_id_U174 = 174;
Constant response_id_U175 = 175;
Constant anchor_U125 = 1105;
Constant anchor_U126 = 1105;
Constant response_id_U176 = 176;
Constant response_id_U177 = 177;
Constant anchor_U127 = 1105;
Constant anchor_U128 = 1105;
Constant anchor_U129 = 1105;
Constant response_id_U178 = 178;
Constant anchor_U130 = 1105;
Constant response_id_U179 = 179;
Constant anchor_U131 = 1105;
Constant response_id_U180 = 180;
Constant anchor_U132 = 1105;
Constant response_id_U181 = 181;
Constant anchor_U133 = 1105;
Constant anchor_U134 = 1105;
Constant response_id_U182 = 182;
Constant anchor_U135 = 1105;
Constant response_id_U183 = 183;
Constant anchor_U136 = 1105;
Constant anchor_U137 = 1105;
Constant response_id_U184 = 184;
Constant anchor_U138 = 1105;
Constant response_id_U185 = 185;
Constant anchor_U139 = 1105;
Constant anchor_U140 = 1105;
Constant response_id_U186 = 186;
Constant anchor_U141 = 1105;
Constant response_id_U187 = 187;
Constant anchor_U142 = 1105;
Constant response_id_U188 = 188;
Constant anchor_U143 = 1105;
Constant response_id_U189 = 189;
Constant anchor_U144 = 1105;
Constant anchor_U145 = 1105;
Constant response_id_U190 = 190;
Constant anchor_U146 = 1105;
Constant response_id_U191 = 191;
Constant anchor_U147 = 1105;
Constant response_id_U192 = 192;
Constant anchor_U148 = 1105;
Constant response_id_U193 = 193;
Constant anchor_U149 = 1105;
Constant response_id_U194 = 194;
Constant anchor_U150 = 1105;
Constant anchor_U151 = 1105;
Constant anchor_U152 = 1105;
Constant response_id_U195 = 195;
Constant response_id_U196 = 196;
Constant anchor_U153 = 1105;
Constant anchor_U154 = 1105;
Constant response_id_U197 = 197;
Constant anchor_U155 = 1105;
Constant response_id_U198 = 198;
Constant response_id_U199 = 199;
Constant anchor_U156 = 1105;
Constant response_id_U200 = 200;
Constant anchor_U157 = 1105;
Constant response_id_U201 = 201;
Constant anchor_U158 = 1105;
Constant anchor_U159 = 1105;
Constant response_id_U202 = 202;
Constant response_id_U203 = 203;
Constant anchor_U160 = 1105;
Constant anchor_U161 = 1105;
Constant anchor_U162 = 1105;
Constant anchor_U163 = 1105;
Constant response_id_U204 = 204;
Constant response_id_U205 = 205;
Constant response_id_U206 = 206;
Constant response_id_U207 = 207;
Constant response_id_U208 = 208;
Constant response_id_U209 = 209;
Constant response_id_U210 = 210;
Constant response_id_U211 = 211;
Constant response_id_U212 = 212;
Constant response_id_U213 = 213;
Constant response_id_U214 = 214;
Constant response_id_U215 = 215;
Constant response_id_U216 = 216;
Constant response_id_U217 = 217;
Constant response_id_U218 = 218;
Constant response_id_U219 = 219;
Constant response_id_U220 = 220;
Constant response_id_U221 = 221;
Constant response_id_U222 = 222;
Constant anchor_U164 = 1105;
Constant anchor_U165 = 1105;
Constant anchor_U166 = 1105;
Constant anchor_U167 = 1105;
Constant response_id_U223 = 223;
Constant response_id_U224 = 224;
Constant anchor_U168 = 1105;
Constant response_id_U225 = 225;
Constant response_id_U226 = 226;
Constant response_id_U227 = 227;
Constant response_id_U228 = 228;
Constant anchor_U169 = 1105;
Constant response_id_U229 = 229;
Constant anchor_U170 = 1105;
Constant response_id_U230 = 230;
Constant response_id_U231 = 231;
Constant anchor_U171 = 1105;
Constant response_id_U232 = 232;
Constant anchor_U172 = 1105;
Constant response_id_U233 = 233;
Constant response_id_U234 = 234;
Constant response_id_U235 = 235;
Constant response_id_U236 = 236;
Constant response_id_U237 = 237;
Constant anchor_U173 = 1105;
Constant anchor_U174 = 1105;
Constant response_id_U238 = 238;
Constant response_id_U239 = 239;
Constant response_id_U240 = 240;
Constant response_id_U241 = 241;
Constant anchor_U175 = 1105;
Constant anchor_U176 = 1105;
Constant anchor_U177 = 1105;
Constant anchor_U178 = 1105;
Constant response_id_U242 = 242;
Constant anchor_U179 = 1105;
Constant response_id_U243 = 243;
Constant anchor_U180 = 1105;
Constant anchor_U181 = 1105;
Constant anchor_U182 = 1105;
Constant response_id_U244 = 244;
Constant response_id_U245 = 245;
Constant response_id_U246 = 246;
Constant anchor_U183 = 1105;
Constant anchor_U184 = 1105;
Constant response_id_U247 = 247;
Constant anchor_U185 = 1105;
Constant anchor_U186 = 1105;
Constant response_id_U248 = 248;
Constant anchor_U187 = 1105;
Constant anchor_U188 = 1105;
Constant anchor_U189 = 1105;
Constant anchor_U190 = 1105;
Constant response_id_U249 = 249;
Constant response_id_U250 = 250;
Constant response_id_U251 = 251;
Constant anchor_U191 = 1105;
Constant response_id_U252 = 252;
Constant anchor_U192 = 1105;
Constant anchor_U193 = 1105;
Constant anchor_U194 = 1105;
Constant response_id_U253 = 253;
Constant anchor_U195 = 1105;
Constant anchor_U196 = 1105;
Constant response_id_U254 = 254;
Constant anchor_U197 = 1105;
Constant response_id_U255 = 255;
Constant response_id_U256 = 256;
Constant anchor_U198 = 1105;
Constant response_id_U257 = 257;
Constant anchor_U199 = 1105;
Constant response_id_U258 = 258;
Constant anchor_U200 = 1105;
Constant response_id_U259 = 259;
Constant anchor_U201 = 1105;
Constant response_id_U260 = 260;
Constant anchor_U202 = 1105;
Constant response_id_U261 = 261;
Constant anchor_U203 = 1105;
Constant response_id_U262 = 262;
Constant anchor_U204 = 1105;
Constant response_id_U263 = 263;
Constant anchor_U205 = 1105;
Constant response_id_U264 = 264;
Constant anchor_U206 = 1105;
Constant response_id_U265 = 265;
Constant response_id_U266 = 266;
Constant anchor_U207 = 1105;
Constant response_id_U267 = 267;
Constant response_id_U268 = 268;
Constant anchor_U208 = 1105;
Constant response_id_U269 = 269;
Constant anchor_U209 = 1105;
Constant response_id_U270 = 270;
Constant response_id_U271 = 271;
Constant anchor_U210 = 1105;
Constant response_id_U272 = 272;
Constant anchor_U211 = 1105;
Constant response_id_U273 = 273;
Constant anchor_U212 = 1105;
Constant response_id_U274 = 274;
Constant anchor_U213 = 1105;
Constant response_id_U275 = 275;
Constant anchor_U214 = 1105;
Constant anchor_U215 = 1105;
Constant response_id_U276 = 276;
Constant response_id_U277 = 277;
Constant anchor_U216 = 1105;
Constant response_id_U278 = 278;
Constant anchor_U217 = 1105;
Constant response_id_U279 = 279;
Constant anchor_U218 = 1105;
Constant response_id_U280 = 280;
Constant anchor_U219 = 1105;
Constant anchor_U220 = 1105;
Constant response_id_U281 = 281;
Constant response_id_U282 = 282;
Constant anchor_U221 = 1105;
Constant response_id_U283 = 283;
Constant anchor_U222 = 1105;
Constant response_id_U284 = 284;
Constant anchor_U223 = 1105;
Constant anchor_U224 = 1105;
Constant response_id_U285 = 285;
Constant anchor_U225 = 1105;
Constant response_id_U286 = 286;
Constant anchor_U226 = 1105;
Constant response_id_U287 = 287;
Constant anchor_U227 = 1105;
Constant anchor_U228 = 1105;
Constant response_id_U288 = 288;
Constant anchor_U229 = 1105;
Constant response_id_U289 = 289;
Constant anchor_U230 = 1105;
Constant response_id_U290 = 290;
Constant anchor_U231 = 1105;
Constant response_id_U291 = 291;
Constant anchor_U232 = 1105;
Constant anchor_U233 = 1105;
Constant response_id_U292 = 292;
Constant anchor_U234 = 1105;
Constant response_id_U293 = 293;
Constant response_id_U294 = 294;
Constant response_id_U295 = 295;
Constant anchor_U235 = 1105;
Constant response_id_U296 = 296;
Constant anchor_U236 = 1105;
Constant response_id_U297 = 297;
Constant anchor_U237 = 1105;
Constant anchor_U238 = 1105;
Constant response_id_U298 = 298;
Constant response_id_U299 = 299;
Constant response_id_U300 = 300;
Constant anchor_U239 = 1105;
Constant response_id_U301 = 301;
Constant anchor_U240 = 1105;
Constant response_id_U302 = 302;
Constant anchor_U241 = 1105;
Constant response_id_U303 = 303;
Constant anchor_U242 = 1105;
Constant anchor_U243 = 1105;
Constant response_id_U304 = 304;
Constant response_id_U305 = 305;
Constant anchor_U244 = 1105;
Constant anchor_U245 = 1105;
Constant response_id_U306 = 306;
Constant anchor_U246 = 1105;
Constant response_id_U307 = 307;
Constant anchor_U247 = 1105;
Constant anchor_U248 = 1105;
Constant response_id_U308 = 308;
Constant response_id_U309 = 309;
Constant anchor_U249 = 1105;
Constant response_id_U310 = 310;
Constant anchor_U250 = 1105;
Constant response_id_U311 = 311;
Constant anchor_U251 = 1105;
Constant response_id_U312 = 312;
Constant anchor_U252 = 1105;
Constant response_id_U313 = 313;
Constant anchor_U253 = 1105;
Constant response_id_U314 = 314;
Constant anchor_U254 = 1105;
Constant response_id_U315 = 315;
Constant anchor_U255 = 1105;
Constant anchor_U256 = 1105;
Constant response_id_U316 = 316;
Constant response_id_U317 = 317;
Constant response_id_U318 = 318;
Constant anchor_U257 = 1105;
Constant response_id_U319 = 319;
Constant anchor_U258 = 1105;
Constant anchor_U259 = 1105;
Constant response_id_U320 = 320;
Constant anchor_U260 = 1105;
Constant response_id_U321 = 321;
Constant anchor_U261 = 1105;
Constant response_id_U322 = 322;
Constant anchor_U262 = 1105;
Constant response_id_U323 = 323;
Constant anchor_U263 = 1105;
Constant response_id_U324 = 324;
Constant anchor_U264 = 1105;
Constant response_id_U325 = 325;
Constant anchor_U265 = 1105;
Constant response_id_U326 = 326;
Constant anchor_U266 = 1105;
Constant response_id_U327 = 327;
Constant anchor_U267 = 1105;
Constant response_id_U328 = 328;
Constant anchor_U268 = 1105;
Constant response_id_U329 = 329;
Constant anchor_U269 = 1105;
Constant response_id_U330 = 330;
Constant anchor_U270 = 1105;
Constant response_id_U331 = 331;
Constant anchor_U271 = 1105;
Constant anchor_U272 = 1105;
Constant anchor_U273 = 1105;
Constant response_id_U332 = 332;
Constant response_id_U333 = 333;
Constant anchor_U274 = 1105;
Constant response_id_U334 = 334;
Constant response_id_U335 = 335;
Constant anchor_U275 = 1105;
Constant response_id_U336 = 336;
Constant response_id_U337 = 337;
Constant response_id_U338 = 338;
Constant anchor_U276 = 1105;
Constant response_id_U339 = 339;
Constant response_id_U340 = 340;
Constant anchor_U277 = 1105;
Constant response_id_U341 = 341;
Constant anchor_U278 = 1105;
Constant response_id_U342 = 342;
Constant response_id_U343 = 343;
Constant anchor_U279 = 1105;
Constant response_id_U344 = 344;
Constant anchor_U280 = 1105;
Constant response_id_U345 = 345;
Constant anchor_U281 = 1105;
Constant response_id_U346 = 346;
Constant anchor_U282 = 1105;
Constant response_id_U347 = 347;
Constant response_id_U348 = 348;
Constant anchor_U283 = 1105;
Constant response_id_U349 = 349;
Constant anchor_U284 = 1105;
Constant response_id_U350 = 350;
Constant anchor_U285 = 1105;
Constant response_id_U351 = 351;
Constant anchor_U286 = 1105;
Constant response_id_U352 = 352;
Constant response_id_U353 = 353;
Constant anchor_U287 = 1105;
Constant response_id_U354 = 354;
Constant anchor_U288 = 1105;
Constant response_id_U355 = 355;
Constant anchor_U289 = 1105;
Constant response_id_U356 = 356;
Constant anchor_U290 = 1105;
Constant response_id_U357 = 357;
Constant response_id_U358 = 358;
Constant anchor_U291 = 1105;
Constant response_id_U359 = 359;
Constant anchor_U292 = 1105;
Constant response_id_U360 = 360;
Constant anchor_U293 = 1105;
Constant response_id_U361 = 361;
Constant anchor_U294 = 1105;
Constant response_id_U362 = 362;
Constant anchor_U295 = 1105;
Constant anchor_U296 = 1105;
Constant response_id_U363 = 363;
Constant anchor_U297 = 1105;
Constant response_id_U364 = 364;
Constant anchor_U298 = 1105;
Constant response_id_U365 = 365;
Constant response_id_U366 = 366;
Constant anchor_U299 = 1105;
Constant response_id_U367 = 367;
Constant anchor_U300 = 1105;
Constant response_id_U368 = 368;
Constant anchor_U301 = 1105;
Constant response_id_U369 = 369;
Constant anchor_U302 = 1105;
Constant response_id_U370 = 370;
Constant anchor_U303 = 1105;
Constant response_id_U371 = 371;
Constant anchor_U304 = 1105;
Constant response_id_U372 = 372;
Constant response_id_U373 = 373;
Constant anchor_U305 = 1105;
Constant response_id_U374 = 374;
Constant response_id_U375 = 375;
Constant anchor_U306 = 1105;
Constant response_id_U376 = 376;
Constant response_id_U377 = 377;
Constant anchor_U307 = 1105;
Constant response_id_U378 = 378;
Constant anchor_U308 = 1105;
Constant response_id_U379 = 379;
Constant response_id_U380 = 380;
Constant anchor_U309 = 1105;
Constant response_id_U381 = 381;
Constant anchor_U310 = 1105;
Constant response_id_U382 = 382;
Constant anchor_U311 = 1105;
Constant response_id_U383 = 383;
Constant anchor_U312 = 1105;
Constant response_id_U384 = 384;
Constant anchor_U313 = 1105;
Constant response_id_U385 = 385;
Constant anchor_U314 = 1105;
Constant response_id_U386 = 386;
Constant response_id_U387 = 387;
Constant anchor_U315 = 1105;
Constant response_id_U388 = 388;
Constant anchor_U316 = 1105;
Constant response_id_U389 = 389;
Constant response_id_U390 = 390;
Constant anchor_U317 = 1105;
Constant response_id_U391 = 391;
Constant anchor_U318 = 1105;
Constant response_id_U392 = 392;
Constant anchor_U319 = 1105;
Constant response_id_U393 = 393;
Constant anchor_U320 = 1105;
Constant anchor_U321 = 1105;
Constant anchor_U322 = 1105;
Constant anchor_U323 = 1105;
Constant anchor_U324 = 1105;
Constant anchor_U325 = 1105;
Constant anchor_U326 = 1105;
Constant anchor_U327 = 1105;
Constant anchor_U328 = 1105;
Constant anchor_U329 = 1105;
Constant anchor_U330 = 1105;
Constant anchor_U331 = 1105;
Constant anchor_U332 = 1105;
Constant anchor_U333 = 1105;
Constant anchor_U334 = 1105;
Constant anchor_U335 = 1105;
Constant anchor_U336 = 1105;
Constant anchor_U337 = 1105;
Constant anchor_U338 = 1105;
Constant anchor_U339 = 1105;
Constant anchor_U340 = 1105;
Constant anchor_U341 = 1105;
Constant anchor_U342 = 1105;
Constant anchor_U343 = 1105;
Constant anchor_U344 = 1105;
Constant anchor_U345 = 1105;
Constant anchor_U346 = 1105;
Constant anchor_U347 = 1105;
Constant anchor_U348 = 1105;
Constant anchor_U349 = 1105;
Constant kind_ref_U51 = 561;
Constant WEAK_ID_52 = 3;
Constant ICOUNT_ROOM = 31;
Constant K1_room_First = I_parking_lot_U1;
Constant kind_ref_U52 = 561;
Constant WEAK_ID_53 = 4;
Constant ICOUNT_THING = 132;
Constant K2_thing_First = selfobj;
Constant kind_ref_U53 = 561;
Constant WEAK_ID_54 = 5;
Constant ICOUNT_DIRECTION = 12;
Constant K3_direction_First = I_north_U1;
Constant kind_ref_U54 = 561;
Constant WEAK_ID_55 = 6;
Constant ICOUNT_DOOR = 7;
Constant K4_door_First = I_aqua_door_U1;
Constant kind_ref_U55 = 561;
Constant WEAK_ID_56 = 7;
Constant ICOUNT_CONTAINER = 24;
Constant K5_container_First = I_wallet_U1;
Constant kind_ref_U56 = 561;
Constant WEAK_ID_57 = 8;
Constant ICOUNT_SUPPORTER = 9;
Constant K6_supporter_First = I_car_seat_U1;
Constant kind_ref_U57 = 561;
Constant WEAK_ID_58 = 9;
Constant ICOUNT_BACKDROP = 4;
Constant K7_backdrop_First = I_lurking_grue_U1;
Constant kind_ref_U58 = 561;
Constant WEAK_ID_59 = 10;
Constant ICOUNT_PERSON = 7;
Constant K8_person_First = selfobj;
Constant kind_ref_U59 = 561;
Constant WEAK_ID_60 = 11;
Constant ICOUNT_REGION = 4;
Constant K9_region_First = I_midway_U1;
Constant kind_ref_U60 = 561;
Constant WEAK_ID_61 = 12;
Constant ICOUNT_MAN = 3;
Constant K10_man_First = I_parking_attendant_U1;
Constant kind_ref_U61 = 561;
Constant WEAK_ID_62 = 13;
Constant ICOUNT_WOMAN = 1;
Constant K11_woman_First = I_little_egypt_U1;
Constant kind_ref_U62 = 561;
Constant WEAK_ID_63 = 14;
Constant ICOUNT_ANIMAL = 0;
Constant kind_ref_U63 = 561;
Constant WEAK_ID_64 = 15;
Constant ICOUNT_DEVICE = 32;
Constant K13_device_First = I_flashlight_U1;
Constant kind_ref_U64 = 561;
Constant WEAK_ID_65 = 16;
Constant ICOUNT_VEHICLE = 1;
Constant K14_vehicle_First = I_hell_ride_car_U1;
Constant kind_ref_U65 = 561;
Constant WEAK_ID_66 = 17;
Constant ICOUNT_PLAYER_S_HOLDALL = 0;
Constant kind_ref_U66 = 561;
Constant WEAK_ID_67 = 18;
Constant ICOUNT_COMMAND_PARSER_ERROR = 25;
Constant INITIAL_MAX_SCORE = 105;
Constant extension_id_U3 = 3;
Constant column_bits_U1 = 1636;
Constant column_blanks_U1 = 0;
Constant column_bits_U2 = 1125;
Constant column_blanks_U2 = 1;
Constant column_bits_U3 = 8294;
Constant column_blanks_U3 = 2;
Constant column_bits_U4 = 103;
Constant column_blanks_U4 = 3;
Constant column_bits_U5 = 104;
Constant column_blanks_U5 = 4;
Constant table_id_U1 = 1;
Constant column_bits_U6 = 2153;
Constant column_bits_U7 = 17514;
Constant column_blanks_U6 = 5;
Constant table_id_U2 = 2;
Constant use_option_id_U29 = 28;
Constant call_U1927 = EMPTY_RULEBOOK;
Constant rulebook_id_U363 = 362;
Constant rulebook_id_U364 = 363;
Constant call_U1929 = EMPTY_RULEBOOK;
Constant rulebook_id_U365 = 364;
Constant activity_id_U35 = 34;
Constant var_id_U112 = 10034;
Constant rulebook_id_U366 = 365;
Constant rulebook_id_U367 = 366;
Constant call_U1932 = EMPTY_RULEBOOK;
Constant rulebook_id_U368 = 367;
Constant action_id_U78 = 77;
Constant var_id_U113 = 20077;
Constant rulebook_id_U369 = 368;
Constant rulebook_id_U370 = 369;
Constant call_U1936 = EMPTY_RULEBOOK;
Constant rulebook_id_U371 = 370;
Constant action_id_U79 = 78;
Constant var_id_U114 = 20078;
Constant relation_id_U123 = 99;
Constant relation_id_U124 = 100;
Constant kind_ref_U67 = 561;
Constant WEAK_ID_68 = 23;
Constant ICOUNT_PASSKEY = 0;
Constant kind_ref_U68 = 561;
Constant WEAK_ID_69 = 24;
Constant ICOUNT_KEYCHAIN = 0;
Constant anchor_U350 = 1105;
Constant response_id_U394 = 394;
Constant anchor_U351 = 1105;
Constant response_id_U395 = 395;
Constant anchor_U352 = 1105;
Constant response_id_U396 = 396;
Constant anchor_U353 = 1105;
Constant response_id_U397 = 397;
Constant anchor_U354 = 1105;
Constant anchor_U355 = 1105;
Constant anchor_U356 = 1105;
Constant anchor_U357 = 1105;
Constant anchor_U358 = 1105;
Constant anchor_U359 = 1105;
Constant response_id_U398 = 398;
Constant anchor_U360 = 1105;
Constant anchor_U361 = 1105;
Constant response_id_U399 = 399;
Constant anchor_U362 = 1105;
Constant anchor_U363 = 1105;
Constant response_id_U400 = 400;
Constant anchor_U364 = 1105;
Constant anchor_U365 = 1105;
Constant anchor_U366 = 1105;
Constant response_id_U401 = 401;
Constant anchor_U367 = 1105;
Constant response_id_U402 = 402;
Constant anchor_U368 = 1105;
Constant response_id_U403 = 403;
Constant anchor_U369 = 1105;
Constant anchor_U370 = 1105;
Constant anchor_U371 = 1105;
Constant anchor_U372 = 1105;
Constant anchor_U373 = 1105;
Constant response_id_U404 = 404;
Constant anchor_U374 = 1105;
Constant anchor_U375 = 1105;
Constant anchor_U376 = 1105;
Constant anchor_U377 = 1105;
Constant anchor_U378 = 1105;
Constant anchor_U379 = 1105;
Constant anchor_U380 = 1105;
Constant response_id_U405 = 405;
Constant anchor_U381 = 1105;
Constant response_id_U406 = 406;
Constant property_id_U120 = 41;
Constant extension_id_U4 = 4;
Constant table_column_id_U8 = 107;
Constant table_column_id_U9 = 108;
Constant table_column_id_U10 = 109;
Constant call_U2005 = EMPTY_RULEBOOK;
Constant rulebook_id_U372 = 371;
Constant rulebook_id_U373 = 372;
Constant call_U2007 = EMPTY_RULEBOOK;
Constant rulebook_id_U374 = 373;
Constant activity_id_U36 = 35;
Constant var_id_U115 = 10035;
Constant anchor_U382 = 1105;
Constant response_id_U407 = 407;
Constant column_bits_U8 = 1643;
Constant column_blanks_U7 = 22;
Constant column_bits_U9 = 1644;
Constant column_blanks_U8 = 23;
Constant column_bits_U10 = 1645;
Constant column_blanks_U9 = 24;
Constant table_id_U3 = 3;
Constant extension_id_U5 = 5;
Constant relation_id_U125 = 101;
Constant relation_id_U126 = 102;
Constant relation_id_U127 = 103;
Constant table_column_id_U11 = 110;
Constant table_column_id_U12 = 111;
Constant table_column_id_U13 = 112;
Constant table_column_id_U14 = 113;
Constant table_column_id_U15 = 114;
Constant table_column_id_U16 = 115;
Constant table_column_id_U17 = 116;
Constant table_column_id_U18 = 117;
Constant call_U2015 = EMPTY_RULEBOOK;
Constant rulebook_id_U375 = 374;
Constant rulebook_id_U376 = 375;
Constant call_U2017 = EMPTY_RULEBOOK;
Constant rulebook_id_U377 = 376;
Constant activity_id_U37 = 36;
Constant var_id_U116 = 10036;
Constant anchor_U383 = 1105;
Constant anchor_U384 = 1105;
Constant anchor_U385 = 1105;
Constant anchor_U386 = 1105;
Constant anchor_U387 = 1105;
Constant anchor_U388 = 1105;
Constant anchor_U389 = 1105;
Constant column_bits_U11 = 1646;
Constant column_blanks_U10 = 25;
Constant column_bits_U12 = 111;
Constant column_blanks_U11 = 26;
Constant column_bits_U13 = 1648;
Constant column_blanks_U12 = 27;
Constant column_bits_U14 = 113;
Constant column_blanks_U13 = 28;
Constant table_id_U4 = 4;
Constant column_bits_U15 = 17522;
Constant column_blanks_U14 = 29;
Constant column_bits_U16 = 115;
Constant column_blanks_U15 = 31;
Constant table_id_U5 = 5;
Constant column_bits_U17 = 1643;
Constant column_blanks_U16 = 33;
Constant column_bits_U18 = 1644;
Constant column_blanks_U17 = 34;
Constant column_bits_U19 = 1645;
Constant column_blanks_U18 = 35;
Constant table_id_U6 = 6;
Constant column_bits_U20 = 1643;
Constant column_blanks_U19 = 36;
Constant column_bits_U21 = 1644;
Constant column_blanks_U20 = 37;
Constant column_bits_U22 = 1645;
Constant column_blanks_U21 = 38;
Constant table_id_U7 = 7;
Constant column_bits_U23 = 1652;
Constant column_blanks_U22 = 39;
Constant column_bits_U24 = 17525;
Constant column_blanks_U23 = 40;
Constant table_id_U8 = 8;
Constant extension_id_U6 = 6;
Constant relation_id_U128 = 104;
Constant relation_id_U129 = 105;
Constant relation_id_U130 = 106;
Constant relation_id_U131 = 107;
Constant relation_id_U132 = 108;
Constant relation_id_U133 = 109;
Constant relation_id_U134 = 110;
Constant relation_id_U135 = 111;
Constant call_U2032 = EMPTY_RULEBOOK;
Constant rulebook_id_U378 = 377;
Constant rulebook_id_U379 = 378;
Constant call_U2034 = EMPTY_RULEBOOK;
Constant rulebook_id_U380 = 379;
Constant action_id_U80 = 79;
Constant var_id_U117 = 20079;
Constant kind_ref_U69 = 561;
Constant WEAK_ID_70 = 25;
Constant ICOUNT_VERBOSITY = 3;
Constant anchor_U390 = 1105;
Constant anchor_U391 = 1105;
Constant anchor_U392 = 1105;
Constant extension_id_U7 = 7;
Constant column_bits_U25 = 1646;
Constant column_blanks_U24 = 41;
Constant column_bits_U26 = 111;
Constant column_blanks_U25 = 42;
Constant column_bits_U27 = 1648;
Constant column_blanks_U26 = 43;
Constant column_bits_U28 = 113;
Constant column_blanks_U27 = 44;
Constant table_id_U9 = 9;
Constant column_bits_U29 = 1646;
Constant column_blanks_U28 = 45;
Constant column_bits_U30 = 111;
Constant column_blanks_U29 = 46;
Constant column_bits_U31 = 1648;
Constant column_blanks_U30 = 47;
Constant column_bits_U32 = 113;
Constant column_blanks_U31 = 48;
Constant table_id_U10 = 10;
Constant column_bits_U33 = 1646;
Constant column_blanks_U32 = 49;
Constant column_bits_U34 = 111;
Constant column_blanks_U33 = 50;
Constant column_bits_U35 = 1648;
Constant column_blanks_U34 = 51;
Constant column_bits_U36 = 113;
Constant column_blanks_U35 = 52;
Constant table_id_U11 = 11;
Constant column_bits_U37 = 1646;
Constant column_blanks_U36 = 53;
Constant column_bits_U38 = 111;
Constant column_blanks_U37 = 54;
Constant column_bits_U39 = 1648;
Constant column_blanks_U38 = 55;
Constant column_bits_U40 = 113;
Constant column_blanks_U39 = 56;
Constant table_id_U12 = 12;
Constant column_bits_U41 = 1646;
Constant column_blanks_U40 = 57;
Constant column_bits_U42 = 111;
Constant column_blanks_U41 = 58;
Constant column_bits_U43 = 1648;
Constant column_blanks_U42 = 59;
Constant column_bits_U44 = 113;
Constant column_blanks_U43 = 60;
Constant table_id_U13 = 13;
Constant rulebook_id_U381 = 380;
Constant rulebook_id_U382 = 381;
Constant rulebook_id_U383 = 382;
Constant action_id_U81 = 80;
Constant var_id_U118 = 20080;
Constant rulebook_id_U384 = 383;
Constant rulebook_id_U385 = 384;
Constant rulebook_id_U386 = 385;
Constant action_id_U82 = 81;
Constant var_id_U119 = 20081;
Constant kind_ref_U70 = 561;
Constant WEAK_ID_71 = 26;
Constant ICOUNT_RIDEABLE_ANIMAL = 0;
Constant kind_ref_U71 = 561;
Constant WEAK_ID_72 = 27;
Constant ICOUNT_RIDEABLE_VEHICLE = 0;
Constant anchor_U393 = 1105;
Constant anchor_U394 = 1105;
Constant anchor_U395 = 1105;
Constant anchor_U396 = 1105;
Constant anchor_U397 = 1105;
Constant anchor_U398 = 1105;
Constant anchor_U399 = 1105;
Constant response_id_U408 = 408;
Constant anchor_U400 = 1105;
Constant response_id_U409 = 409;
Constant anchor_U401 = 1105;
Constant response_id_U410 = 410;
Constant anchor_U402 = 1105;
Constant anchor_U403 = 1105;
Constant anchor_U404 = 1105;
Constant anchor_U405 = 1105;
Constant response_id_U411 = 411;
Constant response_id_U412 = 412;
Constant anchor_U406 = 1105;
Constant response_id_U413 = 413;
Constant response_id_U414 = 414;
Constant response_id_U415 = 415;
Constant anchor_U407 = 1105;
Constant response_id_U416 = 416;
Constant anchor_U408 = 1105;
Constant anchor_U409 = 1105;
Constant response_id_U417 = 417;
Constant response_id_U418 = 418;
Constant anchor_U410 = 1105;
Constant response_id_U419 = 419;
Constant anchor_U411 = 1105;
Constant extension_id_U8 = 8;
Constant rulebook_id_U387 = 386;
Constant call_U2115 = EMPTY_RULEBOOK;
Constant rulebook_id_U388 = 387;
Constant call_U2116 = EMPTY_RULEBOOK;
Constant rulebook_id_U389 = 388;
Constant action_id_U83 = 82;
Constant var_id_U120 = 20082;
Constant rulebook_id_U390 = 389;
Constant call_U2118 = EMPTY_RULEBOOK;
Constant rulebook_id_U391 = 390;
Constant call_U2119 = EMPTY_RULEBOOK;
Constant rulebook_id_U392 = 391;
Constant action_id_U84 = 83;
Constant var_id_U121 = 20083;
Constant anchor_U412 = 1105;
Constant anchor_U413 = 1105;
Constant extension_id_U9 = 9;
Constant rulebook_id_U393 = 392;
Constant call_U2123 = EMPTY_RULEBOOK;
Constant rulebook_id_U394 = 393;
Constant call_U2124 = EMPTY_RULEBOOK;
Constant rulebook_id_U395 = 394;
Constant action_id_U85 = 84;
Constant var_id_U122 = 20084;
Constant anchor_U414 = 1105;
Constant extension_id_U10 = 10;
Constant table_column_id_U19 = 118;
Constant rulebook_id_U396 = 395;
Constant rulebook_id_U397 = 396;
Constant rulebook_id_U398 = 397;
Constant action_id_U86 = 85;
Constant var_id_U123 = 20085;
Constant rulebook_id_U399 = 398;
Constant rulebook_id_U400 = 399;
Constant rulebook_id_U401 = 400;
Constant action_id_U87 = 86;
Constant var_id_U124 = 20086;
Constant rulebook_id_U402 = 401;
Constant rulebook_id_U403 = 402;
Constant call_U2274 = EMPTY_RULEBOOK;
Constant rulebook_id_U404 = 403;
Constant action_id_U88 = 87;
Constant var_id_U125 = 20087;
Constant call_U2275 = EMPTY_RULEBOOK;
Constant rulebook_id_U405 = 404;
Constant rulebook_id_U406 = 405;
Constant call_U2277 = EMPTY_RULEBOOK;
Constant rulebook_id_U407 = 406;
Constant action_id_U89 = 88;
Constant var_id_U126 = 20088;
Constant rulebook_id_U408 = 407;
Constant rulebook_id_U409 = 408;
Constant call_U2280 = EMPTY_RULEBOOK;
Constant rulebook_id_U410 = 409;
Constant action_id_U90 = 89;
Constant var_id_U127 = 20089;
Constant rulebook_id_U411 = 410;
Constant call_U2282 = EMPTY_RULEBOOK;
Constant rulebook_id_U412 = 411;
Constant rulebook_id_U413 = 412;
Constant action_id_U91 = 90;
Constant var_id_U128 = 20090;
Constant relation_id_U136 = 112;
Constant relation_id_U137 = 113;
Constant relation_id_U138 = 114;
Constant relation_id_U139 = 115;
Constant relation_id_U140 = 116;
Constant relation_id_U141 = 117;
Constant relation_id_U142 = 118;
Constant relation_id_U143 = 119;
Constant relation_id_U144 = 120;
Constant relation_id_U145 = 121;
Constant relation_id_U146 = 122;
Constant relation_id_U147 = 123;
Constant relation_id_U148 = 124;
Constant relation_id_U149 = 125;
Constant relation_id_U150 = 126;
Constant relation_id_U151 = 127;
Constant relation_id_U152 = 128;
Constant relation_id_U153 = 129;
Constant relation_id_U154 = 130;
Constant relation_id_U155 = 131;
Constant relation_id_U156 = 132;
Constant relation_id_U157 = 133;
Constant relation_id_U158 = 134;
Constant relation_id_U159 = 135;
Constant relation_id_U160 = 136;
Constant relation_id_U161 = 137;
Constant relation_id_U162 = 138;
Constant relation_id_U163 = 139;
Constant relation_id_U164 = 140;
Constant relation_id_U165 = 141;
Constant relation_id_U166 = 142;
Constant relation_id_U167 = 143;
Constant relation_id_U168 = 144;
Constant relation_id_U169 = 145;
Constant relation_id_U170 = 146;
Constant relation_id_U171 = 147;
Constant relation_id_U172 = 148;
Constant call_U2304 = EMPTY_RULEBOOK;
Constant rulebook_id_U414 = 413;
Constant rulebook_id_U415 = 414;
Constant call_U2306 = EMPTY_RULEBOOK;
Constant rulebook_id_U416 = 415;
Constant activity_id_U38 = 37;
Constant var_id_U129 = 10037;
Constant call_U2307 = EMPTY_RULEBOOK;
Constant rulebook_id_U417 = 416;
Constant rulebook_id_U418 = 417;
Constant rulebook_id_U419 = 418;
Constant rulebook_id_U420 = 419;
Constant kind_ref_U72 = 561;
Constant WEAK_ID_73 = 28;
Constant kind_ref_U73 = 561;
Constant WEAK_ID_74 = 29;
Constant kind_ref_U74 = 561;
Constant WEAK_ID_75 = 30;
Constant ICOUNT_FLUID_CONTAINER = 1;
Constant K20_fluid_container_First = I_can_U1;
Constant kind_ref_U75 = 561;
Constant WEAK_ID_76 = 31;
Constant ICOUNT_LIQUID = 5;
Constant kind_ref_U76 = 561;
Constant WEAK_ID_77 = 32;
Constant ICOUNT_ELECTRIC_LAMP = 1;
Constant K21_electric_lamp_First = I_flashlight_U1;
Constant kind_ref_U77 = 561;
Constant WEAK_ID_78 = 33;
Constant ICOUNT_SWITCH = 0;
Constant kind_ref_U78 = 561;
Constant WEAK_ID_79 = 34;
Constant ICOUNT_SOCKET = 1;
Constant K23_socket_First = I_socket_eleven_U1;
Constant kind_ref_U79 = 561;
Constant WEAK_ID_80 = 35;
Constant ICOUNT_COLORED_FUSE = 6;
Constant K24_colored_fuse_First = I_aqua_fuse_U1;
Constant kind_ref_U80 = 561;
Constant WEAK_ID_81 = 36;
Constant ICOUNT_STRENGTH_PATTERN = 5;
Constant kind_ref_U81 = 561;
Constant WEAK_ID_82 = 37;
Constant ICOUNT_COLORED_LIGHT = 6;
Constant K25_colored_light_First = I_aqua_light_U1;
Constant kind_ref_U82 = 561;
Constant WEAK_ID_83 = 38;
Constant ICOUNT_COLORED_BUTTON = 6;
Constant K26_colored_button_First = I_aqua_button_U1;
Constant kind_ref_U83 = 561;
Constant WEAK_ID_84 = 39;
Constant ICOUNT_COLORED_DIAL = 6;
Constant K27_colored_dial_First = I_aqua_dial_U1;
Constant anchor_U415 = 1105;
Constant anchor_U416 = 1105;
Constant anchor_U417 = 1105;
Constant anchor_U418 = 1105;
Constant anchor_U419 = 1105;
Constant anchor_U420 = 1105;
Constant anchor_U421 = 1105;
Constant anchor_U422 = 1105;
Constant anchor_U423 = 1105;
Constant anchor_U424 = 1105;
Constant anchor_U425 = 1105;
Constant anchor_U426 = 1105;
Constant anchor_U427 = 1105;
Constant anchor_U428 = 1105;
Constant anchor_U429 = 1105;
Constant anchor_U430 = 1105;
Constant anchor_U431 = 1105;
Constant anchor_U432 = 1105;
Constant anchor_U433 = 1105;
Constant anchor_U434 = 1105;
Constant anchor_U435 = 1105;
Constant anchor_U436 = 1105;
Constant anchor_U437 = 1105;
Constant anchor_U438 = 1105;
Constant anchor_U439 = 1105;
Constant anchor_U440 = 1105;
Constant anchor_U441 = 1105;
Constant anchor_U442 = 1105;
Constant anchor_U443 = 1105;
Constant anchor_U444 = 1105;
Constant anchor_U445 = 1105;
Constant anchor_U446 = 1105;
Constant anchor_U447 = 1105;
Constant anchor_U448 = 1105;
Constant anchor_U449 = 1105;
Constant anchor_U450 = 1105;
Constant anchor_U451 = 1105;
Constant anchor_U452 = 1105;
Constant anchor_U453 = 1105;
Constant anchor_U454 = 1105;
Constant anchor_U455 = 1105;
Constant anchor_U456 = 1105;
Constant anchor_U457 = 1105;
Constant anchor_U458 = 1105;
Constant anchor_U459 = 1105;
Constant anchor_U460 = 1105;
Constant anchor_U461 = 1105;
Constant anchor_U462 = 1105;
Constant anchor_U463 = 1105;
Constant anchor_U464 = 1105;
Constant anchor_U465 = 1105;
Constant anchor_U466 = 1105;
Constant anchor_U467 = 1105;
Constant anchor_U468 = 1105;
Constant anchor_U469 = 1105;
Constant anchor_U470 = 1105;
Constant anchor_U471 = 1105;
Constant anchor_U472 = 1105;
Constant anchor_U473 = 1105;
Constant anchor_U474 = 1105;
Constant anchor_U475 = 1105;
Constant anchor_U476 = 1105;
Constant anchor_U477 = 1105;
Constant anchor_U478 = 1105;
Constant anchor_U479 = 1105;
Constant anchor_U480 = 1105;
Constant anchor_U481 = 1105;
Constant anchor_U482 = 1105;
Constant anchor_U483 = 1105;
Constant anchor_U484 = 1105;
Constant anchor_U485 = 1105;
Constant anchor_U486 = 1105;
Constant anchor_U487 = 1105;
Constant anchor_U488 = 1105;
Constant anchor_U489 = 1105;
Constant anchor_U490 = 1105;
Constant anchor_U491 = 1105;
Constant anchor_U492 = 1105;
Constant anchor_U493 = 1105;
Constant anchor_U494 = 1105;
Constant anchor_U495 = 1105;
Constant anchor_U496 = 1105;
Constant anchor_U497 = 1105;
Constant anchor_U498 = 1105;
Constant anchor_U499 = 1105;
Constant anchor_U500 = 1105;
Constant anchor_U501 = 1105;
Constant anchor_U502 = 1105;
Constant anchor_U503 = 1105;
Constant anchor_U504 = 1105;
Constant anchor_U505 = 1105;
Constant anchor_U506 = 1105;
Constant anchor_U507 = 1105;
Constant anchor_U508 = 1105;
Constant anchor_U509 = 1105;
Constant anchor_U510 = 1105;
Constant anchor_U511 = 1105;
Constant anchor_U512 = 1105;
Constant anchor_U513 = 1105;
Constant anchor_U514 = 1105;
Constant anchor_U515 = 1105;
Constant anchor_U516 = 1105;
Constant anchor_U517 = 1105;
Constant anchor_U518 = 1105;
Constant anchor_U519 = 1105;
Constant anchor_U520 = 1105;
Constant anchor_U521 = 1105;
Constant anchor_U522 = 1105;
Constant anchor_U523 = 1105;
Constant anchor_U524 = 1105;
Constant anchor_U525 = 1105;
Constant anchor_U526 = 1105;
Constant anchor_U527 = 1105;
Constant anchor_U528 = 1105;
Constant anchor_U529 = 1105;
Constant anchor_U530 = 1105;
Constant anchor_U531 = 1105;
Constant anchor_U532 = 1105;
Constant anchor_U533 = 1105;
Constant anchor_U534 = 1105;
Constant anchor_U535 = 1105;
Constant anchor_U536 = 1105;
Constant anchor_U537 = 1105;
Constant anchor_U538 = 1105;
Constant anchor_U539 = 1105;
Constant anchor_U540 = 1105;
Constant anchor_U541 = 1105;
Constant anchor_U542 = 1105;
Constant anchor_U543 = 1105;
Constant anchor_U544 = 1105;
Constant anchor_U545 = 1105;
Constant anchor_U546 = 1105;
Constant anchor_U547 = 1105;
Constant anchor_U548 = 1105;
Constant anchor_U549 = 1105;
Constant anchor_U550 = 1105;
Constant anchor_U551 = 1105;
Constant anchor_U552 = 1105;
Constant anchor_U553 = 1105;
Constant anchor_U554 = 1105;
Constant anchor_U555 = 1105;
Constant anchor_U556 = 1105;
Constant anchor_U557 = 1105;
Constant anchor_U558 = 1105;
Constant anchor_U559 = 1105;
Constant anchor_U560 = 1105;
Constant anchor_U561 = 1105;
Constant anchor_U562 = 1105;
Constant anchor_U563 = 1105;
Constant anchor_U564 = 1105;
Constant anchor_U565 = 1105;
Constant anchor_U566 = 1105;
Constant anchor_U567 = 1105;
Constant anchor_U568 = 1105;
Constant anchor_U569 = 1105;
Constant anchor_U570 = 1105;
Constant anchor_U571 = 1105;
Constant anchor_U572 = 1105;
Constant anchor_U573 = 1105;
Constant anchor_U574 = 1105;
Constant anchor_U575 = 1105;
Constant anchor_U576 = 1105;
Constant anchor_U577 = 1105;
Constant anchor_U578 = 1105;
Constant anchor_U579 = 1105;
Constant anchor_U580 = 1105;
Constant anchor_U581 = 1105;
Constant anchor_U582 = 1105;
Constant anchor_U583 = 1105;
Constant anchor_U584 = 1105;
Constant anchor_U585 = 1105;
Constant anchor_U586 = 1105;
Constant property_id_U121 = 42;
Constant property_id_U122 = 43;
Constant property_id_U123 = 44;
Constant property_id_U124 = 45;
Constant property_id_U125 = 46;
Constant property_id_U126 = 47;
Constant property_id_U127 = 48;
Constant property_id_U128 = 49;
Constant property_id_U129 = 50;
Constant property_id_U130 = 51;
Constant property_id_U131 = 52;
Constant property_id_U132 = 53;
Constant column_bits_U45 = 1654;
Constant column_blanks_U44 = 61;
Constant table_id_U14 = 14;
Constant column_bits_U46 = 1654;
Constant column_blanks_U45 = 62;
Constant table_id_U15 = 15;
Constant ptc_id_U1 = 0;
Constant ptc_id_U2 = 1;
Constant ahc_id_U1 = 0;
Constant ahc_id_U2 = 1;
Constant ahc_id_U3 = 2;
Constant ahc_id_U4 = 3;
Release 104;
Constant No_Directions = 12;
Constant line_ref_U1 = 561;
Constant line_ref_U2 = 561;
Constant line_ref_U3 = 561;
Constant line_ref_U4 = 561;
Constant line_ref_U5 = 561;
Constant line_ref_U6 = 561;
Constant line_ref_U7 = 561;
Constant line_ref_U8 = 561;
Constant line_ref_U9 = 561;
Constant line_ref_U10 = 561;
Constant line_ref_U11 = 561;
Constant line_ref_U12 = 561;
Constant line_ref_U13 = 561;
Constant line_ref_U14 = 561;
Constant line_ref_U15 = 561;
Constant line_ref_U16 = 561;
Constant line_ref_U17 = 561;
Constant line_ref_U18 = 561;
Constant line_ref_U19 = 561;
Constant line_ref_U20 = 561;
Constant line_ref_U21 = 561;
Constant line_ref_U22 = 561;
Constant line_ref_U23 = 561;
Constant line_ref_U24 = 561;
Constant line_ref_U25 = 561;
Constant line_ref_U26 = 561;
Constant line_ref_U27 = 561;
Constant line_ref_U28 = 561;
Constant line_ref_U29 = 561;
Constant line_ref_U30 = 561;
Constant line_ref_U31 = 561;
Constant line_ref_U32 = 561;
Constant line_ref_U33 = 561;
Constant line_ref_U34 = 561;
Constant line_ref_U35 = 561;
Constant line_ref_U36 = 561;
Constant line_ref_U37 = 561;
Constant line_ref_U38 = 561;
Constant line_ref_U39 = 561;
Constant line_ref_U40 = 561;
Constant line_ref_U41 = 561;
Constant line_ref_U42 = 561;
Constant line_ref_U43 = 561;
Constant line_ref_U44 = 561;
Constant line_ref_U45 = 561;
Constant line_ref_U46 = 561;
Constant line_ref_U47 = 561;
Constant line_ref_U48 = 561;
Constant line_ref_U49 = 561;
Constant line_ref_U50 = 561;
Constant line_ref_U51 = 561;
Constant line_ref_U52 = 561;
Constant line_ref_U53 = 561;
Constant line_ref_U54 = 561;
Constant line_ref_U55 = 561;
Constant line_ref_U56 = 561;
Constant line_ref_U57 = 561;
Constant line_ref_U58 = 561;
Constant line_ref_U59 = 561;
Constant line_ref_U60 = 561;
Constant line_ref_U61 = 561;
Constant line_ref_U62 = 561;
Constant line_ref_U63 = 561;
Constant line_ref_U64 = 561;
Constant line_ref_U65 = 561;
Constant line_ref_U66 = 561;
Constant line_ref_U67 = 561;
Constant line_ref_U68 = 561;
Constant line_ref_U69 = 561;
Constant line_ref_U70 = 561;
Constant line_ref_U71 = 561;
Constant line_ref_U72 = 561;
Constant line_ref_U73 = 561;
Constant line_ref_U74 = 561;
Constant line_ref_U75 = 561;
Constant line_ref_U76 = 561;
Constant line_ref_U77 = 561;
Constant line_ref_U78 = 561;
Constant line_ref_U79 = 561;
Constant line_ref_U80 = 561;
Constant line_ref_U81 = 561;
Constant line_ref_U82 = 561;
Constant line_ref_U83 = 561;
Constant line_ref_U84 = 561;
Constant line_ref_U85 = 561;
Constant line_ref_U86 = 561;
Constant line_ref_U87 = 561;
Constant line_ref_U88 = 561;
Constant line_ref_U89 = 561;
Constant line_ref_U90 = 561;
Constant line_ref_U91 = 561;
Constant line_ref_U92 = 561;
Constant line_ref_U93 = 561;
Constant line_ref_U94 = 561;
Constant line_ref_U95 = 561;
Constant line_ref_U96 = 561;
Constant line_ref_U97 = 561;
Constant line_ref_U98 = 561;
Constant line_ref_U99 = 561;
Constant line_ref_U100 = 561;
Constant line_ref_U101 = 561;
Constant line_ref_U102 = 561;
Constant line_ref_U103 = 561;
Constant line_ref_U104 = 561;
Constant line_ref_U105 = 561;
Constant line_ref_U106 = 561;
Constant line_ref_U107 = 561;
Constant line_ref_U108 = 561;
Constant line_ref_U109 = 561;
Constant line_ref_U110 = 561;
Constant line_ref_U111 = 561;
Constant line_ref_U112 = 561;
Constant line_ref_U113 = 561;
Constant line_ref_U114 = 561;
Constant line_ref_U115 = 561;
Constant line_ref_U116 = 561;
Constant line_ref_U117 = 561;
Constant line_ref_U118 = 561;
Constant line_ref_U119 = 561;
Constant line_ref_U120 = 561;
Constant line_ref_U121 = 561;
Constant line_ref_U122 = 561;
Constant line_ref_U123 = 561;
Constant line_ref_U124 = 561;
Constant line_ref_U125 = 561;
Constant line_ref_U126 = 561;
Constant line_ref_U127 = 561;
Constant line_ref_U128 = 561;
Constant line_ref_U129 = 561;
Constant line_ref_U130 = 561;
Constant line_ref_U131 = 561;
Constant line_ref_U132 = 561;
Constant line_ref_U133 = 561;
Constant line_ref_U134 = 561;
Constant line_ref_U135 = 561;
Constant line_ref_U136 = 561;
Constant line_ref_U137 = 561;
Constant line_ref_U138 = 561;
Constant line_ref_U139 = 561;
Constant line_ref_U140 = 561;
Constant line_ref_U141 = 561;
Constant line_ref_U142 = 561;
Constant line_ref_U143 = 561;
Constant line_ref_U144 = 561;
Constant line_ref_U145 = 561;
Constant line_ref_U146 = 561;
Constant line_ref_U147 = 561;
Constant line_ref_U148 = 561;
Constant line_ref_U149 = 561;
Constant line_ref_U150 = 561;
Constant line_ref_U151 = 561;
Constant line_ref_U152 = 561;
Constant line_ref_U153 = 561;
Constant line_ref_U154 = 561;
Constant line_ref_U155 = 561;
Constant line_ref_U156 = 561;
Constant line_ref_U157 = 561;
Constant line_ref_U158 = 561;
Constant line_ref_U159 = 561;
Constant line_ref_U160 = 561;
Constant line_ref_U161 = 561;
Constant line_ref_U162 = 561;
Constant line_ref_U163 = 561;
Constant line_ref_U164 = 561;
Constant line_ref_U165 = 561;
Constant line_ref_U166 = 561;
Constant line_ref_U167 = 561;
Constant line_ref_U168 = 561;
Constant line_ref_U169 = 561;
Constant line_ref_U170 = 561;
Constant line_ref_U171 = 561;
Constant line_ref_U172 = 561;
Constant line_ref_U173 = 561;
Constant line_ref_U174 = 561;
Constant line_ref_U175 = 561;
Constant line_ref_U176 = 561;
Constant line_ref_U177 = 561;
Constant line_ref_U178 = 561;
Constant line_ref_U179 = 561;
Constant line_ref_U180 = 561;
Constant line_ref_U181 = 561;
Constant line_ref_U182 = 561;
Constant line_ref_U183 = 561;
Constant line_ref_U184 = 561;
Constant line_ref_U185 = 561;
Constant line_ref_U186 = 561;
Constant line_ref_U187 = 561;
Constant line_ref_U188 = 561;
Constant line_ref_U189 = 561;
Constant line_ref_U190 = 561;
Constant line_ref_U191 = 561;
Constant line_ref_U192 = 561;
Constant line_ref_U193 = 561;
Constant line_ref_U194 = 561;
Constant line_ref_U195 = 561;
Constant line_ref_U196 = 561;
Constant line_ref_U197 = 561;
Constant line_ref_U198 = 561;
Constant line_ref_U199 = 561;
Constant line_ref_U200 = 561;
Constant line_ref_U201 = 561;
Constant line_ref_U202 = 561;
Constant line_ref_U203 = 561;
Constant line_ref_U204 = 561;
Constant line_ref_U205 = 561;
Constant line_ref_U206 = 561;
Constant line_ref_U207 = 561;
Constant line_ref_U208 = 561;
Constant line_ref_U209 = 561;
Constant line_ref_U210 = 561;
Constant line_ref_U211 = 561;
Constant line_ref_U212 = 561;
Constant line_ref_U213 = 561;
Constant line_ref_U214 = 561;
Constant line_ref_U215 = 561;
Constant line_ref_U216 = 561;
Constant line_ref_U217 = 561;
Constant line_ref_U218 = 561;
Constant line_ref_U219 = 561;
Constant line_ref_U220 = 561;
Constant line_ref_U221 = 561;
Constant line_ref_U222 = 561;
Constant line_ref_U223 = 561;
Constant line_ref_U224 = 561;
Constant line_ref_U225 = 561;
Constant line_ref_U226 = 561;
Constant line_ref_U227 = 561;
Constant line_ref_U228 = 561;
Constant line_ref_U229 = 561;
Constant line_ref_U230 = 561;
Constant line_ref_U231 = 561;
Constant line_ref_U232 = 561;
Constant line_ref_U233 = 561;
Constant line_ref_U234 = 561;
Constant line_ref_U235 = 561;
Constant line_ref_U236 = 561;
Constant line_ref_U237 = 561;
Constant line_ref_U238 = 561;
Constant line_ref_U239 = 561;
Constant line_ref_U240 = 561;
Constant line_ref_U241 = 561;
Constant line_ref_U242 = 561;
Constant line_ref_U243 = 561;
Constant line_ref_U244 = 561;
Constant line_ref_U245 = 561;
Constant line_ref_U246 = 561;
Constant line_ref_U247 = 561;
Constant line_ref_U248 = 561;
Constant line_ref_U249 = 561;
Constant line_ref_U250 = 561;
Constant line_ref_U251 = 561;
Constant line_ref_U252 = 561;
Constant line_ref_U253 = 561;
Constant line_ref_U254 = 561;
Constant line_ref_U255 = 561;
Constant line_ref_U256 = 561;
Constant line_ref_U257 = 561;
Constant line_ref_U258 = 561;
Constant line_ref_U259 = 561;
Constant line_ref_U260 = 561;
Constant line_ref_U261 = 561;
Constant line_ref_U262 = 561;
Constant line_ref_U263 = 561;
Constant KIT_CONFIGURATION_BITMAP = 389;
Constant KIT_CONFIGURATION_LOOKMODE = 2;
Constant MAX_FRAME_SIZE_NEEDED = 6;
Constant RNG_SEED_AT_START_OF_PLAY = 0;
Constant id_U1 = 561;
Constant id_U2 = 561;
Constant id_U3 = 561;
Constant id_U4 = 561;
Constant id_U5 = 561;
Constant id_U6 = 561;
Constant id_U7 = 561;
Constant id_U8 = 561;
Constant id_U9 = 561;
Constant id_U10 = 561;
Constant id_U11 = 561;
Constant id_U12 = 561;
Constant id_U13 = 561;
Constant id_U14 = 561;
Constant id_U15 = 561;
Constant id_U16 = 561;
Constant id_U17 = 561;
Constant id_U18 = 561;
Constant id_U19 = 561;
Constant id_U20 = 561;
Constant id_U21 = 561;
Constant id_U22 = 561;
Constant id_U23 = 561;
Constant id_U24 = 561;
Constant id_U25 = 561;
Constant id_U26 = 561;
Constant id_U27 = 561;
Constant id_U28 = 561;
Constant id_U29 = 561;
Constant id_U30 = 561;
Constant id_U31 = 561;
Constant id_U32 = 561;
Constant id_U33 = 561;
Constant id_U34 = 561;
Constant id_U35 = 561;
Constant id_U36 = 561;
Constant id_U37 = 561;
Constant id_U38 = 561;
Constant id_U39 = 561;
Constant id_U40 = 561;
Constant id_U41 = 561;
Constant id_U42 = 561;
Constant id_U43 = 561;
Constant id_U44 = 561;
Constant id_U45 = 561;
Constant id_U46 = 561;
Constant id_U47 = 561;
Constant id_U48 = 561;
Constant id_U49 = 561;
Constant id_U50 = 561;
Constant id_U51 = 561;
Constant id_U52 = 561;
Constant id_U53 = 561;
Constant id_U54 = 561;
Constant id_U55 = 561;
Constant id_U56 = 561;
Constant id_U57 = 561;
Constant id_U58 = 561;
Constant id_U59 = 561;
Constant id_U60 = 561;
Constant id_U61 = 561;
Constant id_U62 = 561;
Constant id_U63 = 561;
Constant id_U64 = 561;
Constant id_U65 = 561;
Constant id_U66 = 561;
Constant id_U67 = 561;
Constant id_U68 = 561;
Constant id_U69 = 561;
Constant id_U70 = 561;
Constant id_U71 = 561;
Constant id_U72 = 561;
Constant id_U73 = 561;
Constant id_U74 = 561;
Constant id_U75 = 561;
Constant id_U76 = 561;
Constant id_U77 = 561;
Constant id_U78 = 561;
Constant id_U79 = 561;
Constant id_U80 = 561;
Constant id_U81 = 561;
Constant id_U82 = 561;
Constant id_U83 = 561;
Constant id_U84 = 561;
Constant id_U85 = 561;
Constant id_U86 = 561;
Constant id_U87 = 561;
Constant id_U88 = 561;
Constant id_U89 = 561;
Constant id_U90 = 561;
Constant id_U91 = 561;
Constant id_U92 = 561;
Constant id_U93 = 561;
Constant id_U94 = 561;
Constant id_U95 = 561;
Constant id_U96 = 561;
Constant id_U97 = 561;
Constant id_U98 = 561;
Constant id_U99 = 561;
Constant id_U100 = 561;
Constant id_U101 = 561;
Constant id_U102 = 561;
Constant id_U103 = 561;
Constant id_U104 = 561;
Constant id_U105 = 561;
Constant id_U106 = 561;
Constant id_U107 = 561;
Constant id_U108 = 561;
Constant id_U109 = 561;
Constant id_U110 = 561;
Constant id_U111 = 561;
Constant id_U112 = 561;
Constant id_U113 = 561;
Constant id_U114 = 561;
Constant id_U115 = 561;
Constant id_U116 = 561;
Constant id_U117 = 561;
Constant id_U118 = 561;
Constant id_U119 = 561;
Constant id_U120 = 561;
Constant id_U121 = 561;
Constant id_U122 = 561;
Constant id_U123 = 561;
Constant id_U124 = 561;
Constant id_U125 = 561;
Constant id_U126 = 561;
Constant id_U127 = 561;
Constant id_U128 = 561;
Constant id_U129 = 561;
Constant id_U130 = 561;
Constant id_U131 = 561;
Constant id_U132 = 561;
Constant id_U133 = 561;
Constant id_U134 = 561;
Constant id_U135 = 561;
Constant id_U136 = 561;
Constant id_U137 = 561;
Constant id_U138 = 561;
Constant id_U139 = 561;
Constant id_U140 = 561;
Constant id_U141 = 561;
Constant id_U142 = 561;
Constant id_U143 = 561;
Constant id_U144 = 561;
Constant id_U145 = 561;
Constant id_U146 = 561;
Constant id_U147 = 561;
Constant id_U148 = 561;
Constant id_U149 = 561;
Constant id_U150 = 561;
Constant id_U151 = 561;
Constant id_U152 = 561;
Constant id_U153 = 561;
Constant id_U154 = 561;
Constant id_U155 = 561;
Constant id_U156 = 561;
Constant id_U157 = 561;
Constant id_U158 = 561;
Constant id_U159 = 561;
Constant id_U160 = 561;
Constant id_U161 = 561;
Constant id_U162 = 561;
Constant id_U163 = 561;
Constant id_U164 = 561;
Constant id_U165 = 561;
Constant id_U166 = 561;
Constant id_U167 = 561;
Constant id_U168 = 561;
Constant id_U169 = 561;
Constant id_U170 = 561;
Constant id_U171 = 561;
Constant id_U172 = 561;
Constant id_U173 = 561;
Constant id_U174 = 561;
Constant id_U175 = 561;
Constant id_U176 = 561;
Constant id_U177 = 561;
Constant id_U178 = 561;
Constant id_U179 = 561;
Constant id_U180 = 561;
Constant id_U181 = 561;
Constant id_U182 = 561;
Constant id_U183 = 561;
Constant id_U184 = 561;
Constant id_U185 = 561;
Constant id_U186 = 561;
Constant id_U187 = 561;
Constant id_U188 = 561;
Constant id_U189 = 561;
Constant id_U190 = 561;
Constant id_U191 = 561;
Constant id_U192 = 561;
Constant id_U193 = 561;
Constant id_U194 = 561;
Constant id_U195 = 561;
Constant id_U196 = 561;
Constant id_U197 = 561;
Constant id_U198 = 561;
Constant id_U199 = 561;
Constant id_U200 = 561;
Constant id_U201 = 561;
Constant id_U202 = 561;
Constant id_U203 = 561;
Constant id_U204 = 561;
Constant id_U205 = 561;
Constant id_U206 = 561;
Constant id_U207 = 561;
Constant id_U208 = 561;
Constant id_U209 = 561;
Constant id_U210 = 561;
Constant id_U211 = 561;
Constant id_U212 = 561;
Constant id_U213 = 561;
Constant id_U214 = 561;
Constant id_U215 = 561;
Constant id_U216 = 561;
Constant id_U217 = 561;
Constant id_U218 = 561;
Constant id_U219 = 561;
Constant id_U220 = 561;
Constant id_U221 = 561;
Constant id_U222 = 561;
Constant id_U223 = 561;
Constant id_U224 = 561;
Constant id_U225 = 561;
Constant id_U226 = 561;
Constant id_U227 = 561;
Constant id_U228 = 561;
Constant id_U229 = 561;
Constant id_U230 = 561;
Constant id_U231 = 561;
Constant id_U232 = 561;
Constant id_U233 = 561;
Constant id_U234 = 561;
Constant id_U235 = 561;
Constant id_U236 = 561;
Constant id_U237 = 561;
Constant id_U238 = 561;
Constant id_U239 = 561;
Constant id_U240 = 561;
Constant id_U241 = 561;
Constant id_U242 = 561;
Constant id_U243 = 561;
Constant id_U244 = 561;
Constant id_U245 = 561;
Constant id_U246 = 561;
Constant id_U247 = 561;
Constant id_U248 = 561;
Constant id_U249 = 561;
Constant id_U250 = 561;
Constant id_U251 = 561;
Constant id_U252 = 561;
Constant id_U253 = 561;
Constant id_U254 = 561;
Constant id_U255 = 561;
Constant id_U256 = 561;
Constant id_U257 = 561;
Constant id_U258 = 561;
Constant MEMORY_HEAP_SIZE = 262144;
Constant BASICINFORMKIT = 1;
Constant HDR_MAGICNUMBER = 0;
Constant HDR_GLULXVERSION = 4;
Constant HDR_RAMSTART = 8;
Constant HDR_EXTSTART = 12;
Constant HDR_ENDMEM = 16;
Constant HDR_STACKSIZE = 20;
Constant HDR_STARTFUNC = 24;
Constant HDR_DECODINGTBL = 28;
Constant HDR_CHECKSUM = 32;
Constant ROM_INFO = 36;
Constant ROM_MEMORYLAYOUT = 40;
Constant ROM_INFORMVERSION = 44;
Constant ROM_COMPVERSION = 48;
Constant ROM_GAMERELEASE = 52;
Constant ROM_GAMESERIAL = 54;
Constant NORMAL_VMSTY = 0;
Constant HEADER_VMSTY = 3;
Constant SUBHEADER_VMSTY = 4;
Constant ALERT_VMSTY = 5;
Constant NOTE_VMSTY = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY = 8;
Constant CLR_DEFAULT = 1;
Constant CLR_BLACK = 2;
Constant CLR_RED = 3;
Constant CLR_GREEN = 4;
Constant CLR_YELLOW = 5;
Constant CLR_BLUE = 6;
Constant CLR_MAGENTA = 7;
Constant CLR_PURPLE = 7;
Constant CLR_CYAN = 8;
Constant CLR_AZURE = 8;
Constant CLR_WHITE = 9;
Constant WIN_ALL = 0;
Constant WIN_STATUS = 1;
Constant WIN_MAIN = 2;
Constant PARA_COMPLETED = 1;
Constant PARA_PROMPTSKIP = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS = 8;
Constant PARA_CONTENTEXPECTED = 16;
Constant POSSESS_PK = 256;
Constant DEFART_PK = 257;
Constant INDEFART_PK = 258;
Constant LIGHTED_PK = 259;
Constant UNLIGHTED_PK = 260;
Constant RTP_BACKDROP = 1;
Constant RTP_EXITDOOR = 2;
Constant RTP_NOEXIT = 3;
Constant RTP_CANTCHANGE = 4;
Constant RTP_IMPREL = 5;
Constant RTP_RULESTACK = 6;
Constant RTP_TOOMANYRULEBOOKS = 7;
Constant RTP_TOOMANYEVENTS = 8;
Constant RTP_BADPROPERTY = 9;
Constant RTP_UNPROVIDED = 10;
Constant RTP_UNSET = 11;
Constant RTP_TOOMANYACTS = 12;
Constant RTP_CANTABANDON = 13;
Constant RTP_CANTEND = 14;
Constant RTP_CANTMOVENOTHING = 15;
Constant RTP_CANTREMOVENOTHING = 16;
Constant RTP_DIVZERO = 17;
Constant RTP_BADVALUEPROPERTY = 18;
Constant RTP_NOTBACKDROP = 19;
Constant RTP_TABLE_NOCOL = 20;
Constant RTP_TABLE_NOCORR = 21;
Constant RTP_TABLE_NOROW = 22;
Constant RTP_TABLE_NOENTRY = 23;
Constant RTP_TABLE_NOTABLE = 24;
Constant RTP_TABLE_NOMOREBLANKS = 25;
Constant RTP_TABLE_NOROWS = 26;
Constant RTP_TABLE_CANTSORT = 27;
Constant RTP_NOTINAROOM = 28;
Constant RTP_BADTOPIC = 29;
Constant RTP_ROUTELESS = 30;
Constant RTP_PROPOFNOTHING = 31;
Constant RTP_DECIDEONWRONGKIND = 32;
Constant RTP_DECIDEONNOTHING = 33;
Constant RTP_TABLE_CANTSAVE = 34;
Constant RTP_TABLE_WONTFIT = 35;
Constant RTP_TABLE_BADFILE = 36;
Constant RTP_LOWLEVELERROR = 37;
Constant RTP_DONTIGNORETURNSEQUENCE = 38;
Constant RTP_SAYINVALIDSNIPPET = 39;
Constant RTP_SPLICEINVALIDSNIPPET = 40;
Constant RTP_INCLUDEINVALIDSNIPPET = 41;
Constant RTP_LISTWRITERMEMORY = 42;
Constant RTP_CANTREMOVEPLAYER = 43;
Constant RTP_CANTREMOVEDOORS = 44;
Constant RTP_CANTCHANGEOFFSTAGE = 45;
Constant RTP_MSTACKMEMORY = 46;
Constant RTP_TYPECHECK = 47;
Constant RTP_FILEIOERROR = 48;
Constant RTP_HEAPERROR = 49;
Constant RTP_LISTRANGEERROR = 50;
Constant RTP_REGEXPSYNTAXERROR = 51;
Constant RTP_NOGLULXUNICODE = 52;
Constant RTP_BACKDROPONLY = 53;
Constant RTP_NOTTHING = 54;
Constant RTP_SCENEHASNTSTARTED = 55;
Constant RTP_SCENEHASNTENDED = 56;
Constant RTP_NEGATIVEROOT = 57;
Constant RTP_TABLE_CANTRUNTHROUGH = 58;
Constant RTP_CANTITERATE = 59;
Constant RTP_WRONGASSIGNEDKIND = 60;
Constant RTP_CANTBEOFFSTAGE = 61;
Constant RTP_RELKINDVIOLATION = 62;
Constant RTP_CANTMAKEPART = 63;
Constant RTP_TEXTTOKENTOOHARD = 64;
Constant RTP_TABLE_NOTABLE2 = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL = 67;
Constant RTP_LISTSIZENEGATIVE = 68;
Constant RTP_REGIONSNOTADJACENT = 69;
Constant STARTING_VIRTUAL_MACHINE_ACT = 0;
Constant PRINTING_THE_NAME_ACT = 1;
Constant PRINTING_THE_PLURAL_NAME_ACT = 2;
Constant PRINTING_RESPONSE_ACT = 3;
Constant PRINTING_A_NUMBER_OF_ACT = 4;
Constant PRINTING_ROOM_DESC_DETAILS_ACT = 5;
Constant PRINTING_INVENTORY_DETAILS_ACT = 6;
Constant LISTING_CONTENTS_ACT = 7;
Constant GROUPING_TOGETHER_ACT = 8;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT = 9;
Constant LISTING_NONDESCRIPT_ITEMS_ACT = 10;
Constant PRINTING_NAME_OF_DARK_ROOM_ACT = 11;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT = 12;
Constant PRINTING_NEWS_OF_DARKNESS_ACT = 13;
Constant PRINTING_NEWS_OF_LIGHT_ACT = 14;
Constant REFUSAL_TO_ACT_IN_DARK_ACT = 15;
Constant CONSTRUCTING_STATUS_LINE_ACT = 16;
Constant PRINTING_BANNER_TEXT_ACT = 17;
Constant READING_A_COMMAND_ACT = 18;
Constant DECIDING_SCOPE_ACT = 19;
Constant DECIDING_CONCEALED_POSSESS_ACT = 20;
Constant DECIDING_WHETHER_ALL_INC_ACT = 21;
Constant CLARIFYING_PARSERS_CHOICE_ACT = 22;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT = 23;
Constant PRINTING_A_PARSER_ERROR_ACT = 24;
Constant SUPPLYING_A_MISSING_NOUN_ACT = 25;
Constant SUPPLYING_A_MISSING_SECOND_ACT = 26;
Constant IMPLICITLY_TAKING_ACT = 27;
Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 28;
Constant PRINTING_PLAYERS_OBITUARY_ACT = 29;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 30;
Constant PRINTING_LOCALE_DESCRIPTION_ACT = 31;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 32;
Constant PRINTING_LOCALE_PARAGRAPH_ACT = 33;
Constant STARTUP_RB = 0;
Constant SHUTDOWN_RB = 1;
Constant TURN_SEQUENCE_RB = 11;
Constant WHEN_PLAY_BEGINS_RB = 13;
Constant WHEN_PLAY_ENDS_RB = 14;
Constant WHEN_SCENE_BEGINS_RB = 15;
Constant WHEN_SCENE_ENDS_RB = 16;
Constant ACTION_PROCESSING_RB = 18;
Constant SETTING_ACTION_VARIABLES_RB = 19;
Constant SPECIFIC_ACTION_PROCESSING_RB = 20;
Constant ACCESSIBILITY_RB = 22;
Constant REACHING_INSIDE_RB = 23;
Constant REACHING_OUTSIDE_RB = 24;
Constant VISIBLE_RB = 25;
Constant PERSUADE_RB = 26;
Constant UNSUCCESSFUL_ATTEMPT_RB = 27;
Constant AFTER_RB = 32;
Constant REPORT_RB = 33;
Constant DOES_THE_PLAYER_MEAN_RB = 34;
Constant MULTIPLE_ACTION_PROCESSING_RB = 35;
Constant PARSING_REASON = 0;
Constant TALKING_REASON = 1;
Constant EACH_TURN_REASON = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON = 6;
Constant ILLEGAL_TT = 0;
Constant ELEMENTARY_TT = 1;
Constant PREPOSITION_TT = 2;
Constant ROUTINE_FILTER_TT = 3;
Constant ATTR_FILTER_TT = 4;
Constant SCOPE_TT = 5;
Constant GPR_TT = 6;
Constant NOUN_TOKEN = 0;
Constant HELD_TOKEN = 1;
Constant MULTI_TOKEN = 2;
Constant MULTIHELD_TOKEN = 3;
Constant MULTIEXCEPT_TOKEN = 4;
Constant MULTIINSIDE_TOKEN = 5;
Constant CREATURE_TOKEN = 6;
Constant SPECIAL_TOKEN = 7;
Constant NUMBER_TOKEN = 8;
Constant TOPIC_TOKEN = 9;
Constant ENDIT_TOKEN = 15;
Constant GPR_FAIL = -1;
Constant GPR_PREPOSITION = 0;
Constant GPR_NUMBER = 1;
Constant GPR_MULTIPLE = 2;
Constant GPR_NOUN = -256;
Constant Computed_Constant_Value_0_U2 = 1;
Constant Computed_Constant_Value_2_U2 = 2;
Constant Computed_Constant_Value_4_U1 = 3;
Constant Computed_Constant_Value_6_U1 = 4;
Constant Computed_Constant_Value_8_U1 = 5;
Constant Computed_Constant_Value_10_U1 = 6;
Constant NEWLINE_BIT = 1;
Constant INDENT_BIT = 2;
Constant FULLINV_BIT = 4;
Constant ENGLISH_BIT = 8;
Constant RECURSE_BIT = 16;
Constant ALWAYS_BIT = 32;
Constant TERSE_BIT = 64;
Constant PARTINV_BIT = 128;
Constant DEFART_BIT = 256;
Constant WORKFLAG_BIT = 512;
Constant ISARE_BIT = 1024;
Constant CONCEAL_BIT = 2048;
Constant NOARTICLE_BIT = 4096;
Constant EXTRAINDENT_BIT = 8192;
Constant CFIRSTART_BIT = 16384;
Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;
Constant list_filter_permits = A_privately_named;
Constant USE_SCORING_TCBIT = 1;
Constant PREVENT_UNDO_TCBIT = 2;
Constant SERIAL_COMMA_TCBIT = 4;
Constant PROGRAMMING_EXPONENTS_TCBIT = 8;
Constant FIX_RNG_TCBIT = 16;
Constant ECHO_COMMANDS_TCBIT = 32;
Constant NO_VERB_VERB_DEFINED_TCBIT = 64;
Constant DIALECT_US_TCBIT = 128;
Constant STORY_AUTHOR_TCBIT = 256;
Constant RANKING_TABLE_TCBIT = 512;
Constant Computed_Constant_Value_12_U1 = 4;
Constant LanguageCases = 1;
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;
Constant GLK_NULL = 0;
Constant INPUT_BUFFER_LEN = 260;
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;
Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = -7;
Constant keycode_Down = -5;
Constant keycode_End = -13;
Constant keycode_Escape = -8;
Constant keycode_Func1 = -17;
Constant keycode_Func10 = -26;
Constant keycode_Func11 = -27;
Constant keycode_Func12 = -28;
Constant keycode_Func2 = -18;
Constant keycode_Func3 = -19;
Constant keycode_Func4 = -20;
Constant keycode_Func5 = -21;
Constant keycode_Func6 = -22;
Constant keycode_Func7 = -23;
Constant keycode_Func8 = -24;
Constant keycode_Func9 = -25;
Constant keycode_Home = -12;
Constant keycode_Left = -2;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = -11;
Constant keycode_PageUp = -10;
Constant keycode_Return = -6;
Constant keycode_Right = -3;
Constant keycode_Tab = -9;
Constant keycode_Unknown = -1;
Constant keycode_Up = -4;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;
Constant GG_MAINWIN_ROCK = 201;
Constant GG_STATUSWIN_ROCK = 202;
Constant GG_QUOTEWIN_ROCK = 203;
Constant GG_SAVESTR_ROCK = 301;
Constant GG_SCRIPTSTR_ROCK = 302;
Constant GG_COMMANDWSTR_ROCK = 303;
Constant GG_COMMANDRSTR_ROCK = 304;
Constant GG_SCRIPTFREF_ROCK = 401;
Constant GG_FOREGROUNDCHAN_ROCK = 410;
Constant GG_BACKGROUNDCHAN_ROCK = 411;
Constant GG_ANYTOSTRING_LEN = 66;
Constant M_0 = 0;
Constant M_1 = 1065353216;
Constant M_HALF = 1056964608;
Constant M_THIRD = 1051372203;
Constant M_LOG10 = 1075010958;
Constant M_N1 = -1082130432;
Constant M_PI = 1078530011;
Constant M_NPI = -1068953637;
Constant M_2PI = 1086918619;
Constant M_PI2 = 1070141403;
Constant M_NPI2 = -1077342245;
Constant M_E = 1076754516;
Constant M_E2 = 1089237798;
Constant M_N0 = -2147483648;
Constant M_INF = 2139095040;
Constant M_NINF = -8388608;
Constant M_NAN = 2139095041;
Constant M_NNAN = -8388607;
Constant AUXF_MAGIC = 0;
Constant AUXF_MAGIC_VALUE = 16339;
Constant AUXF_STATUS = 1;
Constant AUXF_STATUS_IS_CLOSED = 1;
Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2;
Constant AUXF_STREAM = 3;
Constant AUXF_FILENAME = 4;
Constant AUXF_IFID_OF_OWNER = 5;
Constant TB_COLUMN_REAL = 32768;
Constant TB_COLUMN_SIGNED = 16384;
Constant TB_COLUMN_TOPIC = 8192;
Constant TB_COLUMN_DONTSORTME = 4096;
Constant TB_COLUMN_NOBLANKBITS = 2048;
Constant TB_COLUMN_CANEXCHANGE = 1024;
Constant TB_COLUMN_ALLOCATED = 512;
Constant TB_COLUMN_NUMBER = 511;
Constant COL_HSIZE = 2;
Constant Computed_Constant_Value_16_U1 = 2;
Constant MSTACK_CAPACITY = 20;
Constant RS_NEITHER = 0;
Constant RS_SUCCEEDS = 1;
Constant RS_FAILS = 2;
Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = 1;
Constant BLK_FLAG_16_BIT = 2;
Constant BLK_FLAG_WORD = 4;
Constant BLK_FLAG_RESIDENT = 8;
Constant BLK_FLAG_TRUNCMULT = 16;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;
Constant Computed_Constant_Value_19_U1 = 3;
Constant Computed_Constant_Value_21_U1 = 2;
Constant BLK_NEXT = 3;
Constant BLK_PREV = 4;
Constant SMALLEST_BLK_WORTH_ALLOCATING = 12;
Constant BLK_BVBITMAP = 255;
Constant BLK_BVBITMAP_LONGBLOCK = 16;
Constant BLK_BVBITMAP_TEXT = 32;
Constant BLK_BVBITMAP_CONSTANT = 64;
Constant BLK_BVBITMAP_LONGBLOCKMASK = -240;
Constant BLK_BVBITMAP_TEXTMASK = -224;
Constant BLK_BVBITMAP_CONSTANTMASK = -192;
Constant CREATE_KOVS = 1;
Constant CAST_KOVS = 2;
Constant DESTROY_KOVS = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS = 5;
Constant EXTENT_KOVS = 6;
Constant COPYQUICK_KOVS = 7;
Constant COPYSB_KOVS = 8;
Constant KINDDATA_KOVS = 9;
Constant COPY_KOVS = 10;
Constant COMPARE_KOVS = 11;
Constant READ_FILE_KOVS = 12;
Constant WRITE_FILE_KOVS = 13;
Constant HASH_KOVS = 14;
Constant DEBUG_KOVS = 15;
Constant Computed_Constant_Value_26_U1 = 1;
Constant Computed_Constant_Value_29_U1 = 2;
Constant Computed_Constant_Value_31_U1 = 3;
Constant Computed_Constant_Value_34_U1 = 4;
Constant Large_Unicode_Tables = 0;
Constant TEXT_TY_NoBuffers = 2;
Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;
Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;
Constant UNIC_NCT = 10000;
Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;
Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;
Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;
Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;
Constant SENSITIVITY_RE_CC = -50;
Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;
Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;
Constant LIST_ITEM_KOV_F = 0;
Constant LIST_LENGTH_F = 1;
Constant LIST_ITEM_BASE = 2;
Constant COMBINATION_KIND_F = 0;
Constant COMBINATION_ITEM_BASE = 1;
Constant Computed_Constant_Value_42_U1 = 5;
Constant Computed_Constant_Value_44_U1 = 5;
Constant Computed_Constant_Value_46_U1 = 5;
Constant Computed_Constant_Value_48_U1 = 5;
Constant Computed_Constant_Value_50_U1 = 5;
Constant Computed_Constant_Value_52_U1 = 5;
Constant RRV_USED = 6;
Constant RRV_FILLED = 7;
Constant RRV_DATA_BASE = 8;
Constant RRVAL_V_TO_V = 0;
Constant RRF_USED = 1;
Constant RRF_DELETED = 2;
Constant RRF_SINGLE = 4;
Constant RRF_HASX = 16;
Constant RRF_HASY = 32;
Constant RRF_ENTKEYX = 64;
Constant RRF_ENTKEYY = 128;
Constant RELS_COPY = 32;
Constant RELS_DESTROY = 16;
Constant RELS_EMPTY = 3;
Constant RELS_SET_VALENCY = 5;
Constant RLANY_GET_X = 1;
Constant RLANY_GET_Y = 2;
Constant RLANY_CAN_GET_X = 3;
Constant RLANY_CAN_GET_Y = 4;
Constant RLIST_ALL_X = 1;
Constant RLIST_ALL_Y = 2;
Constant RLIST_ALL_PAIRS = 3;
Constant RRP_MIN_SIZE = 8;
Constant RRP_PERTURB_SHIFT = 5;
Constant MINUS_RRP_PERTURB_SHIFT = -5;
Constant RRP_RESIZE_SMALL = 4;
Constant RRP_RESIZE_LARGE = 2;
Constant RRP_LARGE_IS = 256;
Constant RRP_CROWDED_IS = 2;
Constant RR_NAME = 5;
Constant RR_PERMISSIONS = 6;
Constant RR_STORAGE = 7;
Constant RR_KIND = 8;
Constant RR_HANDLER = 9;
Constant RR_DESCRIPTION = 10;
Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;
Constant Computed_Constant_Value_61_U1 = 32;
Constant MAX_TIMERS = 0;
Constant Computed_Constant_Value_14_U1 = 1;
Constant Computed_Constant_Value_37_U1 = 2;
Constant property_id_U133 = 132;
Constant property_id_U134 = 133;
Constant property_id_U135 = 134;
Constant property_id_U136 = 135;
Constant property_id_U137 = 136;
Constant property_id_U138 = 137;
Constant property_id_U139 = 138;
Constant property_id_U140 = 139;
Constant property_id_U141 = 140;
Constant property_id_U142 = 141;
Constant property_id_U143 = 142;
Constant property_id_U144 = 143;
Constant property_id_U145 = 144;
Constant property_id_U146 = 145;
Constant property_id_U147 = 146;
Constant property_id_U148 = 147;
Constant property_id_U149 = 148;
Constant property_id_U150 = 149;
Constant property_id_U151 = 150;
Constant property_id_U152 = 151;
Constant property_id_U153 = 152;
Constant property_id_U154 = 153;
Constant property_id_U155 = 154;
Constant property_id_U156 = 155;
Constant property_id_U157 = 156;
Constant property_id_U158 = 157;
Constant property_id_U159 = 158;
Constant property_id_U160 = 159;
Constant property_id_U161 = 160;
Constant property_id_U162 = 161;
Constant property_id_U163 = 162;
Constant property_id_U164 = 163;
Constant property_id_U165 = 164;
Constant property_id_U166 = 165;
Constant property_id_U167 = 166;
Constant property_id_U168 = 167;
Constant property_id_U169 = 168;
Constant property_id_U170 = 169;
Constant property_id_U171 = 170;
Constant property_id_U172 = 171;
Constant property_id_U173 = 172;
Constant property_id_U174 = 173;
Constant property_id_U175 = 174;
Constant property_id_U176 = 175;
Constant property_id_U177 = 176;
Constant property_id_U178 = 177;
Constant property_id_U179 = 178;
Constant property_id_U180 = 179;
Constant property_id_U181 = 180;
Constant property_id_U182 = 181;
Constant property_id_U183 = 182;
Constant property_id_U184 = 183;
Constant property_id_U185 = 184;
Constant property_id_U186 = 185;
Constant property_id_U187 = 186;
Constant property_id_U188 = 187;
Constant property_id_U189 = 188;
Constant property_id_U190 = 189;
Constant property_id_U191 = 190;
Constant property_id_U192 = 191;
Constant property_id_U193 = 192;
Constant property_id_U194 = 193;
Constant property_id_U195 = 194;
Constant property_id_U196 = 195;
Constant property_id_U197 = 196;
Constant property_id_U198 = 197;
Constant property_id_U199 = 198;
Constant property_id_U200 = 199;
Constant property_id_U201 = 200;
Constant property_id_U202 = 201;
Constant property_id_U203 = 202;
Constant property_id_U204 = 203;
Constant property_id_U205 = 204;
Constant property_id_U206 = 205;
Constant property_id_U207 = 206;
Constant ENGLISHLANGUAGEKIT = 1;
Constant AGAIN1__WD = 'again';
Constant AGAIN2__WD = 'g//';
Constant AGAIN3__WD = 'again';
Constant OOPS1__WD = 'oops';
Constant OOPS2__WD = 'o//';
Constant OOPS3__WD = 'oops';
Constant UNDO1__WD = 'undo';
Constant UNDO2__WD = 'undo';
Constant UNDO3__WD = 'undo';
Constant ALL1__WD = 'all';
Constant ALL2__WD = 'each';
Constant ALL3__WD = 'every';
Constant ALL4__WD = 'everything';
Constant ALL5__WD = 'both';
Constant AND1__WD = 'and';
Constant AND2__WD = 'and';
Constant AND3__WD = 'and';
Constant BUT1__WD = 'but';
Constant BUT2__WD = 'except';
Constant BUT3__WD = 'but';
Constant ME1__WD = 'me';
Constant ME2__WD = 'myself';
Constant ME3__WD = 'self';
Constant OF1__WD = 'of';
Constant OF2__WD = 'of';
Constant OF3__WD = 'of';
Constant OF4__WD = 'of';
Constant OTHER1__WD = 'another';
Constant OTHER2__WD = 'other';
Constant OTHER3__WD = 'other';
Constant THEN1__WD = 'then';
Constant THEN2__WD = 'then';
Constant THEN3__WD = 'then';
Constant NO1__WD = 'n//';
Constant NO2__WD = 'no';
Constant NO3__WD = 'no';
Constant YES1__WD = 'y//';
Constant YES2__WD = 'yes';
Constant YES3__WD = 'yes';
Constant AMUSING__WD = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD = 'q//';
Constant QUIT2__WD = 'quit';
Constant RESTART__WD = 'restart';
Constant RESTORE__WD = 'restore';
Constant LanguageAnimateGender = A_male;
Constant LanguageInanimateGender = A_neuter;
Constant LanguageContractionForms = 2;
Constant WORLDMODELKIT = 1;
Constant Computed_Constant_Value_0_U3 = 2;
Constant Computed_Constant_Value_2_U3 = 3;
Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;
Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3;
Constant AD_ACTION = 0;
Constant AD_REQUIREMENTS = 1;
Constant AD_NOUN_KOV = 2;
Constant AD_SECOND_KOV = 3;
Constant AD_VARIABLES_CREATOR = 4;
Constant AD_VARIABLES_ID = 5;
Constant AD_RECORD_SIZE = 6;
Constant TOUCH_NOUN_ABIT = 1;
Constant TOUCH_SECOND_ABIT = 2;
Constant LIGHT_ABIT = 4;
Constant NEED_NOUN_ABIT = 8;
Constant NEED_SECOND_ABIT = 16;
Constant OUT_OF_WORLD_ABIT = 32;
Constant CARRY_NOUN_ABIT = 64;
Constant CARRY_SECOND_ABIT = 128;
Constant MAX_NESTED_ACTIVITIES = 20;
Constant FAST_ROUTE_FINDING = 0;
Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;
Constant Computed_Constant_Value_4_U2 = 0;
Constant Computed_Constant_Value_6_U2 = 5;
Constant Computed_Constant_Value_8_U2 = 1;
Constant Computed_Constant_Value_11_U2 = 1;
Constant Computed_Constant_Value_13_U2 = 1;
Constant Computed_Constant_Value_15_U2 = 1;
Constant Computed_Constant_Value_17_U2 = 1;
Constant Computed_Constant_Value_19_U2 = 1;
Constant Computed_Constant_Value_21_U2 = 1;
Constant COMMANDPARSERKIT = 1;
Constant STUCK_PE = 1;
Constant UPTO_PE = 2;
Constant NUMBER_PE = 3;
Constant ANIMA_PE = 4;
Constant CANTSEE_PE = 5;
Constant TOOLIT_PE = 6;
Constant NOTHELD_PE = 7;
Constant MULTI_PE = 8;
Constant MMULTI_PE = 9;
Constant VAGUE_PE = 10;
Constant EXCEPT_PE = 11;
Constant VERB_PE = 12;
Constant SCENERY_PE = 13;
Constant ITGONE_PE = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE = 16;
Constant NOTHING_PE = 17;
Constant ASKSCOPE_PE = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20;
Constant ANIMAAGAIN_PE = 21;
Constant COMMABEGIN_PE = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE = 24;
Constant TOTALK_PE = 25;
Constant PATTERN_NULL = 65535;
Constant INDEF_ALL_WANTED = 32767;
Constant comma_word = 'comma,';
Constant OTHER_BIT = 1;
Constant MY_BIT = 2;
Constant THAT_BIT = 4;
Constant PLURAL_BIT = 8;
Constant LIT_BIT = 16;
Constant UNLIT_BIT = 32;
Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;
Constant PREFER_HELD = 0;
Constant HIGHEST_DPMR_SCORE = 4;
Constant Computed_Constant_Value_0_U4 = 1;
Constant EMPTY_TEXT_PACKED = "";
Constant alphabetised_text_0 = " ";
Constant alphabetised_text_1 = " N = Next";
Constant alphabetised_text_2 = " P = Previous";
Constant I7_FULL_VERSION_NUMBER = "10.1.2";
Constant I7_VERSION_NUMBER = "10.1.2";
Serial "241212";
Constant alphabetised_text_3 = ">";
Constant alphabetised_text_4 = "A car waits to take you through the horror that is Hell Ride.";
Constant alphabetised_text_5 = "A faux leather seat that looked great when it was new.";
Constant alphabetised_text_6 = "A spiked chair looms in the corner, its cruel design gleaming faintly in the dim light.";
Constant alphabetised_text_7 = "About Interactive Fiction";
Constant alphabetised_text_8 = "As you enter the dimly lit tent, you see that the stage is decorated to resemble an exotic Middle Eastern market or palace, featuring rich, colorful fabrics, brass ornaments, and lanterns casting a warm, flickering glow. Scents of incense waft through the air, enhancing the atmosphere of mystique. The backdrop displays painted scenes of pyramids, desert landscapes, and domed structures to evoking a sense of being transported to the ~Middle East~. ";
Constant alphabetised_text_9 = "At the center of the square stands a raised wooden platform, stark and imposing, where the grim sentence is to be carried out.";
Constant alphabetised_text_10 = "At the center of the square, rising like a grim monument to mortality, stands the gallows-a wooden platform, darkened by age and weather, with thick ropes hanging like vipers poised to strike.";
Constant alphabetised_text_11 = "At the center, three wooden stakes rise ominously from a circular pyre of logs and kindling, their rough surfaces darkened by smoke from countless such scenes before. Bound tightly to these stakes are three women, their wrists and ankles secured with coarse, heavy ropes. Their faces tell different stories-one of defiance, another of resignation, and the third of pure terror.";
Constant alphabetised_text_12 = "Awl";
Constant alphabetised_text_13 = "Backstage";
Constant alphabetised_text_14 = "Barker";
Constant alphabetised_text_15 = "Be creative";
Constant alphabetised_text_16 = "Blueberries";
Constant alphabetised_text_17 = "Can opener";
Constant alphabetised_text_18 = "Cashier";
Constant alphabetised_text_19 = "Concession Stand";
Constant alphabetised_text_20 = "Containment";
Constant alphabetised_text_21 = "Control Panel";
Constant alphabetised_text_22 = "Control Room";
Constant alphabetised_text_23 = "Controlling the Game";
Constant alphabetised_text_24 = "Cooperate";
Constant alphabetised_text_25 = "Corkscrew";
Constant alphabetised_text_26 = "Cotton candy";
Constant alphabetised_text_27 = "Crawl Space";
Constant alphabetised_text_28 = "Dark Hallway";
Constant alphabetised_text_29 = "Dark Passage";
Constant alphabetised_text_30 = "Dungeon";
Constant alphabetised_text_31 = "ENTER = Select";
Constant alphabetised_text_32 = "Electrical Closet Eleven";
Constant alphabetised_text_33 = "Electrical Closet Five";
Constant alphabetised_text_34 = "Electrical Closet Nine";
Constant alphabetised_text_35 = "Electrical Closet One";
Constant alphabetised_text_36 = "Electrical Closet Seven";
Constant alphabetised_text_37 = "Electrical Closet Three";
Constant alphabetised_text_38 = "Electrical Room";
Constant alphabetised_text_39 = "Explore";
Constant alphabetised_text_40 = "Fingernail clippers";
Constant alphabetised_text_41 = "Gallows Room";
Constant alphabetised_text_42 = "Generator Room";
Constant alphabetised_text_43 = "Getting Started";
Constant alphabetised_text_44 = "Grease";
Constant alphabetised_text_45 = "Guillotine Room";
Constant alphabetised_text_46 = "Head of the Line";
Constant alphabetised_text_47 = "Hell Ride";
Constant alphabetised_text_48 = "Hell Ride car";
Constant alphabetised_text_49 = "Hell Ride ticket";
Constant alphabetised_text_50 = "HellRide";
Constant alphabetised_text_51 = "High Striker";
Constant alphabetised_text_52 = "Holding room";
Constant alphabetised_text_53 = "Horror";
Constant alphabetised_text_54 = "How the World is Assembled";
Constant alphabetised_text_55 = "I am a room just to have a place to reference.";
Constant alphabetised_text_56 = "If You Get Stuck";
Constant alphabetised_text_57 = "Instructions";
Constant alphabetised_text_58 = "Instructions for Play";
Constant alphabetised_text_59 = "It looks like you could set something there.";
Constant alphabetised_text_60 = "Kiosk";
Constant alphabetised_text_61 = "Little Egypt";
Constant alphabetised_text_62 = "Little Egypt emerges draped in flowing silk veils which she skillfully uses as part of the dance. Her attire consists of a sparkling, sequined bodice and a flowing skirt, adorned with jingling coin belts and jewelry that accentuate her movements.";
Constant alphabetised_text_63 = "Little Egypt is an exotic looking, beautiful woman who is draped in flowing silk veils which she skillfully uses as part of the dance. Her attire consists of a sparkling, sequined bodice and a flowing skirt, adorned with jingling coin belts and jewelry that accentuate her movements.";
Constant alphabetised_text_64 = "Little Egypt makes eye contact with you and smiles enigmatically. During her performance she balances a sword on her head and accents her dance with finger cymbals.";
Constant alphabetised_text_65 = "Lubricant";
Constant alphabetised_text_66 = "Maintenance Office";
Constant alphabetised_text_67 = "Mechanical Room North";
Constant alphabetised_text_68 = "Mechanical Room South";
Constant alphabetised_text_69 = "Midway";
Constant alphabetised_text_70 = "Most IF games are set in a world made up of rooms without internal division. Movement between rooms is possible; movement within a room does not always amount to anything. >WALK OVER TO THE DESK is rarely a useful sort of command. On the other hand, if something is described as being high or out of reach, it is sometimes relevant to stand on an object to increase your height. This kind of activity tends to be important only if prompted by the game text.";
Constant alphabetised_text_71 = "Most of the actions you can perform in the world of IF are brief and specific. >WALK WEST or >OPEN DOOR are likely to be provided. >TAKE A JOURNEY or >BUILD A TABLE are not. Things like >GO TO THE HOTEL are on the borderline: some games allow them, but most do not. In general, abstract, multi-stage behavior usually has to be broken down in order for the game to understand it. ";
Constant alphabetised_text_72 = "No Shoes";
Constant alphabetised_text_73 = "Objects";
Constant alphabetised_text_74 = "One thing that IF does tend to model thoroughly is containment. Is something in or on something else? The game keeps track of this, and many puzzles have to do with where things are -- in the player's possession, lying on the floor of the room, on a table, in a box, etc.";
Constant alphabetised_text_75 = "Other Characters";
Constant alphabetised_text_76 = "Other characters in IF games are sometimes rather limited. On the other hand, there are also games in which character interaction is the main point of the game. You should be able to get a feel early on for the characters -- if they seem to respond to a lot of questions, remember what they're told, move around on their own, etc., then they may be fairly important. If they have a lot of stock responses and don't seem to have been the game designer's main concern, then they are most likely present either as local color or to provide the solution to a specific puzzle or set of puzzles. Characters in very puzzle-oriented games often have to be bribed, threatened, or cajoled into doing something that the player cannot do -- giving up a piece of information or an object, reaching something high, allowing the player into a restricted area, and so on.";
Constant alphabetised_text_77 = "Parking Attendant";
Constant alphabetised_text_78 = "Parking Lot";
Constant alphabetised_text_79 = "Play with someone else. Two heads are often better than one. If that doesn't work, try emailing the author or (better yet) posting a request for hints on the newsgroup rec.games.int-fiction.  For best results, put the name of the game you want help with in the subject line; then leave a page or so of blank spoiler space (so that no one will read about where you got to in the game unless they've already played it), and describe your problem as clearly as possible.  Someone will probably be able to tell you how to get around it.";
Constant alphabetised_text_80 = "Pliers";
Constant alphabetised_text_81 = "QUIT";
Constant alphabetised_text_82 = "RESTART";
Constant alphabetised_text_83 = "RESTORE a saved game";
Constant alphabetised_text_84 = "Read carefully";
Constant alphabetised_text_85 = "Ride Attendant";
Constant alphabetised_text_86 = "Ride Entrance";
Constant alphabetised_text_87 = "Ride Exit";
Constant alphabetised_text_88 = "Rooms and Travel";
Constant alphabetised_text_89 = "Sailor";
Constant alphabetised_text_90 = "Sample Hint";
Constant alphabetised_text_91 = "Second Floor";
Constant alphabetised_text_92 = "Show Facade";
Constant alphabetised_text_93 = "Show Tent";
Constant alphabetised_text_94 = "Space";
Constant alphabetised_text_95 = "Stage";
Constant alphabetised_text_96 = "Stake Room";
Constant alphabetised_text_97 = "Stocks Room";
Constant alphabetised_text_98 = "Storage Room";
Constant alphabetised_text_99 = "Strongman Attendant";
Constant alphabetised_text_100 = "Swiss army knife";
Constant alphabetised_text_101 = "The backstage control room is a functional, no-frills space hidden behind the glitter and chaos of the carnival. It's where the real work happens-a nerve center for monitoring and managing the operations of the rides, attractions, and lighting systems. The room is enclosed by plain, industrial walls, painted a dull gray and marked with scuffs, scratches, and the occasional smudge of grease or fingerprints.^^Rows of monitors line the main wall, displaying live feeds from security cameras and ride controls. Each screen shows a different part of the carnival: blinking lights of the Ferris wheel, the whirling motion of a carousel, and the eerie darkness of the Hell Ride. A few screens flicker or show static, adding to the sense of wear and tear that pervades the room. Beneath the monitors, a control panel is cluttered with switches, buttons, and dials, each labeled with functions like ~Ride Start,~ ~Lighting Override~, and ~Emergency Stop.~ Small lights blink in green, yellow, or red, signaling the status of different systems.^^The hum of electronics fills the air, mingled with the occasional crackle of a two-way radio resting on a desk. The radios buzz intermittently with the voices of carnival workers reporting issues or coordinating movements: ~Maintenance to Tilt-a-Whirl-need a wrench at Station 2!~^^The floor is a patchwork of worn linoleum and exposed concrete, littered with stray papers, toolkits, and empty coffee cups. A cluttered desk sits against one wall, covered with logbooks, ride schedules, and laminated emergency procedures. A corkboard above the desk is pinned with maintenance charts, carnival maps, and handwritten notes, some of them circled in red ink with messages like ~Check circuit breakers on Zipper~ or ~Replace bulbs near south entrance.~^^A single fluorescent light fixture hangs overhead, buzzing faintly as it casts a cold, sterile glow across the room. The air is cool but tinged with a faint metallic smell, mixed with the earthy dampness from the surrounding carnival grounds. In one corner, a small, battered first-aid kit hangs on the wall, its contents slightly spilling out, and a faded fire extinguisher sits nearby.^^Despite its unassuming appearance, the control room feels alive with purpose-a behind-the-scenes hub that ensures the carnival's magic unfolds without a hitch. It's a space where the mechanics, electronics, and human effort merge to keep the carnival running smoothly, even as chaos and excitement reign outside.";
Constant alphabetised_text_102 = "The blueberries are ripe and juicy.";
Constant alphabetised_text_103 = "The bucket of popcorn looks enormous!";
Constant alphabetised_text_104 = "The candy apple is your typical caramel covered apple. It looks like it would get stuck in your teeth.";
Constant alphabetised_text_105 = "The cars that will take you into the fearsome Hell Ride stop here for you to board.  To the south is the track that will take you into the ride. The safety bar is raised allowing you to enter the car. The darkness looks just a little bit darker.";
Constant alphabetised_text_106 = "The concession stand is a vibrant, bustling hub of activity, perched along the midway with its enticing smells and bright signage luring carnival-goers. The booth is painted in cheerful, primary colors-reds, blues, and yellows-with bold lettering across the top that proclaims: ~SODA! POPCORN! CANDY APPLES! COTTON CANDY! PRETZELS!~ Strings of tiny, twinkling lights frame the stand, casting a warm glow that makes it stand out even in the carnival's dazzling atmosphere.^^Behind the counter, the scene is a whirlwind of movement. A large popcorn machine sits to one side, its glass case fogged up with heat as golden kernels tumble and pop inside, filling the air with their buttery aroma. Nearby, a spinning rack of candy apples gleams under the lights, their glossy red coatings catching every glimmer. Cotton candy machines whirl on the opposite side, their sugary strands forming fluffy clouds of pink and blue, ready to be twirled onto paper cones.^^Stacks of soft pretzels sit under a heat lamp, their golden-brown surfaces glistening with melted butter and coarse salt. Warm, doughy scents mingle with the sugary sweetness of the candy apples and cotton candy, creating an irresistible combination. Ice-cold sodas are arranged in a cooler behind the counter, their colorful labels visible through the condensation on the glass door.^^The counter top is a cheerful chaos of activity. Paper bags and napkins are stacked neatly in one corner, alongside small cups of nacho cheese for pretzels and sugar sprinkles for cotton candy. A handwritten menu board leans against the front of the stand, listing prices in playful chalk lettering.^^The workers, wearing brightly colored aprons and matching hats, move quickly and efficiently, handing out snacks to eager customers. Behind them, shelves are stocked with supplies: bags of popcorn kernels, bottles of soda syrup, and tubs of pretzel dough, ready to keep the stand running all night.^^In front of the stand, the crowd is lively and animated. Children tug at their parents~ sleeves, pointing at the spinning cotton candy or the shiny candy apples. Teens laugh and chat as they sip sodas and share buttery pretzels. The stand is not just a place to grab a quick snack-it's a sensory experience that enhances the carnival's magic, offering a delicious pause amid the excitement.^^There is a menu to the right of the window. You can see the treats inside the stand.";
Constant alphabetised_text_107 = "The cotton candy is a mixture of pink and blue floss.";
Constant alphabetised_text_108 = "The crawl space beneath the carnival ride is a tight, claustrophobic tunnel shrouded in darkness and filled with the hum of machinery above. The air is stale and heavy, carrying the sharp metallic scent of oil and the faint tang of rust. Every sound is amplified in the confined space-the groaning of steel beams, the clanking of chains, and the rhythmic thrum of motors driving the ride above.^^The ground is uneven, a mix of packed dirt and loose gravel scattered with forgotten tools, scraps of metal, and tangled wires. Overhead, a network of pipes and cables crisscross the space, some wrapped in fraying insulation that crackles faintly as you crawl past. Small puddles of murky water collect in dips on the floor, their surfaces rippling with vibrations from the ride's movement.";
Constant alphabetised_text_109 = "The electrical room is a compact but vital space, tucked away behind the scenes of the carnival's bustling attractions. The room hums with a steady, electric energy, the air thick with the scent of overheated wires, metal, and a faint tang of ozone. The walls are lined with metal panels, some polished and sleek, others weathered and streaked with grease from years of operation.^^A central breaker panel dominates one wall, its surface covered in a grid of switches and levers, each labeled with destinations like ~Ferris Wheel Lights~, ~Carousel Motors~, and ~Midway Games~. Bright indicator lights blink sporadically, casting green, yellow, and red glows that reflect off the polished steel surfaces. Overhead, conduits and thick bundles of cables snake across the ceiling, bound together with zip ties and disappearing into the walls to distribute power throughout the carnival.^^In one corner of the room, a junction box sits open, its wires spilling out like the veins of the carnival. A maintenance worker's touch lingers here, with tools scattered on a small workbench nearby: wire cutters, screwdrivers, and spools of electrical tape. A laminated wiring diagram is pinned to the wall above the bench, its corners dog-eared and smudged with greasy fingerprints.^^The floor is dirt, its surface marked with scratches, oil stains, and scattered bits of wire clippings. A faint vibration runs through the room, a pulse from the generator in the adjacent space or the distant hum of the carnival rides.^^Mounted along another wall is an emergency shutdown panel, painted bright red with a prominent lever labeled ~Master Power Off.~ A fire extinguisher hangs nearby, accompanied by a faded safety poster warning about the dangers of electrical fires. Below it, a collection of replacement fuses and circuit boards are neatly arranged on a shelf, ready for use when something inevitably malfunctions.^^A small fan sits on the workbench, oscillating weakly to counter the oppressive heat radiating from the machinery. The light in the room comes from bare fluorescent tubes overhead, their cold glow flickering slightly, casting sharp shadows that shift with every movement.^^Despite its functionality, the electrical room carries a certain unease. The constant hum of electricity, the flicker of lights, and the sharpness of exposed wires hint at the delicate balance of power keeping the carnival alive. It's a space where the magic of the midway is stripped bare, revealing the raw energy coursing through its veins.";
Constant alphabetised_text_110 = "The game you are playing is a work of Interactive Fiction.  In interactive fiction you play the main character of a story.  You type commands which determine the actions of the character and the flow of the plot.  Some IF games include graphics, but most do not: the imagery is provided courtesy of your imagination.  On the other hand, there's a wide range of action available: whereas in other games you may be restricted to shooting, movement, or searching items you can click on with a mouse, IF allows you a wide range of verbs.";
Constant alphabetised_text_111 = "The generator room is a compact, industrial space tucked away from the vibrant chaos of the carnival, where the hum and flicker of electricity are birthed to power the attractions. The walls are constructed of reinforced concrete, their surfaces marked with grime, oil streaks, and the faint outlines of graffiti left by past workers. The room smells of diesel fuel, hot metal, and the faint tang of ozone, mingled with the earthy scent of dampness from the surrounding ground.^^At the center of the room sits the main generator, a hulking, metallic beast of machinery. Its steel casing is scuffed and dented from years of use, though it still functions with a steady, low rumble that resonates through the floor. Thick cables, black and rubberized, extend like veins from the generator to the room's walls, where they feed into an array of junction boxes and circuit breakers.^^The generator's control panel is mounted to one side, cluttered with buttons, switches, and gauges. Labels, many peeling or faded, identify each component: ~Fuel Intake~, ~Voltage Control~, ~Emergency Shutoff~. A small display screen flickers with real-time readouts, showing power levels and load distribution to the various carnival attractions.^^The floor is made of rough, uneven concrete, with small puddles of spilled fuel or condensation pooling in its crevices. Along the walls, shelves are stacked with spare parts-fuel filters, spark plugs, and coils of insulated wire. Tools are scattered on a nearby workbench, alongside a canister of grease and a well-worn maintenance manual.^^The air is thick and warm, vibrating faintly with the generator's operation. A vent in the corner struggles to extract the heat, its fan spinning with a faint, rhythmic whir. The dim lighting in the room comes from a single industrial bulb encased in a protective cage, casting harsh shadows across the machinery and walls.^^In one corner, a row of diesel fuel canisters stands neatly arranged, their metallic surfaces gleaming under the light. A faded safety poster hangs above them, its message barely legible: ~Fuel Safely-No Open Flames!~^^Despite its utilitarian design, the room carries an air of importance. The generator room is the heartbeat of the carnival, its steady output ensuring that the lights flash, the rides whirl, and the sounds of joy and terror continue uninterrupted. Yet, in its stark isolation, it feels oddly disconnected from the lively world it powers, a quiet reminder of the machinery behind the magic.";
Constant alphabetised_text_112 = "The grue is a sinister, lurking presence in the dark places of the earth. Its favorite diet is humans, but its insatiable appetite is tempered by its fear of light. No grue has ever been seen by the light of day, and few have survived its fearsome jaws to tell the tale.";
Constant alphabetised_text_113 = "The maintenance office is a chaotic and dimly lit space tucked away behind the glitz and glamour of the carnival. It smells of grease, sweat, and faintly of popcorn from the midway outside. The air is heavy and warm, thick with the lingering scent of oil and dust stirred up by constant work.^^The walls are lined with cluttered shelves holding an assortment of tools and parts-rusty wrenches, screwdrivers, hammers, bolts, and screws organized (or not) in mismatched containers. Tattered labels, some scrawled in fading marker, hint at what lies inside. Cans of paint, grease, and lubricant sit precariously on the edges of workbenches, their lids half-open or missing entirely.^^The center of the room is dominated by a large desk scarred with years of use. A vise clamp holds a bent piece of metal in place, while a spread of loose wires, gears, and springs litter the surface. A single, broken fluorescent light hangs from the ceiling.^^In one corner, a disassembled ride mechanism sits, its inner workings exposed like the guts of a machine. Chains and pulleys dangle from hooks overhead, their metallic clink echoing faintly as they sway slightly with the vibration of the rides outside. A half-drained mug of coffee sits forgotten on a stool nearby, next to a grease-stained manual lying open to a random page.^^The walls bear evidence of the room's purpose: faded safety posters warning of hazards, a cork board pinned with ride maintenance schedules and hastily scribbled notes, and a faded photograph of the carnival in its prime. A clock ticks faintly in the background, though its hands don't seem to match the current time.^^The floor is uneven and gritty, coated in a fine layer of dust and littered with stray nails and scraps of metal. In one corner, a toolbox sits half-open, its contents spilling out as though abandoned mid-task. Nearby, a rickety fan struggles to spin, offering little relief from the oppressive heat.^^Despite the disarray, the room hums with purpose. This is the beating heart of the carnival's machinery, a hidden realm where the magic of the attractions is kept alive by grease-stained hands and sheer determination.";
Constant alphabetised_text_114 = "The mallet is over sized, perhaps to give you an advantage in the Strong Man game.";
Constant alphabetised_text_115 = "The north mechanical room is smaller and more focused, housing the auxiliary systems that support the ride's operation. It's quieter than the south room, though the hum of capacitors and relays creates a constant, low background noise. Rows of electrical panels line the walls, each labeled with functions such as ~Lighting Controls,~ ~Brake Systems~, and ~Emergency Shutdown~. Smaller cables and conduits run along the walls, connecting these systems to the main hub in the south room.^^In one corner, a hydraulic pump and reservoir control specific mechanisms of the ride, such as lifting arms or rotating platforms. Pressure gauges flicker intermittently, and the occasional hiss of fluid escaping creates a sharp contrast to the otherwise subdued atmosphere. A small generator sits nearby, its housing slightly dented but functional, ready to activate in case of a power failure.^^A compact workbench is tucked against the eastern wall, strewn with tools and coiled wires. Above it, shelves are stacked with neatly labeled replacement parts: fuses, cables, and hydraulic tubing. A faded diagram of the ride's layout is pinned to the wall nearby, marked with annotations in red ink from previous maintenance efforts.^^The lighting is dimmer here, provided by a single hanging bulb that casts soft shadows across the room. The air feels cooler and slightly damp, with a faint smell of mildew mixing with the metallic tang of the machinery.^^The north mechanical room functions as a support system, ensuring that auxiliary processes run smoothly and that emergency backups are ready to deploy if needed. Though quieter and less imposing than its southern counterpart, it is just as critical to the ride's overall operation.";
Constant alphabetised_text_116 = "The performance begins with slow, undulating movements, drawing the you into the rhythm of exotic live music played on traditional instruments like the oud, darbuka, or zurna. As the tempo builds, her hips, torso, and hands move in intricate, mesmerizing patterns, demonstrating remarkable control and fluidity. She incorporates dramatic spins, drops, and shimmies, often accentuating the beat of the music with a quick jingle of her coin belt.";
Constant alphabetised_text_117 = "The performance concludes with a dramatic flourish of a fast-paced shimmy, a bold spin, and Little Egypt dramatically casts off her veils. The dancer takes a bow to enthusiastic applause, leaving you spellbound by the sensual yet artful display.";
Constant alphabetised_text_118 = "The public square is a charged space, bustling with a crowd eager to witness the grim spectacle. The sky overhead is a patchwork of gray clouds, casting the cobblestone ground in a somber light. At the center of the square stands a raised wooden platform, stark and imposing, where the grim sentence is to be carried out.^^A lone figure stands on the scaffold, their posture slumped under the weight of their fate. Their hands are bound tightly behind their back with coarse ropes, and their head hangs low, avoiding the stares of the gathered crowd. Their clothing, once fine, is now tattered and muddied, a visible testament to the fall from grace that has led to this moment.^^The crowd presses closer, encircling the platform with a mix of emotions etched onto their faces. Some jeer, shouting curses and insults, their voices rising in a cacophony of condemnation. Others watch in heavy silence, their expressions grim and reflective. A few hold children on their shoulders, their young faces filled with curious fascination, unaware of the gravity of what they are about to witness.^^At the edge of the platform, a town crier stands with a long scroll in hand, his voice carrying over the murmurs of the crowd: ~This man has been found guilty of high treason against the crown. Let his punishment serve as a warning to all who would seek to defy the will of the realm!~^^The condemned flinches at the words but remains silent, their face pale and eyes darting nervously. The executioner, a large figure clad in a hooded black robe, stands nearby with arms crossed, their demeanor cold and methodical. A few feet away, the guillotine looms, its blade gleaming dully in the filtered light, ready to deliver the final judgment.^^The tension in the square is palpable as the crier steps aside and the executioner signals for the crowd to quiet. The murmurs fade, replaced by an oppressive silence that hangs over the scene like a shroud. The only sounds now are the rustle of the wind and the faint creak of the wooden scaffold.^^As the condemned is led toward the guillotine, a crow caws from a nearby rooftop, its harsh cry echoing through the square like a dark omen. The crowd leans forward, holding its collective breath, as the weight of justice and mortality descends upon the scene.^^There is just lone problem: the guillotine is being raised and lowered by some mechanism. It appears that the timing of the guillotine is off and it is being lowered onto the cars instead of between them. If a person were to be in a car as it passed under the guillotine, they would be decapitated.";
Constant alphabetised_text_119 = "The ride of a lifetime...";
Constant alphabetised_text_120 = "The soda is ice cold.";
Constant alphabetised_text_121 = "The soft pretzel is sprinkled generously with salt.";
Constant alphabetised_text_122 = "The south mechanical room is the heart of the carnival ride, a large, noisy space where the primary systems are housed. The room is dominated by a massive motor, its rhythmic hum filling the air as it drives the ride's main mechanics. Thick belts and pulleys extend from the motor to a series of gears and drive shafts, each component working in seamless coordination to power the ride.^^The walls are lined with heavy-duty electrical panels, their surfaces marked with warning labels like ~High Voltage~ and ~Do Not Open While Powered~. Bright indicator lights blink in greens and reds, providing a visual heartbeat to the room's constant activity. Overhead, insulated wires and steel conduits run along the ceiling, their routes clearly labeled but seemingly endless.^^A workbench along one wall is cluttered with tools-wrenches, screwdrivers, and pliers-neatly arranged next to containers of spare parts like bolts, washers, and lubricants. Manuals and maintenance logs sit open, their pages marked with grease-stained fingerprints. The faint smell of oil and metal pervades the air, along with a hint of ozone from the electrical systems.^^A cooling fan whirs in the corner, its blades spinning in a futile attempt to temper the room's warmth. The sound of chains clinking occasionally breaks through the hum, accompanied by the sharp hiss of hydraulic fluid releasing pressure. The floor is a patchwork of metal grates and concrete, worn smooth in some areas by years of use.^^The south mechanical room is brightly lit, with overhead fluorescent lights encased in protective wire cages. This is the main operations hub, where the power of the ride is generated and controlled, ensuring its thrilling movements stay in sync.";
Constant alphabetised_text_123 = "The stage is decorated to resemble an exotic Middle Eastern market or palace, featuring rich, colorful fabrics, brass ornaments, and lanterns casting a warm, flickering glow. Scents of incense waft through the air, enhancing the atmosphere of mystique. The backdrop displays painted scenes of pyramids, desert landscapes, and domed structures to evoking a sense of being transported to the ~Middle East~.";
Constant alphabetised_text_124 = "The stand is bathed in red light, adding to the ominous mood.";
Constant alphabetised_text_125 = "There are a variety of things to eat here.";
Constant alphabetised_text_126 = "There are five levels marked on the pole: Weakling, Getting There, Average, Almost There, and Muscle Man.";
Constant alphabetised_text_127 = "There is a bullseye on the base. I guess this is where you have to aim the mallet.";
Constant alphabetised_text_128 = "This is a crimson colored button.";
Constant alphabetised_text_129 = "This is a gray colored button.";
Constant alphabetised_text_130 = "This is a khaki colored button.";
Constant alphabetised_text_131 = "This is a pad of lined paper.";
Constant alphabetised_text_132 = "This is a poorly lit hallway. Ahead you can see the glow of an open door.";
Constant alphabetised_text_133 = "This is a red stapler.";
Constant alphabetised_text_134 = "This is a sharp pair of office scissors.";
Constant alphabetised_text_135 = "This is a sheer gold veil that Little Egypt wore (and removed) during her show. Your head swims as you smell the scent of her perfume on her veil: patchouli.";
Constant alphabetised_text_136 = "This is a small silver key. I wonder what it unlocks.";
Constant alphabetised_text_137 = "This is a socket. A fuse probably goes in here.";
Constant alphabetised_text_138 = "This is a socket. A fuse probably goes in here..";
Constant alphabetised_text_139 = "This is a teddy bear like you had when you were a kid. Right down to the red bow around its neck.";
Constant alphabetised_text_140 = "This is an aqua colored button.";
Constant alphabetised_text_141 = "This is an electrical fuse. It is aqua colored. The same color as the door where you found it.";
Constant alphabetised_text_142 = "This is an electrical fuse. It is crimson colored. The same color as the door where you found it.";
Constant alphabetised_text_143 = "This is an electrical fuse. It is emerald colored. The same color as the door where you found it.";
Constant alphabetised_text_144 = "This is an electrical fuse. It is gray colored. The same color as the door where you found it.";
Constant alphabetised_text_145 = "This is an electrical fuse. It is indigo colored. The same color as the door where you found it.";
Constant alphabetised_text_146 = "This is an electrical fuse. It is khaki colored. The same color as the door where you found it.";
Constant alphabetised_text_147 = "This is an emerald colored button.";
Constant alphabetised_text_148 = "This is an exlectrical fuse. It is magenta colored.";
Constant alphabetised_text_149 = "This is an indigo colored button.";
Constant alphabetised_text_150 = "This is another bored teenager. His thoughts are entirely focused on a cheeseburger for lunch.";
Constant alphabetised_text_151 = "This is one of many folding chairs in the tent tonight.";
Constant alphabetised_text_152 = "This is the standard issue Swiss Army knife with a screwdriver, an awl, a pair fingernail clippers, a can opener, and a corkscrew.";
Constant alphabetised_text_153 = "This room is backstage at the Hell Ride attraction. The room is littered with bags of trash, piles of junk, and dust bunnies so large they should be paying rent. West is back the way you came from. There an exit to the south.";
Constant alphabetised_text_154 = "Treats";
Constant alphabetised_text_155 = "Types of Action";
Constant alphabetised_text_156 = "UNDO the last command";
Constant alphabetised_text_157 = "You are despondent given that you and your date just had a huge fight and they stormed off. Maybe visiting the attractions at the carnival will make you feel better.";
Constant alphabetised_text_158 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the east.";
Constant alphabetised_text_159 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the north east.";
Constant alphabetised_text_160 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the north west.";
Constant alphabetised_text_161 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the south east.";
Constant alphabetised_text_162 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the south west.";
Constant alphabetised_text_163 = "You are in a section of the electrical room. There is an electrical panel here. There is an exit to the west.";
Constant alphabetised_text_164 = "You are inside the Little Egypt Show. The attraction facade is to the east. There folding chairs organized neatly in rows. The show should start soon.";
Constant alphabetised_text_165 = "You found this in a stack of coupons on the counter of the gas station.";
Constant alphabetised_text_166 = "You have died!";
Constant alphabetised_text_167 = "You have died.";
Constant alphabetised_text_168 = "You have won!";
Constant alphabetised_text_169 = "You start the long walk home.";
Constant alphabetised_text_170 = "You've decided to stay and enjoy the carnival anyway.";
Constant alphabetised_text_171 = "Your standard ballpoint pen. It says Bic on the side.";
Constant alphabetised_text_172 = "Yourself";
Constant outcome_allow_access_U1 = "allow access";
Constant outcome_allow_startup_U1 = "allow startup";
Constant alphabetised_text_173 = "animals";
Constant alphabetised_text_174 = "aqua button";
Constant alphabetised_text_175 = "aqua dial";
Constant alphabetised_text_176 = "aqua door";
Constant alphabetised_text_177 = "aqua fuse";
Constant alphabetised_text_178 = "aqua light";
Constant alphabetised_text_179 = "awl";
Constant alphabetised_text_180 = "backdrops";
Constant alphabetised_text_181 = "bags of trash";
Constant alphabetised_text_182 = "ballpoint pen";
Constant alphabetised_text_183 = "bar";
Constant alphabetised_text_184 = "beater car";
Constant alphabetised_text_185 = "blueberries";
Constant alphabetised_text_186 = "blueberry bush";
Constant alphabetised_text_187 = "bucket of popcorn";
Constant alphabetised_text_188 = "can";
Constant alphabetised_text_189 = "can opener";
Constant alphabetised_text_190 = "candy apple";
Constant alphabetised_text_191 = "cans of paint";
Constant alphabetised_text_192 = "car seat";
Constant alphabetised_text_193 = "channel locks";
Constant alphabetised_text_194 = "colored buttons";
Constant alphabetised_text_195 = "colored dials";
Constant alphabetised_text_196 = "colored fuses";
Constant alphabetised_text_197 = "colored lights";
Constant alphabetised_text_198 = "containers";
Constant alphabetised_text_199 = "corkscrew";
Constant alphabetised_text_200 = "cotton candy";
Constant alphabetised_text_201 = "coupon";
Constant alphabetised_text_202 = "crimson button";
Constant alphabetised_text_203 = "crimson dial";
Constant alphabetised_text_204 = "crimson door";
Constant alphabetised_text_205 = "crimson fuse";
Constant alphabetised_text_206 = "crimson light";
Constant alphabetised_text_207 = "dashboard";
Constant outcome_deny_access_U1 = "deny access";
Constant outcome_deny_startup_U1 = "deny startup";
Constant alphabetised_text_208 = "desk";
Constant alphabetised_text_209 = "devices";
Constant alphabetised_text_210 = "dime";
Constant alphabetised_text_211 = "directions";
Constant alphabetised_text_212 = "doors";
Constant alphabetised_text_213 = "down";
Constant alphabetised_text_214 = "drawer";
Constant alphabetised_text_215 = "dust bunnies";
Constant alphabetised_text_216 = "east";
Constant alphabetised_text_217 = "electric lamps";
Constant alphabetised_text_218 = "emerald button";
Constant alphabetised_text_219 = "emerald dial";
Constant alphabetised_text_220 = "emerald door";
Constant alphabetised_text_221 = "emerald fuse";
Constant alphabetised_text_222 = "emerald light";
Constant alphabetised_text_223 = "fingernail clippers";
Constant alphabetised_text_224 = "flashlight";
Constant alphabetised_text_225 = "fluid containers";
Constant alphabetised_text_226 = "folding chair";
Constant alphabetised_text_227 = "foo";
Constant alphabetised_text_228 = "gallows platform";
Constant alphabetised_text_229 = "glove box";
Constant alphabetised_text_230 = "gloves";
Constant alphabetised_text_231 = "gray button";
Constant alphabetised_text_232 = "gray dial";
Constant alphabetised_text_233 = "gray door";
Constant alphabetised_text_234 = "gray fuse";
Constant alphabetised_text_235 = "gray light";
Constant alphabetised_text_236 = "grease";
Constant alphabetised_text_237 = "ground";
Constant alphabetised_text_238 = "guillotine platform";
Constant alphabetised_text_239 = "hammer";
Constant alphabetised_text_240 = "indigo button";
Constant alphabetised_text_241 = "indigo dial";
Constant alphabetised_text_242 = "indigo door";
Constant alphabetised_text_243 = "indigo fuse";
Constant alphabetised_text_244 = "indigo light";
Constant alphabetised_text_245 = "inside";
Constant alphabetised_text_246 = "iron seat";
Constant outcome_it_does_U1 = "it does";
Constant outcome_it_does_not_U1 = "it does not";
Constant outcome_it_is_likely_U1 = "it is likely";
Constant outcome_it_is_possible_U1 = "it is possible";
Constant outcome_it_is_unlikely_U1 = "it is unlikely";
Constant outcome_it_is_very_likely_U1 = "it is very likely";
Constant outcome_it_is_very_unlikely_U1 = "it is very unlikely";
Constant alphabetised_text_247 = "keychains";
Constant alphabetised_text_248 = "keys";
Constant alphabetised_text_249 = "khaki button";
Constant alphabetised_text_250 = "khaki dial";
Constant alphabetised_text_251 = "khaki door";
Constant alphabetised_text_252 = "khaki fuse";
Constant alphabetised_text_253 = "khaki light";
Constant alphabetised_text_254 = "ladder";
Constant alphabetised_text_255 = "lever";
Constant alphabetised_text_256 = "lubricant";
Constant alphabetised_text_257 = "lurking grue";
Constant alphabetised_text_258 = "magenta fuse";
Constant alphabetised_text_259 = "mallet";
Constant alphabetised_text_260 = "markings";
Constant alphabetised_text_261 = "men";
Constant alphabetised_text_262 = "menu";
Constant alphabetised_text_263 = "merchandise stand";
Constant alphabetised_text_264 = "monitor";
Constant alphabetised_text_265 = "monkey wrench";
Constant alphabetised_text_266 = "north";
Constant alphabetised_text_267 = "northeast";
Constant alphabetised_text_268 = "northwest";
Constant alphabetised_text_269 = "outside";
Constant alphabetised_text_270 = "pad of paper";
Constant alphabetised_text_271 = "parking stub";
Constant alphabetised_text_272 = "parking ticket";
Constant alphabetised_text_273 = "passkeys";
Constant alphabetised_text_274 = "people";
Constant outcome_persuasion_fails_U1 = "persuasion fails";
Constant outcome_persuasion_succeeds_U1 = "persuasion succeeds";
Constant alphabetised_text_275 = "pile of junk";
Constant alphabetised_text_276 = "player's holdalls";
Constant alphabetised_text_277 = "pliers";
Constant alphabetised_text_278 = "poster of Taylor Swift";
Constant alphabetised_text_279 = "pyre";
Constant alphabetised_text_280 = "radio";
Constant alphabetised_text_281 = "regions";
Constant alphabetised_text_282 = "rideable animals";
Constant alphabetised_text_283 = "rideable vehicles";
Constant alphabetised_text_284 = "scissors";
Constant alphabetised_text_285 = "screwdriver";
Constant alphabetised_text_286 = "see some suggestions for AMUSING things to do";
Constant alphabetised_text_287 = "sheer veil";
Constant alphabetised_text_288 = "silver key";
Constant alphabetised_text_289 = "sky";
Constant alphabetised_text_290 = "sockets";
Constant alphabetised_text_291 = "soft pretzel";
Constant alphabetised_text_292 = "south";
Constant alphabetised_text_293 = "southeast";
Constant alphabetised_text_294 = "southwest";
Constant alphabetised_text_295 = "stapler";
Constant alphabetised_text_296 = "supporters";
Constant alphabetised_text_297 = "switches";
Constant alphabetised_text_298 = "teddy bear";
Constant alphabetised_text_299 = "the";
Constant alphabetised_text_300 = "the electrical panel";
Constant alphabetised_text_301 = "the indicator";
Constant alphabetised_text_302 = "the socket";
Constant alphabetised_text_303 = "the switch";
Constant outcome_there_is_insufficien_U1 = "there is insufficient light";
Constant outcome_there_is_sufficient__U1 = "there is sufficient light";
Constant alphabetised_text_304 = "toolbox";
Constant alphabetised_text_305 = "treats";
Constant alphabetised_text_306 = "up";
Constant alphabetised_text_307 = "vehicles";
Constant alphabetised_text_308 = "wallet";
Constant alphabetised_text_309 = "west";
Constant alphabetised_text_310 = "women";
Constant alphabetised_text_311 = "wooden stocks";
Constant alphabetised_text_312 = "yourself";
Constant V1_starting_the_virtual_mach = activity_id_U1;
Constant V2_printing_the_name = activity_id_U2;
Constant V3_printing_the_plural_name = activity_id_U3;
Constant text_U1 = alphabetised_text_266;
Constant text_U2 = alphabetised_text_299;
Constant text_U3 = alphabetised_text_211;
Constant text_U4 = alphabetised_text_267;
Constant text_U5 = alphabetised_text_299;
Constant text_U6 = alphabetised_text_211;
Constant text_U7 = alphabetised_text_268;
Constant text_U8 = alphabetised_text_299;
Constant text_U9 = alphabetised_text_211;
Constant text_U10 = alphabetised_text_292;
Constant text_U11 = alphabetised_text_299;
Constant text_U12 = alphabetised_text_211;
Constant text_U13 = alphabetised_text_293;
Constant text_U14 = alphabetised_text_299;
Constant text_U15 = alphabetised_text_211;
Constant text_U16 = alphabetised_text_294;
Constant text_U17 = alphabetised_text_299;
Constant text_U18 = alphabetised_text_211;
Constant text_U19 = alphabetised_text_216;
Constant text_U20 = alphabetised_text_299;
Constant text_U21 = alphabetised_text_211;
Constant text_U22 = alphabetised_text_309;
Constant text_U23 = alphabetised_text_299;
Constant text_U24 = alphabetised_text_211;
Constant text_U25 = alphabetised_text_306;
Constant text_U26 = alphabetised_text_299;
Constant text_U27 = alphabetised_text_211;
Constant text_U28 = alphabetised_text_213;
Constant text_U29 = alphabetised_text_299;
Constant text_U30 = alphabetised_text_211;
Constant text_U31 = alphabetised_text_245;
Constant text_U32 = alphabetised_text_299;
Constant text_U33 = alphabetised_text_211;
Constant text_U34 = alphabetised_text_269;
Constant text_U35 = alphabetised_text_299;
Constant text_U36 = alphabetised_text_211;
Constant text_U37 = alphabetised_text_312;
Constant text_U38 = alphabetised_text_157;
Constant text_U39 = alphabetised_text_172;
Constant text_U40 = alphabetised_text_312;
Constant text_U41 = alphabetised_text_274;
Constant RBNO0_OUTCOME_U1 = outcome_it_is_very_unlikely_U1;
Constant RBNO4_OUTCOME_U1 = outcome_it_is_very_likely_U1;
Constant RBNO3_OUTCOME_U1 = outcome_it_is_likely_U1;
Constant RBNO2_OUTCOME_U1 = outcome_it_is_possible_U1;
Constant RBNO1_OUTCOME_U1 = outcome_it_is_unlikely_U1;
Constant V4_issuing_the_response_text = activity_id_U4;
Constant V5_printing_a_number = activity_id_U5;
Constant V6_printing_room_description = activity_id_U6;
Constant V7_printing_inventory_detail = activity_id_U7;
Constant V8_listing_contents = activity_id_U8;
Constant V9_grouping_together = activity_id_U9;
Constant V10_writing_a_paragraph_about = activity_id_U10;
Constant V11_listing_nondescript_items = activity_id_U11;
Constant V12_printing_the_name_of_a_da = activity_id_U12;
Constant V13_printing_the_description_ = activity_id_U13;
Constant V14_printing_the_announcement = activity_id_U14;
Constant V15_printing_the_announcement = activity_id_U15;
Constant V16_printing_a_refusal_to_act = activity_id_U16;
Constant V17_constructing_the_status_l = activity_id_U17;
Constant V18_printing_the_banner_text = activity_id_U18;
Constant V19_reading_a_command = activity_id_U19;
Constant V20_deciding_the_scope = activity_id_U20;
Constant V21_deciding_the_concealed_po = activity_id_U21;
Constant V22_deciding_whether_all_incl = activity_id_U22;
Constant V23_clarifying_the_parser_s_c = activity_id_U23;
Constant V24_asking_which_do_you_mean = activity_id_U24;
Constant V25_printing_a_parser_error = activity_id_U25;
Constant V26_supplying_a_missing_noun = activity_id_U26;
Constant V27_supplying_a_missing_secon = activity_id_U27;
Constant V28_implicitly_taking = activity_id_U28;
Constant V29_amusing_a_victorious_play = activity_id_U29;
Constant V30_printing_the_player_s_obi = activity_id_U30;
Constant V31_handling_the_final_questi = activity_id_U31;
Constant V32_printing_the_locale_descr = activity_id_U32;
Constant V33_choosing_notable_locale_o = activity_id_U33;
Constant V34_printing_a_locale_paragra = activity_id_U34;
Constant text_U42 = alphabetised_text_211;
Constant text_U43 = alphabetised_text_212;
Constant text_U44 = alphabetised_text_198;
Constant text_U45 = alphabetised_text_296;
Constant text_U46 = alphabetised_text_180;
Constant text_U47 = alphabetised_text_274;
Constant text_U48 = alphabetised_text_281;
Constant text_U49 = alphabetised_text_261;
Constant text_U50 = alphabetised_text_310;
Constant K12_animal_First = nothing;
Constant text_U51 = alphabetised_text_173;
Constant text_U52 = alphabetised_text_209;
Constant text_U53 = alphabetised_text_307;
Constant K15_player_s_holdall_First = nothing;
Constant text_U54 = alphabetised_text_276;
Constant text_U55 = alphabetised_text_3;
Constant text_U56 = alphabetised_text_72;
Constant text_U57 = alphabetised_text_119;
Constant text_U58 = alphabetised_text_53;
Constant text_U59 = alphabetised_text_170;
Constant column_identity_U1 = table_column_id_U1;
Constant text_U60 = alphabetised_text_82;
Constant text_U61 = alphabetised_text_83;
Constant text_U62 = alphabetised_text_286;
Constant text_U63 = alphabetised_text_81;
Constant text_U64 = alphabetised_text_156;
Constant column_identity_U2 = table_column_id_U2;
Constant column_identity_U3 = table_column_id_U3;
Constant column_identity_U4 = table_column_id_U4;
Constant column_identity_U5 = table_column_id_U5;
Constant column_identity_U6 = table_column_id_U6;
Constant column_identity_U7 = table_column_id_U7;
Constant V35_refusing_keys = activity_id_U35;
Constant K16_passkey_First = nothing;
Constant text_U65 = alphabetised_text_273;
Constant K17_keychain_First = nothing;
Constant text_U66 = alphabetised_text_247;
Constant V36_pausing_the_game = activity_id_U36;
Constant column_identity_U8 = table_column_id_U8;
Constant column_identity_U9 = table_column_id_U9;
Constant column_identity_U10 = table_column_id_U10;
Constant V37_displaying = activity_id_U37;
Constant text_U67 = alphabetised_text_57;
Constant column_identity_U11 = table_column_id_U11;
Constant text_U68 = alphabetised_text_227;
Constant column_identity_U12 = table_column_id_U12;
Constant column_identity_U13 = table_column_id_U13;
Constant text_U69 = alphabetised_text_183;
Constant column_identity_U14 = table_column_id_U14;
Constant column_identity_U15 = table_column_id_U15;
Constant column_identity_U16 = table_column_id_U16;
Constant column_identity_U17 = table_column_id_U8;
Constant column_identity_U18 = table_column_id_U9;
Constant column_identity_U19 = table_column_id_U10;
Constant column_identity_U20 = table_column_id_U8;
Constant text_U70 = alphabetised_text_1;
Constant text_U71 = alphabetised_text_2;
Constant column_identity_U21 = table_column_id_U9;
Constant column_identity_U22 = table_column_id_U10;
Constant text_U72 = alphabetised_text_0;
Constant text_U73 = alphabetised_text_31;
Constant column_identity_U23 = table_column_id_U17;
Constant text_U74 = alphabetised_text_90;
Constant column_identity_U24 = table_column_id_U18;
Constant column_identity_U25 = table_column_id_U11;
Constant text_U75 = alphabetised_text_47;
Constant text_U76 = alphabetised_text_58;
Constant column_identity_U26 = table_column_id_U12;
Constant column_identity_U27 = table_column_id_U13;
Constant text_U77 = alphabetised_text_53;
Constant column_identity_U28 = table_column_id_U14;
Constant column_identity_U29 = table_column_id_U11;
Constant text_U78 = alphabetised_text_7;
Constant text_U79 = alphabetised_text_43;
Constant text_U80 = alphabetised_text_88;
Constant text_U81 = alphabetised_text_73;
Constant text_U82 = alphabetised_text_23;
Constant text_U83 = alphabetised_text_54;
Constant text_U84 = alphabetised_text_56;
Constant column_identity_U30 = table_column_id_U12;
Constant column_identity_U31 = table_column_id_U13;
Constant text_U85 = alphabetised_text_110;
Constant column_identity_U32 = table_column_id_U14;
Constant column_identity_U33 = table_column_id_U11;
Constant text_U86 = alphabetised_text_94;
Constant text_U87 = alphabetised_text_20;
Constant text_U88 = alphabetised_text_155;
Constant text_U89 = alphabetised_text_75;
Constant column_identity_U34 = table_column_id_U12;
Constant column_identity_U35 = table_column_id_U13;
Constant text_U90 = alphabetised_text_70;
Constant text_U91 = alphabetised_text_74;
Constant text_U92 = alphabetised_text_71;
Constant text_U93 = alphabetised_text_76;
Constant column_identity_U36 = table_column_id_U14;
Constant column_identity_U37 = table_column_id_U11;
Constant text_U94 = alphabetised_text_39;
Constant text_U95 = alphabetised_text_84;
Constant text_U96 = alphabetised_text_15;
Constant text_U97 = alphabetised_text_24;
Constant column_identity_U38 = table_column_id_U12;
Constant column_identity_U39 = table_column_id_U13;
Constant text_U98 = alphabetised_text_79;
Constant column_identity_U40 = table_column_id_U14;
Constant column_identity_U41 = table_column_id_U11;
Constant column_identity_U42 = table_column_id_U12;
Constant column_identity_U43 = table_column_id_U13;
Constant column_identity_U44 = table_column_id_U14;
Constant K18_rideable_animal_First = nothing;
Constant text_U99 = alphabetised_text_282;
Constant K19_rideable_vehicle_First = nothing;
Constant text_U100 = alphabetised_text_283;
Constant text_U101 = alphabetised_text_308;
Constant text_U102 = alphabetised_text_198;
Constant text_U103 = alphabetised_text_224;
Constant text_U104 = alphabetised_text_217;
Constant text_U105 = alphabetised_text_257;
Constant text_U106 = alphabetised_text_112;
Constant text_U107 = alphabetised_text_180;
Constant text_U108 = alphabetised_text_289;
Constant text_U109 = alphabetised_text_180;
Constant text_U110 = alphabetised_text_237;
Constant text_U111 = alphabetised_text_180;
Constant text_U112 = alphabetised_text_89;
Constant text_U113 = alphabetised_text_180;
Constant text_U114 = alphabetised_text_248;
Constant text_U115 = alphabetised_text_192;
Constant text_U116 = alphabetised_text_5;
Constant text_U117 = alphabetised_text_296;
Constant text_U118 = alphabetised_text_201;
Constant text_U119 = alphabetised_text_165;
Constant text_U120 = alphabetised_text_78;
Constant text_U121 = alphabetised_text_60;
Constant text_U122 = alphabetised_text_77;
Constant text_U123 = alphabetised_text_261;
Constant text_U124 = alphabetised_text_272;
Constant text_U125 = alphabetised_text_271;
Constant text_U126 = alphabetised_text_184;
Constant text_U127 = alphabetised_text_198;
Constant text_U128 = alphabetised_text_207;
Constant text_U129 = alphabetised_text_59;
Constant text_U130 = alphabetised_text_296;
Constant text_U131 = alphabetised_text_229;
Constant text_U132 = alphabetised_text_198;
Constant text_U133 = alphabetised_text_230;
Constant text_U134 = alphabetised_text_186;
Constant text_U135 = alphabetised_text_198;
Constant text_U136 = alphabetised_text_185;
Constant text_U137 = alphabetised_text_102;
Constant text_U138 = alphabetised_text_16;
Constant text_U139 = alphabetised_text_210;
Constant text_U140 = alphabetised_text_46;
Constant text_U141 = alphabetised_text_92;
Constant text_U142 = alphabetised_text_51;
Constant text_U143 = alphabetised_text_19;
Constant text_U144 = alphabetised_text_106;
Constant text_U145 = alphabetised_text_49;
Constant text_U146 = alphabetised_text_18;
Constant text_U147 = alphabetised_text_261;
Constant text_U148 = alphabetised_text_305;
Constant text_U149 = alphabetised_text_125;
Constant text_U150 = alphabetised_text_154;
Constant text_U151 = alphabetised_text_262;
Constant text_U152 = alphabetised_text_188;
Constant text_U153 = alphabetised_text_120;
Constant text_U154 = alphabetised_text_225;
Constant text_U155 = alphabetised_text_187;
Constant text_U156 = alphabetised_text_103;
Constant text_U157 = alphabetised_text_190;
Constant text_U158 = alphabetised_text_104;
Constant text_U159 = alphabetised_text_200;
Constant text_U160 = alphabetised_text_107;
Constant text_U161 = alphabetised_text_26;
Constant text_U162 = alphabetised_text_291;
Constant text_U163 = alphabetised_text_121;
Constant text_U164 = alphabetised_text_260;
Constant text_U165 = alphabetised_text_126;
Constant text_U166 = alphabetised_text_99;
Constant text_U167 = alphabetised_text_274;
Constant text_U168 = alphabetised_text_298;
Constant text_U169 = alphabetised_text_139;
Constant text_U170 = alphabetised_text_100;
Constant text_U171 = alphabetised_text_152;
Constant text_U172 = alphabetised_text_198;
Constant text_U173 = alphabetised_text_278;
Constant text_U174 = alphabetised_text_258;
Constant text_U175 = alphabetised_text_148;
Constant text_U176 = alphabetised_text_259;
Constant text_U177 = alphabetised_text_114;
Constant text_U178 = alphabetised_text_285;
Constant text_U179 = alphabetised_text_179;
Constant text_U180 = alphabetised_text_12;
Constant text_U181 = alphabetised_text_223;
Constant text_U182 = alphabetised_text_40;
Constant text_U183 = alphabetised_text_189;
Constant text_U184 = alphabetised_text_17;
Constant text_U185 = alphabetised_text_199;
Constant text_U186 = alphabetised_text_25;
Constant text_U187 = alphabetised_text_255;
Constant text_U188 = alphabetised_text_127;
Constant text_U189 = alphabetised_text_93;
Constant text_U190 = alphabetised_text_164;
Constant text_U191 = alphabetised_text_14;
Constant text_U192 = alphabetised_text_274;
Constant text_U193 = alphabetised_text_61;
Constant text_U194 = alphabetised_text_63;
Constant text_U195 = alphabetised_text_310;
Constant text_U196 = alphabetised_text_287;
Constant text_U197 = alphabetised_text_135;
Constant text_U198 = alphabetised_text_95;
Constant text_U199 = alphabetised_text_123;
Constant text_U200 = alphabetised_text_226;
Constant text_U201 = alphabetised_text_151;
Constant text_U202 = alphabetised_text_296;
Constant text_U203 = alphabetised_text_86;
Constant text_U204 = alphabetised_text_105;
Constant text_U205 = alphabetised_text_85;
Constant text_U206 = alphabetised_text_150;
Constant text_U207 = alphabetised_text_261;
Constant text_U208 = alphabetised_text_48;
Constant text_U209 = alphabetised_text_4;
Constant text_U210 = alphabetised_text_307;
Constant text_U211 = alphabetised_text_97;
Constant text_U212 = alphabetised_text_311;
Constant text_U213 = alphabetised_text_296;
Constant text_U214 = alphabetised_text_177;
Constant text_U215 = alphabetised_text_141;
Constant text_U216 = alphabetised_text_196;
Constant text_U217 = alphabetised_text_41;
Constant text_U218 = alphabetised_text_228;
Constant text_U219 = alphabetised_text_10;
Constant text_U220 = alphabetised_text_296;
Constant text_U221 = alphabetised_text_205;
Constant text_U222 = alphabetised_text_142;
Constant text_U223 = alphabetised_text_196;
Constant text_U224 = alphabetised_text_96;
Constant text_U225 = alphabetised_text_279;
Constant text_U226 = alphabetised_text_11;
Constant text_U227 = alphabetised_text_198;
Constant text_U228 = alphabetised_text_221;
Constant text_U229 = alphabetised_text_143;
Constant text_U230 = alphabetised_text_196;
Constant text_U231 = alphabetised_text_30;
Constant text_U232 = alphabetised_text_246;
Constant text_U233 = alphabetised_text_6;
Constant text_U234 = alphabetised_text_296;
Constant text_U235 = alphabetised_text_234;
Constant text_U236 = alphabetised_text_144;
Constant text_U237 = alphabetised_text_196;
Constant text_U238 = alphabetised_text_45;
Constant text_U239 = alphabetised_text_118;
Constant text_U240 = alphabetised_text_238;
Constant text_U241 = alphabetised_text_9;
Constant text_U242 = alphabetised_text_296;
Constant text_U243 = alphabetised_text_243;
Constant text_U244 = alphabetised_text_145;
Constant text_U245 = alphabetised_text_196;
Constant text_U246 = alphabetised_text_87;
Constant text_U247 = alphabetised_text_263;
Constant text_U248 = alphabetised_text_124;
Constant text_U249 = alphabetised_text_198;
Constant text_U250 = alphabetised_text_252;
Constant text_U251 = alphabetised_text_146;
Constant text_U252 = alphabetised_text_196;
Constant text_U253 = alphabetised_text_29;
Constant text_U254 = alphabetised_text_153;
Constant text_U255 = alphabetised_text_215;
Constant text_U256 = alphabetised_text_181;
Constant text_U257 = alphabetised_text_275;
Constant text_U258 = alphabetised_text_198;
Constant text_U259 = alphabetised_text_66;
Constant text_U260 = alphabetised_text_113;
Constant text_U261 = alphabetised_text_208;
Constant text_U262 = alphabetised_text_296;
Constant text_U263 = alphabetised_text_214;
Constant text_U264 = alphabetised_text_198;
Constant text_U265 = alphabetised_text_280;
Constant text_U266 = alphabetised_text_209;
Constant text_U267 = alphabetised_text_284;
Constant text_U268 = alphabetised_text_134;
Constant text_U269 = alphabetised_text_295;
Constant text_U270 = alphabetised_text_133;
Constant text_U271 = alphabetised_text_182;
Constant text_U272 = alphabetised_text_171;
Constant text_U273 = alphabetised_text_270;
Constant text_U274 = alphabetised_text_131;
Constant text_U275 = alphabetised_text_176;
Constant text_U276 = alphabetised_text_212;
Constant text_U277 = alphabetised_text_288;
Constant text_U278 = alphabetised_text_136;
Constant text_U279 = alphabetised_text_191;
Constant text_U280 = alphabetised_text_236;
Constant text_U281 = alphabetised_text_44;
Constant text_U282 = alphabetised_text_256;
Constant text_U283 = alphabetised_text_65;
Constant text_U284 = alphabetised_text_254;
Constant text_U285 = alphabetised_text_212;
Constant text_U286 = alphabetised_text_28;
Constant text_U287 = alphabetised_text_132;
Constant text_U288 = alphabetised_text_27;
Constant text_U289 = alphabetised_text_108;
Constant text_U290 = alphabetised_text_204;
Constant text_U291 = alphabetised_text_212;
Constant text_U292 = alphabetised_text_67;
Constant text_U293 = alphabetised_text_115;
Constant text_U294 = alphabetised_text_304;
Constant text_U295 = alphabetised_text_198;
Constant text_U296 = alphabetised_text_265;
Constant text_U297 = alphabetised_text_193;
Constant text_U298 = alphabetised_text_277;
Constant text_U299 = alphabetised_text_80;
Constant text_U300 = alphabetised_text_239;
Constant text_U301 = alphabetised_text_220;
Constant text_U302 = alphabetised_text_212;
Constant text_U303 = alphabetised_text_68;
Constant text_U304 = alphabetised_text_122;
Constant text_U305 = alphabetised_text_233;
Constant text_U306 = alphabetised_text_212;
Constant text_U307 = alphabetised_text_42;
Constant text_U308 = alphabetised_text_111;
Constant text_U309 = alphabetised_text_242;
Constant text_U310 = alphabetised_text_212;
Constant text_U311 = alphabetised_text_38;
Constant text_U312 = alphabetised_text_109;
Constant text_U313 = alphabetised_text_32;
Constant text_U314 = alphabetised_text_161;
Constant text_U315 = alphabetised_text_300;
Constant text_U316 = alphabetised_text_198;
Constant text_U317 = alphabetised_text_137;
Constant text_U318 = alphabetised_text_302;
Constant text_U319 = alphabetised_text_290;
Constant text_U320 = alphabetised_text_303;
Constant text_U321 = alphabetised_text_209;
Constant text_U322 = alphabetised_text_301;
Constant text_U323 = alphabetised_text_209;
Constant text_U324 = alphabetised_text_34;
Constant text_U325 = alphabetised_text_158;
Constant text_U326 = alphabetised_text_300;
Constant text_U327 = alphabetised_text_198;
Constant text_U328 = alphabetised_text_302;
Constant text_U329 = alphabetised_text_137;
Constant text_U330 = alphabetised_text_198;
Constant text_U331 = alphabetised_text_303;
Constant text_U332 = alphabetised_text_209;
Constant text_U333 = alphabetised_text_301;
Constant text_U334 = alphabetised_text_209;
Constant text_U335 = alphabetised_text_36;
Constant text_U336 = alphabetised_text_159;
Constant text_U337 = alphabetised_text_300;
Constant text_U338 = alphabetised_text_198;
Constant text_U339 = alphabetised_text_302;
Constant text_U340 = alphabetised_text_138;
Constant text_U341 = alphabetised_text_198;
Constant text_U342 = alphabetised_text_303;
Constant text_U343 = alphabetised_text_209;
Constant text_U344 = alphabetised_text_301;
Constant text_U345 = alphabetised_text_209;
Constant text_U346 = alphabetised_text_33;
Constant text_U347 = alphabetised_text_160;
Constant text_U348 = alphabetised_text_300;
Constant text_U349 = alphabetised_text_198;
Constant text_U350 = alphabetised_text_302;
Constant text_U351 = alphabetised_text_137;
Constant text_U352 = alphabetised_text_198;
Constant text_U353 = alphabetised_text_303;
Constant text_U354 = alphabetised_text_209;
Constant text_U355 = alphabetised_text_301;
Constant text_U356 = alphabetised_text_209;
Constant text_U357 = alphabetised_text_37;
Constant text_U358 = alphabetised_text_163;
Constant text_U359 = alphabetised_text_300;
Constant text_U360 = alphabetised_text_198;
Constant text_U361 = alphabetised_text_302;
Constant text_U362 = alphabetised_text_137;
Constant text_U363 = alphabetised_text_198;
Constant text_U364 = alphabetised_text_303;
Constant text_U365 = alphabetised_text_209;
Constant text_U366 = alphabetised_text_301;
Constant text_U367 = alphabetised_text_209;
Constant text_U368 = alphabetised_text_35;
Constant text_U369 = alphabetised_text_162;
Constant text_U370 = alphabetised_text_300;
Constant text_U371 = alphabetised_text_198;
Constant text_U372 = alphabetised_text_302;
Constant text_U373 = alphabetised_text_137;
Constant text_U374 = alphabetised_text_198;
Constant text_U375 = alphabetised_text_303;
Constant text_U376 = alphabetised_text_209;
Constant text_U377 = alphabetised_text_301;
Constant text_U378 = alphabetised_text_209;
Constant text_U379 = alphabetised_text_98;
Constant text_U380 = alphabetised_text_251;
Constant text_U381 = alphabetised_text_212;
Constant text_U382 = alphabetised_text_22;
Constant text_U383 = alphabetised_text_101;
Constant text_U384 = alphabetised_text_21;
Constant text_U385 = alphabetised_text_296;
Constant text_U386 = alphabetised_text_178;
Constant text_U387 = alphabetised_text_197;
Constant text_U388 = alphabetised_text_206;
Constant text_U389 = alphabetised_text_197;
Constant text_U390 = alphabetised_text_222;
Constant text_U391 = alphabetised_text_197;
Constant text_U392 = alphabetised_text_235;
Constant text_U393 = alphabetised_text_197;
Constant text_U394 = alphabetised_text_244;
Constant text_U395 = alphabetised_text_197;
Constant text_U396 = alphabetised_text_253;
Constant text_U397 = alphabetised_text_197;
Constant text_U398 = alphabetised_text_174;
Constant text_U399 = alphabetised_text_140;
Constant text_U400 = alphabetised_text_194;
Constant text_U401 = alphabetised_text_202;
Constant text_U402 = alphabetised_text_128;
Constant text_U403 = alphabetised_text_194;
Constant text_U404 = alphabetised_text_218;
Constant text_U405 = alphabetised_text_147;
Constant text_U406 = alphabetised_text_194;
Constant text_U407 = alphabetised_text_231;
Constant text_U408 = alphabetised_text_129;
Constant text_U409 = alphabetised_text_194;
Constant text_U410 = alphabetised_text_240;
Constant text_U411 = alphabetised_text_149;
Constant text_U412 = alphabetised_text_194;
Constant text_U413 = alphabetised_text_249;
Constant text_U414 = alphabetised_text_130;
Constant text_U415 = alphabetised_text_194;
Constant text_U416 = alphabetised_text_264;
Constant text_U417 = alphabetised_text_175;
Constant text_U418 = alphabetised_text_195;
Constant text_U419 = alphabetised_text_203;
Constant text_U420 = alphabetised_text_195;
Constant text_U421 = alphabetised_text_219;
Constant text_U422 = alphabetised_text_195;
Constant text_U423 = alphabetised_text_232;
Constant text_U424 = alphabetised_text_195;
Constant text_U425 = alphabetised_text_241;
Constant text_U426 = alphabetised_text_195;
Constant text_U427 = alphabetised_text_250;
Constant text_U428 = alphabetised_text_195;
Constant text_U429 = alphabetised_text_52;
Constant text_U430 = alphabetised_text_55;
Constant text_U431 = alphabetised_text_69;
Constant text_U432 = alphabetised_text_281;
Constant text_U433 = alphabetised_text_50;
Constant text_U434 = alphabetised_text_281;
Constant text_U435 = alphabetised_text_13;
Constant text_U436 = alphabetised_text_281;
Constant text_U437 = alphabetised_text_91;
Constant text_U438 = alphabetised_text_281;
Constant abilities_U5 = (RELS_TEST);
Constant abilities_U6 = (RELS_TEST);
Constant abilities_U8 = (RELS_TEST);
Constant abilities_U9 = (RELS_TEST);
Constant V38_showing_action = activity_id_U38;
Constant text_U439 = alphabetised_text_225;
Constant text_U440 = alphabetised_text_217;
Constant K22_switch_First = nothing;
Constant text_U441 = alphabetised_text_303;
Constant text_U442 = alphabetised_text_297;
Constant text_U443 = alphabetised_text_302;
Constant text_U444 = alphabetised_text_290;
Constant text_U445 = alphabetised_text_196;
Constant text_U446 = alphabetised_text_197;
Constant text_U447 = alphabetised_text_194;
Constant text_U448 = alphabetised_text_195;
Constant text_U449 = alphabetised_text_166;
Constant text_U450 = alphabetised_text_169;
Constant text_U451 = alphabetised_text_167;
Constant text_U452 = alphabetised_text_168;
Constant column_identity_U45 = table_column_id_U19;
Constant text_U453 = alphabetised_text_8;
Constant text_U454 = alphabetised_text_62;
Constant text_U455 = alphabetised_text_116;
Constant text_U456 = alphabetised_text_64;
Constant text_U457 = alphabetised_text_117;
Constant column_identity_U46 = table_column_id_U19;
Constant text_U458 = alphabetised_text_47;
Constant text_U459 = alphabetised_text_119;
Constant text_U460 = alphabetised_text_72;
Constant GPR_REPARSE = REPARSE_CODE;
Constant TABLE_NOVALUE = IMPROBABLE_VALUE;
Constant RC_INFINITY = MAX_POSITIVE_NUMBER;
Constant RRVAL_V_TO_O = RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V = RELS_X_UNIQUE;
Constant RRVAL_SYM_V_TO_V = RELS_SYMMETRIC;
Constant NUMBER_SCENES_CREATED = ICOUNT_SCENE;
Constant ActionCount = CCOUNT_ACTION_NAME;
Constant NUM_DOORS = ICOUNT_DOOR;
Constant NUM_ROOMS = ICOUNT_ROOM;
Constant Computed_Constant_Value_2_U1 = (Computed_Constant_Value_0_U1 + Computed_Constant_Value_1_U1);
Constant Computed_Constant_Value_1_U2 = (GPR_NOUN + Computed_Constant_Value_0_U2);
Constant Computed_Constant_Value_3_U1 = (GPR_NOUN + Computed_Constant_Value_2_U2);
Constant Computed_Constant_Value_5_U1 = (GPR_NOUN + Computed_Constant_Value_4_U1);
Constant Computed_Constant_Value_7_U1 = (GPR_NOUN + Computed_Constant_Value_6_U1);
Constant Computed_Constant_Value_9_U1 = (GPR_NOUN + Computed_Constant_Value_8_U1);
Constant Computed_Constant_Value_11_U1 = (GPR_NOUN + Computed_Constant_Value_10_U1);
Constant Computed_Constant_Value_13_U1 = (DynamicMemoryAllocation / Computed_Constant_Value_12_U1);
Constant Computed_Constant_Value_17_U1 = (Computed_Constant_Value_16_U1 + MAX_FRAME_SIZE_NEEDED);
Constant Computed_Constant_Value_20_U1 = (Computed_Constant_Value_19_U1 * WORDSIZE);
Constant Computed_Constant_Value_22_U1 = (Computed_Constant_Value_21_U1 * WORDSIZE);
Constant Computed_Constant_Value_25_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_28_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_32_U1 = (BLK_BVBITMAP_TEXT + Computed_Constant_Value_31_U1);
Constant Computed_Constant_Value_33_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK);
Constant Computed_Constant_Value_36_U1 = (BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT);
Constant Computed_Constant_Value_40_U1 = (WORDSIZE * RE_PACKET_SIZE);
Constant Computed_Constant_Value_43_U1 = (RR_NAME - Computed_Constant_Value_42_U1);
Constant Computed_Constant_Value_45_U1 = (RR_PERMISSIONS - Computed_Constant_Value_44_U1);
Constant Computed_Constant_Value_47_U1 = (RR_STORAGE - Computed_Constant_Value_46_U1);
Constant Computed_Constant_Value_49_U1 = (RR_KIND - Computed_Constant_Value_48_U1);
Constant Computed_Constant_Value_51_U1 = (RR_HANDLER - Computed_Constant_Value_50_U1);
Constant Computed_Constant_Value_53_U1 = (RR_DESCRIPTION - Computed_Constant_Value_52_U1);
Constant Computed_Constant_Value_54_U1 = (RELS_X_UNIQUE + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_55_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_56_U1 = (RELS_SYMMETRIC + RELS_X_UNIQUE);
Constant Computed_Constant_Value_58_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_62_U1 = (ICOUNT_OBJECT + Computed_Constant_Value_61_U1);
Constant Computed_Constant_Value_15_U1 = (GG_ANYTOSTRING_LEN + Computed_Constant_Value_14_U1);
Constant Computed_Constant_Value_41_U1 = (RE_MAX_PACKETS * RE_PACKET_SIZE);
Constant Computed_Constant_Value_3_U2 = (Computed_Constant_Value_2_U3 * ICOUNT_OBJECT);
Constant Computed_Constant_Value_5_U2 = (ICOUNT_FIGURE_NAME + ICOUNT_SOUND_NAME);
Constant Computed_Constant_Value_12_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_11_U2);
Constant Computed_Constant_Value_14_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_13_U2);
Constant Computed_Constant_Value_16_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_15_U2);
Constant Computed_Constant_Value_18_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_17_U2);
Constant Computed_Constant_Value_20_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_19_U2);
Constant Computed_Constant_Value_22_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_21_U2);
Constant Computed_Constant_Value_1_U4 = (MATCH_LIST_WORDS + Computed_Constant_Value_0_U4);
Constant TEXT_TY_BufferSize = Computed_Constant_Value_2_U1;
Constant GPR_HELD = Computed_Constant_Value_1_U2;
Constant GPR_MULTI = Computed_Constant_Value_3_U1;
Constant GPR_MULTIHELD = Computed_Constant_Value_5_U1;
Constant GPR_MULTIEXCEPT = Computed_Constant_Value_7_U1;
Constant GPR_MULTIINSIDE = Computed_Constant_Value_9_U1;
Constant GPR_CREATURE = Computed_Constant_Value_11_U1;
Constant BLOCKV_STACK_SIZE = Computed_Constant_Value_13_U1;
Constant MAX_MSTACK_FRAME = Computed_Constant_Value_17_U1;
Constant BLK_DATA_OFFSET = Computed_Constant_Value_20_U1;
Constant PACKED_TEXT_STORAGE = Computed_Constant_Value_32_U1;
Constant TEXT_TY_Storage_Flags = Computed_Constant_Value_36_U1;
Constant RE_PACKET_SIZE_IN_BYTES = Computed_Constant_Value_40_U1;
Constant RRV_NAME = Computed_Constant_Value_43_U1;
Constant RRV_PERMISSIONS = Computed_Constant_Value_45_U1;
Constant RRV_STORAGE = Computed_Constant_Value_47_U1;
Constant RRV_KIND = Computed_Constant_Value_49_U1;
Constant RRV_HANDLER = Computed_Constant_Value_51_U1;
Constant RRV_DESCRIPTION = Computed_Constant_Value_53_U1;
Constant RRVAL_O_TO_O = Computed_Constant_Value_54_U1;
Constant RRVAL_EQUIV = Computed_Constant_Value_55_U1;
Constant MAX_ROUTE_LENGTH = Computed_Constant_Value_62_U1;
Constant Computed_Constant_Value_1_U3 = (NUMBER_SCENES_CREATED + Computed_Constant_Value_0_U3);
Constant REQUISITION_STACK_SIZE = Computed_Constant_Value_3_U2;
Constant Computed_Constant_Value_9_U2 = (NUM_DOORS + Computed_Constant_Value_8_U2);
Constant strong_id_U4 = DK2_activity_on_objects;
Constant strong_id_U5 = DK3_phrase_real_number____re;
Constant strong_id_U6 = DK4_phrase_real_number____nu;
Constant SCENE_ARRAY_SIZE = Computed_Constant_Value_1_U3;
Constant Computed_Constant_Value_10_U2 = (NUM_ROOMS * NUM_ROOMS);
Constant Computed_Constant_Value_27_U1 = (Computed_Constant_Value_25_U1 + Computed_Constant_Value_26_U1);
Constant Computed_Constant_Value_30_U1 = (Computed_Constant_Value_28_U1 + Computed_Constant_Value_29_U1);
Constant Computed_Constant_Value_35_U1 = (Computed_Constant_Value_33_U1 + Computed_Constant_Value_34_U1);
Constant Computed_Constant_Value_57_U1 = (Computed_Constant_Value_56_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_59_U1 = (Computed_Constant_Value_58_U1 + RELS_X_UNIQUE);
Constant Computed_Constant_Value_7_U2 = (Computed_Constant_Value_5_U2 + Computed_Constant_Value_6_U2);
Constant strong_id_U1 = DK10_relation_of_rooms_to_doo;
Constant strong_id_U2 = DK11_relation_of_passkeys_to_;
Constant strong_id_U3 = DK1_rule;
Constant strong_id_U7 = DK5_relation_of_values;
Constant strong_id_U8 = DK6_relation_of_objects;
Constant strong_id_U9 = DK7_relation_of_supporters_t;
Constant strong_id_U10 = DK8_relation_of_things;
Constant strong_id_U11 = DK9_relation_of_people_to_th;
Constant Computed_Constant_Value_18_U1 = (MSTACK_CAPACITY * MAX_MSTACK_FRAME);
Constant CONSTANT_PACKED_TEXT_STORAGE = Computed_Constant_Value_27_U1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = Computed_Constant_Value_30_U1;
Constant UNPACKED_TEXT_STORAGE = Computed_Constant_Value_35_U1;
Constant RRVAL_SYM_O_TO_O = Computed_Constant_Value_57_U1;
Constant Computed_Constant_Value_38_U1 = (TEXT_TY_BufferSize + Computed_Constant_Value_37_U1);
Constant MSTACK_SIZE = Computed_Constant_Value_18_U1;
Constant abilities_U13 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U17 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U18 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U19 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U20 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant Computed_Constant_Value_60_U1 = (Computed_Constant_Value_59_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_23_U1 = (BLK_DATA_OFFSET + Computed_Constant_Value_22_U1);
Constant VALENCY_MASK = Computed_Constant_Value_60_U1;
Constant Computed_Constant_Value_39_U1 = (Computed_Constant_Value_38_U1 * TEXT_TY_NoBuffers);
Constant BLK_DATA_MULTI_OFFSET = Computed_Constant_Value_23_U1;
Constant Story = bc_U1188;
Constant Headline = bc_U1189;
Constant Story_Author = bc_U1190;
Constant Computed_Constant_Value_24_U1 = (MEMORY_HEAP_SIZE + BLK_DATA_MULTI_OFFSET);
Constant abilities_U7 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U10 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U11 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U12 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U14 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U15 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U16 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U1 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U2 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U3 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U4 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_Y_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant MEANINGLESS_RR = Rel_Record20;
Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;
Array A_absent --> [ 2; subterfuge_1; 1; "absent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_animate --> [ 2; subterfuge_2; 1; "animate"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_clothing --> [ 2; subterfuge_3; 1; "wearable"; K2_thing; NULL; ];
Array A_concealed --> [ 2; subterfuge_4; 1; "undescribed"; K2_thing; NULL; ];
Array A_container --> [ 2; subterfuge_5; 1; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door --> [ 2; subterfuge_6; 1; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_edible --> [ 2; subterfuge_7; 1; "edible"; K2_thing; NULL; ];
Array A_enterable --> [ 2; subterfuge_8; 1; "enterable"; K6_supporter; K5_container; NULL; ];
Array A_light --> [ 2; subterfuge_9; 1; "lighted"; K2_thing; K1_room; NULL; ];
Array A_lockable --> [ 2; subterfuge_10; 1; "lockable"; K4_door; K5_container; NULL; ];
Array A_locked --> [ 2; subterfuge_11; 1; "locked"; K4_door; K5_container; NULL; ];
Array A_moved --> [ 2; subterfuge_12; 1; "handled"; K2_thing; NULL; ];
Array A_on --> [ 2; subterfuge_13; 1; "switched on"; K13_device; NULL; ];
Array A_open --> [ 2; subterfuge_14; 1; "open"; K4_door; K5_container; NULL; ];
Array A_openable --> [ 2; subterfuge_15; 1; "openable"; K4_door; K5_container; NULL; ];
Array A_scenery --> [ 2; subterfuge_16; 1; "scenery"; K2_thing; K3_direction; NULL; ];
Array A_static --> [ 2; subterfuge_17; 1; "fixed in place"; K2_thing; NULL; ];
Array A_supporter --> [ 2; subterfuge_18; 1; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_switchable --> [ 2; subterfuge_19; 1; "switchable"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_talkable --> [ 2; subterfuge_20; 1; "<nameless>"; NULL; ];
Array A_transparent --> [ 2; subterfuge_21; 1; "transparent"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_visited --> [ 2; subterfuge_22; 1; "visited"; K1_room; NULL; ];
Array A_worn --> [ 2; subterfuge_23; 1; "<nameless>"; NULL; ];
Array A_male --> [ 2; subterfuge_24; 1; "<nameless>"; NULL; ];
Array A_female --> [ 2; subterfuge_25; 1; "female"; K8_person; NULL; ];
Array A_neuter --> [ 2; subterfuge_26; 1; "neuter"; K8_person; NULL; ];
Array A_pluralname --> [ 2; subterfuge_27; 1; "plural-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_ambigpluralname --> [ 2; subterfuge_28; 1; "ambiguously plural"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_proper --> [ 2; subterfuge_29; 1; "proper-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_remove_proper --> [ 2; subterfuge_30; 1; "<nameless>"; NULL; ];
Array A_privately_named --> [ 2; subterfuge_31; 1; "privately-named"; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mentioned --> [ 2; subterfuge_32; 1; "mentioned"; K2_thing; NULL; ];
Array A_pushable --> [ 2; subterfuge_33; 1; "pushable between rooms"; K2_thing; NULL; ];
Array A_mark_as_room --> [ 2; subterfuge_34; 1; "mark_as_room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mark_as_thing --> [ 2; subterfuge_35; 1; "mark_as_thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_workflag --> [ 2; subterfuge_36; 1; "marked for listing"; K2_thing; K3_direction; NULL; ];
Array A_workflag2 --> [ 2; subterfuge_37; 1; "<nameless>"; NULL; ];
Array A_add_to_scope --> [ 1; subterfuge_38; 0; "<nameless>"; NULL; ];
Array A_article --> [ 1; subterfuge_39; 0; "indefinite article"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_capacity --> [ 1; subterfuge_40; 0; "carrying capacity"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_component_child --> [ 1; subterfuge_41; 0; "component_child"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_parent --> [ 1; subterfuge_42; 0; "component_parent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_sibling --> [ 1; subterfuge_43; 0; "component_sibling"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_description --> [ 1; subterfuge_44; 0; "description"; K1_room; K2_thing; NULL; ];
Array A_door_dir --> [ 1; subterfuge_45; 0; "door_dir"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door_to --> [ 1; subterfuge_46; 0; "leading-through destination"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; K4_door; NULL; ];
Array A_found_in --> [ 1; subterfuge_47; 0; "found_in"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_initial --> [ 1; subterfuge_48; 0; "initial appearance"; K2_thing; NULL; ];
Array A_list_together --> [ 1; subterfuge_49; 0; "list grouping key"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_map_region --> [ 1; subterfuge_50; 0; "map region"; K1_room; NULL; ];
Array A_parse_name --> [ 1; subterfuge_51; 0; "parse_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_plural --> [ 1; subterfuge_52; 0; "printed plural name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_regional_found_in --> [ 1; subterfuge_53; 0; "regional_found_in"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_room_index --> [ 1; subterfuge_54; 0; "room_index"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_short_name --> [ 1; subterfuge_55; 0; "printed name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_saved_short_name --> [ 1; subterfuge_56; 0; "saved_short_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_vector --> [ 1; subterfuge_57; 0; "vector"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_with_key --> [ 1; subterfuge_58; 0; "matching key"; K2_thing; K4_door; K5_container; NULL; ];
Array A_KD_Count --> [ 1; subterfuge_59; 0; "KD_Count"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_Count --> [ 1; subterfuge_60; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK2_Count --> [ 1; subterfuge_61; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK4_Count --> [ 1; subterfuge_62; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK5_Count --> [ 1; subterfuge_63; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK6_Count --> [ 1; subterfuge_64; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK8_Count --> [ 1; subterfuge_65; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK3_Count --> [ 1; subterfuge_66; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_link --> [ 1; subterfuge_67; 0; "<nameless>"; NULL; ];
Array A_IK2_link --> [ 1; subterfuge_68; 0; "<nameless>"; NULL; ];
Array A_IK5_link --> [ 1; subterfuge_69; 0; "<nameless>"; NULL; ];
Array A_IK6_link --> [ 1; subterfuge_70; 0; "<nameless>"; NULL; ];
Array A_IK8_link --> [ 1; subterfuge_71; 0; "<nameless>"; NULL; ];
Array A_articles --> [ 1; subterfuge_72; 0; "<nameless>"; NULL; ];
Array A_grammar --> [ 1; subterfuge_73; 0; "<nameless>"; NULL; ];
Array A_inside_description --> [ 1; subterfuge_74; 0; "<nameless>"; NULL; ];
Array A_short_name_indef --> [ 1; subterfuge_75; 0; "<nameless>"; NULL; ];
Array A_cap_short_name --> [ 1; subterfuge_76; 0; "object"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_before --> [ 1; subterfuge_77; 0; "before"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_action_bitmap --> [ 1; subterfuge_78; 0; "action_bitmap"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_name --> [ 1; subterfuge_79; 0; "name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_variable_initial_value --> [ 1; subterfuge_80; 0; "variable initial value"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_specification --> [ 1; subterfuge_81; 0; "specification"; NULL; ];
Array A_P_indefinite_appearance_text --> [ 1; subterfuge_82; 0; "indefinite appearance text"; NULL; ];
Array A_P_adaptive_text_viewpoint --> [ 1; subterfuge_83; 0; "adaptive text viewpoint"; NULL; ];
Array A_P_opposite --> [ 1; subterfuge_84; 0; "opposite"; K3_direction; NULL; ];
Array A_P_recurring --> [ 1; subterfuge_85; 1; "recurring"; NULL; ];
Array A_K1_room_Next --> [ 1; subterfuge_86; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K2_thing_Next --> [ 1; subterfuge_87; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K3_direction_Next --> [ 1; subterfuge_88; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K4_door_Next --> [ 1; subterfuge_89; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K5_container_Next --> [ 1; subterfuge_90; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K6_supporter_Next --> [ 1; subterfuge_91; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK7_Count --> [ 1; subterfuge_92; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K7_backdrop_Next --> [ 1; subterfuge_93; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K8_person_Next --> [ 1; subterfuge_94; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK9_Count --> [ 1; subterfuge_95; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K9_region_Next --> [ 1; subterfuge_96; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK10_Count --> [ 1; subterfuge_97; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K10_man_Next --> [ 1; subterfuge_98; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Count --> [ 1; subterfuge_99; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Next --> [ 1; subterfuge_100; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Count --> [ 1; subterfuge_101; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Next --> [ 1; subterfuge_102; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Count --> [ 1; subterfuge_103; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Next --> [ 1; subterfuge_104; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Count --> [ 1; subterfuge_105; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Next --> [ 1; subterfuge_106; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Count --> [ 1; subterfuge_107; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Next --> [ 1; subterfuge_108; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_passkey_Count --> [ 1; subterfuge_109; 0; "passkey"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_passkey_Next --> [ 1; subterfuge_110; 0; "passkey"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K17_keychain_Count --> [ 1; subterfuge_111; 0; "keychain"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K17_keychain_Next --> [ 1; subterfuge_112; 0; "keychain"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_unbolting_relation_storage --> [ 1; subterfuge_113; 0; "unbolting relation storage"; K2_thing; NULL; ];
Array A_K18_rideable_animal_Count --> [ 1; subterfuge_114; 0; "rideable animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K18_rideable_animal_Next --> [ 1; subterfuge_115; 0; "rideable animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K19_rideable_vehicle_Count --> [ 1; subterfuge_116; 0; "rideable vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K19_rideable_vehicle_Next --> [ 1; subterfuge_117; 0; "rideable vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K20_fluid_container_Count --> [ 1; subterfuge_118; 0; "fluid container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K20_fluid_container_Next --> [ 1; subterfuge_119; 0; "fluid container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K21_electric_lamp_Count --> [ 1; subterfuge_120; 0; "electric lamp"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K21_electric_lamp_Next --> [ 1; subterfuge_121; 0; "electric lamp"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K22_switch_Count --> [ 1; subterfuge_122; 0; "switch"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K22_switch_Next --> [ 1; subterfuge_123; 0; "switch"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K23_socket_Count --> [ 1; subterfuge_124; 0; "socket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K23_socket_Next --> [ 1; subterfuge_125; 0; "socket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K24_colored_fuse_Count --> [ 1; subterfuge_126; 0; "colored fuse"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K24_colored_fuse_Next --> [ 1; subterfuge_127; 0; "colored fuse"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K25_colored_light_Count --> [ 1; subterfuge_128; 0; "colored light"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K25_colored_light_Next --> [ 1; subterfuge_129; 0; "colored light"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K26_colored_button_Count --> [ 1; subterfuge_130; 0; "colored button"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K26_colored_button_Next --> [ 1; subterfuge_131; 0; "colored button"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K27_colored_dial_Count --> [ 1; subterfuge_132; 0; "colored dial"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K27_colored_dial_Next --> [ 1; subterfuge_133; 0; "colored dial"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_scored --> [ 2; subterfuge_134; 1; "scored"; K1_room; NULL; ];
Array A_P_indoors --> [ 2; subterfuge_135; 1; "indoors"; K1_room; NULL; ];
Array A_P_price --> [ 1; subterfuge_136; 0; "price"; K2_thing; NULL; ];
Array A_P_broken --> [ 2; subterfuge_137; 1; "broken"; K2_thing; NULL; ];
Array A_P_seen --> [ 2; subterfuge_138; 1; "seen"; K2_thing; NULL; ];
Array A_P_fluid_capacity --> [ 1; subterfuge_139; 0; "fluid capacity"; K20_fluid_container; NULL; ];
Array A_P_current_volume --> [ 1; subterfuge_140; 0; "current volume"; K20_fluid_container; NULL; ];
Array A_P_liquid --> [ 1; subterfuge_141; 0; "liquid"; K20_fluid_container; NULL; ];
Array A_P_filled --> [ 2; subterfuge_142; 1; "filled"; K23_socket; I_socket_nine_U1; I_socket_seven_U1; I_socket_five_U1; I_socket_three_U1; I_socket_one_U1; NULL; ];
Array A_P_lost --> [ 2; subterfuge_143; 1; "lost"; K24_colored_fuse; NULL; ];
Array A_P_dial_setting --> [ 1; subterfuge_144; 0; "dial setting"; K27_colored_dial; NULL; ];
Array A_P_underlying_relation_storag --> [ 1; subterfuge_145; 0; "underlying relation storage"; K2_thing; NULL; ];
Array bc_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ActionHappened --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ActionCoding --> [ ##Inv; ##Take; ##Remove; ##Drop; ##PutOn; ##Insert; ##Eat; ##Go; ##Enter; ##Exit; ##GetOff; ##Look; ##Examine; ##LookUnder; ##Search; ##Consult; ##Lock; ##Unlock; ##SwitchOn; ##SwitchOff; ##Open; ##Close; ##Wear; ##Disrobe; ##Give; ##Show; ##WakeOther; ##ThrowAt; ##Attack; ##Kiss; ##Answer; ##Tell; ##Ask; ##AskFor; ##Wait; ##Touch; ##Wave; ##Pull; ##Push; ##Turn; ##PushDir; ##Squeeze; ##Yes; ##No; ##Burn; ##Wake; ##Think; ##Smell; ##Listen; ##Taste; ##Cut; ##Jump; ##Tie; ##Drink; ##Sorry; ##Swing; ##Rub; ##SetTo; ##WaveHands; ##Buy; ##Climb; ##Sleep; ##Quit; ##Save; ##Restore; ##Restart; ##Verify; ##ScriptOn; ##ScriptOff; ##Version; ##Score; ##LMode3; ##LMode2; ##LMode1; ##NotifyOn; ##NotifyOff; ##Pronouns; ##A_unlocking_keylessly; ##A_locking_keylessly; ##A_asking_for_help; ##A_mounting; ##A_dismounting; ##Strong; ##Mild; ##Sing; ##A_pouring_it_into; ##A_hiding_it_under; ##A_hi_speaking; ##A_casting_xyzzy; ##A_hitting; ##A_spinning_it_to; 0; ];
Array ActionData table [ ##Inv; 0; OBJECT_TY; OBJECT_TY; 0; 20000; ##Take; 9; OBJECT_TY; OBJECT_TY; 0; 20001; ##Remove; 27; OBJECT_TY; OBJECT_TY; 0; 20002; ##Drop; 9; OBJECT_TY; OBJECT_TY; 0; 20003; ##PutOn; 27; OBJECT_TY; OBJECT_TY; 0; 20004; ##Insert; 27; OBJECT_TY; OBJECT_TY; 0; 20005; ##Eat; 9; OBJECT_TY; OBJECT_TY; 0; 20006; ##Go; 8; OBJECT_TY; OBJECT_TY; call_U510; 20007; ##Enter; 9; OBJECT_TY; OBJECT_TY; 0; 20008; ##Exit; 0; OBJECT_TY; OBJECT_TY; call_U517; 20009; ##GetOff; 9; OBJECT_TY; OBJECT_TY; 0; 20010; ##Look; 0; OBJECT_TY; OBJECT_TY; call_U524; 20011; ##Examine; 12; OBJECT_TY; OBJECT_TY; call_U528; 20012; ##LookUnder; 12; OBJECT_TY; OBJECT_TY; 0; 20013; ##Search; 13; OBJECT_TY; OBJECT_TY; 0; 20014; ##Consult; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20015; ##Lock; 155; OBJECT_TY; OBJECT_TY; 0; 20016; ##Unlock; 155; OBJECT_TY; OBJECT_TY; 0; 20017; ##SwitchOn; 9; OBJECT_TY; OBJECT_TY; 0; 20018; ##SwitchOff; 9; OBJECT_TY; OBJECT_TY; 0; 20019; ##Open; 9; OBJECT_TY; OBJECT_TY; 0; 20020; ##Close; 9; OBJECT_TY; OBJECT_TY; 0; 20021; ##Wear; 73; OBJECT_TY; OBJECT_TY; 0; 20022; ##Disrobe; 9; OBJECT_TY; OBJECT_TY; 0; 20023; ##Give; 91; OBJECT_TY; OBJECT_TY; 0; 20024; ##Show; 89; OBJECT_TY; OBJECT_TY; 0; 20025; ##WakeOther; 9; OBJECT_TY; OBJECT_TY; 0; 20026; ##ThrowAt; 89; OBJECT_TY; OBJECT_TY; 0; 20027; ##Attack; 9; OBJECT_TY; OBJECT_TY; 0; 20028; ##Kiss; 9; OBJECT_TY; OBJECT_TY; 0; 20029; ##Answer; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20030; ##Tell; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20031; ##Ask; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20032; ##AskFor; 27; OBJECT_TY; OBJECT_TY; 0; 20033; ##Wait; 0; OBJECT_TY; OBJECT_TY; 0; 20034; ##Touch; 9; OBJECT_TY; OBJECT_TY; 0; 20035; ##Wave; 9; OBJECT_TY; OBJECT_TY; 0; 20036; ##Pull; 9; OBJECT_TY; OBJECT_TY; 0; 20037; ##Push; 9; OBJECT_TY; OBJECT_TY; 0; 20038; ##Turn; 9; OBJECT_TY; OBJECT_TY; 0; 20039; ##PushDir; 25; OBJECT_TY; OBJECT_TY; 0; 20040; ##Squeeze; 9; OBJECT_TY; OBJECT_TY; 0; 20041; ##Yes; 0; OBJECT_TY; OBJECT_TY; 0; 20042; ##No; 0; OBJECT_TY; OBJECT_TY; 0; 20043; ##Burn; 9; OBJECT_TY; OBJECT_TY; 0; 20044; ##Wake; 0; OBJECT_TY; OBJECT_TY; 0; 20045; ##Think; 0; OBJECT_TY; OBJECT_TY; 0; 20046; ##Smell; 9; OBJECT_TY; OBJECT_TY; 0; 20047; ##Listen; 9; OBJECT_TY; OBJECT_TY; 0; 20048; ##Taste; 9; OBJECT_TY; OBJECT_TY; 0; 20049; ##Cut; 9; OBJECT_TY; OBJECT_TY; 0; 20050; ##Jump; 0; OBJECT_TY; OBJECT_TY; 0; 20051; ##Tie; 27; OBJECT_TY; OBJECT_TY; 0; 20052; ##Drink; 9; OBJECT_TY; OBJECT_TY; 0; 20053; ##Sorry; 0; OBJECT_TY; OBJECT_TY; 0; 20054; ##Swing; 9; OBJECT_TY; OBJECT_TY; 0; 20055; ##Rub; 9; OBJECT_TY; OBJECT_TY; 0; 20056; ##SetTo; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20057; ##WaveHands; 0; OBJECT_TY; OBJECT_TY; 0; 20058; ##Buy; 9; OBJECT_TY; OBJECT_TY; 0; 20059; ##Climb; 9; OBJECT_TY; OBJECT_TY; 0; 20060; ##Sleep; 0; OBJECT_TY; OBJECT_TY; 0; 20061; ##Quit; 32; OBJECT_TY; OBJECT_TY; 0; 20062; ##Save; 32; OBJECT_TY; OBJECT_TY; 0; 20063; ##Restore; 32; OBJECT_TY; OBJECT_TY; 0; 20064; ##Restart; 32; OBJECT_TY; OBJECT_TY; 0; 20065; ##Verify; 32; OBJECT_TY; OBJECT_TY; 0; 20066; ##ScriptOn; 32; OBJECT_TY; OBJECT_TY; 0; 20067; ##ScriptOff; 32; OBJECT_TY; OBJECT_TY; 0; 20068; ##Version; 32; OBJECT_TY; OBJECT_TY; 0; 20069; ##Score; 32; OBJECT_TY; OBJECT_TY; 0; 20070; ##LMode3; 32; OBJECT_TY; OBJECT_TY; 0; 20071; ##LMode2; 32; OBJECT_TY; OBJECT_TY; 0; 20072; ##LMode1; 32; OBJECT_TY; OBJECT_TY; 0; 20073; ##NotifyOn; 32; OBJECT_TY; OBJECT_TY; 0; 20074; ##NotifyOff; 32; OBJECT_TY; OBJECT_TY; 0; 20075; ##Pronouns; 32; OBJECT_TY; OBJECT_TY; 0; 20076; ##A_unlocking_keylessly; 9; OBJECT_TY; OBJECT_TY; call_U1933; 20077; ##A_locking_keylessly; 9; OBJECT_TY; OBJECT_TY; call_U1937; 20078; ##A_asking_for_help; 32; OBJECT_TY; OBJECT_TY; 0; 20079; ##A_mounting; 9; OBJECT_TY; OBJECT_TY; 0; 20080; ##A_dismounting; 0; OBJECT_TY; OBJECT_TY; 0; 20081; ##Strong; 0; OBJECT_TY; OBJECT_TY; 0; 20082; ##Mild; 0; OBJECT_TY; OBJECT_TY; 0; 20083; ##Sing; 0; OBJECT_TY; OBJECT_TY; 0; 20084; ##A_pouring_it_into; 27; OBJECT_TY; OBJECT_TY; 0; 20085; ##A_hiding_it_under; 91; OBJECT_TY; OBJECT_TY; 0; 20086; ##A_hi_speaking; 8; OBJECT_TY; OBJECT_TY; 0; 20087; ##A_casting_xyzzy; 0; OBJECT_TY; OBJECT_TY; 0; 20088; ##A_hitting; 24; OBJECT_TY; OBJECT_TY; 0; 20089; ##A_spinning_it_to; 25; OBJECT_TY; NUMBER_TY; 0; 20090; 0; ];
Array Activity_after_rulebooks --> [ rulebook_id_U5; rulebook_id_U8; rulebook_id_U11; rulebook_id_U41; rulebook_id_U44; rulebook_id_U47; rulebook_id_U50; rulebook_id_U53; rulebook_id_U56; rulebook_id_U59; rulebook_id_U62; rulebook_id_U65; rulebook_id_U68; rulebook_id_U71; rulebook_id_U74; rulebook_id_U77; rulebook_id_U80; rulebook_id_U83; rulebook_id_U86; rulebook_id_U89; rulebook_id_U92; rulebook_id_U95; rulebook_id_U98; rulebook_id_U101; rulebook_id_U104; rulebook_id_U107; rulebook_id_U110; rulebook_id_U113; rulebook_id_U116; rulebook_id_U119; rulebook_id_U122; rulebook_id_U125; rulebook_id_U128; rulebook_id_U131; rulebook_id_U365; rulebook_id_U374; rulebook_id_U377; rulebook_id_U416; ];
Array Activity_atb_rulebooks -> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 1; 1; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array Activity_before_rulebooks --> [ rulebook_id_U3; rulebook_id_U6; rulebook_id_U9; rulebook_id_U39; rulebook_id_U42; rulebook_id_U45; rulebook_id_U48; rulebook_id_U51; rulebook_id_U54; rulebook_id_U57; rulebook_id_U60; rulebook_id_U63; rulebook_id_U66; rulebook_id_U69; rulebook_id_U72; rulebook_id_U75; rulebook_id_U78; rulebook_id_U81; rulebook_id_U84; rulebook_id_U87; rulebook_id_U90; rulebook_id_U93; rulebook_id_U96; rulebook_id_U99; rulebook_id_U102; rulebook_id_U105; rulebook_id_U108; rulebook_id_U111; rulebook_id_U114; rulebook_id_U117; rulebook_id_U120; rulebook_id_U123; rulebook_id_U126; rulebook_id_U129; rulebook_id_U363; rulebook_id_U372; rulebook_id_U375; rulebook_id_U414; ];
Array Activity_for_rulebooks --> [ rulebook_id_U4; rulebook_id_U7; rulebook_id_U10; rulebook_id_U40; rulebook_id_U43; rulebook_id_U46; rulebook_id_U49; rulebook_id_U52; rulebook_id_U55; rulebook_id_U58; rulebook_id_U61; rulebook_id_U64; rulebook_id_U67; rulebook_id_U70; rulebook_id_U73; rulebook_id_U76; rulebook_id_U79; rulebook_id_U82; rulebook_id_U85; rulebook_id_U88; rulebook_id_U91; rulebook_id_U94; rulebook_id_U97; rulebook_id_U100; rulebook_id_U103; rulebook_id_U106; rulebook_id_U109; rulebook_id_U112; rulebook_id_U115; rulebook_id_U118; rulebook_id_U121; rulebook_id_U124; rulebook_id_U127; rulebook_id_U130; rulebook_id_U364; rulebook_id_U373; rulebook_id_U376; rulebook_id_U415; ];
Array activity_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array TimedEventsTable table [ 0; 0; ];
Array TimedEventTimesTable table [ 0; 0; ];
Array PastActionsI6Routines --> [ PAPR1; PAPR2; PAPR3; PAPR4; 0; 0; ];
Array TableOfVerbs --> [ call_U135; call_U136; call_U137; call_U138; call_U139; call_U140; call_U141; call_U142; call_U143; call_U144; call_U145; call_U146; call_U147; call_U148; call_U149; call_U150; call_U151; call_U152; call_U153; call_U1853; call_U1854; call_U1855; call_U1856; call_U1857; call_U1858; call_U1859; call_U1860; call_U1861; call_U1862; call_U1863; call_U1864; call_U1865; call_U1866; call_U1867; call_U1868; call_U1869; call_U1870; call_U1871; call_U1872; call_U1873; call_U1874; call_U1875; call_U1876; call_U1877; call_U1878; call_U1879; call_U1880; call_U1881; call_U1882; call_U1883; call_U1884; call_U1885; call_U1886; call_U1887; call_U1888; call_U1889; call_U1890; call_U1891; call_U1892; call_U1893; call_U1894; call_U1895; call_U1896; call_U1897; call_U1898; call_U1899; call_U1900; call_U1901; call_U1902; call_U1903; call_U1904; call_U1905; call_U1906; call_U1907; call_U1908; call_U1909; call_U1910; call_U1911; call_U1912; call_U1913; call_U1914; call_U1915; call_U1916; call_U1917; call_U1918; call_U1919; call_U1920; call_U1921; call_U1922; call_U1923; call_U206; call_U207; call_U208; call_U209; call_U210; call_U211; call_U2003; call_U2004; call_U2112; call_U2113; call_U2561; call_U2562; call_U2563; call_U2564; call_U2565; call_U2566; call_U2567; 0; ];
Array KindHierarchy --> [ K0_kind; 0; K1_room; 0; K2_thing; 0; K3_direction; 0; K4_door; 2; K5_container; 2; K6_supporter; 2; K7_backdrop; 2; K8_person; 2; K9_region; 0; K10_man; 8; K11_woman; 8; K12_animal; 8; K13_device; 2; K14_vehicle; 5; K15_player_s_holdall; 5; K16_passkey; 2; K17_keychain; 6; K18_rideable_animal; 12; K19_rideable_vehicle; 6; K20_fluid_container; 5; K21_electric_lamp; 13; K22_switch; 13; K23_socket; 5; K24_colored_fuse; 2; K25_colored_light; 13; K26_colored_button; 13; K27_colored_dial; 13; ];
Array ResourceIDsOfFigures --> [ 0; 1; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 0; ];
Array ResourceIDsOfSounds --> [ 0; 19; 0; ];
Array TableOfExternalFiles --> [ 0; 0; ];
Array RulebookNames --> [ "Startup rulebook"; "Shutdown rulebook"; "before starting the virtual machine rulebook"; "for starting the virtual machine rulebook"; "after starting the virtual machine rulebook"; "before printing the name rulebook"; "for printing the name rulebook"; "after printing the name rulebook"; "before printing the plural name rulebook"; "for printing the plural name rulebook"; "after printing the plural name rulebook"; "Turn sequence rulebook"; "Scene changing rulebook"; "When play begins rulebook"; "When play ends rulebook"; "When scene begins rulebook"; "When scene ends rulebook"; "Every turn rulebook"; "Action-processing rulebook"; "Setting action variables rulebook"; "specific action-processing rulebook"; "player's action awareness rulebook"; "Accessibility rulebook"; "Reaching inside rulebook"; "Reaching outside rulebook"; "Visibility rulebook"; "Persuasion rulebook"; "Unsuccessful attempt by rulebook"; "Before rulebook"; "Instead rulebook"; "Check rulebook"; "Carry out rulebook"; "After rulebook"; "Report rulebook"; "does the player mean rulebook"; "multiple action processing rulebook"; "when Entire Game begins rulebook"; "when Entire Game ends rulebook"; "before issuing the response text rulebook"; "for issuing the response text rulebook"; "after issuing the response text rulebook"; "before printing a number rulebook"; "for printing a number rulebook"; "after printing a number rulebook"; "before printing room description details rulebook"; "for printing room description details rulebook"; "after printing room description details rulebook"; "before printing inventory details rulebook"; "for printing inventory details rulebook"; "after printing inventory details rulebook"; "before listing contents rulebook"; "for listing contents rulebook"; "after listing contents rulebook"; "before grouping together rulebook"; "for grouping together rulebook"; "after grouping together rulebook"; "before writing a paragraph about rulebook"; "for writing a paragraph about rulebook"; "after writing a paragraph about rulebook"; "before listing nondescript items rulebook"; "for listing nondescript items rulebook"; "after listing nondescript items rulebook"; "before printing the name of a dark room rulebook"; "for printing the name of a dark room rulebook"; "after printing the name of a dark room rulebook"; "before printing the description of a dark room rulebook"; "for printing the description of a dark room rulebook"; "after printing the description of a dark room rulebook"; "before printing the announcement of darkness rulebook"; "for printing the announcement of darkness rulebook"; "after printing the announcement of darkness rulebook"; "before printing the announcement of light rulebook"; "for printing the announcement of light rulebook"; "after printing the announcement of light rulebook"; "before printing a refusal to act in the dark rulebook"; "for printing a refusal to act in the dark rulebook"; "after printing a refusal to act in the dark rulebook"; "before constructing the status line rulebook"; "for constructing the status line rulebook"; "after constructing the status line rulebook"; "before printing the banner text rulebook"; "for printing the banner text rulebook"; "after printing the banner text rulebook"; "before reading a command rulebook"; "for reading a command rulebook"; "after reading a command rulebook"; "before deciding the scope rulebook"; "for deciding the scope rulebook"; "after deciding the scope rulebook"; "before deciding the concealed possessions rulebook"; "for deciding the concealed possessions rulebook"; "after deciding the concealed possessions rulebook"; "before deciding whether all includes rulebook"; "for deciding whether all includes rulebook"; "after deciding whether all includes rulebook"; "before clarifying the parser's choice rulebook"; "for clarifying the parser's choice rulebook"; "after clarifying the parser's choice rulebook"; "before asking which do you mean rulebook"; "for asking which do you mean rulebook"; "after asking which do you mean rulebook"; "before printing a parser error rulebook"; "for printing a parser error rulebook"; "after printing a parser error rulebook"; "before supplying a missing noun rulebook"; "for supplying a missing noun rulebook"; "after supplying a missing noun rulebook"; "before supplying a missing second noun rulebook"; "for supplying a missing second noun rulebook"; "after supplying a missing second noun rulebook"; "before implicitly taking rulebook"; "for implicitly taking rulebook"; "after implicitly taking rulebook"; "before amusing a victorious player rulebook"; "for amusing a victorious player rulebook"; "after amusing a victorious player rulebook"; "before printing the player's obituary rulebook"; "for printing the player's obituary rulebook"; "after printing the player's obituary rulebook"; "before handling the final question rulebook"; "for handling the final question rulebook"; "after handling the final question rulebook"; "before printing the locale description rulebook"; "for printing the locale description rulebook"; "after printing the locale description rulebook"; "before choosing notable locale objects rulebook"; "for choosing notable locale objects rulebook"; "after choosing notable locale objects rulebook"; "before printing a locale paragraph about rulebook"; "for printing a locale paragraph about rulebook"; "after printing a locale paragraph about rulebook"; "check taking inventory rulebook"; "carry out taking inventory rulebook"; "report taking inventory rulebook"; "check taking rulebook"; "carry out taking rulebook"; "report taking rulebook"; "check removing it from rulebook"; "carry out removing it from rulebook"; "report removing it from rulebook"; "check dropping rulebook"; "carry out dropping rulebook"; "report dropping rulebook"; "check putting it on rulebook"; "carry out putting it on rulebook"; "report putting it on rulebook"; "check inserting it into rulebook"; "carry out inserting it into rulebook"; "report inserting it into rulebook"; "check eating rulebook"; "carry out eating rulebook"; "report eating rulebook"; "check going rulebook"; "carry out going rulebook"; "report going rulebook"; "check entering rulebook"; "carry out entering rulebook"; "report entering rulebook"; "check exiting rulebook"; "carry out exiting rulebook"; "report exiting rulebook"; "check getting off rulebook"; "carry out getting off rulebook"; "report getting off rulebook"; "check looking rulebook"; "carry out looking rulebook"; "report looking rulebook"; "check examining rulebook"; "carry out examining rulebook"; "report examining rulebook"; "check looking under rulebook"; "carry out looking under rulebook"; "report looking under rulebook"; "check searching rulebook"; "carry out searching rulebook"; "report searching rulebook"; "check consulting it about rulebook"; "carry out consulting it about rulebook"; "report consulting it about rulebook"; "check locking it with rulebook"; "carry out locking it with rulebook"; "report locking it with rulebook"; "check unlocking it with rulebook"; "carry out unlocking it with rulebook"; "report unlocking it with rulebook"; "check switching on rulebook"; "carry out switching on rulebook"; "report switching on rulebook"; "check switching off rulebook"; "carry out switching off rulebook"; "report switching off rulebook"; "check opening rulebook"; "carry out opening rulebook"; "report opening rulebook"; "check closing rulebook"; "carry out closing rulebook"; "report closing rulebook"; "check wearing rulebook"; "carry out wearing rulebook"; "report wearing rulebook"; "check taking off rulebook"; "carry out taking off rulebook"; "report taking off rulebook"; "check giving it to rulebook"; "carry out giving it to rulebook"; "report giving it to rulebook"; "check showing it to rulebook"; "carry out showing it to rulebook"; "report showing it to rulebook"; "check waking rulebook"; "carry out waking rulebook"; "report waking rulebook"; "check throwing it at rulebook"; "carry out throwing it at rulebook"; "report throwing it at rulebook"; "check attacking rulebook"; "carry out attacking rulebook"; "report attacking rulebook"; "check kissing rulebook"; "carry out kissing rulebook"; "report kissing rulebook"; "check answering it that rulebook"; "carry out answering it that rulebook"; "report answering it that rulebook"; "check telling it about rulebook"; "carry out telling it about rulebook"; "report telling it about rulebook"; "check asking it about rulebook"; "carry out asking it about rulebook"; "report asking it about rulebook"; "check asking it for rulebook"; "carry out asking it for rulebook"; "report asking it for rulebook"; "check waiting rulebook"; "carry out waiting rulebook"; "report waiting rulebook"; "check touching rulebook"; "carry out touching rulebook"; "report touching rulebook"; "check waving rulebook"; "carry out waving rulebook"; "report waving rulebook"; "check pulling rulebook"; "carry out pulling rulebook"; "report pulling rulebook"; "check pushing rulebook"; "carry out pushing rulebook"; "report pushing rulebook"; "check turning rulebook"; "carry out turning rulebook"; "report turning rulebook"; "check pushing it to rulebook"; "carry out pushing it to rulebook"; "report pushing it to rulebook"; "check squeezing rulebook"; "carry out squeezing rulebook"; "report squeezing rulebook"; "check saying yes rulebook"; "carry out saying yes rulebook"; "report saying yes rulebook"; "check saying no rulebook"; "carry out saying no rulebook"; "report saying no rulebook"; "check burning rulebook"; "carry out burning rulebook"; "report burning rulebook"; "check waking up rulebook"; "carry out waking up rulebook"; "report waking up rulebook"; "check thinking rulebook"; "carry out thinking rulebook"; "report thinking rulebook"; "check smelling rulebook"; "carry out smelling rulebook"; "report smelling rulebook"; "check listening to rulebook"; "carry out listening to rulebook"; "report listening to rulebook"; "check tasting rulebook"; "carry out tasting rulebook"; "report tasting rulebook"; "check cutting rulebook"; "carry out cutting rulebook"; "report cutting rulebook"; "check jumping rulebook"; "carry out jumping rulebook"; "report jumping rulebook"; "check tying it to rulebook"; "carry out tying it to rulebook"; "report tying it to rulebook"; "check drinking rulebook"; "carry out drinking rulebook"; "report drinking rulebook"; "check saying sorry rulebook"; "carry out saying sorry rulebook"; "report saying sorry rulebook"; "check swinging rulebook"; "carry out swinging rulebook"; "report swinging rulebook"; "check rubbing rulebook"; "carry out rubbing rulebook"; "report rubbing rulebook"; "check setting it to rulebook"; "carry out setting it to rulebook"; "report setting it to rulebook"; "check waving hands rulebook"; "carry out waving hands rulebook"; "report waving hands rulebook"; "check buying rulebook"; "carry out buying rulebook"; "report buying rulebook"; "check climbing rulebook"; "carry out climbing rulebook"; "report climbing rulebook"; "check sleeping rulebook"; "carry out sleeping rulebook"; "report sleeping rulebook"; "check quitting the game rulebook"; "carry out quitting the game rulebook"; "report quitting the game rulebook"; "check saving the game rulebook"; "carry out saving the game rulebook"; "report saving the game rulebook"; "check restoring the game rulebook"; "carry out restoring the game rulebook"; "report restoring the game rulebook"; "check restarting the game rulebook"; "carry out restarting the game rulebook"; "report restarting the game rulebook"; "check verifying the story file rulebook"; "carry out verifying the story file rulebook"; "report verifying the story file rulebook"; "check switching the story transcript on rulebook"; "carry out switching the story transcript on rulebook"; "report switching the story transcript on rulebook"; "check switching the story transcript off rulebook"; "carry out switching the story transcript off rulebook"; "report switching the story transcript off rulebook"; "check requesting the story file version rulebook"; "carry out requesting the story file version rulebook"; "report requesting the story file version rulebook"; "check requesting the score rulebook"; "carry out requesting the score rulebook"; "report requesting the score rulebook"; "check preferring abbreviated room descriptions rulebook"; "carry out preferring abbreviated room descriptions rulebook"; "report preferring abbreviated room descriptions rulebook"; "check preferring unabbreviated room descriptions rulebook"; "carry out preferring unabbreviated room descriptions rulebook"; "report preferring unabbreviated room descriptions rulebook"; "check preferring sometimes abbreviated room descriptions rulebook"; "carry out preferring sometimes abbreviated room descriptions rulebook"; "report preferring sometimes abbreviated room descriptions rulebook"; "check switching score notification on rulebook"; "carry out switching score notification on rulebook"; "report switching score notification on rulebook"; "check switching score notification off rulebook"; "carry out switching score notification off rulebook"; "report switching score notification off rulebook"; "check requesting the pronoun meanings rulebook"; "carry out requesting the pronoun meanings rulebook"; "report requesting the pronoun meanings rulebook"; "before refusing keys rulebook"; "for refusing keys rulebook"; "after refusing keys rulebook"; "check unlocking keylessly rulebook"; "carry out unlocking keylessly rulebook"; "report unlocking keylessly rulebook"; "check locking keylessly rulebook"; "carry out locking keylessly rulebook"; "report locking keylessly rulebook"; "before pausing the game rulebook"; "for pausing the game rulebook"; "after pausing the game rulebook"; "before displaying rulebook"; "for displaying rulebook"; "after displaying rulebook"; "check asking for help rulebook"; "carry out asking for help rulebook"; "report asking for help rulebook"; "check mounting rulebook"; "carry out mounting rulebook"; "report mounting rulebook"; "check dismounting rulebook"; "carry out dismounting rulebook"; "report dismounting rulebook"; "check swearing obscenely rulebook"; "carry out swearing obscenely rulebook"; "report swearing obscenely rulebook"; "check swearing mildly rulebook"; "carry out swearing mildly rulebook"; "report swearing mildly rulebook"; "check singing rulebook"; "carry out singing rulebook"; "report singing rulebook"; "check pouring it into rulebook"; "carry out pouring it into rulebook"; "report pouring it into rulebook"; "check hiding it under rulebook"; "carry out hiding it under rulebook"; "report hiding it under rulebook"; "check hi-speaking rulebook"; "carry out hi-speaking rulebook"; "report hi-speaking rulebook"; "check casting xyzzy rulebook"; "carry out casting xyzzy rulebook"; "report casting xyzzy rulebook"; "check hitting rulebook"; "carry out hitting rulebook"; "report hitting rulebook"; "check spinning it to rulebook"; "carry out spinning it to rulebook"; "report spinning it to rulebook"; "before showing action rulebook"; "for showing action rulebook"; "after showing action rulebook"; "when LittleEgyptAuto begins rulebook"; "when LittleEgyptAuto ends rulebook"; "when HellRideAuto begins rulebook"; "when HellRideAuto ends rulebook"; ];
Array rulebook_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; call_U372; 0; call_U375; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array rulebooks_array --> [ call_U115; call_U116; call_U117; call_U118; call_U119; call_U120; call_U121; call_U122; call_U123; call_U124; call_U125; call_U364; call_U365; call_U366; call_U367; call_U368; call_U369; call_U370; call_U371; call_U373; call_U374; call_U376; call_U377; call_U378; call_U379; call_U380; call_U381; call_U382; call_U383; call_U384; call_U385; call_U386; call_U387; call_U388; call_U389; call_U390; call_U391; call_U392; call_U393; call_U394; call_U395; call_U396; call_U397; call_U398; call_U399; call_U400; call_U401; call_U402; call_U403; call_U404; call_U405; call_U406; call_U407; call_U408; call_U409; call_U410; call_U411; call_U412; call_U413; call_U414; call_U415; call_U416; call_U417; call_U418; call_U419; call_U420; call_U421; call_U422; call_U423; call_U424; call_U425; call_U426; call_U427; call_U428; call_U429; call_U430; call_U431; call_U432; call_U433; call_U434; call_U435; call_U436; call_U437; call_U438; call_U439; call_U440; call_U441; call_U442; call_U443; call_U444; call_U445; call_U446; call_U447; call_U448; call_U449; call_U450; call_U451; call_U452; call_U453; call_U454; call_U455; call_U456; call_U457; call_U458; call_U459; call_U460; call_U461; call_U462; call_U463; call_U464; call_U465; call_U466; call_U467; call_U468; call_U469; call_U470; call_U471; call_U472; call_U473; call_U474; call_U475; call_U476; call_U477; call_U478; call_U479; call_U480; call_U481; call_U482; call_U483; call_U484; call_U485; call_U486; call_U487; call_U488; call_U489; call_U490; call_U491; call_U492; call_U493; call_U494; call_U495; call_U496; call_U497; call_U498; call_U499; call_U500; call_U501; call_U502; call_U503; call_U504; call_U505; call_U506; call_U507; call_U508; call_U509; call_U511; call_U512; call_U513; call_U514; call_U515; call_U516; call_U518; call_U519; call_U520; call_U521; call_U522; call_U523; call_U525; call_U526; call_U527; call_U529; call_U530; call_U531; call_U532; call_U533; call_U534; call_U535; call_U536; call_U537; call_U538; call_U539; call_U540; call_U541; call_U542; call_U543; call_U544; call_U545; call_U546; call_U547; call_U548; call_U549; call_U550; call_U551; call_U552; call_U553; call_U554; call_U555; call_U556; call_U557; call_U558; call_U559; call_U560; call_U561; call_U562; call_U563; call_U564; call_U565; call_U566; call_U567; call_U568; call_U569; call_U570; call_U571; call_U572; call_U573; call_U574; call_U575; call_U576; call_U577; call_U578; call_U579; call_U580; call_U581; call_U582; call_U583; call_U584; call_U585; call_U586; call_U587; call_U588; call_U589; call_U590; call_U591; call_U592; call_U593; call_U594; call_U595; call_U596; call_U597; call_U598; call_U599; call_U600; call_U601; call_U602; call_U603; call_U604; call_U605; call_U606; call_U607; call_U608; call_U609; call_U610; call_U611; call_U612; call_U613; call_U614; call_U615; call_U616; call_U617; call_U618; call_U619; call_U620; call_U621; call_U622; call_U623; call_U624; call_U625; call_U626; call_U627; call_U628; call_U629; call_U630; call_U631; call_U632; call_U633; call_U634; call_U635; call_U636; call_U637; call_U638; call_U639; call_U640; call_U641; call_U642; call_U643; call_U644; call_U645; call_U646; call_U647; call_U648; call_U649; call_U650; call_U651; call_U652; call_U653; call_U654; call_U655; call_U656; call_U657; call_U658; call_U659; call_U660; call_U661; call_U662; call_U663; call_U664; call_U665; call_U666; call_U667; call_U668; call_U669; call_U670; call_U671; call_U672; call_U673; call_U674; call_U675; call_U676; call_U677; call_U678; call_U679; call_U680; call_U681; call_U682; call_U683; call_U684; call_U685; call_U686; call_U687; call_U688; call_U689; call_U690; call_U691; call_U692; call_U693; call_U694; call_U695; call_U696; call_U697; call_U698; call_U699; call_U700; call_U701; call_U702; call_U703; call_U704; call_U705; call_U706; call_U707; call_U708; call_U709; call_U710; call_U711; call_U712; call_U713; call_U714; call_U715; call_U716; call_U717; call_U718; call_U719; call_U720; call_U1927; call_U1928; call_U1929; call_U1930; call_U1931; call_U1932; call_U1934; call_U1935; call_U1936; call_U2005; call_U2006; call_U2007; call_U2015; call_U2016; call_U2017; call_U2032; call_U2033; call_U2034; call_U2057; call_U2058; call_U2059; call_U2060; call_U2061; call_U2062; call_U2114; call_U2115; call_U2116; call_U2117; call_U2118; call_U2119; call_U2122; call_U2123; call_U2124; call_U2266; call_U2267; call_U2268; call_U2269; call_U2270; call_U2271; call_U2272; call_U2273; call_U2274; call_U2275; call_U2276; call_U2277; call_U2278; call_U2279; call_U2280; call_U2281; call_U2282; call_U2283; call_U2304; call_U2305; call_U2306; call_U2307; call_U2308; call_U2309; call_U2310; 0; ];
Array ResponseTexts --> [ ts_array_U1; ts_array_U2; ts_array_U3; ts_array_U4; ts_array_U5; ts_array_U6; ts_array_U7; ts_array_U8; ts_array_U9; ts_array_U10; ts_array_U11; ts_array_U12; ts_array_U13; ts_array_U14; ts_array_U15; ts_array_U16; ts_array_U17; ts_array_U18; ts_array_U19; ts_array_U20; ts_array_U21; ts_array_U22; ts_array_U23; ts_array_U24; ts_array_U25; ts_array_U26; ts_array_U27; ts_array_U28; ts_array_U29; ts_array_U30; ts_array_U31; ts_array_U32; ts_array_U33; ts_array_U34; ts_array_U35; ts_array_U36; ts_array_U37; ts_array_U38; ts_array_U39; ts_array_U40; ts_array_U41; ts_array_U42; ts_array_U43; ts_array_U44; ts_array_U45; ts_array_U46; ts_array_U47; ts_array_U48; ts_array_U49; ts_array_U50; ts_array_U51; ts_array_U52; ts_array_U53; ts_array_U54; ts_array_U55; ts_array_U56; ts_array_U57; ts_array_U58; ts_array_U59; ts_array_U60; ts_array_U61; ts_array_U62; ts_array_U63; ts_array_U64; ts_array_U65; ts_array_U66; ts_array_U67; ts_array_U68; ts_array_U69; ts_array_U70; ts_array_U71; ts_array_U72; ts_array_U73; ts_array_U74; ts_array_U75; ts_array_U76; ts_array_U77; ts_array_U78; ts_array_U79; ts_array_U80; ts_array_U81; ts_array_U82; ts_array_U83; ts_array_U84; ts_array_U85; ts_array_U86; ts_array_U87; ts_array_U88; ts_array_U89; ts_array_U90; ts_array_U91; ts_array_U92; ts_array_U93; ts_array_U94; ts_array_U95; ts_array_U96; ts_array_U97; ts_array_U98; ts_array_U99; ts_array_U100; ts_array_U101; ts_array_U102; ts_array_U103; ts_array_U104; ts_array_U105; ts_array_U106; ts_array_U107; ts_array_U108; ts_array_U109; ts_array_U110; ts_array_U111; ts_array_U112; ts_array_U113; ts_array_U114; ts_array_U115; ts_array_U116; ts_array_U117; ts_array_U118; ts_array_U119; ts_array_U120; ts_array_U121; ts_array_U122; ts_array_U123; ts_array_U124; ts_array_U125; ts_array_U126; ts_array_U127; ts_array_U128; ts_array_U129; ts_array_U130; ts_array_U131; ts_array_U132; ts_array_U133; ts_array_U134; ts_array_U135; ts_array_U136; ts_array_U137; ts_array_U138; ts_array_U139; ts_array_U140; ts_array_U141; ts_array_U142; ts_array_U143; ts_array_U144; ts_array_U145; ts_array_U146; ts_array_U147; ts_array_U148; ts_array_U149; ts_array_U150; ts_array_U151; ts_array_U152; ts_array_U153; ts_array_U154; ts_array_U155; ts_array_U156; ts_array_U157; ts_array_U158; ts_array_U159; ts_array_U160; ts_array_U161; ts_array_U162; ts_array_U163; ts_array_U164; ts_array_U165; ts_array_U166; ts_array_U167; ts_array_U168; ts_array_U169; ts_array_U170; ts_array_U171; ts_array_U172; ts_array_U173; ts_array_U174; ts_array_U175; ts_array_U176; ts_array_U177; ts_array_U178; ts_array_U179; ts_array_U180; ts_array_U181; ts_array_U182; ts_array_U183; ts_array_U184; ts_array_U185; ts_array_U186; ts_array_U187; ts_array_U188; ts_array_U189; ts_array_U190; ts_array_U191; ts_array_U192; ts_array_U193; ts_array_U194; ts_array_U195; ts_array_U196; ts_array_U197; ts_array_U198; ts_array_U199; ts_array_U200; ts_array_U201; ts_array_U202; ts_array_U203; ts_array_U204; ts_array_U205; ts_array_U206; ts_array_U207; ts_array_U208; ts_array_U209; ts_array_U210; ts_array_U211; ts_array_U212; ts_array_U213; ts_array_U214; ts_array_U215; ts_array_U216; ts_array_U217; ts_array_U218; ts_array_U219; ts_array_U220; ts_array_U221; ts_array_U222; ts_array_U223; ts_array_U224; ts_array_U225; ts_array_U226; ts_array_U227; ts_array_U228; ts_array_U229; ts_array_U230; ts_array_U231; ts_array_U232; ts_array_U233; ts_array_U234; ts_array_U235; ts_array_U236; ts_array_U237; ts_array_U238; ts_array_U239; ts_array_U240; ts_array_U241; ts_array_U242; ts_array_U243; ts_array_U244; ts_array_U245; ts_array_U246; ts_array_U247; ts_array_U248; ts_array_U249; ts_array_U250; ts_array_U251; ts_array_U252; ts_array_U253; ts_array_U254; ts_array_U255; ts_array_U256; ts_array_U257; ts_array_U258; ts_array_U259; ts_array_U260; ts_array_U261; ts_array_U262; ts_array_U263; ts_array_U264; ts_array_U265; ts_array_U266; ts_array_U267; ts_array_U268; ts_array_U269; ts_array_U270; ts_array_U271; ts_array_U272; ts_array_U273; ts_array_U274; ts_array_U275; ts_array_U276; ts_array_U277; ts_array_U278; ts_array_U279; ts_array_U280; ts_array_U281; ts_array_U282; ts_array_U283; ts_array_U284; ts_array_U285; ts_array_U286; ts_array_U287; ts_array_U288; ts_array_U289; ts_array_U290; ts_array_U291; ts_array_U292; ts_array_U293; ts_array_U294; ts_array_U295; ts_array_U296; ts_array_U297; ts_array_U298; ts_array_U299; ts_array_U300; ts_array_U301; ts_array_U302; ts_array_U303; ts_array_U304; ts_array_U305; ts_array_U306; ts_array_U307; ts_array_U308; ts_array_U309; ts_array_U310; ts_array_U311; ts_array_U312; ts_array_U313; ts_array_U314; ts_array_U315; ts_array_U316; ts_array_U317; ts_array_U318; ts_array_U319; ts_array_U320; ts_array_U321; ts_array_U322; ts_array_U323; ts_array_U324; ts_array_U325; ts_array_U326; ts_array_U327; ts_array_U328; ts_array_U329; ts_array_U330; ts_array_U331; ts_array_U332; ts_array_U333; ts_array_U334; ts_array_U335; ts_array_U336; ts_array_U337; ts_array_U338; ts_array_U339; ts_array_U340; ts_array_U341; ts_array_U342; ts_array_U343; ts_array_U344; ts_array_U345; ts_array_U346; ts_array_U347; ts_array_U348; ts_array_U349; ts_array_U350; ts_array_U351; ts_array_U352; ts_array_U353; ts_array_U354; ts_array_U355; ts_array_U356; ts_array_U357; ts_array_U358; ts_array_U359; ts_array_U360; ts_array_U361; ts_array_U362; ts_array_U363; ts_array_U364; ts_array_U365; ts_array_U366; ts_array_U367; ts_array_U368; ts_array_U369; ts_array_U370; ts_array_U371; ts_array_U372; ts_array_U373; ts_array_U374; ts_array_U375; ts_array_U376; ts_array_U377; ts_array_U378; ts_array_U379; ts_array_U380; ts_array_U381; ts_array_U382; ts_array_U383; ts_array_U384; ts_array_U385; ts_array_U386; ts_array_U387; ts_array_U388; ts_array_U389; ts_array_U390; ts_array_U391; ts_array_U392; ts_array_U393; ts_array_U394; ts_array_U395; ts_array_U396; ts_array_U397; ts_array_U398; ts_array_U399; ts_array_U400; ts_array_U401; ts_array_U402; ts_array_U403; ts_array_U404; ts_array_U405; ts_array_U406; ts_array_U407; ts_array_U426; ts_array_U427; ts_array_U428; ts_array_U429; ts_array_U430; ts_array_U431; ts_array_U432; ts_array_U433; ts_array_U434; ts_array_U435; ts_array_U436; ts_array_U437; 0; 0; ];
Array ResponseDivisions --> [ "Standard Rules"; 1; 393; "Locksmith by Emily Short"; 394; 406; "Basic Screen Effects by Emily Short"; 407; 407; "Rideable Vehicles by Graham Nelson"; 408; 419; 0; 0; 0; ];
Array TableOfTables --> [ TheEmptyTable; table_data_U1; table_data_U2; table_data_U3; table_data_U4; table_data_U5; table_data_U6; table_data_U7; table_data_U8; table_data_U9; table_data_U10; table_data_U11; table_data_U12; table_data_U13; table_data_U14; table_data_U15; 0; 0; ];
Array TB_Blanks -> [ 0; 0; 0; 4; 27; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 31; 0; 0; 0; 0; 1; 0; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 1; 2; 3; 0; 63; 192; 255; 0; 15; 0; 15; 0; 15; 0; 15; 0; 3; 3; 0; 0; 0; 0; 0; ];
Array closure_data_U1 --> [ DK3_phrase_real_number____re; call_U131; "rsqr function"; ];
Array closure_data_U2 --> [ DK3_phrase_real_number____re; call_U132; "arcsinh function"; ];
Array closure_data_U3 --> [ DK3_phrase_real_number____re; call_U133; "arccosh function"; ];
Array closure_data_U4 --> [ DK3_phrase_real_number____re; call_U134; "arctanh function"; ];
Array closure_data_U5 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Abs; "abs function"; ];
Array closure_data_U6 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Root; "root function"; ];
Array closure_data_U7 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Ceiling; "ceiling function"; ];
Array closure_data_U8 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Floor; "floor function"; ];
Array closure_data_U9 --> [ DK4_phrase_real_number____nu; REAL_NUMBER_TY_to_NUMBER_TY; "int function"; ];
Array closure_data_U10 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Log; "log function"; ];
Array closure_data_U11 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Exp; "exp function"; ];
Array closure_data_U12 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sin; "sin function"; ];
Array closure_data_U13 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cos; "cos function"; ];
Array closure_data_U14 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tan; "tan function"; ];
Array closure_data_U15 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arcsin; "arcsin function"; ];
Array closure_data_U16 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arccos; "arccos function"; ];
Array closure_data_U17 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arctan; "arctan function"; ];
Array closure_data_U18 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sinh; "sinh function"; ];
Array closure_data_U19 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cosh; "cosh function"; ];
Array closure_data_U20 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tanh; "tanh function"; ];
Array inline_U1 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U1; ];
Array bc_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U2; ];
Array bc_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U3; ];
Array bc_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U2 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U4; ];
Array bc_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U5; ];
Array bc_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U6; ];
Array bc_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U3 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U7; ];
Array bc_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U8; ];
Array bc_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U9; ];
Array bc_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U4 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U10; ];
Array bc_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U11; ];
Array bc_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U12; ];
Array bc_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U5 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U13; ];
Array bc_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U14; ];
Array bc_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U15; ];
Array bc_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U6 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U16; ];
Array bc_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U17; ];
Array bc_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U18; ];
Array bc_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U7 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U19; ];
Array bc_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U20; ];
Array bc_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U21; ];
Array bc_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U8 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U22; ];
Array bc_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U23; ];
Array bc_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U24; ];
Array bc_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U9 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U25; ];
Array bc_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U26; ];
Array bc_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U27; ];
Array bc_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U10 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U28; ];
Array bc_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U29; ];
Array bc_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U30; ];
Array bc_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U11 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U31; ];
Array bc_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U32; ];
Array bc_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U33; ];
Array bc_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U12 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U34; ];
Array bc_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U35; ];
Array bc_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U36; ];
Array bc_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U13 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U37; ];
Array bc_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U38; ];
Array bc_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U39; ];
Array bc_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U40; ];
Array bc_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U41; ];
Array bc_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array Rel_Record1 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "leading-through relation"; abilities_U1; A_door_to; DK10_relation_of_rooms_to_doo; call_U359; "Leading-through relates one room ( called the leading-through destination ) to various doors"; ];
Array Rel_Record2 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "lock-fitting relation"; abilities_U2; A_with_key; DK8_relation_of_things; call_U363; "Lock-fitting relates one thing ( called the matching key ) to various things"; ];
Array as_block_constant_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U721; ];
Array ts_array_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U722; ];
Array as_block_constant_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U723; ];
Array ts_array_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U724; ];
Array as_block_constant_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U725; ];
Array ts_array_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U726; ];
Array as_block_constant_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U727; ];
Array ts_array_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U728; ];
Array as_block_constant_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U729; ];
Array ts_array_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U730; ];
Array as_block_constant_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U731; ];
Array ts_array_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U732; ];
Array as_block_constant_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U733; ];
Array ts_array_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U734; ];
Array as_block_constant_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U735; ];
Array ts_array_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U736; ];
Array as_block_constant_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U737; ];
Array ts_array_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U738; ];
Array as_block_constant_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U739; ];
Array ts_array_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U740; ];
Array as_block_constant_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U741; ];
Array ts_array_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U742; ];
Array as_block_constant_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U743; ];
Array ts_array_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U744; ];
Array as_block_constant_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U745; ];
Array ts_array_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U746; ];
Array as_block_constant_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U747; ];
Array ts_array_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U748; ];
Array as_block_constant_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U749; ];
Array ts_array_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U750; ];
Array as_block_constant_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U751; ];
Array ts_array_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U752; ];
Array as_block_constant_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U753; ];
Array ts_array_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U754; ];
Array as_block_constant_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U755; ];
Array ts_array_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U756; ];
Array as_block_constant_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U757; ];
Array ts_array_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U758; ];
Array as_block_constant_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U759; ];
Array ts_array_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U760; ];
Array as_block_constant_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U761; ];
Array ts_array_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U762; ];
Array as_block_constant_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U763; ];
Array ts_array_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U764; ];
Array as_block_constant_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U765; ];
Array ts_array_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U766; ];
Array as_block_constant_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U767; ];
Array ts_array_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U768; ];
Array as_block_constant_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U769; ];
Array ts_array_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U770; ];
Array as_block_constant_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U771; ];
Array ts_array_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U772; ];
Array as_block_constant_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U773; ];
Array ts_array_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U774; ];
Array as_block_constant_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U775; ];
Array ts_array_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U776; ];
Array as_block_constant_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U777; ];
Array ts_array_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U778; ];
Array as_block_constant_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U779; ];
Array ts_array_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U780; ];
Array as_block_constant_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U781; ];
Array ts_array_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U782; ];
Array as_block_constant_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U783; ];
Array ts_array_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U784; ];
Array as_block_constant_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U785; ];
Array ts_array_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U786; ];
Array as_block_constant_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U787; ];
Array ts_array_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U788; ];
Array as_block_constant_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U789; ];
Array ts_array_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U790; ];
Array as_block_constant_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U791; ];
Array ts_array_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U792; ];
Array as_block_constant_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U793; ];
Array ts_array_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U794; ];
Array as_block_constant_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U795; ];
Array ts_array_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U796; ];
Array as_block_constant_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U797; ];
Array ts_array_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U798; ];
Array as_block_constant_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U799; ];
Array ts_array_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U800; ];
Array as_block_constant_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U801; ];
Array ts_array_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U802; ];
Array as_block_constant_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U803; ];
Array ts_array_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U804; ];
Array as_block_constant_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U805; ];
Array ts_array_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U806; ];
Array as_block_constant_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U807; ];
Array ts_array_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U808; ];
Array as_block_constant_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U809; ];
Array ts_array_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U810; ];
Array as_block_constant_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U811; ];
Array ts_array_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U812; ];
Array as_block_constant_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U813; ];
Array ts_array_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U814; ];
Array as_block_constant_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U815; ];
Array ts_array_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U816; ];
Array as_block_constant_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U817; ];
Array ts_array_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U818; ];
Array as_block_constant_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U819; ];
Array ts_array_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U820; ];
Array as_block_constant_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U821; ];
Array ts_array_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U822; ];
Array as_block_constant_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U823; ];
Array ts_array_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U824; ];
Array as_block_constant_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U825; ];
Array ts_array_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U826; ];
Array as_block_constant_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U827; ];
Array ts_array_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U828; ];
Array as_block_constant_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U829; ];
Array ts_array_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U830; ];
Array as_block_constant_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U831; ];
Array ts_array_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U832; ];
Array as_block_constant_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U833; ];
Array ts_array_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U834; ];
Array as_block_constant_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U835; ];
Array ts_array_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U836; ];
Array as_block_constant_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U837; ];
Array ts_array_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U838; ];
Array as_block_constant_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U839; ];
Array ts_array_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U840; ];
Array as_block_constant_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U841; ];
Array ts_array_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U842; ];
Array as_block_constant_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U843; ];
Array ts_array_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U844; ];
Array as_block_constant_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U845; ];
Array ts_array_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U846; ];
Array as_block_constant_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U847; ];
Array ts_array_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U848; ];
Array as_block_constant_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U849; ];
Array ts_array_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U850; ];
Array as_block_constant_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U851; ];
Array ts_array_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U852; ];
Array as_block_constant_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U853; ];
Array ts_array_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U854; ];
Array as_block_constant_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U855; ];
Array ts_array_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U856; ];
Array as_block_constant_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U857; ];
Array ts_array_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U858; ];
Array as_block_constant_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U859; ];
Array ts_array_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U860; ];
Array as_block_constant_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U861; ];
Array ts_array_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U862; ];
Array as_block_constant_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U863; ];
Array ts_array_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U864; ];
Array as_block_constant_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U865; ];
Array ts_array_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U866; ];
Array as_block_constant_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U867; ];
Array ts_array_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U868; ];
Array as_block_constant_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U869; ];
Array ts_array_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U870; ];
Array as_block_constant_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U871; ];
Array ts_array_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U872; ];
Array as_block_constant_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U873; ];
Array ts_array_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U874; ];
Array as_block_constant_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U875; ];
Array ts_array_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U876; ];
Array as_block_constant_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U877; ];
Array ts_array_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U878; ];
Array as_block_constant_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U879; ];
Array ts_array_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U880; ];
Array as_block_constant_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U881; ];
Array ts_array_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U882; ];
Array as_block_constant_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U883; ];
Array ts_array_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U884; ];
Array as_block_constant_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U885; ];
Array ts_array_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U886; ];
Array as_block_constant_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U887; ];
Array ts_array_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U888; ];
Array as_block_constant_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U889; ];
Array ts_array_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U890; ];
Array as_block_constant_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U891; ];
Array ts_array_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U892; ];
Array as_block_constant_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U893; ];
Array ts_array_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U894; ];
Array as_block_constant_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U895; ];
Array ts_array_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U896; ];
Array as_block_constant_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U897; ];
Array ts_array_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U898; ];
Array as_block_constant_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U899; ];
Array ts_array_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U900; ];
Array as_block_constant_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U901; ];
Array ts_array_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U902; ];
Array as_block_constant_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U903; ];
Array ts_array_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U904; ];
Array as_block_constant_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U905; ];
Array ts_array_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U906; ];
Array as_block_constant_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U907; ];
Array ts_array_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U908; ];
Array as_block_constant_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U909; ];
Array ts_array_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U910; ];
Array as_block_constant_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U911; ];
Array ts_array_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U912; ];
Array as_block_constant_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U913; ];
Array ts_array_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U914; ];
Array as_block_constant_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U915; ];
Array ts_array_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U916; ];
Array as_block_constant_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U917; ];
Array ts_array_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U918; ];
Array as_block_constant_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U919; ];
Array ts_array_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U920; ];
Array as_block_constant_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U921; ];
Array ts_array_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U922; ];
Array as_block_constant_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U923; ];
Array ts_array_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U924; ];
Array as_block_constant_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U925; ];
Array ts_array_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U926; ];
Array as_block_constant_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U927; ];
Array ts_array_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U928; ];
Array as_block_constant_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U929; ];
Array ts_array_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U930; ];
Array as_block_constant_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U931; ];
Array ts_array_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U932; ];
Array as_block_constant_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U933; ];
Array ts_array_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U934; ];
Array as_block_constant_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U935; ];
Array ts_array_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U936; ];
Array as_block_constant_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U937; ];
Array ts_array_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U938; ];
Array as_block_constant_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U939; ];
Array ts_array_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U940; ];
Array as_block_constant_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U941; ];
Array ts_array_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U942; ];
Array as_block_constant_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U943; ];
Array ts_array_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U944; ];
Array as_block_constant_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U945; ];
Array ts_array_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U946; ];
Array as_block_constant_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U947; ];
Array ts_array_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U948; ];
Array as_block_constant_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U949; ];
Array ts_array_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U950; ];
Array as_block_constant_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U951; ];
Array ts_array_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U952; ];
Array as_block_constant_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U953; ];
Array ts_array_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U954; ];
Array as_block_constant_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U955; ];
Array ts_array_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U956; ];
Array as_block_constant_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U957; ];
Array ts_array_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U958; ];
Array as_block_constant_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U959; ];
Array ts_array_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U960; ];
Array as_block_constant_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U961; ];
Array ts_array_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U962; ];
Array as_block_constant_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U963; ];
Array ts_array_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U964; ];
Array as_block_constant_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U965; ];
Array ts_array_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U966; ];
Array as_block_constant_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U967; ];
Array ts_array_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U968; ];
Array as_block_constant_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U969; ];
Array ts_array_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U970; ];
Array as_block_constant_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U971; ];
Array ts_array_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U972; ];
Array as_block_constant_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U973; ];
Array ts_array_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U974; ];
Array as_block_constant_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U975; ];
Array ts_array_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U976; ];
Array as_block_constant_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U977; ];
Array ts_array_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U978; ];
Array as_block_constant_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U979; ];
Array ts_array_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U980; ];
Array as_block_constant_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U981; ];
Array ts_array_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U982; ];
Array as_block_constant_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U983; ];
Array ts_array_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U984; ];
Array as_block_constant_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U985; ];
Array ts_array_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U986; ];
Array as_block_constant_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U987; ];
Array ts_array_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U988; ];
Array as_block_constant_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1004; ];
Array ts_array_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1005; ];
Array bc_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1034; ];
Array ts_array_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1035; ];
Array as_block_constant_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1037; ];
Array ts_array_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1038; ];
Array as_block_constant_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1040; ];
Array ts_array_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1041; ];
Array as_block_constant_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1042; ];
Array ts_array_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1043; ];
Array as_block_constant_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1045; ];
Array ts_array_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1046; ];
Array as_block_constant_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1056; ];
Array ts_array_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1057; ];
Array as_block_constant_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1058; ];
Array ts_array_U142 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1059; ];
Array as_block_constant_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1060; ];
Array ts_array_U143 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1061; ];
Array as_block_constant_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1062; ];
Array ts_array_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1063; ];
Array as_block_constant_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1064; ];
Array ts_array_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1065; ];
Array as_block_constant_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1066; ];
Array ts_array_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1067; ];
Array bc_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1077; ];
Array ts_array_U147 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1078; ];
Array bc_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1084; ];
Array ts_array_U148 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1085; ];
Array as_block_constant_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1089; ];
Array ts_array_U149 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1090; ];
Array as_block_constant_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1092; ];
Array ts_array_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1093; ];
Array as_block_constant_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1095; ];
Array ts_array_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1096; ];
Array as_block_constant_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1098; ];
Array ts_array_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1099; ];
Array as_block_constant_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1101; ];
Array ts_array_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1102; ];
Array as_block_constant_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1104; ];
Array ts_array_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1105; ];
Array as_block_constant_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1107; ];
Array ts_array_U155 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1108; ];
Array as_block_constant_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1110; ];
Array ts_array_U156 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1111; ];
Array as_block_constant_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1113; ];
Array ts_array_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1114; ];
Array as_block_constant_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1116; ];
Array ts_array_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1117; ];
Array as_block_constant_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1119; ];
Array ts_array_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1120; ];
Array as_block_constant_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1122; ];
Array ts_array_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1123; ];
Array as_block_constant_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1125; ];
Array ts_array_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1126; ];
Array as_block_constant_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1128; ];
Array ts_array_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1129; ];
Array as_block_constant_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1134; ];
Array ts_array_U163 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1135; ];
Array as_block_constant_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1138; ];
Array ts_array_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1139; ];
Array as_block_constant_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1142; ];
Array ts_array_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1143; ];
Array as_block_constant_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1144; ];
Array ts_array_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1145; ];
Array as_block_constant_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1147; ];
Array ts_array_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1148; ];
Array as_block_constant_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1150; ];
Array ts_array_U168 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1151; ];
Array as_block_constant_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1154; ];
Array ts_array_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1155; ];
Array as_block_constant_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1157; ];
Array ts_array_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1158; ];
Array as_block_constant_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1160; ];
Array ts_array_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1161; ];
Array as_block_constant_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1163; ];
Array ts_array_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1164; ];
Array as_block_constant_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1166; ];
Array ts_array_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1167; ];
Array as_block_constant_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1171; ];
Array ts_array_U174 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1172; ];
Array as_block_constant_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1173; ];
Array ts_array_U175 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1174; ];
Array as_block_constant_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1177; ];
Array ts_array_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1178; ];
Array as_block_constant_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1179; ];
Array ts_array_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1180; ];
Array as_block_constant_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1184; ];
Array ts_array_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1185; ];
Array as_block_constant_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1187; ];
Array ts_array_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1188; ];
Array as_block_constant_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1190; ];
Array ts_array_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1191; ];
Array as_block_constant_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1194; ];
Array ts_array_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1195; ];
Array as_block_constant_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1198; ];
Array ts_array_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1199; ];
Array as_block_constant_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1201; ];
Array ts_array_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1202; ];
Array as_block_constant_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1205; ];
Array ts_array_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1206; ];
Array as_block_constant_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1208; ];
Array ts_array_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1209; ];
Array as_block_constant_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1212; ];
Array ts_array_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1213; ];
Array as_block_constant_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1215; ];
Array ts_array_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1216; ];
Array as_block_constant_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1218; ];
Array ts_array_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1219; ];
Array as_block_constant_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1222; ];
Array ts_array_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1223; ];
Array as_block_constant_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1226; ];
Array ts_array_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1227; ];
Array as_block_constant_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1229; ];
Array ts_array_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1230; ];
Array as_block_constant_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1232; ];
Array ts_array_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1233; ];
Array as_block_constant_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1235; ];
Array ts_array_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1236; ];
Array as_block_constant_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1239; ];
Array ts_array_U194 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1240; ];
Array as_block_constant_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1244; ];
Array ts_array_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1245; ];
Array as_block_constant_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1246; ];
Array ts_array_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1247; ];
Array as_block_constant_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1250; ];
Array ts_array_U197 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1251; ];
Array as_block_constant_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1253; ];
Array ts_array_U198 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1254; ];
Array as_block_constant_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1255; ];
Array ts_array_U199 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1256; ];
Array as_block_constant_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1258; ];
Array ts_array_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1259; ];
Array as_block_constant_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1261; ];
Array ts_array_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1262; ];
Array as_block_constant_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1265; ];
Array ts_array_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1266; ];
Array as_block_constant_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1267; ];
Array ts_array_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1268; ];
Array as_block_constant_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1273; ];
Array ts_array_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1274; ];
Array as_block_constant_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1275; ];
Array ts_array_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1276; ];
Array as_block_constant_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1277; ];
Array ts_array_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1278; ];
Array as_block_constant_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1279; ];
Array ts_array_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1280; ];
Array as_block_constant_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1281; ];
Array ts_array_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1282; ];
Array as_block_constant_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1283; ];
Array ts_array_U209 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1284; ];
Array as_block_constant_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1285; ];
Array ts_array_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1286; ];
Array as_block_constant_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1287; ];
Array ts_array_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1288; ];
Array as_block_constant_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1289; ];
Array ts_array_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1290; ];
Array as_block_constant_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1291; ];
Array ts_array_U213 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1292; ];
Array as_block_constant_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1293; ];
Array ts_array_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1294; ];
Array as_block_constant_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1295; ];
Array ts_array_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1296; ];
Array as_block_constant_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1297; ];
Array ts_array_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1298; ];
Array as_block_constant_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1299; ];
Array ts_array_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1300; ];
Array as_block_constant_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1301; ];
Array ts_array_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1302; ];
Array as_block_constant_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1303; ];
Array ts_array_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1304; ];
Array as_block_constant_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1305; ];
Array ts_array_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1306; ];
Array as_block_constant_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1307; ];
Array ts_array_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1308; ];
Array as_block_constant_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1309; ];
Array ts_array_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1310; ];
Array as_block_constant_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1316; ];
Array ts_array_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1317; ];
Array as_block_constant_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1318; ];
Array ts_array_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1319; ];
Array as_block_constant_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1321; ];
Array ts_array_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1322; ];
Array as_block_constant_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1323; ];
Array ts_array_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1324; ];
Array as_block_constant_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1325; ];
Array ts_array_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1326; ];
Array as_block_constant_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1327; ];
Array ts_array_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1328; ];
Array as_block_constant_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1330; ];
Array ts_array_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1331; ];
Array as_block_constant_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1335; ];
Array ts_array_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1336; ];
Array as_block_constant_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1337; ];
Array ts_array_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1338; ];
Array as_block_constant_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1340; ];
Array ts_array_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1341; ];
Array as_block_constant_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1343; ];
Array ts_array_U233 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1344; ];
Array as_block_constant_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1345; ];
Array ts_array_U234 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1346; ];
Array as_block_constant_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1347; ];
Array ts_array_U235 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1348; ];
Array as_block_constant_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1349; ];
Array ts_array_U236 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1350; ];
Array as_block_constant_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1351; ];
Array ts_array_U237 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1352; ];
Array as_block_constant_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1355; ];
Array ts_array_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1356; ];
Array as_block_constant_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1357; ];
Array ts_array_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1358; ];
Array as_block_constant_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1359; ];
Array ts_array_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1360; ];
Array as_block_constant_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1361; ];
Array ts_array_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1362; ];
Array as_block_constant_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1367; ];
Array ts_array_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1368; ];
Array as_block_constant_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1370; ];
Array ts_array_U243 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1371; ];
Array as_block_constant_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1375; ];
Array ts_array_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1376; ];
Array as_block_constant_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1377; ];
Array ts_array_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1378; ];
Array as_block_constant_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1379; ];
Array ts_array_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1380; ];
Array as_block_constant_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1383; ];
Array ts_array_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1384; ];
Array as_block_constant_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1387; ];
Array ts_array_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1388; ];
Array as_block_constant_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1394; ];
Array ts_array_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1395; ];
Array as_block_constant_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1396; ];
Array ts_array_U250 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1397; ];
Array as_block_constant_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1398; ];
Array ts_array_U251 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1399; ];
Array as_block_constant_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1401; ];
Array ts_array_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1402; ];
Array as_block_constant_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1406; ];
Array ts_array_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1407; ];
Array bc_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1410; ];
Array ts_array_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1411; ];
Array as_block_constant_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1415; ];
Array ts_array_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1416; ];
Array as_block_constant_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1417; ];
Array ts_array_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1418; ];
Array as_block_constant_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1422; ];
Array ts_array_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1423; ];
Array as_block_constant_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1425; ];
Array ts_array_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1426; ];
Array as_block_constant_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1428; ];
Array ts_array_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1429; ];
Array as_block_constant_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1431; ];
Array ts_array_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1432; ];
Array as_block_constant_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1434; ];
Array ts_array_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1435; ];
Array as_block_constant_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1437; ];
Array ts_array_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1438; ];
Array as_block_constant_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1440; ];
Array ts_array_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1441; ];
Array as_block_constant_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1443; ];
Array ts_array_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1444; ];
Array as_block_constant_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1447; ];
Array ts_array_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1448; ];
Array as_block_constant_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1449; ];
Array ts_array_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1450; ];
Array as_block_constant_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1453; ];
Array ts_array_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1454; ];
Array as_block_constant_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1455; ];
Array ts_array_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1456; ];
Array as_block_constant_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1458; ];
Array ts_array_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1459; ];
Array as_block_constant_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1461; ];
Array ts_array_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1462; ];
Array as_block_constant_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1463; ];
Array ts_array_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1464; ];
Array as_block_constant_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1466; ];
Array ts_array_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1467; ];
Array as_block_constant_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1469; ];
Array ts_array_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1470; ];
Array as_block_constant_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1472; ];
Array ts_array_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1473; ];
Array as_block_constant_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1475; ];
Array ts_array_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1476; ];
Array as_block_constant_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1479; ];
Array ts_array_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1480; ];
Array as_block_constant_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1481; ];
Array ts_array_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1482; ];
Array as_block_constant_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1484; ];
Array ts_array_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1485; ];
Array as_block_constant_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1487; ];
Array ts_array_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1488; ];
Array as_block_constant_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1490; ];
Array ts_array_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1491; ];
Array as_block_constant_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1494; ];
Array ts_array_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1495; ];
Array as_block_constant_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1496; ];
Array ts_array_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1497; ];
Array as_block_constant_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1499; ];
Array ts_array_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1500; ];
Array as_block_constant_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1502; ];
Array ts_array_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1503; ];
Array as_block_constant_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1506; ];
Array ts_array_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1507; ];
Array as_block_constant_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1509; ];
Array ts_array_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1510; ];
Array as_block_constant_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1512; ];
Array ts_array_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1513; ];
Array as_block_constant_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1516; ];
Array ts_array_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1517; ];
Array as_block_constant_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1519; ];
Array ts_array_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1520; ];
Array as_block_constant_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1522; ];
Array ts_array_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1523; ];
Array as_block_constant_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1525; ];
Array ts_array_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1526; ];
Array as_block_constant_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1529; ];
Array ts_array_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1530; ];
Array as_block_constant_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1532; ];
Array ts_array_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1533; ];
Array as_block_constant_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1534; ];
Array ts_array_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1535; ];
Array as_block_constant_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1536; ];
Array ts_array_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1537; ];
Array as_block_constant_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1539; ];
Array ts_array_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1540; ];
Array as_block_constant_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1542; ];
Array ts_array_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1543; ];
Array as_block_constant_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1546; ];
Array ts_array_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1547; ];
Array as_block_constant_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1548; ];
Array ts_array_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1549; ];
Array as_block_constant_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1550; ];
Array ts_array_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1551; ];
Array as_block_constant_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1553; ];
Array ts_array_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1554; ];
Array as_block_constant_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1556; ];
Array ts_array_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1557; ];
Array as_block_constant_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1559; ];
Array ts_array_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1560; ];
Array as_block_constant_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1563; ];
Array ts_array_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1564; ];
Array as_block_constant_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1565; ];
Array ts_array_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1566; ];
Array as_block_constant_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1569; ];
Array ts_array_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1570; ];
Array as_block_constant_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1573; ];
Array ts_array_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1574; ];
Array as_block_constant_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1577; ];
Array ts_array_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1578; ];
Array as_block_constant_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1579; ];
Array ts_array_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1580; ];
Array as_block_constant_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1582; ];
Array ts_array_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1583; ];
Array as_block_constant_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1585; ];
Array ts_array_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1586; ];
Array as_block_constant_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1588; ];
Array ts_array_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1589; ];
Array as_block_constant_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1591; ];
Array ts_array_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1592; ];
Array as_block_constant_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1594; ];
Array ts_array_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1595; ];
Array as_block_constant_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1598; ];
Array ts_array_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1599; ];
Array as_block_constant_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1602; ];
Array ts_array_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1603; ];
Array as_block_constant_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1604; ];
Array ts_array_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1605; ];
Array as_block_constant_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1606; ];
Array ts_array_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1607; ];
Array as_block_constant_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1609; ];
Array ts_array_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1610; ];
Array as_block_constant_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1613; ];
Array ts_array_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1614; ];
Array as_block_constant_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1616; ];
Array ts_array_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1617; ];
Array as_block_constant_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1619; ];
Array ts_array_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1620; ];
Array as_block_constant_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1622; ];
Array ts_array_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1623; ];
Array as_block_constant_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1625; ];
Array ts_array_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1626; ];
Array as_block_constant_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1628; ];
Array ts_array_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1629; ];
Array as_block_constant_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1631; ];
Array ts_array_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1632; ];
Array as_block_constant_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1634; ];
Array ts_array_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1635; ];
Array as_block_constant_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1637; ];
Array ts_array_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1638; ];
Array as_block_constant_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1640; ];
Array ts_array_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1641; ];
Array as_block_constant_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1643; ];
Array ts_array_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1644; ];
Array as_block_constant_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1646; ];
Array ts_array_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1647; ];
Array as_block_constant_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1651; ];
Array ts_array_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1652; ];
Array as_block_constant_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1653; ];
Array ts_array_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1654; ];
Array as_block_constant_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1656; ];
Array ts_array_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1657; ];
Array as_block_constant_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1658; ];
Array ts_array_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1659; ];
Array as_block_constant_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1661; ];
Array ts_array_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1662; ];
Array as_block_constant_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1663; ];
Array ts_array_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1664; ];
Array as_block_constant_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1665; ];
Array ts_array_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1666; ];
Array as_block_constant_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1668; ];
Array ts_array_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1669; ];
Array as_block_constant_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1670; ];
Array ts_array_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1671; ];
Array as_block_constant_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1673; ];
Array ts_array_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1674; ];
Array as_block_constant_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1676; ];
Array ts_array_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1677; ];
Array as_block_constant_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1678; ];
Array ts_array_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1679; ];
Array as_block_constant_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1681; ];
Array ts_array_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1682; ];
Array as_block_constant_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1684; ];
Array ts_array_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1685; ];
Array as_block_constant_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1687; ];
Array ts_array_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1688; ];
Array as_block_constant_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1690; ];
Array ts_array_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1691; ];
Array as_block_constant_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1692; ];
Array ts_array_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1693; ];
Array as_block_constant_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1695; ];
Array ts_array_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1696; ];
Array as_block_constant_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1698; ];
Array ts_array_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1699; ];
Array as_block_constant_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1701; ];
Array ts_array_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1702; ];
Array as_block_constant_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1704; ];
Array ts_array_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1705; ];
Array as_block_constant_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1706; ];
Array ts_array_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1707; ];
Array as_block_constant_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1709; ];
Array ts_array_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1710; ];
Array as_block_constant_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1712; ];
Array ts_array_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1713; ];
Array as_block_constant_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1715; ];
Array ts_array_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1716; ];
Array as_block_constant_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1718; ];
Array ts_array_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1719; ];
Array as_block_constant_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1720; ];
Array ts_array_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1721; ];
Array as_block_constant_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1723; ];
Array ts_array_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1724; ];
Array as_block_constant_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1726; ];
Array ts_array_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1727; ];
Array as_block_constant_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1729; ];
Array ts_array_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1730; ];
Array as_block_constant_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1732; ];
Array ts_array_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1733; ];
Array as_block_constant_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1736; ];
Array ts_array_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1737; ];
Array as_block_constant_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1739; ];
Array ts_array_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1740; ];
Array as_block_constant_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1742; ];
Array ts_array_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1743; ];
Array as_block_constant_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1744; ];
Array ts_array_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1745; ];
Array as_block_constant_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1747; ];
Array ts_array_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1748; ];
Array as_block_constant_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1750; ];
Array ts_array_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1751; ];
Array as_block_constant_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1753; ];
Array ts_array_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1754; ];
Array as_block_constant_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1756; ];
Array ts_array_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1757; ];
Array as_block_constant_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1759; ];
Array ts_array_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1760; ];
Array as_block_constant_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1762; ];
Array ts_array_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1763; ];
Array as_block_constant_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1764; ];
Array ts_array_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1765; ];
Array as_block_constant_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1767; ];
Array ts_array_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1768; ];
Array as_block_constant_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1769; ];
Array ts_array_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1770; ];
Array as_block_constant_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1772; ];
Array ts_array_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1773; ];
Array as_block_constant_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1774; ];
Array ts_array_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1775; ];
Array as_block_constant_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1777; ];
Array ts_array_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1778; ];
Array as_block_constant_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1780; ];
Array ts_array_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1781; ];
Array as_block_constant_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1782; ];
Array ts_array_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1783; ];
Array as_block_constant_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1785; ];
Array ts_array_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1786; ];
Array as_block_constant_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1788; ];
Array ts_array_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1789; ];
Array as_block_constant_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1791; ];
Array ts_array_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1792; ];
Array as_block_constant_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1794; ];
Array ts_array_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1795; ];
Array as_block_constant_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1797; ];
Array ts_array_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1798; ];
Array as_block_constant_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1800; ];
Array ts_array_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1801; ];
Array as_block_constant_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1802; ];
Array ts_array_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1803; ];
Array as_block_constant_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1805; ];
Array ts_array_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1806; ];
Array as_block_constant_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1808; ];
Array ts_array_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1809; ];
Array as_block_constant_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1810; ];
Array ts_array_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1811; ];
Array as_block_constant_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1813; ];
Array ts_array_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1814; ];
Array as_block_constant_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1816; ];
Array ts_array_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1817; ];
Array as_block_constant_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1819; ];
Array ts_array_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1820; ];
Array bc_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U14 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U42; ];
Array bc_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U43; ];
Array bc_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U44; ];
Array bc_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U45; ];
Array bc_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U46; ];
Array bc_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U47; ];
Array bc_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U48; ];
Array bc_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U49; ];
Array bc_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U50; ];
Array bc_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U51; ];
Array bc_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U52; ];
Array bc_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U53; ];
Array bc_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U54; ];
Array bc_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK10_relation_of_rooms_to_doo --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array bc_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U55; ];
Array bc_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U56; ];
Array bc_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U57; ];
Array bc_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U58; ];
Array bc_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U59; ];
Array column_data_U1 table [ column_bits_U1; column_blanks_U1; bc_U157; bc_U158; bc_U159; bc_U160; bc_U161; ];
Array bc_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U60; ];
Array bc_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U61; ];
Array bc_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U62; ];
Array bc_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U63; ];
Array bc_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U64; ];
Array column_data_U2 table [ column_bits_U2; column_blanks_U2; 0; 0; 1; 0; 0; ];
Array column_data_U3 table [ column_bits_U3; column_blanks_U3; Consult_Grammar1; Consult_Grammar2; Consult_Grammar3; Consult_Grammar4; Consult_Grammar5; ];
Array column_data_U4 table [ column_bits_U4; column_blanks_U4; IMMEDIATELY_RESTART_VM_R; IMMEDIATELY_RESTORE_SAVED_R; TABLE_NOVALUE; IMMEDIATELY_QUIT_R; IMMEDIATELY_UNDO_R; ];
Array column_data_U5 table [ column_bits_U5; column_blanks_U5; TABLE_NOVALUE; TABLE_NOVALUE; V29_amusing_a_victorious_play; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U1 table [ column_data_U1; column_data_U2; column_data_U3; column_data_U4; column_data_U5; ];
Array column_data_U6 table [ column_bits_U6; NULL; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U7 table [ column_bits_U7; column_blanks_U6; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U2 table [ column_data_U6; column_data_U7; ];
Array Rel_Record3 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "unbolting relation"; abilities_U3; A_P_unbolting_relation_storage; DK11_relation_of_passkeys_to_; call_U1941; "Unbolting relates one passkey to various things"; ];
Array bc_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U65; ];
Array bc_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U66; ];
Array bc_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK11_relation_of_passkeys_to_ --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array as_block_constant_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1945; ];
Array ts_array_U394 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1946; ];
Array as_block_constant_U395 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1948; ];
Array ts_array_U395 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1949; ];
Array as_block_constant_U396 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1951; ];
Array ts_array_U396 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1952; ];
Array as_block_constant_U397 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1954; ];
Array ts_array_U397 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1955; ];
Array as_block_constant_U398 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1962; ];
Array ts_array_U398 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1963; ];
Array as_block_constant_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1966; ];
Array ts_array_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1967; ];
Array as_block_constant_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1970; ];
Array ts_array_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1971; ];
Array as_block_constant_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1975; ];
Array ts_array_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1976; ];
Array as_block_constant_U402 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1978; ];
Array ts_array_U402 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1979; ];
Array as_block_constant_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1981; ];
Array ts_array_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1982; ];
Array as_block_constant_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1988; ];
Array ts_array_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1989; ];
Array as_block_constant_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1997; ];
Array ts_array_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1998; ];
Array as_block_constant_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2000; ];
Array ts_array_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2001; ];
Array as_block_constant_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2009; ];
Array ts_array_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2010; ];
Array column_data_U8 table [ column_bits_U8; column_blanks_U7; ts_array_U408; ];
Array ts_array_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2011; ];
Array column_data_U9 table [ column_bits_U9; column_blanks_U8; bc_U174; ];
Array bc_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U10 table [ column_bits_U10; column_blanks_U9; ts_array_U409; ];
Array ts_array_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2012; ];
Array table_data_U3 table [ column_data_U8; column_data_U9; column_data_U10; ];
Array bc_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U67; ];
Array column_data_U11 table [ column_bits_U11; column_blanks_U10; bc_U176; ];
Array bc_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U68; ];
Array column_data_U12 table [ column_bits_U12; column_blanks_U11; TABLE_NOVALUE; ];
Array column_data_U13 table [ column_bits_U13; column_blanks_U12; bc_U177; ];
Array bc_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U69; ];
Array column_data_U14 table [ column_bits_U14; column_blanks_U13; TABLE_NOVALUE; ];
Array table_data_U4 table [ column_data_U11; column_data_U12; column_data_U13; column_data_U14; ];
Array column_data_U15 table [ column_bits_U15; column_blanks_U14; 78; 110; 80; 112; 81; 113; 13; 32; 130; 129; 27; -8; -6; -5; -4; ];
Array column_data_U16 table [ column_bits_U16; column_blanks_U15; call_U2019; call_U2019; call_U2020; call_U2020; call_U2018; call_U2018; call_U2021; call_U2021; call_U2019; call_U2020; call_U2018; call_U2018; call_U2021; call_U2019; call_U2020; ];
Array table_data_U5 table [ column_data_U15; column_data_U16; ];
Array column_data_U17 table [ column_bits_U17; column_blanks_U16; bc_U178; ];
Array bc_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U18 table [ column_bits_U18; column_blanks_U17; ts_array_U410; ];
Array ts_array_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2025; ];
Array column_data_U19 table [ column_bits_U19; column_blanks_U18; bc_U179; ];
Array bc_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array table_data_U6 table [ column_data_U17; column_data_U18; column_data_U19; ];
Array column_data_U20 table [ column_bits_U20; column_blanks_U19; bc_U180; bc_U181; bc_U182; bc_U183; ];
Array bc_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U70; ];
Array bc_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U71; ];
Array column_data_U21 table [ column_bits_U21; column_blanks_U20; ts_array_U411; bc_U184; bc_U185; bc_U186; ];
Array ts_array_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2026; ];
Array bc_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U22 table [ column_bits_U22; column_blanks_U21; bc_U187; bc_U188; ts_array_U412; bc_U189; ];
Array bc_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U72; ];
Array ts_array_U412 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2027; ];
Array bc_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U73; ];
Array table_data_U7 table [ column_data_U20; column_data_U21; column_data_U22; ];
Array column_data_U23 table [ column_bits_U23; column_blanks_U22; bc_U190; ];
Array bc_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U74; ];
Array column_data_U24 table [ column_bits_U24; column_blanks_U23; TABLE_NOVALUE; ];
Array table_data_U8 table [ column_data_U23; column_data_U24; ];
Array column_data_U25 table [ column_bits_U25; column_blanks_U24; ts_array_U413; bc_U192; ];
Array bc_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U75; ];
Array ts_array_U413 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2043; ];
Array bc_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U76; ];
Array column_data_U26 table [ column_bits_U26; column_blanks_U25; TABLE_NOVALUE; table_data_U10; ];
Array column_data_U27 table [ column_bits_U27; column_blanks_U26; ts_array_U414; TABLE_NOVALUE; ];
Array bc_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U77; ];
Array ts_array_U414 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2044; ];
Array column_data_U28 table [ column_bits_U28; column_blanks_U27; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U9 table [ column_data_U25; column_data_U26; column_data_U27; column_data_U28; ];
Array column_data_U29 table [ column_bits_U29; column_blanks_U28; bc_U194; ts_array_U415; bc_U195; bc_U196; bc_U197; bc_U198; bc_U199; bc_U200; ];
Array bc_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U78; ];
Array ts_array_U415 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2045; ];
Array bc_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U79; ];
Array bc_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U80; ];
Array bc_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U81; ];
Array bc_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U82; ];
Array bc_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U83; ];
Array bc_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U84; ];
Array column_data_U30 table [ column_bits_U30; column_blanks_U29; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; table_data_U11; table_data_U12; ];
Array column_data_U31 table [ column_bits_U31; column_blanks_U30; bc_U201; ts_array_U416; ts_array_U417; ts_array_U418; ts_array_U419; ts_array_U420; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array bc_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U85; ];
Array ts_array_U416 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2046; ];
Array ts_array_U417 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2047; ];
Array ts_array_U418 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2048; ];
Array ts_array_U419 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2049; ];
Array ts_array_U420 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2050; ];
Array column_data_U32 table [ column_bits_U32; column_blanks_U31; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U10 table [ column_data_U29; column_data_U30; column_data_U31; column_data_U32; ];
Array column_data_U33 table [ column_bits_U33; column_blanks_U32; bc_U202; bc_U203; bc_U204; bc_U205; ];
Array bc_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U86; ];
Array bc_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U87; ];
Array bc_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U88; ];
Array bc_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U89; ];
Array column_data_U34 table [ column_bits_U34; column_blanks_U33; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U35 table [ column_bits_U35; column_blanks_U34; bc_U206; bc_U207; bc_U208; bc_U209; ];
Array bc_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U90; ];
Array bc_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U91; ];
Array bc_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U92; ];
Array bc_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U93; ];
Array column_data_U36 table [ column_bits_U36; column_blanks_U35; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U11 table [ column_data_U33; column_data_U34; column_data_U35; column_data_U36; ];
Array column_data_U37 table [ column_bits_U37; column_blanks_U36; bc_U210; bc_U211; bc_U212; bc_U213; ];
Array bc_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U94; ];
Array bc_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U95; ];
Array bc_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U96; ];
Array bc_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U97; ];
Array column_data_U38 table [ column_bits_U38; column_blanks_U37; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U39 table [ column_bits_U39; column_blanks_U38; ts_array_U421; ts_array_U422; ts_array_U423; bc_U214; ];
Array ts_array_U421 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2051; ];
Array ts_array_U422 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2052; ];
Array ts_array_U423 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2053; ];
Array bc_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U98; ];
Array column_data_U40 table [ column_bits_U40; column_blanks_U39; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U12 table [ column_data_U37; column_data_U38; column_data_U39; column_data_U40; ];
Array column_data_U41 table [ column_bits_U41; column_blanks_U40; ts_array_U424; ts_array_U425; ];
Array ts_array_U424 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2054; ];
Array ts_array_U425 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2055; ];
Array column_data_U42 table [ column_bits_U42; column_blanks_U41; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U43 table [ column_bits_U43; column_blanks_U42; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U44 table [ column_bits_U44; column_blanks_U43; call_U2040; call_U2039; ];
Array table_data_U13 table [ column_data_U41; column_data_U42; column_data_U43; column_data_U44; ];
Array bc_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U99; ];
Array bc_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U100; ];
Array bc_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2072; ];
Array ts_array_U426 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2073; ];
Array as_block_constant_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2075; ];
Array ts_array_U427 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2076; ];
Array as_block_constant_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2078; ];
Array ts_array_U428 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2079; ];
Array as_block_constant_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2084; ];
Array ts_array_U429 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2085; ];
Array as_block_constant_U412 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2086; ];
Array ts_array_U430 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2087; ];
Array as_block_constant_U413 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2091; ];
Array ts_array_U431 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2092; ];
Array as_block_constant_U414 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2093; ];
Array ts_array_U432 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2094; ];
Array as_block_constant_U415 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2095; ];
Array ts_array_U433 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2096; ];
Array as_block_constant_U416 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2100; ];
Array ts_array_U434 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2101; ];
Array as_block_constant_U417 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2104; ];
Array ts_array_U435 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2105; ];
Array as_block_constant_U418 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2106; ];
Array ts_array_U436 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2107; ];
Array as_block_constant_U419 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2109; ];
Array ts_array_U437 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2110; ];
Array inline_U15 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U101; ];
Array bc_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U102; ];
Array bc_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U16 --> [ 0; 0; 0; 0; 0; 0; ];
Array ts_array_U438 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2192; ];
Array bc_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U17 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U103; ];
Array ts_array_U439 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2193; ];
Array bc_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U104; ];
Array bc_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U18 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U105; ];
Array bc_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U106; ];
Array bc_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U107; ];
Array bc_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U19 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U108; ];
Array ts_array_U440 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2194; ];
Array bc_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U109; ];
Array bc_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U20 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U110; ];
Array bc_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U111; ];
Array bc_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U21 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U112; ];
Array bc_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U113; ];
Array bc_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U22 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U114; ];
Array ts_array_U441 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2195; ];
Array bc_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U23 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U115; ];
Array bc_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U116; ];
Array bc_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U117; ];
Array bc_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U24 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U118; ];
Array bc_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U119; ];
Array bc_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U120; ];
Array ts_array_U442 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2196; ];
Array bc_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U121; ];
Array ts_array_U443 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2197; ];
Array bc_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U25 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U122; ];
Array ts_array_U444 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2198; ];
Array bc_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U123; ];
Array bc_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U26 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U124; ];
Array bc_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U27 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U125; ];
Array bc_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U28 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U126; ];
Array ts_array_U445 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2199; ];
Array bc_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U127; ];
Array bc_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U29 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U128; ];
Array bc_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U129; ];
Array bc_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U130; ];
Array bc_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U30 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U131; ];
Array bc_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U132; ];
Array bc_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U31 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U133; ];
Array ts_array_U446 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2200; ];
Array bc_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U32 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U134; ];
Array bc_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U135; ];
Array bc_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U33 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U136; ];
Array bc_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U137; ];
Array bc_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U138; ];
Array bc_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U34 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U139; ];
Array ts_array_U447 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2201; ];
Array bc_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U140; ];
Array ts_array_U448 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2202; ];
Array bc_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U141; ];
Array ts_array_U449 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2203; ];
Array bc_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U142; ];
Array ts_array_U450 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2204; ];
Array bc_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U143; ];
Array bc_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U144; ];
Array bc_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U35 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U145; ];
Array ts_array_U451 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2205; ];
Array bc_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U36 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U146; ];
Array ts_array_U452 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2206; ];
Array bc_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U147; ];
Array bc_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U37 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U148; ];
Array bc_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U149; ];
Array bc_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U150; ];
Array bc_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U38 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U151; ];
Array ts_array_U453 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2207; ];
Array bc_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U39 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U152; ];
Array bc_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U153; ];
Array bc_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U154; ];
Array bc_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U40 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U155; ];
Array bc_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U156; ];
Array bc_U395 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U396 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U397 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U398 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U41 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U157; ];
Array bc_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U158; ];
Array bc_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U402 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U42 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U159; ];
Array bc_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U160; ];
Array bc_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U161; ];
Array bc_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U43 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U412 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U162; ];
Array bc_U413 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U163; ];
Array bc_U414 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U415 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U416 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U417 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U44 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U418 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U164; ];
Array bc_U419 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U165; ];
Array bc_U420 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U421 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U422 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U423 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U45 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U424 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U166; ];
Array ts_array_U454 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2208; ];
Array bc_U425 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U426 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U167; ];
Array bc_U427 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U428 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U46 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U429 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U168; ];
Array bc_U430 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U169; ];
Array bc_U431 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U432 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U433 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U434 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U47 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U435 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U170; ];
Array bc_U436 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U171; ];
Array bc_U437 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U438 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U172; ];
Array bc_U439 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U440 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U48 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U441 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U173; ];
Array ts_array_U455 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2209; ];
Array bc_U442 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U443 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U444 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U445 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U49 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U446 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U174; ];
Array bc_U447 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U175; ];
Array bc_U448 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U449 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U450 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U451 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U50 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U452 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U176; ];
Array bc_U453 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U177; ];
Array bc_U454 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U455 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U456 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U457 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U51 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U458 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U178; ];
Array bc_U459 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U460 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U461 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U462 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U463 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U52 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U464 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U179; ];
Array bc_U465 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U180; ];
Array bc_U466 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U467 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U468 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U469 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U470 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U53 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U471 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U181; ];
Array bc_U472 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U182; ];
Array bc_U473 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U474 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U475 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U476 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U477 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U54 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U478 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U183; ];
Array bc_U479 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U184; ];
Array bc_U480 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U481 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U482 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U483 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U484 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U55 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U485 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U185; ];
Array bc_U486 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U186; ];
Array bc_U487 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U488 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U489 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U490 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U491 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U56 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U492 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U187; ];
Array bc_U493 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U188; ];
Array bc_U494 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U495 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U496 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U497 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U498 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U189; ];
Array bc_U499 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U190; ];
Array bc_U500 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U501 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U502 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U57 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U503 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U191; ];
Array ts_array_U456 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2210; ];
Array bc_U504 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U505 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U192; ];
Array bc_U506 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U507 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U58 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U508 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U193; ];
Array bc_U509 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U194; ];
Array bc_U510 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U511 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U195; ];
Array bc_U512 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U513 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U59 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U514 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U196; ];
Array bc_U515 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U197; ];
Array bc_U516 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U517 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U518 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U519 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U60 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U520 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U198; ];
Array bc_U521 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U199; ];
Array bc_U522 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U523 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U524 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U525 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U61 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U526 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U200; ];
Array bc_U527 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U201; ];
Array bc_U528 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U529 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U202; ];
Array bc_U530 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U531 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U532 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U533 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U203; ];
Array bc_U534 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U204; ];
Array bc_U535 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U536 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U537 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U62 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U538 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U205; ];
Array bc_U539 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U206; ];
Array bc_U540 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U541 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U207; ];
Array bc_U542 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U543 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U544 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U63 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U545 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U208; ];
Array bc_U546 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U209; ];
Array bc_U547 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U548 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U210; ];
Array bc_U549 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U550 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U551 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U211; ];
Array ts_array_U457 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2215; ];
Array bc_U552 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U553 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U554 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U64 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U555 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U212; ];
Array ts_array_U458 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2216; ];
Array bc_U556 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U557 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U213; ];
Array bc_U558 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U559 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U65 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U560 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U214; ];
Array bc_U561 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U215; ];
Array bc_U562 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U563 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U216; ];
Array bc_U564 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U565 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U566 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U217; ];
Array ts_array_U459 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2217; ];
Array bc_U567 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U568 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U569 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U66 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U570 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U218; ];
Array bc_U571 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U219; ];
Array bc_U572 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U573 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U220; ];
Array bc_U574 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U575 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U67 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U576 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U221; ];
Array bc_U577 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U222; ];
Array bc_U578 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U579 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U223; ];
Array bc_U580 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U581 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U582 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U224; ];
Array ts_array_U460 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2218; ];
Array bc_U583 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U584 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U585 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U68 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U586 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U225; ];
Array bc_U587 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U226; ];
Array bc_U588 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U589 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U227; ];
Array bc_U590 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U591 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U69 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U592 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U228; ];
Array bc_U593 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U229; ];
Array bc_U594 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U595 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U230; ];
Array bc_U596 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U597 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U598 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U231; ];
Array ts_array_U461 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2219; ];
Array bc_U599 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U600 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U601 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U70 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U602 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U232; ];
Array bc_U603 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U233; ];
Array bc_U604 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U605 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U234; ];
Array bc_U606 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U607 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U71 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U608 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U235; ];
Array bc_U609 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U236; ];
Array bc_U610 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U611 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U237; ];
Array bc_U612 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U613 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U614 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U238; ];
Array bc_U615 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U239; ];
Array bc_U616 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U617 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U618 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U72 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U619 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U240; ];
Array bc_U620 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U241; ];
Array bc_U621 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U622 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U242; ];
Array bc_U623 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U624 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U73 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U625 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U243; ];
Array bc_U626 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U244; ];
Array bc_U627 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U628 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U245; ];
Array bc_U629 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U630 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U631 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U246; ];
Array ts_array_U462 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2220; ];
Array bc_U632 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U633 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U634 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U74 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U635 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U247; ];
Array bc_U636 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U248; ];
Array bc_U637 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U638 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U249; ];
Array bc_U639 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U640 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U75 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U641 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U250; ];
Array bc_U642 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U251; ];
Array bc_U643 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U644 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U252; ];
Array bc_U645 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U646 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U647 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U253; ];
Array bc_U648 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U254; ];
Array bc_U649 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U650 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U651 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U76 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U652 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U255; ];
Array bc_U653 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U654 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U655 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U656 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U657 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U77 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U658 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U256; ];
Array bc_U659 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U660 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U661 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U662 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U663 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U78 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U664 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U257; ];
Array bc_U665 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U666 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U667 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U258; ];
Array bc_U668 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U669 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U670 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U259; ];
Array bc_U671 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U260; ];
Array bc_U672 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U673 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U674 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U79 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U675 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U261; ];
Array ts_array_U463 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2221; ];
Array bc_U676 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U677 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U262; ];
Array bc_U678 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U679 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U80 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U680 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U263; ];
Array bc_U681 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U682 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U683 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U264; ];
Array bc_U684 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U685 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U81 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U686 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U265; ];
Array ts_array_U464 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2222; ];
Array bc_U687 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U688 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U266; ];
Array bc_U689 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U690 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U82 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U691 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U267; ];
Array bc_U692 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U268; ];
Array bc_U693 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U694 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U695 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U696 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U83 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U697 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U269; ];
Array bc_U698 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U270; ];
Array bc_U699 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U700 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U701 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U702 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U84 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U703 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U271; ];
Array bc_U704 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U272; ];
Array bc_U705 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U706 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U707 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U708 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U85 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U709 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U273; ];
Array bc_U710 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U274; ];
Array bc_U711 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U712 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U713 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U714 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U86 --> [ I_maintenance_office_U1; I_stocks_room_U1; ];
Array inline_U87 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U715 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U275; ];
Array ts_array_U465 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2223; ];
Array bc_U716 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U717 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U276; ];
Array bc_U718 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U719 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U88 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U720 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U277; ];
Array bc_U721 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U278; ];
Array bc_U722 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U723 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U724 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U725 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U89 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U726 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U279; ];
Array bc_U727 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U728 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U729 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U730 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U731 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U90 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U732 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U280; ];
Array bc_U733 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U281; ];
Array bc_U734 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U735 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U736 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U737 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U738 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U91 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U739 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U282; ];
Array bc_U740 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U283; ];
Array bc_U741 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U742 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U743 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U744 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U745 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U92 --> [ I_maintenance_office_U1; I_dark_hallway_U1; ];
Array inline_U93 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U746 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U284; ];
Array ts_array_U466 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2224; ];
Array bc_U747 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U748 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U285; ];
Array bc_U749 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U750 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U751 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U286; ];
Array bc_U752 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U287; ];
Array bc_U753 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U754 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U755 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U756 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U288; ];
Array bc_U757 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U289; ];
Array bc_U758 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U759 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U760 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U94 --> [ I_crawl_space_U1; I_gallows_room_U1; ];
Array inline_U95 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U761 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U290; ];
Array ts_array_U467 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2225; ];
Array bc_U762 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U763 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U291; ];
Array bc_U764 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U765 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U766 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U292; ];
Array bc_U767 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U293; ];
Array bc_U768 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U769 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U770 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U96 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U771 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U294; ];
Array bc_U772 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U773 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U774 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U295; ];
Array bc_U775 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U776 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U97 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U777 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U296; ];
Array bc_U778 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U779 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U780 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U781 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U782 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U98 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U783 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U297; ];
Array bc_U784 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U785 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U786 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U787 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U788 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U99 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U789 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U298; ];
Array bc_U790 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U299; ];
Array bc_U791 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U792 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U793 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U794 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U795 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U100 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U796 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U300; ];
Array bc_U797 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U798 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U799 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U800 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U801 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U101 --> [ I_mechanical_room_north_U1; I_stake_room_U1; ];
Array inline_U102 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U802 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U301; ];
Array ts_array_U468 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2226; ];
Array bc_U803 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U804 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U302; ];
Array bc_U805 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U806 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U807 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U303; ];
Array bc_U808 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U304; ];
Array bc_U809 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U810 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U811 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U103 --> [ I_mechanical_room_south_U1; I_dungeon_U1; ];
Array inline_U104 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U812 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U305; ];
Array ts_array_U469 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2227; ];
Array bc_U813 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U814 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U306; ];
Array bc_U815 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U816 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U817 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U307; ];
Array bc_U818 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U308; ];
Array bc_U819 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U820 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U821 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U105 --> [ I_generator_room_U1; I_guillotine_room_U1; ];
Array inline_U106 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U822 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U309; ];
Array ts_array_U470 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2228; ];
Array bc_U823 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U824 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U310; ];
Array bc_U825 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U826 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U827 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U311; ];
Array bc_U828 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U312; ];
Array bc_U829 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U830 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U831 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U832 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U313; ];
Array bc_U833 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U314; ];
Array bc_U834 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U835 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U836 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U107 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U837 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U315; ];
Array ts_array_U471 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2229; ];
Array bc_U838 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U839 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U316; ];
Array bc_U840 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U841 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U108 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U842 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U317; ];
Array bc_U843 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U844 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U318; ];
Array bc_U845 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U319; ];
Array bc_U846 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U847 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U109 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U848 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U320; ];
Array ts_array_U472 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2230; ];
Array bc_U849 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U850 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U321; ];
Array bc_U851 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U852 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U110 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U853 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U322; ];
Array ts_array_U473 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2231; ];
Array bc_U854 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U855 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U323; ];
Array bc_U856 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U857 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U858 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U324; ];
Array bc_U859 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U325; ];
Array bc_U860 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U861 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U862 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U111 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U863 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U326; ];
Array ts_array_U474 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2232; ];
Array bc_U864 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U865 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U327; ];
Array bc_U866 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U867 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U112 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U868 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U328; ];
Array bc_U869 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U329; ];
Array bc_U870 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U871 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U330; ];
Array bc_U872 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U873 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U113 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U874 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U331; ];
Array ts_array_U475 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2234; ];
Array bc_U875 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U876 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U332; ];
Array bc_U877 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U878 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U114 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U879 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U333; ];
Array ts_array_U476 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2235; ];
Array bc_U880 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U881 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U334; ];
Array bc_U882 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U883 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U884 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U335; ];
Array bc_U885 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U336; ];
Array bc_U886 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U887 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U888 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U115 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U889 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U337; ];
Array ts_array_U477 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2236; ];
Array bc_U890 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U891 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U338; ];
Array bc_U892 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U893 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U116 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U894 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U339; ];
Array bc_U895 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U340; ];
Array bc_U896 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U897 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U341; ];
Array bc_U898 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U899 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U117 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U900 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U342; ];
Array ts_array_U478 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2238; ];
Array bc_U901 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U902 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U343; ];
Array bc_U903 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U904 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U118 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U905 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U344; ];
Array ts_array_U479 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2239; ];
Array bc_U906 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U907 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U345; ];
Array bc_U908 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U909 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U910 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U346; ];
Array bc_U911 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U347; ];
Array bc_U912 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U913 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U914 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U119 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U915 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U348; ];
Array ts_array_U480 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2240; ];
Array bc_U916 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U917 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U349; ];
Array bc_U918 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U919 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U120 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U920 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U350; ];
Array bc_U921 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U351; ];
Array bc_U922 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U923 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U352; ];
Array bc_U924 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U925 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U121 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U926 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U353; ];
Array ts_array_U481 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2242; ];
Array bc_U927 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U928 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U354; ];
Array bc_U929 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U930 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U122 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U931 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U355; ];
Array ts_array_U482 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2243; ];
Array bc_U932 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U933 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U356; ];
Array bc_U934 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U935 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U936 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U357; ];
Array bc_U937 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U358; ];
Array bc_U938 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U939 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U940 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U123 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U941 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U359; ];
Array ts_array_U483 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2244; ];
Array bc_U942 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U943 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U360; ];
Array bc_U944 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U945 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U124 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U946 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U361; ];
Array bc_U947 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U362; ];
Array bc_U948 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U949 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U363; ];
Array bc_U950 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U951 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U125 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U952 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U364; ];
Array ts_array_U484 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2246; ];
Array bc_U953 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U954 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U365; ];
Array bc_U955 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U956 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U126 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U957 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U366; ];
Array ts_array_U485 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2247; ];
Array bc_U958 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U959 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U367; ];
Array bc_U960 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U961 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U962 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U368; ];
Array bc_U963 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U369; ];
Array bc_U964 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U965 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U966 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U127 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U967 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U370; ];
Array ts_array_U486 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2248; ];
Array bc_U968 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U969 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U371; ];
Array bc_U970 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U971 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U128 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U972 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U372; ];
Array bc_U973 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U373; ];
Array bc_U974 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U975 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U374; ];
Array bc_U976 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U977 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U129 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U978 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U375; ];
Array ts_array_U487 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2250; ];
Array bc_U979 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U980 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U376; ];
Array bc_U981 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U982 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U130 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U983 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U377; ];
Array ts_array_U488 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2251; ];
Array bc_U984 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U985 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U378; ];
Array bc_U986 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U987 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U988 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U379; ];
Array ts_array_U489 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2252; ];
Array bc_U989 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U990 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U991 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U131 --> [ I_storage_room_U1; I_ride_exit_U1; ];
Array inline_U132 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U992 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U380; ];
Array ts_array_U490 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2253; ];
Array bc_U993 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U994 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U381; ];
Array bc_U995 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U996 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U997 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U382; ];
Array bc_U998 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U383; ];
Array bc_U999 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1000 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1001 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U133 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1002 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U384; ];
Array bc_U1003 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1004 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1005 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U385; ];
Array bc_U1006 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1007 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U134 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1008 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U386; ];
Array ts_array_U491 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2254; ];
Array bc_U1009 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1010 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U387; ];
Array bc_U1011 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1012 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U135 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1013 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U388; ];
Array ts_array_U492 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2255; ];
Array bc_U1014 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1015 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U389; ];
Array bc_U1016 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1017 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U136 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1018 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U390; ];
Array ts_array_U493 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2256; ];
Array bc_U1019 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1020 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U391; ];
Array bc_U1021 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1022 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U137 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1023 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U392; ];
Array ts_array_U494 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2257; ];
Array bc_U1024 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1025 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U393; ];
Array bc_U1026 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1027 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U138 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1028 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U394; ];
Array ts_array_U495 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2258; ];
Array bc_U1029 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1030 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U395; ];
Array bc_U1031 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1032 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U139 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1033 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U396; ];
Array ts_array_U496 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2259; ];
Array bc_U1034 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1035 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U397; ];
Array bc_U1036 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1037 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U140 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1038 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U398; ];
Array bc_U1039 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U399; ];
Array bc_U1040 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1041 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U400; ];
Array bc_U1042 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1043 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U141 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1044 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U401; ];
Array bc_U1045 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U402; ];
Array bc_U1046 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1047 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U403; ];
Array bc_U1048 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1049 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U142 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1050 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U404; ];
Array bc_U1051 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U405; ];
Array bc_U1052 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1053 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U406; ];
Array bc_U1054 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1055 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U143 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1056 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U407; ];
Array bc_U1057 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U408; ];
Array bc_U1058 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1059 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U409; ];
Array bc_U1060 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1061 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U144 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1062 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U410; ];
Array bc_U1063 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U411; ];
Array bc_U1064 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1065 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U412; ];
Array bc_U1066 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1067 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U145 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1068 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U413; ];
Array bc_U1069 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U414; ];
Array bc_U1070 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1071 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U415; ];
Array bc_U1072 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1073 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U146 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1074 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U416; ];
Array bc_U1075 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1076 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1077 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1078 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1079 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U147 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1080 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U417; ];
Array ts_array_U497 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2260; ];
Array bc_U1081 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1082 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U418; ];
Array bc_U1083 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1084 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U148 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1085 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U419; ];
Array ts_array_U498 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2261; ];
Array bc_U1086 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1087 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U420; ];
Array bc_U1088 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1089 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U149 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1090 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U421; ];
Array ts_array_U499 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2262; ];
Array bc_U1091 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1092 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U422; ];
Array bc_U1093 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1094 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U150 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1095 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U423; ];
Array ts_array_U500 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2263; ];
Array bc_U1096 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1097 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U424; ];
Array bc_U1098 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1099 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U151 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1100 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U425; ];
Array ts_array_U501 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2264; ];
Array bc_U1101 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1102 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U426; ];
Array bc_U1103 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1104 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U152 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1105 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U427; ];
Array ts_array_U502 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2265; ];
Array bc_U1106 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1107 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U428; ];
Array bc_U1108 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1109 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1110 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U429; ];
Array bc_U1111 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U430; ];
Array bc_U1112 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1113 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1114 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U153 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1115 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U431; ];
Array bc_U1116 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U432; ];
Array bc_U1117 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1118 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U154 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1119 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U433; ];
Array bc_U1120 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U434; ];
Array bc_U1121 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1122 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U155 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1123 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U435; ];
Array bc_U1124 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U436; ];
Array bc_U1125 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1126 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U156 --> [ 0; 0; 0; 0; 0; 0; ];
Array bc_U1127 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U437; ];
Array bc_U1128 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U438; ];
Array bc_U1129 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1130 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array Rel_Record4 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "underlying relation"; abilities_U4; A_P_underlying_relation_storag; DK8_relation_of_things; call_U2287; "Underlying relates various things to one thing"; ];
Array Rel_Record5 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "equality relation"; abilities_U5; 0; DK5_relation_of_values; call_U2288; "is"; ];
Array Rel_Record6 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "meaning relation"; abilities_U6; 0; DK6_relation_of_objects; call_U2289; "means"; ];
Array Rel_Record7 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "possession relation"; abilities_U7; 0; DK6_relation_of_objects; call_U2290; "has"; ];
Array Rel_Record8 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "universal relation"; abilities_U8; 0; DK6_relation_of_objects; call_U2291; "relates"; ];
Array Rel_Record9 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "provision relation"; abilities_U9; 0; DK6_relation_of_objects; call_U2292; "provides"; ];
Array Rel_Record10 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "containment relation"; abilities_U10; 0; DK6_relation_of_objects; call_U2293; "contains"; ];
Array Rel_Record11 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "support relation"; abilities_U11; 0; DK7_relation_of_supporters_t; call_U2294; "supports"; ];
Array Rel_Record12 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "incorporation relation"; abilities_U12; 0; DK8_relation_of_things; call_U2295; "incorporates"; ];
Array Rel_Record13 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "enclosure relation"; abilities_U13; 0; DK6_relation_of_objects; call_U2296; "encloses"; ];
Array Rel_Record14 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "carrying relation"; abilities_U14; 0; DK9_relation_of_people_to_th; call_U2297; "carries"; ];
Array Rel_Record15 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "holding relation"; abilities_U15; 0; DK9_relation_of_people_to_th; call_U2298; "holds"; ];
Array Rel_Record16 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "wearing relation"; abilities_U16; 0; DK9_relation_of_people_to_th; call_U2299; "wears"; ];
Array Rel_Record17 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "visibility relation"; abilities_U17; 0; DK8_relation_of_things; call_U2300; "can-see"; ];
Array Rel_Record18 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "touchability relation"; abilities_U18; 0; DK8_relation_of_things; call_U2301; "can-touch"; ];
Array Rel_Record19 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "concealment relation"; abilities_U19; 0; DK8_relation_of_things; call_U2302; "conceals"; ];
Array Rel_Record20 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "never-holding relation"; abilities_U20; 0; DK5_relation_of_values; call_U2303; "is"; ];
Array bc_U1131 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U439; ];
Array bc_U1132 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1133 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1134 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1135 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1136 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1137 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U440; ];
Array bc_U1138 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1139 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1140 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1141 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1142 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1143 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U441; ];
Array bc_U1144 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U442; ];
Array bc_U1145 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1146 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1147 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1148 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1149 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U443; ];
Array bc_U1150 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U444; ];
Array bc_U1151 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1152 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1153 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1154 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1155 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U445; ];
Array bc_U1156 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1157 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1158 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1159 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1160 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1161 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U446; ];
Array bc_U1162 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1163 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1164 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1165 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1166 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1167 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U447; ];
Array bc_U1168 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1169 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1170 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1171 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1172 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1173 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U448; ];
Array bc_U1174 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1175 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1176 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1177 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1178 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK1_rule --> [ RULE_TY; 2; ACTION_NAME_TY; VOID_TY; ];
Array DK2_activity_on_objects --> [ ACTIVITY_TY; 1; OBJECT_TY; ];
Array DK3_phrase_real_number____re --> [ PHRASE_TY; 2; REAL_NUMBER_TY; ];
Array DK4_phrase_real_number____nu --> [ PHRASE_TY; 2; NUMBER_TY; ];
Array DK5_relation_of_values --> [ RELATION_TY; 2; VALUE_TY; VALUE_TY; ];
Array DK6_relation_of_objects --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK7_relation_of_supporters_t --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK8_relation_of_things --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK9_relation_of_people_to_th --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array bc_U1179 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U449; ];
Array bc_U1180 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U450; ];
Array ts_array_U503 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2384; ];
Array bc_U1181 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U451; ];
Array label_associated_storage_U1667 --> [ 0; 0; ];
Array label_associated_storage_U1668 --> [ 0; 0; ];
Array bc_U1182 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U452; ];
Array column_data_U45 table [ column_bits_U45; column_blanks_U44; bc_U1183; bc_U1184; bc_U1185; bc_U1186; ts_array_U504; bc_U1187; ];
Array bc_U1183 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U453; ];
Array bc_U1184 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U454; ];
Array bc_U1185 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U455; ];
Array bc_U1186 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U456; ];
Array ts_array_U504 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2568; ];
Array bc_U1187 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U457; ];
Array table_data_U14 table [ column_data_U45; ];
Array column_data_U46 table [ column_bits_U46; column_blanks_U45; ts_array_U505; ts_array_U506; ts_array_U507; ts_array_U508; ts_array_U509; ts_array_U510; ts_array_U511; ];
Array ts_array_U505 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2569; ];
Array ts_array_U506 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2570; ];
Array ts_array_U507 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2571; ];
Array ts_array_U508 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2572; ];
Array ts_array_U509 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2573; ];
Array ts_array_U510 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2574; ];
Array ts_array_U511 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2575; ];
Array table_data_U15 table [ column_data_U46; ];
Array bc_U1188 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U458; ];
Array bc_U1189 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U459; ];
Array bc_U1190 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U460; ];
Array UUID_ARRAY -> [ 45; 'U'; 'U'; 'I'; 'D'; ':'; '/'; '/'; 'E'; '0'; 'A'; '5'; 'A'; 'F'; 'B'; '9'; '-'; '1'; '8'; 'B'; 'F'; '-'; '4'; '4'; '8'; '5'; '-'; 'B'; '0'; '8'; '3'; '-'; '4'; '2'; '6'; 'C'; 'A'; '5'; '1'; 'C'; 'C'; 'E'; '7'; '0'; '/'; '/'; ];
Array InitialSituation --> [ selfobj; 0; I_parking_lot_U1; 540; 0; ];
Array Map_Storage --> [ 0; 0; 0; I_kiosk_U1; 0; 0; 0; 0; 0; 0; 0; 0; I_parking_lot_U1; 0; 0; I_head_of_the_line_U1; 0; I_concession_stand_U1; I_high_striker_U1; I_show_facade_U1; 0; 0; 0; 0; I_kiosk_U1; 0; 0; I_ride_entrance_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_kiosk_U1; I_show_tent_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_kiosk_U1; 0; 0; 0; 0; 0; I_kiosk_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_show_facade_U1; 0; 0; 0; 0; 0; I_head_of_the_line_U1; 0; 0; I_stocks_room_U1; 0; 0; I_dark_passage_U1; 0; 0; 0; 0; 0; I_ride_entrance_U1; 0; 0; I_gallows_room_U1; 0; 0; I_aqua_door_U1; 0; 0; 0; 0; 0; I_stocks_room_U1; 0; 0; I_stake_room_U1; 0; 0; I_crimson_door_U1; 0; 0; 0; 0; 0; I_gallows_room_U1; 0; 0; I_dungeon_U1; 0; 0; I_emerald_door_U1; 0; 0; 0; 0; 0; I_stake_room_U1; 0; 0; I_guillotine_room_U1; 0; 0; I_gray_door_U1; 0; 0; 0; 0; 0; I_dungeon_U1; 0; 0; I_ride_exit_U1; 0; 0; I_indigo_door_U1; 0; 0; 0; 0; 0; I_guillotine_room_U1; 0; 0; 0; 0; 0; I_khaki_door_U1; 0; 0; 0; 0; 0; 0; 0; 0; I_maintenance_office_U1; 0; 0; 0; I_ride_entrance_U1; 0; 0; 0; 0; I_dark_passage_U1; 0; 0; I_crawl_space_U1; 0; 0; 0; I_aqua_door_U1; I_ladder_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_control_room_U1; 0; I_ladder_U1; 0; 0; I_maintenance_office_U1; 0; 0; I_mechanical_room_north_U1; 0; 0; 0; I_crimson_door_U1; 0; 0; 0; 0; I_crawl_space_U1; 0; 0; I_mechanical_room_south_U1; 0; 0; 0; I_emerald_door_U1; 0; 0; 0; 0; I_mechanical_room_north_U1; 0; 0; I_generator_room_U1; 0; 0; 0; I_gray_door_U1; 0; 0; 0; 0; I_mechanical_room_south_U1; 0; 0; I_electrical_room_U1; 0; 0; 0; I_indigo_door_U1; 0; 0; 0; 0; I_generator_room_U1; I_electrical_closet_one_U1; I_electrical_closet_eleven_U1; I_storage_room_U1; I_electrical_closet_five_U1; I_electrical_closet_seven_U1; I_electrical_closet_three_U1; I_electrical_closet_nine_U1; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_khaki_door_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_dark_hallway_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array name_array1 --> [ 'north'; 'directions//p'; 'n//'; ];
Array name_array2 --> [ 'northeast'; 'directions//p'; 'ne'; ];
Array name_array3 --> [ 'northwest'; 'directions//p'; 'nw'; ];
Array name_array4 --> [ 'south'; 'directions//p'; 's//'; ];
Array name_array5 --> [ 'southeast'; 'directions//p'; 'se'; ];
Array name_array6 --> [ 'southwest'; 'directions//p'; 'sw'; ];
Array name_array7 --> [ 'east'; 'directions//p'; 'e//'; ];
Array name_array8 --> [ 'west'; 'directions//p'; 'w//'; ];
Array name_array9 --> [ 'up'; 'directions//p'; 'u//'; ];
Array name_array10 --> [ 'down'; 'directions//p'; 'd//'; ];
Array name_array11 --> [ 'inside'; 'directions//p'; 'in'; ];
Array name_array12 --> [ 'outside'; 'directions//p'; 'out'; ];
Array name_array13 --> [ 'wallet'; 'containers//p'; ];
Array name_array14 --> [ 'money'; 'things//p'; 'cash'; ];
Array name_array15 --> [ 'flashlight'; 'electric//p'; 'lamps//p'; 'light'; ];
Array name_array16 --> [ 'lurking'; 'grue'; 'backdrops//p'; ];
Array name_array17 --> [ 'sky'; 'backdrops//p'; ];
Array name_array18 --> [ 'ground'; 'backdrops//p'; 'floor'; ];
Array name_array19 --> [ 'sailor'; 'backdrops//p'; ];
Array name_array20 --> [ 'keys'; 'things//p'; 'key'; ];
Array name_array21 --> [ 'car'; 'seat'; 'supporters//p'; ];
Array name_array22 --> [ 'coupon'; 'things//p'; ];
Array name_array23 --> [ 'parking'; 'lot'; 'rooms//p'; ];
Array name_array24 --> [ 'kiosk'; 'rooms//p'; ];
Array name_array25 --> [ 'parking'; 'attendant'; 'men//p'; 'attendent'; ];
Array name_array26 --> [ 'parking'; 'ticket'; 'things//p'; ];
Array name_array27 --> [ 'parking'; 'stub'; 'things//p'; ];
Array name_array28 --> [ 'beater'; 'car'; 'containers//p'; 'vehicle'; ];
Array name_array29 --> [ 'dashboard'; 'supporters//p'; ];
Array name_array30 --> [ 'glove'; 'box'; 'containers//p'; 'compartment'; ];
Array name_array31 --> [ 'gloves'; 'things//p'; ];
Array name_array32 --> [ 'blueberry'; 'bush'; 'containers//p'; ];
Array name_array33 --> [ 'blueberries'; 'things//p'; 'berries'; ];
Array name_array34 --> [ 'dime'; 'things//p'; 'shiny'; ];
Array name_array35 --> [ 'head'; 'of'; 'the'; 'line'; 'rooms//p'; ];
Array name_array36 --> [ 'show'; 'facade'; 'rooms//p'; ];
Array name_array37 --> [ 'high'; 'striker'; 'rooms//p'; ];
Array name_array38 --> [ 'concession'; 'stand'; 'rooms//p'; ];
Array name_array39 --> [ 'hell'; 'ride'; 'ticket'; 'things//p'; ];
Array name_array40 --> [ 'cashier'; 'men//p'; ];
Array name_array41 --> [ 'treats'; 'things//p'; 'treat'; ];
Array name_array42 --> [ 'menu'; 'things//p'; ];
Array name_array43 --> [ 'can'; 'fluid//p'; 'containers//p'; 'coke'; 'of'; ];
Array name_array44 --> [ 'bucket'; 'of'; 'popcorn'; 'things//p'; ];
Array name_array45 --> [ 'candy'; 'apple'; 'things//p'; ];
Array name_array46 --> [ 'cotton'; 'candy'; 'things//p'; ];
Array name_array47 --> [ 'soft'; 'pretzel'; 'things//p'; ];
Array name_array48 --> [ 'markings'; 'things//p'; 'marking'; 'sign'; 'signs'; ];
Array name_array49 --> [ 'strongman'; 'attendant'; 'people//p'; 'attendent'; ];
Array name_array50 --> [ 'teddy'; 'bear'; 'things//p'; ];
Array name_array51 --> [ 'swiss'; 'army'; 'knife'; 'containers//p'; ];
Array name_array52 --> [ 'poster'; 'of'; 'taylor'; 'swift'; 'things//p'; ];
Array name_array53 --> [ 'magenta'; 'fuse'; 'things//p'; ];
Array name_array54 --> [ 'mallet'; 'things//p'; 'hammer'; ];
Array name_array55 --> [ 'screwdriver'; 'things//p'; ];
Array name_array56 --> [ 'awl'; 'things//p'; ];
Array name_array57 --> [ 'fingernail'; 'clippers'; 'things//p'; ];
Array name_array58 --> [ 'can'; 'opener'; 'things//p'; ];
Array name_array59 --> [ 'corkscrew'; 'things//p'; ];
Array name_array60 --> [ 'lever'; 'things//p'; 'bullseye'; 'target'; ];
Array name_array61 --> [ 'show'; 'tent'; 'rooms//p'; ];
Array name_array62 --> [ 'barker'; 'people//p'; ];
Array name_array63 --> [ 'little'; 'egypt'; 'women//p'; ];
Array name_array64 --> [ 'sheer'; 'veil'; 'things//p'; ];
Array name_array65 --> [ 'stage'; 'things//p'; ];
Array name_array66 --> [ 'folding'; 'chair'; 'supporters//p'; ];
Array name_array67 --> [ 'ride'; 'entrance'; 'rooms//p'; ];
Array name_array68 --> [ 'ride'; 'attendant'; 'men//p'; 'attendent'; ];
Array name_array69 --> [ 'hell'; 'ride'; 'car'; 'vehicles//p'; ];
Array name_array70 --> [ 'stocks'; 'room'; 'rooms//p'; ];
Array name_array71 --> [ 'wooden'; 'stocks'; 'supporters//p'; ];
Array name_array72 --> [ 'aqua'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array73 --> [ 'gallows'; 'room'; 'rooms//p'; ];
Array name_array74 --> [ 'gallows'; 'platform'; 'supporters//p'; 'gallows'; ];
Array name_array75 --> [ 'crimson'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array76 --> [ 'stake'; 'room'; 'rooms//p'; ];
Array name_array77 --> [ 'pyre'; 'containers//p'; 'bonfire'; 'fire'; 'stake'; 'stakes'; 'flame'; 'flames'; ];
Array name_array78 --> [ 'emerald'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array79 --> [ 'dungeon'; 'rooms//p'; ];
Array name_array80 --> [ 'iron'; 'seat'; 'supporters//p'; ];
Array name_array81 --> [ 'gray'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array82 --> [ 'guillotine'; 'room'; 'rooms//p'; ];
Array name_array83 --> [ 'guillotine'; 'platform'; 'supporters//p'; 'scaffold'; ];
Array name_array84 --> [ 'indigo'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array85 --> [ 'ride'; 'exit'; 'rooms//p'; ];
Array name_array86 --> [ 'merchandise'; 'stand'; 'containers//p'; 'stand'; ];
Array name_array87 --> [ 'khaki'; 'fuse'; 'colored//p'; 'fuses//p'; ];
Array name_array88 --> [ 'dark'; 'passage'; 'rooms//p'; ];
Array name_array89 --> [ 'dust'; 'bunnies'; 'things//p'; 'bunnies'; ];
Array name_array90 --> [ 'bags'; 'of'; 'trash'; 'things//p'; 'bags'; 'trash'; ];
Array name_array91 --> [ 'pile'; 'of'; 'junk'; 'containers//p'; 'piles'; 'junk'; ];
Array name_array92 --> [ 'maintenance'; 'office'; 'rooms//p'; ];
Array name_array93 --> [ 'desk'; 'supporters//p'; ];
Array name_array94 --> [ 'drawer'; 'containers//p'; ];
Array name_array95 --> [ 'radio'; 'devices//p'; ];
Array name_array96 --> [ 'scissors'; 'things//p'; ];
Array name_array97 --> [ 'stapler'; 'things//p'; ];
Array name_array98 --> [ 'ballpoint'; 'pen'; 'things//p'; ];
Array name_array99 --> [ 'pad'; 'of'; 'paper'; 'things//p'; ];
Array name_array100 --> [ 'aqua'; 'door'; 'doors//p'; ];
Array name_array101 --> [ 'silver'; 'key'; 'things//p'; ];
Array name_array102 --> [ 'cans'; 'of'; 'paint'; 'things//p'; ];
Array name_array103 --> [ 'grease'; 'things//p'; ];
Array name_array104 --> [ 'lubricant'; 'things//p'; ];
Array name_array105 --> [ 'ladder'; 'doors//p'; ];
Array name_array106 --> [ 'dark'; 'hallway'; 'rooms//p'; ];
Array name_array107 --> [ 'crawl'; 'space'; 'rooms//p'; ];
Array name_array108 --> [ 'crimson'; 'door'; 'doors//p'; ];
Array name_array109 --> [ 'mechanical'; 'room'; 'north'; 'rooms//p'; ];
Array name_array110 --> [ 'toolbox'; 'containers//p'; ];
Array name_array111 --> [ 'monkey'; 'wrench'; 'things//p'; ];
Array name_array112 --> [ 'channel'; 'locks'; 'things//p'; ];
Array name_array113 --> [ 'pliers'; 'things//p'; ];
Array name_array114 --> [ 'hammer'; 'things//p'; ];
Array name_array115 --> [ 'emerald'; 'door'; 'doors//p'; ];
Array name_array116 --> [ 'mechanical'; 'room'; 'south'; 'rooms//p'; ];
Array name_array117 --> [ 'gray'; 'door'; 'doors//p'; 'grey'; ];
Array name_array118 --> [ 'generator'; 'room'; 'rooms//p'; ];
Array name_array119 --> [ 'indigo'; 'door'; 'doors//p'; ];
Array name_array120 --> [ 'electrical'; 'room'; 'rooms//p'; ];
Array name_array121 --> [ 'electrical'; 'closet'; 'eleven'; 'rooms//p'; ];
Array name_array122 --> [ 'electrical'; 'panel'; 'eleven'; 'containers//p'; ];
Array name_array123 --> [ 'socket'; 'eleven'; 'sockets//p'; ];
Array name_array124 --> [ 'switch'; 'eleven'; 'devices//p'; ];
Array name_array125 --> [ 'indicator'; 'light'; 'eleven'; 'devices//p'; ];
Array name_array126 --> [ 'electrical'; 'closet'; 'nine'; 'rooms//p'; ];
Array name_array127 --> [ 'electrical'; 'panel'; 'nine'; 'containers//p'; ];
Array name_array128 --> [ 'socket'; 'nine'; 'containers//p'; ];
Array name_array129 --> [ 'switch'; 'nine'; 'devices//p'; ];
Array name_array130 --> [ 'indicator'; 'light'; 'nine'; 'devices//p'; ];
Array name_array131 --> [ 'electrical'; 'closet'; 'seven'; 'rooms//p'; ];
Array name_array132 --> [ 'electrical'; 'panel'; 'seven'; 'containers//p'; ];
Array name_array133 --> [ 'socket'; 'seven'; 'containers//p'; ];
Array name_array134 --> [ 'switch'; 'seven'; 'devices//p'; ];
Array name_array135 --> [ 'indicator'; 'light'; 'seven'; 'devices//p'; ];
Array name_array136 --> [ 'electrical'; 'closet'; 'five'; 'rooms//p'; ];
Array name_array137 --> [ 'electrical'; 'panel'; 'five'; 'containers//p'; ];
Array name_array138 --> [ 'socket'; 'five'; 'containers//p'; ];
Array name_array139 --> [ 'switch'; 'five'; 'devices//p'; ];
Array name_array140 --> [ 'indicator'; 'light'; 'five'; 'devices//p'; ];
Array name_array141 --> [ 'electrical'; 'closet'; 'three'; 'rooms//p'; ];
Array name_array142 --> [ 'electrical'; 'panel'; 'three'; 'containers//p'; ];
Array name_array143 --> [ 'socket'; 'three'; 'containers//p'; ];
Array name_array144 --> [ 'switch'; 'three'; 'devices//p'; ];
Array name_array145 --> [ 'indicator'; 'light'; 'three'; 'devices//p'; ];
Array name_array146 --> [ 'electrical'; 'closet'; 'one'; 'rooms//p'; ];
Array name_array147 --> [ 'electrical'; 'panel'; 'one'; 'containers//p'; ];
Array name_array148 --> [ 'socket'; 'one'; 'containers//p'; ];
Array name_array149 --> [ 'switch'; 'one'; 'devices//p'; ];
Array name_array150 --> [ 'indicator'; 'light'; 'one'; 'devices//p'; ];
Array name_array151 --> [ 'storage'; 'room'; 'rooms//p'; ];
Array name_array152 --> [ 'khaki'; 'door'; 'doors//p'; ];
Array name_array153 --> [ 'control'; 'room'; 'rooms//p'; ];
Array name_array154 --> [ 'control'; 'panel'; 'supporters//p'; ];
Array name_array155 --> [ 'aqua'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array156 --> [ 'crimson'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array157 --> [ 'emerald'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array158 --> [ 'gray'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array159 --> [ 'indigo'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array160 --> [ 'khaki'; 'light'; 'colored//p'; 'lights//p'; 'indicator'; ];
Array name_array161 --> [ 'aqua'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array162 --> [ 'crimson'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array163 --> [ 'emerald'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array164 --> [ 'gray'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array165 --> [ 'indigo'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array166 --> [ 'khaki'; 'button'; 'colored//p'; 'buttons//p'; ];
Array name_array167 --> [ 'monitor'; 'things//p'; 'screen'; ];
Array name_array168 --> [ 'aqua'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array169 --> [ 'crimson'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array170 --> [ 'emerald'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array171 --> [ 'gray'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array172 --> [ 'indigo'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array173 --> [ 'khaki'; 'dial'; 'colored//p'; 'dials//p'; ];
Array name_array174 --> [ 'holding'; 'room'; 'rooms//p'; ];
Array name_array175 --> [ 'midway'; 'regions//p'; ];
Array name_array176 --> [ 'hellride'; 'regions//p'; ];
Array name_array177 --> [ 'backstage'; 'regions//p'; ];
Array name_array178 --> [ 'second'; 'floor'; 'regions//p'; ];
Array LocalParking --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array PowersOfTwo_TB --> [ 2048; 1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1; ];
Array IncreasingPowersOfTwo_TB --> [ 1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768; ];
Array EMPTY_TEXT_VALUE --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array TheEmptyTable --> [ 0; 0; ];
Array blockv_stack --> 16384; ! blank with extent 16384
Array Protect_I7_Arrays --> [ 16339; 12345; ];
Array I7_SOO_SHUF -> 32; ! blank with extent 32
Array gg_event --> 4; ! blank with extent 4
Array gg_arguments buffer 28; ! blank with extent 28
Array buffer buffer 260; ! blank with extent 260
Array buffer2 buffer 260; ! blank with extent 260
Array buffer3 buffer 260; ! blank with extent 260
Array parse --> 61; ! blank with extent 61
Array parse2 --> 61; ! blank with extent 61
Array gg_tokenbuf -> 15; ! blank with extent 15
Array AnyToStrArr -> 67; ! blank with extent 67
Array PowersOfTen --> [ 1; 10; 100; 1000; 10000; 100000; 1000000; 10000000; 100000000; 1000000000; ];
Array CheckTableEntryIsBlank_LU -> [ 1; 2; 4; 8; 16; 32; 64; 128; ];
Array CheckTableEntryIsNonBlank_LU -> [ 254; 253; 251; 247; 239; 223; 191; 127; ];
Array MStack --> 160; ! blank with extent 160
Array latest_rule_result --> 3; ! blank with extent 3
Array Flex_Heap -> 262164; ! blank with extent 262164
Array TEXT_TY_Buffers --> 8202; ! blank with extent 8202
Array CharCasingChart0 --> [ 97; 26; -32; 170; 1; UNIC_NCT; 181; 1; 743; 186; 1; UNIC_NCT; 223; 1; UNIC_NCT; 224; 23; -32; 248; 7; -32; 255; 1; 121; 257; -47; -1; 305; 1; -232; 307; -5; -1; 312; 1; UNIC_NCT; 314; -15; -1; 329; 1; UNIC_NCT; 331; -45; -1; 378; -5; -1; 383; 1; -300; 384; 1; UNIC_NCT; 387; -3; -1; 392; 1; -1; 396; 1; -1; 397; 1; UNIC_NCT; 402; 1; -1; 405; 1; 97; 409; 1; -1; 410; 2; UNIC_NCT; 414; 1; 130; 417; -5; -1; 424; 1; -1; 426; 2; UNIC_NCT; 429; 1; -1; 432; 1; -1; 436; -3; -1; 441; 1; -1; 442; 1; UNIC_NCT; 445; 1; -1; 446; 1; UNIC_NCT; 447; 1; 56; 454; 1; -2; 457; 1; -2; 460; 1; -2; 462; -15; -1; 477; 1; -79; 479; -17; -1; 496; 1; UNIC_NCT; 499; 1; -2; 501; 1; -1; 505; -39; -1; 545; 1; UNIC_NCT; 547; -17; -1; 564; 3; UNIC_NCT; 592; 3; UNIC_NCT; 595; 1; -210; 596; 1; -206; 597; 1; UNIC_NCT; 598; 2; -205; 600; 1; UNIC_NCT; 601; 1; -202; 602; 1; UNIC_NCT; 603; 1; -203; 604; 4; UNIC_NCT; 608; 1; -205; 609; 2; UNIC_NCT; 611; 1; -207; 612; 4; UNIC_NCT; 616; 1; -209; 617; 1; -211; 618; 5; UNIC_NCT; 623; 1; -211; 624; 2; UNIC_NCT; 626; 1; -213; 627; 2; UNIC_NCT; 629; 1; -214; 630; 10; UNIC_NCT; 640; 1; -218; 641; 2; UNIC_NCT; 643; 1; -218; 644; 4; UNIC_NCT; 648; 1; -218; 649; 1; UNIC_NCT; 650; 2; -217; 652; 6; UNIC_NCT; 658; 1; -219; 659; 29; UNIC_NCT; 912; 1; UNIC_NCT; 940; 1; -38; 941; 3; -37; 944; 1; UNIC_NCT; 945; 17; -32; 962; 1; -31; 963; 9; -32; 972; 1; -64; 973; 2; -63; 976; 1; -62; 977; 1; -57; 981; 1; -47; 982; 1; -54; 983; 1; UNIC_NCT; 985; -23; -1; 1008; 1; -86; 1009; 1; -80; 1010; 1; 7; 1011; 1; UNIC_NCT; 1013; 1; -96; 1016; 1; -1; 1019; 1; -1; 1072; 32; -32; 1104; 16; -80; 1121; -33; -1; 1163; -53; -1; 1218; -13; -1; 1233; -37; -1; 1273; 1; -1; 1281; -15; -1; 1377; 38; -48; 1415; 1; UNIC_NCT; 7424; 44; UNIC_NCT; 7522; 10; UNIC_NCT; 7681; -149; -1; 7830; 5; UNIC_NCT; 7835; 1; -59; 7841; -89; -1; 7936; 8; 8; 7952; 6; 8; 7968; 8; 8; 7984; 8; 8; 8000; 6; 8; 8016; 1; UNIC_NCT; 8017; 1; 8; 8018; 1; UNIC_NCT; 8019; 1; 8; 8020; 1; UNIC_NCT; 8021; 1; 8; 8022; 1; UNIC_NCT; 8023; 1; 8; 8032; 8; 8; 8048; 2; 74; 8050; 4; 86; 8054; 2; 100; 8056; 2; 128; 8058; 2; 112; 8060; 2; 126; 8064; 8; 8; 8080; 8; 8; 8096; 8; 8; 8112; 2; 8; 8114; 1; UNIC_NCT; 8115; 1; 9; 8116; -3; UNIC_NCT; 8119; 1; UNIC_NCT; 8126; 1; -7205; 8130; 1; UNIC_NCT; 8131; 1; 9; 8132; -3; UNIC_NCT; 8135; 1; UNIC_NCT; 8144; 2; 8; 8146; 2; UNIC_NCT; 8150; 2; UNIC_NCT; 8160; 2; 8; 8162; 3; UNIC_NCT; 8165; 1; 7; 8166; 2; UNIC_NCT; 8178; 1; UNIC_NCT; 8179; 1; 9; 8180; -3; UNIC_NCT; 8183; 1; UNIC_NCT; 8305; 1; UNIC_NCT; 8319; 1; UNIC_NCT; 8458; 1; UNIC_NCT; 8462; 2; UNIC_NCT; 8467; 1; UNIC_NCT; 8495; 1; UNIC_NCT; 8500; 1; UNIC_NCT; 8505; 1; UNIC_NCT; 8509; 1; UNIC_NCT; 8518; 4; UNIC_NCT; 64256; 7; UNIC_NCT; 64275; 5; UNIC_NCT; 65345; 26; -32; 0; ];
Array CharCasingChart1 --> [ 65; 26; 32; 192; 23; 32; 216; 7; 32; 256; -47; 1; 304; 1; -199; 306; -5; 1; 313; -15; 1; 330; -45; 1; 376; 1; -121; 377; -5; 1; 385; 1; 210; 386; -3; 1; 390; 1; 206; 391; 1; 1; 393; 2; 205; 395; 1; 1; 398; 1; 79; 399; 1; 202; 400; 1; 203; 401; 1; 1; 403; 1; 205; 404; 1; 207; 406; 1; 211; 407; 1; 209; 408; 1; 1; 412; 1; 211; 413; 1; 213; 415; 1; 214; 416; -5; 1; 422; 1; 218; 423; 1; 1; 425; 1; 218; 428; 1; 1; 430; 1; 218; 431; 1; 1; 433; 2; 217; 435; -3; 1; 439; 1; 219; 440; 1; 1; 444; 1; 1; 452; 1; 2; 455; 1; 2; 458; 1; 2; 461; -15; 1; 478; -17; 1; 497; 1; 2; 500; 1; 1; 502; 1; -97; 503; 1; -56; 504; -39; 1; 544; 1; -130; 546; -17; 1; 902; 1; 38; 904; 3; 37; 908; 1; 64; 910; 2; 63; 913; 17; 32; 931; 9; 32; 978; 3; UNIC_NCT; 984; -23; 1; 1012; 1; -60; 1015; 1; 1; 1017; 1; -7; 1018; 1; 1; 1024; 16; 80; 1040; 32; 32; 1120; -33; 1; 1162; -53; 1; 1216; 1; UNIC_NCT; 1217; -13; 1; 1232; -37; 1; 1272; 1; 1; 1280; -15; 1; 1329; 38; 48; 4256; 38; UNIC_NCT; 7680; -149; 1; 7840; -89; 1; 7944; 8; -8; 7960; 6; -8; 7976; 8; -8; 7992; 8; -8; 8008; 6; -8; 8025; -7; -8; 8040; 8; -8; 8120; 2; -8; 8122; 2; -74; 8136; 4; -86; 8152; 2; -8; 8154; 2; -100; 8168; 2; -8; 8170; 2; -112; 8172; 1; -7; 8184; 2; -128; 8186; 2; -126; 8450; 1; UNIC_NCT; 8455; 1; UNIC_NCT; 8459; 3; UNIC_NCT; 8464; 3; UNIC_NCT; 8469; 1; UNIC_NCT; 8473; 5; UNIC_NCT; 8484; 1; UNIC_NCT; 8486; 1; -7517; 8488; 1; UNIC_NCT; 8490; 1; -8383; 8491; 1; -8262; 8492; 2; UNIC_NCT; 8496; 2; UNIC_NCT; 8499; 1; UNIC_NCT; 8510; 2; UNIC_NCT; 8517; 1; UNIC_NCT; 65313; 26; 32; 0; ];
Array RE_PACKET_space --> 448; ! blank with extent 448
Array RE_Subexpressions --> 11; ! blank with extent 11
Array Allocated_Match_Vars --> 10; ! blank with extent 10
Array Subexp_Posns --> 20; ! blank with extent 20
Array RTP_Buffer --> [ -1; 0; 0; 0; 0; 0; 0; ];
Array LanguagePronouns table [ 'it'; 568; NULL; 'him'; 2048; NULL; 'her'; 1024; NULL; 'them'; 455; NULL; ];
Array LanguageDescriptors table [ 'my'; 4095; POSSESS_PK; 0; 'this'; 4095; POSSESS_PK; 0; 'these'; 455; POSSESS_PK; 0; 'that'; 4095; POSSESS_PK; 1; 'those'; 455; POSSESS_PK; 1; 'his'; 4095; POSSESS_PK; 'him'; 'her'; 4095; POSSESS_PK; 'her'; 'their'; 4095; POSSESS_PK; 'them'; 'its'; 4095; POSSESS_PK; 'it'; 'the'; 4095; DEFART_PK; NULL; 'a//'; 3640; INDEFART_PK; NULL; 'an'; 3640; INDEFART_PK; NULL; 'some'; 455; INDEFART_PK; NULL; 'lit'; 4095; LIGHTED_PK; NULL; 'lighted'; 4095; LIGHTED_PK; NULL; 'unlit'; 4095; UNLIGHTED_PK; NULL; ];
Array LanguageNumbers table [ 'one'; 1; 'two'; 2; 'three'; 3; 'four'; 4; 'five'; 5; 'six'; 6; 'seven'; 7; 'eight'; 8; 'nine'; 9; 'ten'; 10; 'eleven'; 11; 'twelve'; 12; 'thirteen'; 13; 'fourteen'; 14; 'fifteen'; 15; 'sixteen'; 16; 'seventeen'; 17; 'eighteen'; 18; 'nineteen'; 19; 'twenty'; 20; 'twenty-one'; 21; 'twenty-two'; 22; 'twenty-three'; 23; 'twenty-four'; 24; 'twenty-five'; 25; 'twenty-six'; 26; 'twenty-seven'; 27; 'twenty-eight'; 28; 'twenty-nine'; 29; 'thirty'; 30; ];
Array LanguageArticles --> [ "The "; "the "; "a "; "The "; "the "; "an "; "The "; "the "; "some "; "The "; "the "; "some "; ];
Array LanguageGNAsToArticles --> [ 0; 0; 0; 1; 1; 1; 0; 0; 0; 1; 1; 1; ];
Array scene_started --> 5; ! blank with extent 5
Array scene_ended --> 5; ! blank with extent 5
Array scene_status --> 5; ! blank with extent 5
Array scene_endings --> 5; ! blank with extent 5
Array scene_latest_ending --> 5; ! blank with extent 5
Array multiple_object --> 200; ! blank with extent 200
Array parser_results --> 16; ! blank with extent 16
Array requisition_stack --> 537; ! blank with extent 537
Array LWI_Storage --> [ 1; -1; Computed_Constant_Value_4_U2; ];
Array Details_of_Specific_Action --> 5; ! blank with extent 5
Array activities_stack --> 20; ! blank with extent 20
Array activity_parameters_stack --> 20; ! blank with extent 20
Array ResourceUsageFlags -> 23; ! blank with extent 23
Array T_SL_Score_Moves --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Score_Moves; ];
Array T_SL_Location --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Location; ];
Array StorageForShortName buffer 250; ! blank with extent 250
Array DoorRoutingViable -> 8; ! blank with extent 8
Array FWMatrix --> 961; ! blank with extent 961
Array TimesActionHasHappened --> 5; ! blank with extent 5
Array TurnsActionHasBeenHappening --> 5; ! blank with extent 5
Array LastTurnActionHappenedOn --> 5; ! blank with extent 5
Array ActionCurrentlyHappeningFlag -> 5; ! blank with extent 5
Array past_chronological_record --> 3; ! blank with extent 3
Array present_chronological_record --> 3; ! blank with extent 3
Array SAT_Tmp --> 7; ! blank with extent 7
Array pattern --> 32; ! blank with extent 32
Array pattern2 --> 32; ! blank with extent 32
Array line_ttype --> 32; ! blank with extent 32
Array line_tdata --> 32; ! blank with extent 32
Array line_token --> 32; ! blank with extent 32
Array oops_workspace -> 64; ! blank with extent 64
Array match_list --> 200; ! blank with extent 200
Array match_classes --> 200; ! blank with extent 200
Array match_scores --> 200; ! blank with extent 200
Array alt_match_list --> 201; ! blank with extent 201
Array KOVP_0 table [ 0; 0; 1; 0; 0; ];
Array KOVP_1 table [ 0; 0; bc_U62; bc_U532; bc_U544; ];
Array KOVP_2 table [ 0; 0; I_first_person_plural_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; ];
Array value_ranges --> 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Array value_property_holders --> 0 0 VPH_2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 VPH_41 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Class K0_kind
    has ~pluralname
    has ~proper
    with short_name bc_U1
    with plural bc_U2
    with article bc_U3
    has ~ambigpluralname
    with list_together bc_U4
;
Class K1_room
  class K0_kind
    with description bc_U67
    with map_region 0
    has ~privately_named
    has light
    has ~visited
    has P_indoors
    has ~P_scored
    with short_name bc_U68
    with plural bc_U69
    with article bc_U70
    with list_together bc_U71
;
Class K2_thing
  class K0_kind
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    with P_price 0
    has ~P_broken
    has ~P_seen
    with component_parent 0
    with component_child 0
    with component_sibling 0
    with action_bitmap 0 0 0 0 0 0
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description bc_U72
    with initial bc_U73
    with with_key 0
    with P_unbolting_relation_storage 0
    with P_underlying_relation_storag 0
    with short_name bc_U74
    with plural bc_U75
    with article bc_U76
    with list_together bc_U77
;
Class K6_supporter
  class K2_thing
    with plural bc_U94
    with capacity 100
    has static
    has transparent
    has ~enterable
    with description bc_U95
    with initial bc_U96
    with short_name bc_U97
    with article bc_U98
    with list_together bc_U99
;
Class K17_keychain
  class K6_supporter
    with plural bc_U168
    has ~static
    with description bc_U169
    with initial bc_U170
    with short_name bc_U171
    with article bc_U172
    with list_together bc_U173
;
Class K19_rideable_vehicle
  class K6_supporter

	with before [; Go: return 1; ],
    with plural bc_U221
    has static
    has enterable
    with description bc_U222
    with initial bc_U223
    with short_name bc_U224
    with article bc_U225
    with list_together bc_U226
;
Class K8_person
  class K2_thing
    with plural bc_U106
    with capacity 100
    has transparent
    has ~female
    has ~neuter
    with description bc_U107
    with initial bc_U108
    with short_name bc_U109
    with article bc_U110
    with list_together bc_U111
;
Class K10_man
  class K8_person
    with plural bc_U116
    has ~female
    has ~neuter
    with description bc_U117
    with initial bc_U118
    with short_name bc_U119
    with article bc_U120
    with list_together bc_U121
;
Class K11_woman
  class K8_person
    with plural bc_U122
    has female
    has ~neuter
    with description bc_U123
    with initial bc_U124
    with short_name bc_U125
    with article bc_U126
    with list_together bc_U127
;
Class K12_animal
  class K8_person
    with plural bc_U128
    with description bc_U129
    with initial bc_U130
    with short_name bc_U131
    with article bc_U132
    with list_together bc_U133
;
Class K18_rideable_animal
  class K12_animal

	has enterable supporter,
	with before [; Go: return 1; ],
    with plural bc_U215
    has static
    with description bc_U216
    with initial bc_U217
    with short_name bc_U218
    with article bc_U219
    with list_together bc_U220
;
Class K4_door
  class K2_thing
    with plural bc_U82
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to 0
    with with_key 0
    with description bc_U83
    with initial bc_U84
    with short_name bc_U85
    with article bc_U86
    with list_together bc_U87
;
Class K5_container
  class K2_thing
    with plural bc_U88
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key 0
    with description bc_U89
    with initial bc_U90
    with short_name bc_U91
    with article bc_U92
    with list_together bc_U93
;
Class K14_vehicle
  class K5_container
    with plural bc_U140
    has static
    has enterable
    with description bc_U141
    with initial bc_U142
    with short_name bc_U143
    with article bc_U144
    with list_together bc_U145
;
Class K15_player_s_holdall
  class K5_container
    with plural bc_U146
    has ~static
    has openable
    with description bc_U147
    with initial bc_U148
    with short_name bc_U149
    with article bc_U150
    with list_together bc_U151
;
Class K20_fluid_container
  class K5_container
    with plural bc_U1131
    with P_fluid_capacity 120
    with P_current_volume 0
    with parse_name parse_name199
    with P_liquid I_water_U1
    with description bc_U1132
    with initial bc_U1133
    with short_name bc_U1134
    with article bc_U1135
    with list_together bc_U1136
;
Class K23_socket
  class K5_container
    with short_name bc_U1149
    with plural bc_U1150
    has static
    has open
    has ~P_filled
    with description bc_U1151
    with initial bc_U1152
    with article bc_U1153
    with list_together bc_U1154
;
Class K7_backdrop
  class K2_thing
    with plural bc_U100
    has static
    has scenery
    has ~pushable
    with description bc_U101
    with initial bc_U102
    with short_name bc_U103
    with article bc_U104
    with list_together bc_U105
;
Class K13_device
  class K2_thing
    with plural bc_U134
    has ~on
    with description bc_U135
    with initial bc_U136
    with short_name bc_U137
    with article bc_U138
    with list_together bc_U139
;
Class K21_electric_lamp
  class K13_device
    with plural bc_U1137
    with description bc_U1138
    with initial bc_U1139
    with short_name bc_U1140
    with article bc_U1141
    with list_together bc_U1142
;
Class K22_switch
  class K13_device
    with short_name bc_U1143
    with plural bc_U1144
    has static
    has ~on
    with description bc_U1145
    with initial bc_U1146
    with article bc_U1147
    with list_together bc_U1148
;
Class K25_colored_light
  class K13_device
    with plural bc_U1161
    has static
    has ~on
    with parse_name parse_name204
    with description bc_U1162
    with initial bc_U1163
    with short_name bc_U1164
    with article bc_U1165
    with list_together bc_U1166
;
Class K26_colored_button
  class K13_device
    with plural bc_U1167
    has static
    has ~on
    with description bc_U1168
    with initial bc_U1169
    with short_name bc_U1170
    with article bc_U1171
    with list_together bc_U1172
;
Class K27_colored_dial
  class K13_device
    with plural bc_U1173
    with P_dial_setting 0
    has static
    with description bc_U1174
    with initial bc_U1175
    with short_name bc_U1176
    with article bc_U1177
    with list_together bc_U1178
;
Class K16_passkey
  class K2_thing
    with plural bc_U162
    with description bc_U163
    with initial bc_U164
    with short_name bc_U165
    with article bc_U166
    with list_together bc_U167
;
Class K24_colored_fuse
  class K2_thing
    with plural bc_U1155
    has P_lost
    with description bc_U1156
    with initial bc_U1157
    with short_name bc_U1158
    with article bc_U1159
    with list_together bc_U1160
;
Class K9_region
  class K0_kind
    with plural bc_U112
    has ~privately_named
    with short_name bc_U113
    with article bc_U114
    with list_together bc_U115
;
Class K3_direction
  class K0_kind
    with plural bc_U78
    has ~privately_named
    has scenery
    has ~workflag
    with P_opposite I_north_U1
    with short_name bc_U79
    with article bc_U80
    with list_together bc_U81
;
Object Compass "(Compass object)"
    has concealed
;
Object thedark "(thedark object)"
    has concealed
;
Object VPH_41    with P_recurring KOVP_0
    with description KOVP_1
;
Object VPH_2    with P_adaptive_text_viewpoint KOVP_2
;
K3_direction I_north_U1 Compass    with short_name bc_U6
    with article bc_U7
    with P_opposite I_south_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 0
    with K3_direction_Next I_northeast_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name1
    with name 'north' 'directions//p' 'n//'
    with plural bc_U8
    with list_together bc_U9
;
K3_direction I_northeast_U1 Compass    with short_name bc_U10
    with article bc_U11
    with P_opposite I_southwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 1
    with K3_direction_Next I_northwest_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name2
    with name 'northeast' 'directions//p' 'ne'
    with plural bc_U12
    with list_together bc_U13
;
K3_direction I_northwest_U1 Compass    with short_name bc_U14
    with article bc_U15
    with P_opposite I_southeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 2
    with K3_direction_Next I_south_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name3
    with name 'northwest' 'directions//p' 'nw'
    with plural bc_U16
    with list_together bc_U17
;
K3_direction I_south_U1 Compass    with short_name bc_U18
    with article bc_U19
    with P_opposite I_north_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 3
    with K3_direction_Next I_southeast_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name4
    with name 'south' 'directions//p' 's//'
    with plural bc_U20
    with list_together bc_U21
;
K3_direction I_southeast_U1 Compass    with short_name bc_U22
    with article bc_U23
    with P_opposite I_northwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 4
    with K3_direction_Next I_southwest_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name5
    with name 'southeast' 'directions//p' 'se'
    with plural bc_U24
    with list_together bc_U25
;
K3_direction I_southwest_U1 Compass    with short_name bc_U26
    with article bc_U27
    with P_opposite I_northeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 5
    with K3_direction_Next I_east_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name6
    with name 'southwest' 'directions//p' 'sw'
    with plural bc_U28
    with list_together bc_U29
;
K3_direction I_east_U1 Compass    with short_name bc_U30
    with article bc_U31
    with P_opposite I_west_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 6
    with K3_direction_Next I_west_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name7
    with name 'east' 'directions//p' 'e//'
    with plural bc_U32
    with list_together bc_U33
;
K3_direction I_west_U1 Compass    with short_name bc_U34
    with article bc_U35
    with P_opposite I_east_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 7
    with K3_direction_Next I_up_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name8
    with name 'west' 'directions//p' 'w//'
    with plural bc_U36
    with list_together bc_U37
;
K3_direction I_up_U1 Compass    with short_name bc_U38
    with article bc_U39
    with P_opposite I_down_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 8
    with K3_direction_Next I_down_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name9
    with name 'up' 'directions//p' 'u//'
    with plural bc_U40
    with list_together bc_U41
;
K3_direction I_down_U1 Compass    with short_name bc_U42
    with article bc_U43
    with P_opposite I_up_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 9
    with K3_direction_Next in_obj
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name10
    with name 'down' 'directions//p' 'd//'
    with plural bc_U44
    with list_together bc_U45
;
K3_direction in_obj Compass    with short_name bc_U46
    with article bc_U47
    with P_opposite out_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 10
    with K3_direction_Next out_obj
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name11
    with name 'inside' 'directions//p' 'in'
    with plural bc_U48
    with list_together bc_U49
;
K3_direction out_obj Compass    with short_name bc_U50
    with article bc_U51
    with P_opposite in_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 11
    with K3_direction_Next 0
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name12
    with name 'outside' 'directions//p' 'out'
    with plural bc_U52
    with list_together bc_U53
;
K8_person selfobj    with short_name bc_U54
    with description bc_U55
    has proper
    has privately_named
    has concealed
    with vector 0
    with cap_short_name bc_U56
    has mark_as_thing
    has animate
    with before NULL
    with saved_short_name bc_U57
    with KD_Count 8
    with IK2_Count 0
    with K2_thing_Next I_wallet_U1
    with IK8_Count 0
    with K8_person_Next I_parking_attendant_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name13
    with initial bc_U58
    with plural bc_U59
    with article bc_U60
    with list_together bc_U61
;
K5_container -> I_wallet_U1    with short_name bc_U227
    has ~static
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 1
    with K2_thing_Next I_money_U1
    with IK5_Count 0
    with K5_container_Next I_beater_car_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'wallet' 'containers//p'
    with description bc_U228
    with initial bc_U229
    with plural bc_U230
    with article bc_U231
    with list_together bc_U232
;
K2_thing -> -> I_money_U1    with short_name ts_array_U438
    has proper
    has ~static
    with P_price 1000
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 2
    with K2_thing_Next I_coupon_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name15
    with name 'money' 'things//p' 'cash'
    with description bc_U233
    with initial bc_U234
    with plural bc_U235
    with article bc_U236
    with list_together bc_U237
;
K2_thing -> -> I_coupon_U1    with short_name bc_U277
    with description bc_U278
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 10
    with K2_thing_Next I_lurking_grue_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'coupon' 'things//p'
    with initial bc_U279
    with plural bc_U280
    with article bc_U281
    with list_together bc_U282
;
K7_backdrop I_lurking_grue_U1    with short_name bc_U243
    with description bc_U244
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 4
    with K2_thing_Next I_sky_U1
    with IK7_Count 0
    with K7_backdrop_Next I_sky_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'lurking' 'grue' 'backdrops//p'
    with initial bc_U245
    with plural bc_U246
    with article bc_U247
    with list_together bc_U248
;
K7_backdrop I_sky_U1    with short_name bc_U249
    with description ts_array_U440
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 5
    with K2_thing_Next I_ground_U1
    with IK7_Count 1
    with K7_backdrop_Next I_ground_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'sky' 'backdrops//p'
    with initial bc_U250
    with plural bc_U251
    with article bc_U252
    with list_together bc_U253
;
K7_backdrop I_ground_U1    with short_name bc_U254
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 6
    with K2_thing_Next I_sailor_U1
    with IK7_Count 2
    with K7_backdrop_Next I_sailor_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name19
    with name 'ground' 'backdrops//p' 'floor'
    with description bc_U255
    with initial bc_U256
    with plural bc_U257
    with article bc_U258
    with list_together bc_U259
;
K7_backdrop I_sailor_U1    with short_name bc_U260
    has scenery
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 7
    with K2_thing_Next I_keys_U1
    with IK7_Count 3
    with K7_backdrop_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'sailor' 'backdrops//p'
    with description bc_U261
    with initial bc_U262
    with plural bc_U263
    with article bc_U264
    with list_together bc_U265
;
K2_thing I_keys_U1    with short_name bc_U266
    with description ts_array_U441
    with P_underlying_relation_storag I_car_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 8
    with K2_thing_Next I_car_seat_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name21
    with name 'keys' 'things//p' 'key'
    with initial bc_U267
    with plural bc_U268
    with article bc_U269
    with list_together bc_U270
;
K6_supporter I_car_seat_U1    with short_name bc_U271
    with description bc_U272
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with component_parent I_beater_car_U1
    with component_sibling I_dashboard_U1
    with KD_Count 6
    with IK2_Count 9
    with K2_thing_Next I_parking_attendant_U1
    with IK6_Count 0
    with K6_supporter_Next I_dashboard_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'car' 'seat' 'supporters//p'
    with initial bc_U273
    with plural bc_U274
    with article bc_U275
    with list_together bc_U276
;
K1_room I_parking_lot_U1    with short_name bc_U283
    with description ts_array_U442
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 0
    with K1_room_Next I_kiosk_U1
    with name 'parking' 'lot' 'rooms//p'
    with plural bc_U284
    with article bc_U285
    with list_together bc_U286
;
K10_man -> I_parking_attendant_U1    with short_name bc_U291
    with description ts_array_U444
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 10
    with IK2_Count 11
    with K2_thing_Next I_parking_ticket_U1
    with IK8_Count 1
    with K8_person_Next I_cashier_U1
    with IK10_Count 0
    with K10_man_Next I_cashier_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name26
    with name 'parking' 'attendant' 'men//p' 'attendent'
    with initial bc_U292
    with plural bc_U293
    with article bc_U294
    with list_together bc_U295
;
K2_thing -> -> I_parking_ticket_U1    with short_name bc_U296
    has ~static
    with P_price 500
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 12
    with K2_thing_Next I_parking_stub_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'parking' 'ticket' 'things//p'
    with description bc_U297
    with initial bc_U298
    with plural bc_U299
    with article bc_U300
    with list_together bc_U301
;
K2_thing -> -> I_parking_stub_U1    with short_name bc_U302
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 13
    with K2_thing_Next I_beater_car_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'parking' 'stub' 'things//p'
    with description bc_U303
    with initial bc_U304
    with plural bc_U305
    with article bc_U306
    with list_together bc_U307
;
K5_container -> I_beater_car_U1    with short_name bc_U308
    with description ts_array_U445
    has static
    has enterable
    has open
    with vector 0
    has mark_as_thing
    has container
    with component_child I_car_seat_U1
    with KD_Count 5
    with IK2_Count 14
    with K2_thing_Next I_blueberry_bush_U1
    with IK5_Count 1
    with K5_container_Next I_blueberry_bush_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name29
    with name 'beater' 'car' 'containers//p' 'vehicle'
    with initial bc_U309
    with plural bc_U310
    with article bc_U311
    with list_together bc_U312
;
K5_container -> I_blueberry_bush_U1    with short_name bc_U330
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 18
    with K2_thing_Next I_blueberries_U1
    with IK5_Count 3
    with K5_container_Next I_glove_box_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'blueberry' 'bush' 'containers//p'
    with description bc_U331
    with initial bc_U332
    with plural bc_U333
    with article bc_U334
    with list_together bc_U335
;
K2_thing -> -> I_blueberries_U1    with short_name bc_U336
    with description bc_U337
    has proper
    has edible
    with vector 0
    with cap_short_name bc_U338
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 19
    with K2_thing_Next I_cashier_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name34
    with name 'blueberries' 'things//p' 'berries'
    with initial bc_U339
    with plural bc_U340
    with article bc_U341
    with list_together bc_U342
;
K1_room I_kiosk_U1    with short_name bc_U287
    with description ts_array_U443
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 1
    with K1_room_Next I_head_of_the_line_U1
    with name 'kiosk' 'rooms//p'
    with plural bc_U288
    with article bc_U289
    with list_together bc_U290
;
K10_man -> I_cashier_U1    with short_name bc_U370
    with description ts_array_U452
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 10
    with IK2_Count 22
    with K2_thing_Next I_hell_ride_ticket_U1
    with IK8_Count 2
    with K8_person_Next I_ride_attendant_U1
    with IK10_Count 1
    with K10_man_Next I_ride_attendant_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'cashier' 'men//p'
    with initial bc_U371
    with plural bc_U372
    with article bc_U373
    with list_together bc_U374
;
K2_thing -> -> I_hell_ride_ticket_U1    with short_name bc_U365
    with description ts_array_U451
    has ~static
    with P_price 300
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 21
    with K2_thing_Next I_dashboard_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'hell' 'ride' 'ticket' 'things//p'
    with initial bc_U366
    with plural bc_U367
    with article bc_U368
    with list_together bc_U369
;
K6_supporter I_dashboard_U1    with short_name bc_U313
    with description bc_U314
    with vector 0
    has mark_as_thing
    has supporter
    with component_parent I_beater_car_U1
    with component_sibling I_glove_box_U1
    with KD_Count 6
    with IK2_Count 15
    with K2_thing_Next I_glove_box_U1
    with IK6_Count 1
    with K6_supporter_Next I_folding_chair_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'dashboard' 'supporters//p'
    with initial bc_U315
    with plural bc_U316
    with article bc_U317
    with list_together bc_U318
;
K5_container I_glove_box_U1    with short_name bc_U319
    with with_key I_keys_U1
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_beater_car_U1
    with KD_Count 5
    with IK2_Count 16
    with K2_thing_Next I_gloves_U1
    with IK5_Count 2
    with K5_container_Next I_swiss_army_knife_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name31
    with name 'glove' 'box' 'containers//p' 'compartment'
    with description bc_U320
    with initial bc_U321
    with plural bc_U322
    with article bc_U323
    with list_together bc_U324
;
K2_thing -> I_gloves_U1    with short_name bc_U325
    with description ts_array_U446
    has clothing
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 17
    with K2_thing_Next I_dime_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'gloves' 'things//p'
    with initial bc_U326
    with plural bc_U327
    with article bc_U328
    with list_together bc_U329
;
K2_thing I_dime_U1    with short_name bc_U343
    with description ts_array_U447
    with P_underlying_relation_storag I_car_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 20
    with K2_thing_Next I_ride_attendant_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name35
    with name 'dime' 'things//p' 'shiny'
    with initial bc_U344
    with plural bc_U345
    with article bc_U346
    with list_together bc_U347
;
K1_room I_head_of_the_line_U1    with short_name bc_U348
    with description ts_array_U448
    with map_region I_midway_U1
    has proper
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 2
    with K1_room_Next I_show_facade_U1
    with name 'head' 'of' 'the' 'line' 'rooms//p'
    with plural bc_U349
    with article bc_U350
    with list_together bc_U351
;
K10_man -> I_ride_attendant_U1    with short_name bc_U538
    with description bc_U539
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 10
    with IK2_Count 48
    with K2_thing_Next I_barker_U1
    with IK8_Count 6
    with K8_person_Next I_barker_U1
    with IK10_Count 2
    with K10_man_Next 0
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name69
    with name 'ride' 'attendant' 'men//p' 'attendent'
    with initial bc_U540
    with plural bc_U541
    with article bc_U542
    with list_together bc_U543
;
K1_room I_show_facade_U1    with short_name bc_U352
    with description ts_array_U449
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 3
    with K1_room_Next I_high_striker_U1
    with name 'show' 'facade' 'rooms//p'
    with plural bc_U353
    with article bc_U354
    with list_together bc_U355
;
K8_person -> I_barker_U1    with short_name bc_U503
    with description ts_array_U456
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 8
    with IK2_Count 43
    with K2_thing_Next I_markings_U1
    with IK8_Count 4
    with K8_person_Next I_strongman_attendant_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'barker' 'people//p'
    with initial bc_U504
    with plural bc_U505
    with article bc_U506
    with list_together bc_U507
;
K1_room I_high_striker_U1    with short_name bc_U356
    with description ts_array_U450
    with map_region I_midway_U1
    has proper
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 4
    with K1_room_Next I_concession_stand_U1
    with name 'high' 'striker' 'rooms//p'
    with plural bc_U357
    with article bc_U358
    with list_together bc_U359
;
K2_thing -> I_markings_U1    with short_name bc_U418
    with description bc_U419
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 30
    with K2_thing_Next I_strongman_attendant_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name49
    with name 'markings' 'things//p' 'marking' 'sign' 'signs'
    with initial bc_U420
    with plural bc_U421
    with article bc_U422
    with list_together bc_U423
;
K8_person -> I_strongman_attendant_U1    with short_name bc_U424
    with description ts_array_U454
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 8
    with IK2_Count 31
    with K2_thing_Next I_teddy_bear_U1
    with IK8_Count 3
    with K8_person_Next I_little_egypt_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name50
    with name 'strongman' 'attendant' 'people//p' 'attendent'
    with initial bc_U425
    with plural bc_U426
    with article bc_U427
    with list_together bc_U428
;
K2_thing -> -> I_teddy_bear_U1    with short_name bc_U429
    with description bc_U430
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 32
    with K2_thing_Next I_swiss_army_knife_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'teddy' 'bear' 'things//p'
    with initial bc_U431
    with plural bc_U432
    with article bc_U433
    with list_together bc_U434
;
K5_container -> -> I_swiss_army_knife_U1    with short_name bc_U435
    with description bc_U436
    has ~static
    has open
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 33
    with K2_thing_Next I_screwdriver_U1
    with IK5_Count 5
    with K5_container_Next I_can_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'swiss' 'army' 'knife' 'containers//p'
    with initial bc_U437
    with plural bc_U438
    with article bc_U439
    with list_together bc_U440
;
K2_thing -> -> -> I_screwdriver_U1    with short_name bc_U458
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 37
    with K2_thing_Next I_awl_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'screwdriver' 'things//p'
    with description bc_U459
    with initial bc_U460
    with plural bc_U461
    with article bc_U462
    with list_together bc_U463
;
K2_thing -> -> -> I_awl_U1    with short_name bc_U464
    has proper
    has ~static
    with vector 0
    with cap_short_name bc_U465
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 38
    with K2_thing_Next I_fingernail_clippers_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'awl' 'things//p'
    with description bc_U466
    with initial bc_U467
    with plural bc_U468
    with article bc_U469
    with list_together bc_U470
;
K2_thing -> -> -> I_fingernail_clippers_U1    with short_name bc_U471
    has proper
    has ~static
    with vector 0
    with cap_short_name bc_U472
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 39
    with K2_thing_Next I_can_opener_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'fingernail' 'clippers' 'things//p'
    with description bc_U473
    with initial bc_U474
    with plural bc_U475
    with article bc_U476
    with list_together bc_U477
;
K2_thing -> -> -> I_can_opener_U1    with short_name bc_U478
    has proper
    has ~static
    with vector 0
    with cap_short_name bc_U479
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 40
    with K2_thing_Next I_corkscrew_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'can' 'opener' 'things//p'
    with description bc_U480
    with initial bc_U481
    with plural bc_U482
    with article bc_U483
    with list_together bc_U484
;
K2_thing -> -> -> I_corkscrew_U1    with short_name bc_U485
    has proper
    has ~static
    with vector 0
    with cap_short_name bc_U486
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 41
    with K2_thing_Next I_poster_of_taylor_swift_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'corkscrew' 'things//p'
    with description bc_U487
    with initial bc_U488
    with plural bc_U489
    with article bc_U490
    with list_together bc_U491
;
K2_thing -> -> I_poster_of_taylor_swift_U1    with short_name bc_U441
    with description ts_array_U455
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 34
    with K2_thing_Next I_magenta_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'poster' 'of' 'taylor' 'swift' 'things//p'
    with initial bc_U442
    with plural bc_U443
    with article bc_U444
    with list_together bc_U445
;
K2_thing -> -> I_magenta_fuse_U1    with short_name bc_U446
    with description bc_U447
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 35
    with K2_thing_Next I_mallet_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'magenta' 'fuse' 'things//p'
    with initial bc_U448
    with plural bc_U449
    with article bc_U450
    with list_together bc_U451
;
K2_thing -> -> I_mallet_U1    with short_name bc_U452
    with description bc_U453
    has ~static
    with P_price 200
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 36
    with K2_thing_Next I_lever_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name55
    with name 'mallet' 'things//p' 'hammer'
    with initial bc_U454
    with plural bc_U455
    with article bc_U456
    with list_together bc_U457
;
K2_thing -> I_lever_U1    with short_name bc_U492
    with description bc_U493
    has static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 42
    with K2_thing_Next I_treats_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name61
    with name 'lever' 'things//p' 'bullseye' 'target'
    with initial bc_U494
    with plural bc_U495
    with article bc_U496
    with list_together bc_U497
;
K1_room I_concession_stand_U1    with short_name bc_U360
    with description bc_U361
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 5
    with K1_room_Next I_show_tent_U1
    with name 'concession' 'stand' 'rooms//p'
    with plural bc_U362
    with article bc_U363
    with list_together bc_U364
;
K2_thing -> I_treats_U1    with short_name bc_U375
    with description bc_U376
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U377
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 23
    with K2_thing_Next I_menu_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name42
    with name 'treats' 'things//p' 'treat'
    with initial bc_U378
    with plural bc_U379
    with article bc_U380
    with list_together bc_U381
;
K2_thing -> I_menu_U1    with short_name bc_U382
    with description ts_array_U453
    has static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 24
    with K2_thing_Next I_can_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'menu' 'things//p'
    with initial bc_U383
    with plural bc_U384
    with article bc_U385
    with list_together bc_U386
;
K20_fluid_container -> I_can_U1    with short_name bc_U387
    with description bc_U388
    with P_current_volume 80
    with P_price 200
    with P_liquid I_cola_U1
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 20
    with IK2_Count 25
    with K2_thing_Next I_bucket_of_popcorn_U1
    with IK5_Count 4
    with K5_container_Next I_hell_ride_car_U1
    with K20_fluid_container_Count 0
    with K20_fluid_container_Next 0
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name44
    with name 'can' 'fluid//p' 'containers//p' 'coke' 'of'
    with initial bc_U389
    with plural bc_U390
    with article bc_U391
    with list_together bc_U392
;
K2_thing -> I_bucket_of_popcorn_U1    with short_name bc_U393
    with description bc_U394
    has edible
    with P_price 250
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 26
    with K2_thing_Next I_candy_apple_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'bucket' 'of' 'popcorn' 'things//p'
    with initial bc_U395
    with plural bc_U396
    with article bc_U397
    with list_together bc_U398
;
K2_thing -> I_candy_apple_U1    with short_name bc_U399
    with description bc_U400
    has edible
    with P_price 150
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 27
    with K2_thing_Next I_cotton_candy_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'candy' 'apple' 'things//p'
    with initial bc_U401
    with plural bc_U402
    with article bc_U403
    with list_together bc_U404
;
K2_thing -> I_cotton_candy_U1    with short_name bc_U405
    with description bc_U406
    has proper
    has edible
    with P_price 150
    with vector 0
    with cap_short_name bc_U407
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 28
    with K2_thing_Next I_soft_pretzel_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'cotton' 'candy' 'things//p'
    with initial bc_U408
    with plural bc_U409
    with article bc_U410
    with list_together bc_U411
;
K2_thing -> I_soft_pretzel_U1    with short_name bc_U412
    with description bc_U413
    has edible
    with P_price 150
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 29
    with K2_thing_Next I_little_egypt_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'soft' 'pretzel' 'things//p'
    with initial bc_U414
    with plural bc_U415
    with article bc_U416
    with list_together bc_U417
;
K1_room I_show_tent_U1    with short_name bc_U498
    with description bc_U499
    with map_region I_midway_U1
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 6
    with K1_room_Next I_ride_entrance_U1
    with name 'show' 'tent' 'rooms//p'
    with plural bc_U500
    with article bc_U501
    with list_together bc_U502
;
K11_woman -> I_little_egypt_U1    with short_name bc_U508
    with description bc_U509
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 11
    with IK2_Count 44
    with K2_thing_Next I_stage_U1
    with IK8_Count 5
    with K8_person_Next 0
    with K11_woman_Count 0
    with K11_woman_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'little' 'egypt' 'women//p'
    with initial bc_U510
    with plural bc_U511
    with article bc_U512
    with list_together bc_U513
;
K2_thing -> I_stage_U1    with short_name bc_U520
    with description bc_U521
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 46
    with K2_thing_Next I_folding_chair_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'stage' 'things//p'
    with initial bc_U522
    with plural bc_U523
    with article bc_U524
    with list_together bc_U525
;
K6_supporter -> I_folding_chair_U1    with short_name bc_U526
    with description bc_U527
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 47
    with K2_thing_Next I_sheer_veil_U1
    with IK6_Count 2
    with K6_supporter_Next I_wooden_stocks_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'folding' 'chair' 'supporters//p'
    with initial bc_U528
    with plural bc_U529
    with article bc_U530
    with list_together bc_U531
;
K2_thing I_sheer_veil_U1    with short_name bc_U514
    with description bc_U515
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 45
    with K2_thing_Next I_hell_ride_car_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'sheer' 'veil' 'things//p'
    with initial bc_U516
    with plural bc_U517
    with article bc_U518
    with list_together bc_U519
;
K1_room I_ride_entrance_U1    with short_name bc_U533
    with description bc_U534
    with map_region I_hellride_U1
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 7
    with K1_room_Next I_stocks_room_U1
    with name 'ride' 'entrance' 'rooms//p'
    with plural bc_U535
    with article bc_U536
    with list_together bc_U537
;
K14_vehicle -> I_hell_ride_car_U1    with short_name bc_U545
    with description bc_U546
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 14
    with IK2_Count 49
    with K2_thing_Next I_wooden_stocks_U1
    with IK5_Count 6
    with K5_container_Next I_pyre_U1
    with K14_vehicle_Count 0
    with K14_vehicle_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'hell' 'ride' 'car' 'vehicles//p'
    with initial bc_U547
    with plural bc_U548
    with article bc_U549
    with list_together bc_U550
;
K1_room I_stocks_room_U1    with short_name bc_U551
    with description ts_array_U457
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 8
    with K1_room_Next I_gallows_room_U1
    with name 'stocks' 'room' 'rooms//p'
    with plural bc_U552
    with article bc_U553
    with list_together bc_U554
;
K6_supporter -> I_wooden_stocks_U1    with short_name bc_U555
    with description ts_array_U458
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 50
    with K2_thing_Next I_aqua_fuse_U1
    with IK6_Count 3
    with K6_supporter_Next I_gallows_platform_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'wooden' 'stocks' 'supporters//p'
    with initial bc_U556
    with plural bc_U557
    with article bc_U558
    with list_together bc_U559
;
K24_colored_fuse I_aqua_fuse_U1    with short_name bc_U560
    with description bc_U561
    with P_underlying_relation_storag I_wooden_stocks_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 51
    with K2_thing_Next I_gallows_platform_U1
    with K24_colored_fuse_Count 0
    with K24_colored_fuse_Next I_crimson_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'aqua' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U562
    with plural bc_U563
    with article bc_U564
    with list_together bc_U565
;
K1_room I_gallows_room_U1    with short_name bc_U566
    with description ts_array_U459
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 9
    with K1_room_Next I_stake_room_U1
    with name 'gallows' 'room' 'rooms//p'
    with plural bc_U567
    with article bc_U568
    with list_together bc_U569
;
K6_supporter -> I_gallows_platform_U1    with short_name bc_U570
    with description bc_U571
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 52
    with K2_thing_Next I_crimson_fuse_U1
    with IK6_Count 4
    with K6_supporter_Next I_iron_seat_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name75
    with name 'gallows' 'platform' 'supporters//p' 'gallows'
    with initial bc_U572
    with plural bc_U573
    with article bc_U574
    with list_together bc_U575
;
K24_colored_fuse I_crimson_fuse_U1    with short_name bc_U576
    with description bc_U577
    with P_underlying_relation_storag I_gallows_platform_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 53
    with K2_thing_Next I_pyre_U1
    with K24_colored_fuse_Count 1
    with K24_colored_fuse_Next I_emerald_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'crimson' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U578
    with plural bc_U579
    with article bc_U580
    with list_together bc_U581
;
K1_room I_stake_room_U1    with short_name bc_U582
    with description ts_array_U460
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 10
    with K1_room_Next I_dungeon_U1
    with name 'stake' 'room' 'rooms//p'
    with plural bc_U583
    with article bc_U584
    with list_together bc_U585
;
K5_container -> I_pyre_U1    with short_name bc_U586
    with description bc_U587
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 54
    with K2_thing_Next I_emerald_fuse_U1
    with IK5_Count 7
    with K5_container_Next I_merchandise_stand_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name78
    with name 'pyre' 'containers//p' 'bonfire' 'fire' 'stake' 'stakes' 'flame' 'flames'
    with initial bc_U588
    with plural bc_U589
    with article bc_U590
    with list_together bc_U591
;
K24_colored_fuse -> -> I_emerald_fuse_U1    with short_name bc_U592
    with description bc_U593
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 55
    with K2_thing_Next I_iron_seat_U1
    with K24_colored_fuse_Count 2
    with K24_colored_fuse_Next I_gray_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'emerald' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U594
    with plural bc_U595
    with article bc_U596
    with list_together bc_U597
;
K1_room I_dungeon_U1    with short_name bc_U598
    with description ts_array_U461
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 11
    with K1_room_Next I_guillotine_room_U1
    with name 'dungeon' 'rooms//p'
    with plural bc_U599
    with article bc_U600
    with list_together bc_U601
;
K6_supporter -> I_iron_seat_U1    with short_name bc_U602
    with description bc_U603
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 56
    with K2_thing_Next I_gray_fuse_U1
    with IK6_Count 5
    with K6_supporter_Next I_guillotine_platform_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name81
    with name 'iron' 'seat' 'supporters//p'
    with initial bc_U604
    with plural bc_U605
    with article bc_U606
    with list_together bc_U607
;
K24_colored_fuse I_gray_fuse_U1    with short_name bc_U608
    with description bc_U609
    with P_underlying_relation_storag I_iron_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 57
    with K2_thing_Next I_guillotine_platform_U1
    with K24_colored_fuse_Count 3
    with K24_colored_fuse_Next I_indigo_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'gray' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U610
    with plural bc_U611
    with article bc_U612
    with list_together bc_U613
;
K1_room I_guillotine_room_U1    with short_name bc_U614
    with description bc_U615
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 12
    with K1_room_Next I_ride_exit_U1
    with name 'guillotine' 'room' 'rooms//p'
    with plural bc_U616
    with article bc_U617
    with list_together bc_U618
;
K6_supporter -> I_guillotine_platform_U1    with short_name bc_U619
    with description bc_U620
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 58
    with K2_thing_Next I_indigo_fuse_U1
    with IK6_Count 6
    with K6_supporter_Next I_desk_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name84
    with name 'guillotine' 'platform' 'supporters//p' 'scaffold'
    with initial bc_U621
    with plural bc_U622
    with article bc_U623
    with list_together bc_U624
;
K24_colored_fuse I_indigo_fuse_U1    with short_name bc_U625
    with description bc_U626
    with P_underlying_relation_storag I_guillotine_platform_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 59
    with K2_thing_Next I_merchandise_stand_U1
    with K24_colored_fuse_Count 4
    with K24_colored_fuse_Next I_khaki_fuse_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indigo' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U627
    with plural bc_U628
    with article bc_U629
    with list_together bc_U630
;
K1_room I_ride_exit_U1    with short_name bc_U631
    with description ts_array_U462
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 13
    with K1_room_Next I_dark_passage_U1
    with name 'ride' 'exit' 'rooms//p'
    with plural bc_U632
    with article bc_U633
    with list_together bc_U634
;
K5_container -> I_merchandise_stand_U1    with short_name bc_U635
    with description bc_U636
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 60
    with K2_thing_Next I_khaki_fuse_U1
    with IK5_Count 8
    with K5_container_Next I_pile_of_junk_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name87
    with name 'merchandise' 'stand' 'containers//p' 'stand'
    with initial bc_U637
    with plural bc_U638
    with article bc_U639
    with list_together bc_U640
;
K24_colored_fuse -> -> I_khaki_fuse_U1    with short_name bc_U641
    with description bc_U642
    with P_underlying_relation_storag I_merchandise_stand_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 61
    with K2_thing_Next I_dust_bunnies_U1
    with K24_colored_fuse_Count 5
    with K24_colored_fuse_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'khaki' 'fuse' 'colored//p' 'fuses//p'
    with initial bc_U643
    with plural bc_U644
    with article bc_U645
    with list_together bc_U646
;
K1_room I_dark_passage_U1    with short_name bc_U647
    with description bc_U648
    with map_region I_backstage_U1
    has proper
    has P_scored
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 14
    with K1_room_Next I_maintenance_office_U1
    with name 'dark' 'passage' 'rooms//p'
    with plural bc_U649
    with article bc_U650
    with list_together bc_U651
;
K2_thing -> I_dust_bunnies_U1    with short_name bc_U652
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 62
    with K2_thing_Next I_bags_of_trash_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name90
    with name 'dust' 'bunnies' 'things//p' 'bunnies'
    with description bc_U653
    with initial bc_U654
    with plural bc_U655
    with article bc_U656
    with list_together bc_U657
;
K2_thing -> I_bags_of_trash_U1    with short_name bc_U658
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 63
    with K2_thing_Next I_pile_of_junk_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name91
    with name 'bags' 'of' 'trash' 'things//p' 'bags' 'trash'
    with description bc_U659
    with initial bc_U660
    with plural bc_U661
    with article bc_U662
    with list_together bc_U663
;
K5_container -> I_pile_of_junk_U1    with short_name bc_U664
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 64
    with K2_thing_Next I_flashlight_U1
    with IK5_Count 9
    with K5_container_Next I_drawer_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name92
    with name 'pile' 'of' 'junk' 'containers//p' 'piles' 'junk'
    with description bc_U665
    with initial bc_U666
    with plural bc_U667
    with article bc_U668
    with list_together bc_U669
;
K21_electric_lamp -> -> I_flashlight_U1    with short_name bc_U238
    with description ts_array_U439
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 21
    with IK2_Count 3
    with K2_thing_Next I_desk_U1
    with K13_device_Count 0
    with K13_device_Next I_radio_U1
    with K21_electric_lamp_Count 0
    with K21_electric_lamp_Next 0
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name16
    with name 'flashlight' 'electric//p' 'lamps//p' 'light'
    with initial bc_U239
    with plural bc_U240
    with article bc_U241
    with list_together bc_U242
;
K1_room I_maintenance_office_U1    with short_name bc_U670
    with description bc_U671
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 15
    with K1_room_Next I_dark_hallway_U1
    with name 'maintenance' 'office' 'rooms//p'
    with plural bc_U672
    with article bc_U673
    with list_together bc_U674
;
K6_supporter -> I_desk_U1    with short_name bc_U675
    with description ts_array_U463
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with component_child I_drawer_U1
    with KD_Count 6
    with IK2_Count 65
    with K2_thing_Next I_radio_U1
    with IK6_Count 7
    with K6_supporter_Next I_control_panel_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'desk' 'supporters//p'
    with initial bc_U676
    with plural bc_U677
    with article bc_U678
    with list_together bc_U679
;
K13_device -> -> I_radio_U1    with short_name bc_U686
    with initial ts_array_U464
    has static
    has ~on
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 13
    with IK2_Count 67
    with K2_thing_Next I_cans_of_paint_U1
    with K13_device_Count 1
    with K13_device_Next I_switch_eleven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'radio' 'devices//p'
    with description bc_U687
    with plural bc_U688
    with article bc_U689
    with list_together bc_U690
;
K2_thing -> I_cans_of_paint_U1    with short_name bc_U726
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 74
    with K2_thing_Next I_grease_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'cans' 'of' 'paint' 'things//p'
    with description bc_U727
    with initial bc_U728
    with plural bc_U729
    with article bc_U730
    with list_together bc_U731
;
K2_thing -> I_grease_U1    with short_name bc_U732
    has proper
    with vector 0
    with cap_short_name bc_U733
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 75
    with K2_thing_Next I_lubricant_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'grease' 'things//p'
    with description bc_U734
    with initial bc_U735
    with plural bc_U736
    with article bc_U737
    with list_together bc_U738
;
K2_thing -> I_lubricant_U1    with short_name bc_U739
    has proper
    with vector 0
    with cap_short_name bc_U740
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 76
    with K2_thing_Next I_drawer_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'lubricant' 'things//p'
    with description bc_U741
    with initial bc_U742
    with plural bc_U743
    with article bc_U744
    with list_together bc_U745
;
K5_container I_drawer_U1    with short_name bc_U680
    has static
    has scenery
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_desk_U1
    with KD_Count 5
    with IK2_Count 66
    with K2_thing_Next I_scissors_U1
    with IK5_Count 10
    with K5_container_Next I_toolbox_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'drawer' 'containers//p'
    with description bc_U681
    with initial bc_U682
    with plural bc_U683
    with article bc_U684
    with list_together bc_U685
;
K2_thing -> I_scissors_U1    with short_name bc_U691
    with description bc_U692
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 68
    with K2_thing_Next I_stapler_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'scissors' 'things//p'
    with initial bc_U693
    with plural bc_U694
    with article bc_U695
    with list_together bc_U696
;
K2_thing -> I_stapler_U1    with short_name bc_U697
    with description bc_U698
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 69
    with K2_thing_Next I_ballpoint_pen_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'stapler' 'things//p'
    with initial bc_U699
    with plural bc_U700
    with article bc_U701
    with list_together bc_U702
;
K2_thing -> I_ballpoint_pen_U1    with short_name bc_U703
    with description bc_U704
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 70
    with K2_thing_Next I_pad_of_paper_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'ballpoint' 'pen' 'things//p'
    with initial bc_U705
    with plural bc_U706
    with article bc_U707
    with list_together bc_U708
;
K2_thing -> I_pad_of_paper_U1    with short_name bc_U709
    with description bc_U710
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 71
    with K2_thing_Next I_aqua_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'pad' 'of' 'paper' 'things//p'
    with initial bc_U711
    with plural bc_U712
    with article bc_U713
    with list_together bc_U714
;
K4_door I_aqua_door_U1    with short_name bc_U715
    with description ts_array_U465
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_maintenance_office_U1 I_stocks_room_U1
    has door
    with door_dir TSD_door_dir_value1
    with door_to TSD_door_to_value1
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 72
    with K2_thing_Next I_ladder_U1
    with IK4_Count 0
    with K4_door_Next I_ladder_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'aqua' 'door' 'doors//p'
    with initial bc_U716
    with plural bc_U717
    with article bc_U718
    with list_together bc_U719
;
K4_door I_ladder_U1    with short_name bc_U746
    with description ts_array_U466
    has open
    with vector 0
    with found_in I_maintenance_office_U1 I_dark_hallway_U1
    has door
    with door_dir TSD_door_dir_value2
    with door_to TSD_door_to_value2
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 77
    with K2_thing_Next I_crimson_door_U1
    with IK4_Count 1
    with K4_door_Next I_crimson_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'ladder' 'doors//p'
    with initial bc_U747
    with plural bc_U748
    with article bc_U749
    with list_together bc_U750
;
K1_room I_dark_hallway_U1    with short_name bc_U751
    with description bc_U752
    with map_region I_second_floor_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 16
    with K1_room_Next I_crawl_space_U1
    with name 'dark' 'hallway' 'rooms//p'
    with plural bc_U753
    with article bc_U754
    with list_together bc_U755
;
K1_room I_crawl_space_U1    with short_name bc_U756
    with description bc_U757
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 17
    with K1_room_Next I_mechanical_room_north_U1
    with name 'crawl' 'space' 'rooms//p'
    with plural bc_U758
    with article bc_U759
    with list_together bc_U760
;
K4_door I_crimson_door_U1    with short_name bc_U761
    with description ts_array_U467
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_crawl_space_U1 I_gallows_room_U1
    has door
    with door_dir TSD_door_dir_value3
    with door_to TSD_door_to_value3
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 78
    with K2_thing_Next I_toolbox_U1
    with IK4_Count 2
    with K4_door_Next I_emerald_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'crimson' 'door' 'doors//p'
    with initial bc_U762
    with plural bc_U763
    with article bc_U764
    with list_together bc_U765
;
K1_room I_mechanical_room_north_U1    with short_name bc_U766
    with description bc_U767
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 18
    with K1_room_Next I_mechanical_room_south_U1
    with name 'mechanical' 'room' 'north' 'rooms//p'
    with plural bc_U768
    with article bc_U769
    with list_together bc_U770
;
K5_container -> I_toolbox_U1    with short_name bc_U771
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 79
    with K2_thing_Next I_monkey_wrench_U1
    with IK5_Count 11
    with K5_container_Next I_electrical_panel_eleven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'toolbox' 'containers//p'
    with description bc_U772
    with initial bc_U773
    with plural bc_U774
    with article bc_U775
    with list_together bc_U776
;
K2_thing -> -> I_monkey_wrench_U1    with short_name bc_U777
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 80
    with K2_thing_Next I_channel_locks_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'monkey' 'wrench' 'things//p'
    with description bc_U778
    with initial bc_U779
    with plural bc_U780
    with article bc_U781
    with list_together bc_U782
;
K2_thing -> -> I_channel_locks_U1    with short_name bc_U783
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 81
    with K2_thing_Next I_pliers_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'channel' 'locks' 'things//p'
    with description bc_U784
    with initial bc_U785
    with plural bc_U786
    with article bc_U787
    with list_together bc_U788
;
K2_thing -> -> I_pliers_U1    with short_name bc_U789
    has proper
    with vector 0
    with cap_short_name bc_U790
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 82
    with K2_thing_Next I_hammer_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'pliers' 'things//p'
    with description bc_U791
    with initial bc_U792
    with plural bc_U793
    with article bc_U794
    with list_together bc_U795
;
K2_thing -> -> I_hammer_U1    with short_name bc_U796
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 83
    with K2_thing_Next I_emerald_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'hammer' 'things//p'
    with description bc_U797
    with initial bc_U798
    with plural bc_U799
    with article bc_U800
    with list_together bc_U801
;
K4_door I_emerald_door_U1    with short_name bc_U802
    with description ts_array_U468
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_mechanical_room_north_U1 I_stake_room_U1
    has door
    with door_dir TSD_door_dir_value4
    with door_to TSD_door_to_value4
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 84
    with K2_thing_Next I_gray_door_U1
    with IK4_Count 3
    with K4_door_Next I_gray_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'emerald' 'door' 'doors//p'
    with initial bc_U803
    with plural bc_U804
    with article bc_U805
    with list_together bc_U806
;
K1_room I_mechanical_room_south_U1    with short_name bc_U807
    with description bc_U808
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 19
    with K1_room_Next I_generator_room_U1
    with name 'mechanical' 'room' 'south' 'rooms//p'
    with plural bc_U809
    with article bc_U810
    with list_together bc_U811
;
K4_door I_gray_door_U1    with short_name bc_U812
    with description ts_array_U469
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_mechanical_room_south_U1 I_dungeon_U1
    has door
    with door_dir TSD_door_dir_value5
    with door_to TSD_door_to_value5
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 85
    with K2_thing_Next I_indigo_door_U1
    with IK4_Count 4
    with K4_door_Next I_indigo_door_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name118
    with name 'gray' 'door' 'doors//p' 'grey'
    with initial bc_U813
    with plural bc_U814
    with article bc_U815
    with list_together bc_U816
;
K1_room I_generator_room_U1    with short_name bc_U817
    with description bc_U818
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 20
    with K1_room_Next I_electrical_room_U1
    with name 'generator' 'room' 'rooms//p'
    with plural bc_U819
    with article bc_U820
    with list_together bc_U821
;
K4_door I_indigo_door_U1    with short_name bc_U822
    with description ts_array_U470
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_generator_room_U1 I_guillotine_room_U1
    has door
    with door_dir TSD_door_dir_value6
    with door_to TSD_door_to_value6
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 86
    with K2_thing_Next I_electrical_panel_eleven_U1
    with IK4_Count 5
    with K4_door_Next I_khaki_door_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indigo' 'door' 'doors//p'
    with initial bc_U823
    with plural bc_U824
    with article bc_U825
    with list_together bc_U826
;
K1_room I_electrical_room_U1    with short_name bc_U827
    with description bc_U828
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 21
    with K1_room_Next I_electrical_closet_eleven_U1
    with name 'electrical' 'room' 'rooms//p'
    with plural bc_U829
    with article bc_U830
    with list_together bc_U831
;
K1_room I_electrical_closet_eleven_U1    with short_name bc_U832
    with description bc_U833
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 22
    with K1_room_Next I_electrical_closet_nine_U1
    with name 'electrical' 'closet' 'eleven' 'rooms//p'
    with plural bc_U834
    with article bc_U835
    with list_together bc_U836
;
K5_container -> I_electrical_panel_eleven_U1    with short_name bc_U837
    with description ts_array_U471
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_switch_eleven_U1
    with KD_Count 5
    with IK2_Count 87
    with K2_thing_Next I_socket_eleven_U1
    with IK5_Count 12
    with K5_container_Next I_socket_eleven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'eleven' 'containers//p'
    with initial bc_U838
    with plural bc_U839
    with article bc_U840
    with list_together bc_U841
;
K23_socket -> -> I_socket_eleven_U1    with description bc_U842
    has proper
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 23
    with IK2_Count 88
    with K2_thing_Next I_switch_eleven_U1
    with IK5_Count 13
    with K5_container_Next I_electrical_panel_nine_U1
    with K23_socket_Count 0
    with K23_socket_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'eleven' 'sockets//p'
    with initial bc_U843
    with short_name bc_U844
    with plural bc_U845
    with article bc_U846
    with list_together bc_U847
;
K13_device I_switch_eleven_U1    with short_name bc_U848
    with description ts_array_U472
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_eleven_U1
    with component_sibling I_indicator_light_eleven_U1
    has switchable
    with KD_Count 13
    with IK2_Count 89
    with K2_thing_Next I_indicator_light_eleven_U1
    with K13_device_Count 2
    with K13_device_Next I_indicator_light_eleven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'eleven' 'devices//p'
    with initial bc_U849
    with plural bc_U850
    with article bc_U851
    with list_together bc_U852
;
K13_device I_indicator_light_eleven_U1    with short_name bc_U853
    with description ts_array_U473
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_eleven_U1
    has switchable
    with KD_Count 13
    with IK2_Count 90
    with K2_thing_Next I_electrical_panel_nine_U1
    with K13_device_Count 3
    with K13_device_Next I_switch_nine_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'eleven' 'devices//p'
    with initial bc_U854
    with plural bc_U855
    with article bc_U856
    with list_together bc_U857
;
K1_room I_electrical_closet_nine_U1    with short_name bc_U858
    with description bc_U859
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 23
    with K1_room_Next I_electrical_closet_seven_U1
    with name 'electrical' 'closet' 'nine' 'rooms//p'
    with plural bc_U860
    with article bc_U861
    with list_together bc_U862
;
K5_container -> I_electrical_panel_nine_U1    with short_name bc_U863
    with description ts_array_U474
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_switch_nine_U1
    with KD_Count 5
    with IK2_Count 91
    with K2_thing_Next I_socket_nine_U1
    with IK5_Count 14
    with K5_container_Next I_socket_nine_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'nine' 'containers//p'
    with initial bc_U864
    with plural bc_U865
    with article bc_U866
    with list_together bc_U867
;
K5_container -> -> I_socket_nine_U1    with short_name bc_U868
    with description bc_U869
    has proper
    has static
    has open
    has ~P_filled
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 92
    with K2_thing_Next I_switch_nine_U1
    with IK5_Count 15
    with K5_container_Next I_electrical_panel_seven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'nine' 'containers//p'
    with initial bc_U870
    with plural bc_U871
    with article bc_U872
    with list_together bc_U873
;
K13_device I_switch_nine_U1    with short_name bc_U874
    with description ts_array_U475
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_nine_U1
    with component_sibling I_indicator_light_nine_U1
    has switchable
    with KD_Count 13
    with IK2_Count 93
    with K2_thing_Next I_indicator_light_nine_U1
    with K13_device_Count 4
    with K13_device_Next I_indicator_light_nine_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'nine' 'devices//p'
    with initial bc_U875
    with plural bc_U876
    with article bc_U877
    with list_together bc_U878
;
K13_device I_indicator_light_nine_U1    with short_name bc_U879
    with description ts_array_U476
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_nine_U1
    has switchable
    with KD_Count 13
    with IK2_Count 94
    with K2_thing_Next I_electrical_panel_seven_U1
    with K13_device_Count 5
    with K13_device_Next I_switch_seven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'nine' 'devices//p'
    with initial bc_U880
    with plural bc_U881
    with article bc_U882
    with list_together bc_U883
;
K1_room I_electrical_closet_seven_U1    with short_name bc_U884
    with description bc_U885
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 24
    with K1_room_Next I_electrical_closet_five_U1
    with name 'electrical' 'closet' 'seven' 'rooms//p'
    with plural bc_U886
    with article bc_U887
    with list_together bc_U888
;
K5_container -> I_electrical_panel_seven_U1    with short_name bc_U889
    with description ts_array_U477
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_switch_seven_U1
    with KD_Count 5
    with IK2_Count 95
    with K2_thing_Next I_socket_seven_U1
    with IK5_Count 16
    with K5_container_Next I_socket_seven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'seven' 'containers//p'
    with initial bc_U890
    with plural bc_U891
    with article bc_U892
    with list_together bc_U893
;
K5_container -> -> I_socket_seven_U1    with short_name bc_U894
    with description bc_U895
    has proper
    has static
    has open
    has ~P_filled
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 96
    with K2_thing_Next I_switch_seven_U1
    with IK5_Count 17
    with K5_container_Next I_electrical_panel_five_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'seven' 'containers//p'
    with initial bc_U896
    with plural bc_U897
    with article bc_U898
    with list_together bc_U899
;
K13_device I_switch_seven_U1    with short_name bc_U900
    with description ts_array_U478
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_seven_U1
    with component_sibling I_indicator_light_seven_U1
    has switchable
    with KD_Count 13
    with IK2_Count 97
    with K2_thing_Next I_indicator_light_seven_U1
    with K13_device_Count 6
    with K13_device_Next I_indicator_light_seven_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'seven' 'devices//p'
    with initial bc_U901
    with plural bc_U902
    with article bc_U903
    with list_together bc_U904
;
K13_device I_indicator_light_seven_U1    with short_name bc_U905
    with description ts_array_U479
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_seven_U1
    has switchable
    with KD_Count 13
    with IK2_Count 98
    with K2_thing_Next I_electrical_panel_five_U1
    with K13_device_Count 7
    with K13_device_Next I_switch_five_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'seven' 'devices//p'
    with initial bc_U906
    with plural bc_U907
    with article bc_U908
    with list_together bc_U909
;
K1_room I_electrical_closet_five_U1    with short_name bc_U910
    with description bc_U911
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 25
    with K1_room_Next I_electrical_closet_three_U1
    with name 'electrical' 'closet' 'five' 'rooms//p'
    with plural bc_U912
    with article bc_U913
    with list_together bc_U914
;
K5_container -> I_electrical_panel_five_U1    with short_name bc_U915
    with description ts_array_U480
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_indicator_light_five_U1
    with KD_Count 5
    with IK2_Count 99
    with K2_thing_Next I_socket_five_U1
    with IK5_Count 18
    with K5_container_Next I_socket_five_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'five' 'containers//p'
    with initial bc_U916
    with plural bc_U917
    with article bc_U918
    with list_together bc_U919
;
K5_container -> -> I_socket_five_U1    with short_name bc_U920
    with description bc_U921
    has proper
    has static
    has open
    has ~P_filled
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 100
    with K2_thing_Next I_switch_five_U1
    with IK5_Count 19
    with K5_container_Next I_electrical_panel_three_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'five' 'containers//p'
    with initial bc_U922
    with plural bc_U923
    with article bc_U924
    with list_together bc_U925
;
K13_device -> -> I_switch_five_U1    with short_name bc_U926
    with description ts_array_U481
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 13
    with IK2_Count 101
    with K2_thing_Next I_indicator_light_five_U1
    with K13_device_Count 8
    with K13_device_Next I_indicator_light_five_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'five' 'devices//p'
    with initial bc_U927
    with plural bc_U928
    with article bc_U929
    with list_together bc_U930
;
K13_device I_indicator_light_five_U1    with short_name bc_U931
    with description ts_array_U482
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_five_U1
    has switchable
    with KD_Count 13
    with IK2_Count 102
    with K2_thing_Next I_electrical_panel_three_U1
    with K13_device_Count 9
    with K13_device_Next I_switch_three_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'five' 'devices//p'
    with initial bc_U932
    with plural bc_U933
    with article bc_U934
    with list_together bc_U935
;
K1_room I_electrical_closet_three_U1    with short_name bc_U936
    with description bc_U937
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 26
    with K1_room_Next I_electrical_closet_one_U1
    with name 'electrical' 'closet' 'three' 'rooms//p'
    with plural bc_U938
    with article bc_U939
    with list_together bc_U940
;
K5_container -> I_electrical_panel_three_U1    with short_name bc_U941
    with description ts_array_U483
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_switch_three_U1
    with KD_Count 5
    with IK2_Count 103
    with K2_thing_Next I_socket_three_U1
    with IK5_Count 20
    with K5_container_Next I_socket_three_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'three' 'containers//p'
    with initial bc_U942
    with plural bc_U943
    with article bc_U944
    with list_together bc_U945
;
K5_container -> -> I_socket_three_U1    with short_name bc_U946
    with description bc_U947
    has proper
    has static
    has open
    has ~P_filled
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 104
    with K2_thing_Next I_switch_three_U1
    with IK5_Count 21
    with K5_container_Next I_electrical_panel_one_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'three' 'containers//p'
    with initial bc_U948
    with plural bc_U949
    with article bc_U950
    with list_together bc_U951
;
K13_device I_switch_three_U1    with short_name bc_U952
    with description ts_array_U484
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_three_U1
    with component_sibling I_indicator_light_three_U1
    has switchable
    with KD_Count 13
    with IK2_Count 105
    with K2_thing_Next I_indicator_light_three_U1
    with K13_device_Count 10
    with K13_device_Next I_indicator_light_three_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'three' 'devices//p'
    with initial bc_U953
    with plural bc_U954
    with article bc_U955
    with list_together bc_U956
;
K13_device I_indicator_light_three_U1    with short_name bc_U957
    with description ts_array_U485
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_three_U1
    has switchable
    with KD_Count 13
    with IK2_Count 106
    with K2_thing_Next I_silver_key_U1
    with K13_device_Count 11
    with K13_device_Next I_switch_one_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'three' 'devices//p'
    with initial bc_U958
    with plural bc_U959
    with article bc_U960
    with list_together bc_U961
;
K1_room I_electrical_closet_one_U1    with short_name bc_U962
    with description bc_U963
    with map_region I_backstage_U1
    has ~light
    has P_scored
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 27
    with K1_room_Next I_storage_room_U1
    with name 'electrical' 'closet' 'one' 'rooms//p'
    with plural bc_U964
    with article bc_U965
    with list_together bc_U966
;
K2_thing -> I_silver_key_U1    with short_name bc_U720
    with description bc_U721
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 73
    with K2_thing_Next I_electrical_panel_one_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'silver' 'key' 'things//p'
    with initial bc_U722
    with plural bc_U723
    with article bc_U724
    with list_together bc_U725
;
K5_container -> I_electrical_panel_one_U1    with short_name bc_U967
    with description ts_array_U486
    with with_key I_swiss_army_knife_U1
    has proper
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_child I_switch_one_U1
    with KD_Count 5
    with IK2_Count 107
    with K2_thing_Next I_socket_one_U1
    with IK5_Count 22
    with K5_container_Next I_socket_one_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'electrical' 'panel' 'one' 'containers//p'
    with initial bc_U968
    with plural bc_U969
    with article bc_U970
    with list_together bc_U971
;
K5_container -> -> I_socket_one_U1    with short_name bc_U972
    with description bc_U973
    has proper
    has static
    has open
    has ~P_filled
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 108
    with K2_thing_Next I_switch_one_U1
    with IK5_Count 23
    with K5_container_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'socket' 'one' 'containers//p'
    with initial bc_U974
    with plural bc_U975
    with article bc_U976
    with list_together bc_U977
;
K13_device I_switch_one_U1    with short_name bc_U978
    with description ts_array_U487
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_one_U1
    with component_sibling I_indicator_light_one_U1
    has switchable
    with KD_Count 13
    with IK2_Count 109
    with K2_thing_Next I_indicator_light_one_U1
    with K13_device_Count 12
    with K13_device_Next I_indicator_light_one_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'switch' 'one' 'devices//p'
    with initial bc_U979
    with plural bc_U980
    with article bc_U981
    with list_together bc_U982
;
K13_device I_indicator_light_one_U1    with short_name bc_U983
    with description ts_array_U488
    has proper
    has ~on
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_panel_one_U1
    has switchable
    with KD_Count 13
    with IK2_Count 110
    with K2_thing_Next I_khaki_door_U1
    with K13_device_Count 13
    with K13_device_Next I_aqua_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indicator' 'light' 'one' 'devices//p'
    with initial bc_U984
    with plural bc_U985
    with article bc_U986
    with list_together bc_U987
;
K1_room I_storage_room_U1    with short_name bc_U988
    with description ts_array_U489
    with map_region I_backstage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 28
    with K1_room_Next I_control_room_U1
    with name 'storage' 'room' 'rooms//p'
    with plural bc_U989
    with article bc_U990
    with list_together bc_U991
;
K4_door I_khaki_door_U1    with short_name bc_U992
    with description ts_array_U490
    with with_key I_silver_key_U1
    has ~open
    has lockable
    has locked
    with vector 0
    with found_in I_storage_room_U1 I_ride_exit_U1
    has door
    with door_dir TSD_door_dir_value7
    with door_to TSD_door_to_value7
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 111
    with K2_thing_Next I_control_panel_U1
    with IK4_Count 6
    with K4_door_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'khaki' 'door' 'doors//p'
    with initial bc_U993
    with plural bc_U994
    with article bc_U995
    with list_together bc_U996
;
K1_room I_control_room_U1    with short_name bc_U997
    with description bc_U998
    with map_region I_second_floor_U1
    has proper
    has ~light
    has P_scored
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 29
    with K1_room_Next I_holding_room_U1
    with name 'control' 'room' 'rooms//p'
    with plural bc_U999
    with article bc_U1000
    with list_together bc_U1001
;
K6_supporter -> I_control_panel_U1    with short_name bc_U1002
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with component_child I_aqua_light_U1
    with KD_Count 6
    with IK2_Count 112
    with K2_thing_Next I_aqua_light_U1
    with IK6_Count 8
    with K6_supporter_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'control' 'panel' 'supporters//p'
    with description bc_U1003
    with initial bc_U1004
    with plural bc_U1005
    with article bc_U1006
    with list_together bc_U1007
;
K25_colored_light I_aqua_light_U1    with short_name bc_U1008
    with description ts_array_U491
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_crimson_light_U1
    has switchable
    with KD_Count 25
    with IK2_Count 113
    with K2_thing_Next I_crimson_light_U1
    with K13_device_Count 14
    with K13_device_Next I_crimson_light_U1
    with K25_colored_light_Count 0
    with K25_colored_light_Next I_crimson_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'aqua' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1009
    with plural bc_U1010
    with article bc_U1011
    with list_together bc_U1012
;
K25_colored_light I_crimson_light_U1    with short_name bc_U1013
    with description ts_array_U492
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_emerald_light_U1
    has switchable
    with KD_Count 25
    with IK2_Count 114
    with K2_thing_Next I_emerald_light_U1
    with K13_device_Count 15
    with K13_device_Next I_emerald_light_U1
    with K25_colored_light_Count 1
    with K25_colored_light_Next I_emerald_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'crimson' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1014
    with plural bc_U1015
    with article bc_U1016
    with list_together bc_U1017
;
K25_colored_light I_emerald_light_U1    with short_name bc_U1018
    with description ts_array_U493
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_gray_light_U1
    has switchable
    with KD_Count 25
    with IK2_Count 115
    with K2_thing_Next I_gray_light_U1
    with K13_device_Count 16
    with K13_device_Next I_gray_light_U1
    with K25_colored_light_Count 2
    with K25_colored_light_Next I_gray_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'emerald' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1019
    with plural bc_U1020
    with article bc_U1021
    with list_together bc_U1022
;
K25_colored_light I_gray_light_U1    with short_name bc_U1023
    with description ts_array_U494
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_indigo_light_U1
    has switchable
    with KD_Count 25
    with IK2_Count 116
    with K2_thing_Next I_indigo_light_U1
    with K13_device_Count 17
    with K13_device_Next I_indigo_light_U1
    with K25_colored_light_Count 3
    with K25_colored_light_Next I_indigo_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'gray' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1024
    with plural bc_U1025
    with article bc_U1026
    with list_together bc_U1027
;
K25_colored_light I_indigo_light_U1    with short_name bc_U1028
    with description ts_array_U495
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_khaki_light_U1
    has switchable
    with KD_Count 25
    with IK2_Count 117
    with K2_thing_Next I_khaki_light_U1
    with K13_device_Count 18
    with K13_device_Next I_khaki_light_U1
    with K25_colored_light_Count 4
    with K25_colored_light_Next I_khaki_light_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indigo' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1029
    with plural bc_U1030
    with article bc_U1031
    with list_together bc_U1032
;
K25_colored_light I_khaki_light_U1    with short_name bc_U1033
    with description ts_array_U496
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_aqua_button_U1
    has switchable
    with KD_Count 25
    with IK2_Count 118
    with K2_thing_Next I_aqua_button_U1
    with K13_device_Count 19
    with K13_device_Next I_aqua_button_U1
    with K25_colored_light_Count 5
    with K25_colored_light_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'khaki' 'light' 'colored//p' 'lights//p' 'indicator'
    with initial bc_U1034
    with plural bc_U1035
    with article bc_U1036
    with list_together bc_U1037
;
K26_colored_button I_aqua_button_U1    with short_name bc_U1038
    with description bc_U1039
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_crimson_button_U1
    has switchable
    with KD_Count 26
    with IK2_Count 119
    with K2_thing_Next I_crimson_button_U1
    with K13_device_Count 20
    with K13_device_Next I_crimson_button_U1
    with K26_colored_button_Count 0
    with K26_colored_button_Next I_crimson_button_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'aqua' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1040
    with plural bc_U1041
    with article bc_U1042
    with list_together bc_U1043
;
K26_colored_button I_crimson_button_U1    with short_name bc_U1044
    with description bc_U1045
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_emerald_button_U1
    has switchable
    with KD_Count 26
    with IK2_Count 120
    with K2_thing_Next I_emerald_button_U1
    with K13_device_Count 21
    with K13_device_Next I_emerald_button_U1
    with K26_colored_button_Count 1
    with K26_colored_button_Next I_emerald_button_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'crimson' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1046
    with plural bc_U1047
    with article bc_U1048
    with list_together bc_U1049
;
K26_colored_button I_emerald_button_U1    with short_name bc_U1050
    with description bc_U1051
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_gray_button_U1
    has switchable
    with KD_Count 26
    with IK2_Count 121
    with K2_thing_Next I_gray_button_U1
    with K13_device_Count 22
    with K13_device_Next I_gray_button_U1
    with K26_colored_button_Count 2
    with K26_colored_button_Next I_gray_button_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'emerald' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1052
    with plural bc_U1053
    with article bc_U1054
    with list_together bc_U1055
;
K26_colored_button I_gray_button_U1    with short_name bc_U1056
    with description bc_U1057
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_indigo_button_U1
    has switchable
    with KD_Count 26
    with IK2_Count 122
    with K2_thing_Next I_indigo_button_U1
    with K13_device_Count 23
    with K13_device_Next I_indigo_button_U1
    with K26_colored_button_Count 3
    with K26_colored_button_Next I_indigo_button_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'gray' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1058
    with plural bc_U1059
    with article bc_U1060
    with list_together bc_U1061
;
K26_colored_button I_indigo_button_U1    with short_name bc_U1062
    with description bc_U1063
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_khaki_button_U1
    has switchable
    with KD_Count 26
    with IK2_Count 123
    with K2_thing_Next I_khaki_button_U1
    with K13_device_Count 24
    with K13_device_Next I_khaki_button_U1
    with K26_colored_button_Count 4
    with K26_colored_button_Next I_khaki_button_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indigo' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1064
    with plural bc_U1065
    with article bc_U1066
    with list_together bc_U1067
;
K26_colored_button I_khaki_button_U1    with short_name bc_U1068
    with description bc_U1069
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_monitor_U1
    has switchable
    with KD_Count 26
    with IK2_Count 124
    with K2_thing_Next I_monitor_U1
    with K13_device_Count 25
    with K13_device_Next I_aqua_dial_U1
    with K26_colored_button_Count 5
    with K26_colored_button_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'khaki' 'button' 'colored//p' 'buttons//p'
    with initial bc_U1070
    with plural bc_U1071
    with article bc_U1072
    with list_together bc_U1073
;
K2_thing I_monitor_U1    with short_name bc_U1074
    has static
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_aqua_dial_U1
    with KD_Count 2
    with IK2_Count 125
    with K2_thing_Next I_aqua_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with parse_name parse_name168
    with name 'monitor' 'things//p' 'screen'
    with description bc_U1075
    with initial bc_U1076
    with plural bc_U1077
    with article bc_U1078
    with list_together bc_U1079
;
K27_colored_dial I_aqua_dial_U1    with short_name bc_U1080
    with description ts_array_U497
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_crimson_dial_U1
    has switchable
    with KD_Count 27
    with IK2_Count 126
    with K2_thing_Next I_crimson_dial_U1
    with K13_device_Count 26
    with K13_device_Next I_crimson_dial_U1
    with K27_colored_dial_Count 0
    with K27_colored_dial_Next I_crimson_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'aqua' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1081
    with plural bc_U1082
    with article bc_U1083
    with list_together bc_U1084
;
K27_colored_dial I_crimson_dial_U1    with short_name bc_U1085
    with description ts_array_U498
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_emerald_dial_U1
    has switchable
    with KD_Count 27
    with IK2_Count 127
    with K2_thing_Next I_emerald_dial_U1
    with K13_device_Count 27
    with K13_device_Next I_emerald_dial_U1
    with K27_colored_dial_Count 1
    with K27_colored_dial_Next I_emerald_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'crimson' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1086
    with plural bc_U1087
    with article bc_U1088
    with list_together bc_U1089
;
K27_colored_dial I_emerald_dial_U1    with short_name bc_U1090
    with description ts_array_U499
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_gray_dial_U1
    has switchable
    with KD_Count 27
    with IK2_Count 128
    with K2_thing_Next I_gray_dial_U1
    with K13_device_Count 28
    with K13_device_Next I_gray_dial_U1
    with K27_colored_dial_Count 2
    with K27_colored_dial_Next I_gray_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'emerald' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1091
    with plural bc_U1092
    with article bc_U1093
    with list_together bc_U1094
;
K27_colored_dial I_gray_dial_U1    with short_name bc_U1095
    with description ts_array_U500
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_indigo_dial_U1
    has switchable
    with KD_Count 27
    with IK2_Count 129
    with K2_thing_Next I_indigo_dial_U1
    with K13_device_Count 29
    with K13_device_Next I_indigo_dial_U1
    with K27_colored_dial_Count 3
    with K27_colored_dial_Next I_indigo_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'gray' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1096
    with plural bc_U1097
    with article bc_U1098
    with list_together bc_U1099
;
K27_colored_dial I_indigo_dial_U1    with short_name bc_U1100
    with description ts_array_U501
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    with component_sibling I_khaki_dial_U1
    has switchable
    with KD_Count 27
    with IK2_Count 130
    with K2_thing_Next I_khaki_dial_U1
    with K13_device_Count 30
    with K13_device_Next I_khaki_dial_U1
    with K27_colored_dial_Count 4
    with K27_colored_dial_Next I_khaki_dial_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'indigo' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1101
    with plural bc_U1102
    with article bc_U1103
    with list_together bc_U1104
;
K27_colored_dial I_khaki_dial_U1    with short_name bc_U1105
    with description ts_array_U502
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_U1
    has switchable
    with KD_Count 27
    with IK2_Count 131
    with K2_thing_Next 0
    with K13_device_Count 31
    with K13_device_Next 0
    with K27_colored_dial_Count 5
    with K27_colored_dial_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'khaki' 'dial' 'colored//p' 'dials//p'
    with initial bc_U1106
    with plural bc_U1107
    with article bc_U1108
    with list_together bc_U1109
;
K1_room I_holding_room_U1    with short_name bc_U1110
    with description bc_U1111
    with map_region I_second_floor_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 30
    with K1_room_Next 0
    with name 'holding' 'room' 'rooms//p'
    with plural bc_U1112
    with article bc_U1113
    with list_together bc_U1114
;
K9_region I_midway_U1    with short_name bc_U1115
    with vector 0
    with regional_found_in RFI_for_I1
    with KD_Count 9
    with IK9_Count 0
    with K9_region_Next I_hellride_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'midway' 'regions//p'
    with plural bc_U1116
    with article bc_U1117
    with list_together bc_U1118
;
K9_region I_hellride_U1    with short_name bc_U1119
    has proper
    with vector 0
    with regional_found_in RFI_for_I2
    with KD_Count 9
    with IK9_Count 1
    with K9_region_Next I_backstage_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'hellride' 'regions//p'
    with plural bc_U1120
    with article bc_U1121
    with list_together bc_U1122
;
K9_region I_backstage_U1    with short_name bc_U1123
    has proper
    with vector 0
    with regional_found_in RFI_for_I3
    with KD_Count 9
    with IK9_Count 2
    with K9_region_Next I_second_floor_U1
    with action_bitmap 0 0 0 0 0 0
    with name 'backstage' 'regions//p'
    with plural bc_U1124
    with article bc_U1125
    with list_together bc_U1126
;
K9_region I_second_floor_U1    with short_name bc_U1127
    has proper
    with vector 0
    with regional_found_in RFI_for_I4
    with KD_Count 9
    with IK9_Count 3
    with K9_region_Next 0
    with action_bitmap 0 0 0 0 0 0
    with name 'second' 'floor' 'regions//p'
    with plural bc_U1128
    with article bc_U1129
    with list_together bc_U1130
;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef before; Constant before = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef P_variable_initial_value; Constant P_variable_initial_value = 0; #endif;
#ifndef P_specification; Constant P_specification = 0; #endif;
#ifndef P_indefinite_appearance_text; Constant P_indefinite_appearance_text = 0; #endif;
#ifndef P_adaptive_text_viewpoint; Constant P_adaptive_text_viewpoint = 0; #endif;
#ifndef P_opposite; Constant P_opposite = 0; #endif;
#ifndef P_recurring; Constant P_recurring = 0; #endif;
#ifndef K1_room_Next; Constant K1_room_Next = 0; #endif;
#ifndef K2_thing_Next; Constant K2_thing_Next = 0; #endif;
#ifndef K3_direction_Next; Constant K3_direction_Next = 0; #endif;
#ifndef K4_door_Next; Constant K4_door_Next = 0; #endif;
#ifndef K5_container_Next; Constant K5_container_Next = 0; #endif;
#ifndef K6_supporter_Next; Constant K6_supporter_Next = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef K7_backdrop_Next; Constant K7_backdrop_Next = 0; #endif;
#ifndef K8_person_Next; Constant K8_person_Next = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef K9_region_Next; Constant K9_region_Next = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef K10_man_Next; Constant K10_man_Next = 0; #endif;
#ifndef K11_woman_Count; Constant K11_woman_Count = 0; #endif;
#ifndef K11_woman_Next; Constant K11_woman_Next = 0; #endif;
#ifndef K12_animal_Count; Constant K12_animal_Count = 0; #endif;
#ifndef K12_animal_Next; Constant K12_animal_Next = 0; #endif;
#ifndef K13_device_Count; Constant K13_device_Count = 0; #endif;
#ifndef K13_device_Next; Constant K13_device_Next = 0; #endif;
#ifndef K14_vehicle_Count; Constant K14_vehicle_Count = 0; #endif;
#ifndef K14_vehicle_Next; Constant K14_vehicle_Next = 0; #endif;
#ifndef K15_player_s_holdall_Count; Constant K15_player_s_holdall_Count = 0; #endif;
#ifndef K15_player_s_holdall_Next; Constant K15_player_s_holdall_Next = 0; #endif;
#ifndef K16_passkey_Count; Constant K16_passkey_Count = 0; #endif;
#ifndef K16_passkey_Next; Constant K16_passkey_Next = 0; #endif;
#ifndef K17_keychain_Count; Constant K17_keychain_Count = 0; #endif;
#ifndef K17_keychain_Next; Constant K17_keychain_Next = 0; #endif;
#ifndef P_unbolting_relation_storage; Constant P_unbolting_relation_storage = 0; #endif;
#ifndef K18_rideable_animal_Count; Constant K18_rideable_animal_Count = 0; #endif;
#ifndef K18_rideable_animal_Next; Constant K18_rideable_animal_Next = 0; #endif;
#ifndef K19_rideable_vehicle_Count; Constant K19_rideable_vehicle_Count = 0; #endif;
#ifndef K19_rideable_vehicle_Next; Constant K19_rideable_vehicle_Next = 0; #endif;
#ifndef K20_fluid_container_Count; Constant K20_fluid_container_Count = 0; #endif;
#ifndef K20_fluid_container_Next; Constant K20_fluid_container_Next = 0; #endif;
#ifndef K21_electric_lamp_Count; Constant K21_electric_lamp_Count = 0; #endif;
#ifndef K21_electric_lamp_Next; Constant K21_electric_lamp_Next = 0; #endif;
#ifndef K22_switch_Count; Constant K22_switch_Count = 0; #endif;
#ifndef K22_switch_Next; Constant K22_switch_Next = 0; #endif;
#ifndef K23_socket_Count; Constant K23_socket_Count = 0; #endif;
#ifndef K23_socket_Next; Constant K23_socket_Next = 0; #endif;
#ifndef K24_colored_fuse_Count; Constant K24_colored_fuse_Count = 0; #endif;
#ifndef K24_colored_fuse_Next; Constant K24_colored_fuse_Next = 0; #endif;
#ifndef K25_colored_light_Count; Constant K25_colored_light_Count = 0; #endif;
#ifndef K25_colored_light_Next; Constant K25_colored_light_Next = 0; #endif;
#ifndef K26_colored_button_Count; Constant K26_colored_button_Count = 0; #endif;
#ifndef K26_colored_button_Next; Constant K26_colored_button_Next = 0; #endif;
#ifndef K27_colored_dial_Count; Constant K27_colored_dial_Count = 0; #endif;
#ifndef K27_colored_dial_Next; Constant K27_colored_dial_Next = 0; #endif;
#ifndef P_price; Constant P_price = 0; #endif;
#ifndef P_fluid_capacity; Constant P_fluid_capacity = 0; #endif;
#ifndef P_current_volume; Constant P_current_volume = 0; #endif;
#ifndef P_liquid; Constant P_liquid = 0; #endif;
#ifndef P_dial_setting; Constant P_dial_setting = 0; #endif;
#ifndef P_underlying_relation_storag; Constant P_underlying_relation_storag = 0; #endif;
#Ifdef TARGET_ZCODE;
Global max_z_object;
#Ifdef Z__Region;
[ OC__Cl obj cla j a n objflag;
    @jl obj 1 ?NotObj;
    @jg obj max_z_object ?NotObj;
    @inc objflag;
    #Ifdef K1_room;
    @je cla K1_room ?~NotRoom;
    @test_attr obj mark_as_room ?rtrue;
    @rfalse;
    .NotRoom;
    #Endif;
    #Ifdef K2_thing;
    @je cla K2_thing ?~NotObj;
    @test_attr obj mark_as_thing ?rtrue;
    @rfalse;
    #Endif;
    .NotObj;

    @je cla Object Class ?ObjOrClass;
    @je cla Routine String ?RoutOrStr;

    @jin cla 1 ?~Mistake;

    @jz objflag ?rfalse;
    @get_prop_addr obj 2 -> a;
    @jz a ?rfalse;
    @get_prop_len a -> n;

    @div n 2 -> n;
    .Loop;
    @loadw a j -> sp;
    @je sp cla ?rtrue;
    @inc j;
    @jl j n ?Loop;
    @rfalse;

    .ObjOrClass;
    @jz objflag ?rfalse;
    @je cla Object ?JustObj;

    ! So now cla is Class
    @jg obj String ?~rtrue;
    @jin obj Class ?rtrue;
    @rfalse;

    .JustObj;
    ! So now cla is Object
    @jg obj String ?~rfalse;
    @jin obj Class ?rfalse;
    @rtrue;

    .RoutOrStr;
    @jz objflag ?~rfalse;
    @call_2s Z__Region obj -> sp;
    @inc sp;
    @je sp cla ?rtrue;
    @rfalse;

    .Mistake;
    RT__Err("apply 'ofclass' for", cla, -1);
    rfalse;
];
#Endif;
#Endif;
[ KeyPause key;
    while (1) {
        (key = VM_KeyChar());
        if ((key == -4 or -5 or -10 or -11 or -12 or -13)) {
            continue;
        }
        rfalse;
    }
];
[ SPACEPause i;
    while ((i ~= 13 or 31 or 32)) {
        (i = VM_KeyChar());
    }
];
[ GetKey;
    return VM_KeyChar();
];
[ CenterPrint str depth i j len;
    if (0) { font on; } else { font off; }(i = VM_ScreenWidth());
    (len = TEXT_TY_CharacterLength(str));
    if ((len > 63)) {
        (len = 63);
    }
    (j = (((i - len)/2) - 1));
    VM_MoveCursorInStatusLine(depth, j);
    I7_String(str);
    if (1) { font on; } else { font off; }];
[ CenterPrintComplex str i j len;
    if (0) { font on; } else { font off; }print "^";
    (i = VM_ScreenWidth());
    (len = TEXT_TY_CharacterLength(str));
    if ((len > 63)) {
        (len = 63);
    }
    (j = (((i - len)/2) - 1));
    spaces j;
    I7_String(str);
    if (1) { font on; } else { font off; }];
[ I7ScreenHeight i screen_height;
    (i = (0->(32)));
    if ((screen_height == 0 or 255)) {
        (screen_height = 18);
    }
    (screen_height = (screen_height - 7));
    return screen_height;
];
[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    (screen_width = VM_ScreenWidth());
    VM_ClearScreen(1);
];
[ I7VM_MoveCursorInStatusLine depth;
    VM_MoveCursorInStatusLine(depth, 1);
];
[ RightAlign depth screen_width o n;
    (screen_width = VM_ScreenWidth());
    (n = right_alignment_depth);
    (o = (screen_width - n));
    VM_MoveCursorInStatusLine(depth, o);
];
[ call_U1 sk;
    rfalse;
];
[ call_U2 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "printed name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_short_name), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_short_name));
                    print (char) 34;
                }
                print "^";
                print "printed plural name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_plural), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_plural));
                    print (char) 34;
                }
                print "^";
                print "indefinite article: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_article), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_article));
                    print (char) 34;
                }
                print "^";
                print "list grouping key: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_list_together), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_list_together));
                    print (char) 34;
                }
                print "^";
            }
        } else {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has pluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "plural-named";
                }
                if (((0) && ((~~((t_0 has pluralname)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "singular-named";
                }
                if (((0) && ((t_0 has proper)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "proper-named";
                }
                if (((0) && ((~~((t_0 has proper)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "improper-named";
                }
                if (((0) && ((t_0 has ambigpluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "ambiguously plural";
                }
            }
        }
        return na;
    #endif;
];
[ call_U3 sk;
    return I_entire_game_U1;
];
[ PrintSceneName value;
    switch (value) {
        I_entire_game_U1:
            print "Entire Game";
            ;
        I_littleegyptauto_U1:
            print "LittleEgyptAuto";
            ;
        I_hellrideauto_U1:
            print "HellRideAuto";
            ;
        default:
            print "<illegal scene>";
            ;
    }
];
[ call_U4 x;
    return ((x%3) + 1);
];
[ call_U5 x;
    return (((x + 1)%3) + 1);
];
[ call_U6 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U7 sk;
    rfalse;
];
[ DECIMAL_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U9 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (original_wn = wn);
    (original_wn = wn);
    return GPR_FAIL;
];
[ call_U10 sk;
    rfalse;
];
[ call_U12 sk;
    rfalse;
];
[ TRUTH_STATE_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U13 sk;
    return BlkValueCreate(sk);
];
[ call_U14 sk;
    return 101;
];
[ call_U15 sk;
    return 32;
];
[ call_U16 sk;
    rfalse;
];
[ call_U17 sk;
    rfalse;
];
[ call_U18 sk;
    rfalse;
];
[ call_U19 sk;
    return TheEmptyTable;
];
[ call_U20 sk;
    rfalse;
];
[ RulebookOutcomePrintingRule nro;
    if ((nro == 0)) {
        print "(no outcome)";
    } else {
        print (string) nro;
        rfalse;
    }
];
[ call_U21 sk;
    return outcome_allow_startup_U1;
];
[ call_U22 sk;
    rfalse;
];
[ PrintExternalFileName value;
    switch (value) {
        default:
            print "<illegal external file>";
            ;
    }
];
[ call_U23 x;
    return x;
];
[ call_U24 x;
    return x;
];
[ call_U25 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(0);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U26 sk;
    rfalse;
];
[ call_U27 sk;
    return BlkValueCreate(sk);
];
[ call_U28 sk;
    return ##Wait;
];
[ call_U29 sk;
    return 540;
];
[ TIME_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U31 sk;
    return I_figure_of_cover_U1;
];
[ PrintFigureName value;
    switch (value) {
        I_figure_of_cover_U1:
            print "Figure of cover";
            ;
        I_figure_of_hell_ride_U1:
            print "Figure of Hell Ride";
            ;
        I_figure_of_midway_U1:
            print "Figure of Midway";
            ;
        I_figure_of_ticketbooth_U1:
            print "Figure of TicketBooth";
            ;
        I_figure_of_concessionstand_U1:
            print "Figure of ConcessionStand";
            ;
        I_figure_of_littleegyptfacad_U1:
            print "Figure of LittleEgyptFacade";
            ;
        I_figure_of_littleegyptshow_U1:
            print "Figure of LittleEgyptShow";
            ;
        I_figure_of_highstriker_U1:
            print "Figure of HighStriker";
            ;
        I_figure_of_hellrideentrance_U1:
            print "Figure of HellRideEntrance";
            ;
        I_figure_of_controlpanel_U1:
            print "Figure of ControlPanel";
            ;
        I_figure_of_controlpanelstoc_U1:
            print "Figure of ControlPanelStocks";
            ;
        I_figure_of_controlpanelgall_U1:
            print "Figure of ControlPanelGallows";
            ;
        I_figure_of_controlpanelstak_U1:
            print "Figure of ControlPanelStake";
            ;
        I_figure_of_controlpaneldung_U1:
            print "Figure of ControlPanelDungeon";
            ;
        I_figure_of_controlpanelguil_U1:
            print "Figure of ControlPanelGuillotine";
            ;
        I_figure_of_controlpanelexit_U1:
            print "Figure of ControlPanelExit";
            ;
        I_figure_of_coupon_U1:
            print "Figure of Coupon";
            ;
        default:
            print "<illegal figure name>";
            ;
    }
];
[ call_U32 x;
    return ((x%17) + 1);
];
[ call_U33 x;
    return (((x + 15)%17) + 1);
];
[ call_U34 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(17);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U35 sk;
    return I_sound_of_strongman_bell_U1;
];
[ PrintSoundName value;
    switch (value) {
        I_sound_of_strongman_bell_U1:
            print "Sound of Strongman Bell";
            ;
        default:
            print "<illegal sound name>";
            ;
    }
];
[ call_U36 x;
    return x;
];
[ call_U37 x;
    return x;
];
[ call_U38 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U39 sk;
    return DefaultTopic;
];
[ call_U40 sk;
    return BlkValueCreate(sk);
];
[ call_U41 sk;
    rfalse;
];
[ call_U42 sk;
    rfalse;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv:
            InvDbg(n, s, for_say);
            ;
        ##Take:
            TakeDbg(n, s, for_say);
            ;
        ##Remove:
            RemoveDbg(n, s, for_say);
            ;
        ##Drop:
            DropDbg(n, s, for_say);
            ;
        ##PutOn:
            PutOnDbg(n, s, for_say);
            ;
        ##Insert:
            InsertDbg(n, s, for_say);
            ;
        ##Eat:
            EatDbg(n, s, for_say);
            ;
        ##Go:
            GoDbg(n, s, for_say);
            ;
        ##Enter:
            EnterDbg(n, s, for_say);
            ;
        ##Exit:
            ExitDbg(n, s, for_say);
            ;
        ##GetOff:
            GetOffDbg(n, s, for_say);
            ;
        ##Look:
            LookDbg(n, s, for_say);
            ;
        ##Examine:
            ExamineDbg(n, s, for_say);
            ;
        ##LookUnder:
            LookUnderDbg(n, s, for_say);
            ;
        ##Search:
            SearchDbg(n, s, for_say);
            ;
        ##Consult:
            ConsultDbg(n, s, for_say);
            ;
        ##Lock:
            LockDbg(n, s, for_say);
            ;
        ##Unlock:
            UnlockDbg(n, s, for_say);
            ;
        ##SwitchOn:
            SwitchOnDbg(n, s, for_say);
            ;
        ##SwitchOff:
            SwitchOffDbg(n, s, for_say);
            ;
        ##Open:
            OpenDbg(n, s, for_say);
            ;
        ##Close:
            CloseDbg(n, s, for_say);
            ;
        ##Wear:
            WearDbg(n, s, for_say);
            ;
        ##Disrobe:
            DisrobeDbg(n, s, for_say);
            ;
        ##Give:
            GiveDbg(n, s, for_say);
            ;
        ##Show:
            ShowDbg(n, s, for_say);
            ;
        ##WakeOther:
            WakeOtherDbg(n, s, for_say);
            ;
        ##ThrowAt:
            ThrowAtDbg(n, s, for_say);
            ;
        ##Attack:
            AttackDbg(n, s, for_say);
            ;
        ##Kiss:
            KissDbg(n, s, for_say);
            ;
        ##Answer:
            AnswerDbg(n, s, for_say);
            ;
        ##Tell:
            TellDbg(n, s, for_say);
            ;
        ##Ask:
            AskDbg(n, s, for_say);
            ;
        ##AskFor:
            AskForDbg(n, s, for_say);
            ;
        ##Wait:
            WaitDbg(n, s, for_say);
            ;
        ##Touch:
            TouchDbg(n, s, for_say);
            ;
        ##Wave:
            WaveDbg(n, s, for_say);
            ;
        ##Pull:
            PullDbg(n, s, for_say);
            ;
        ##Push:
            PushDbg(n, s, for_say);
            ;
        ##Turn:
            TurnDbg(n, s, for_say);
            ;
        ##PushDir:
            PushDirDbg(n, s, for_say);
            ;
        ##Squeeze:
            SqueezeDbg(n, s, for_say);
            ;
        ##Yes:
            YesDbg(n, s, for_say);
            ;
        ##No:
            NoDbg(n, s, for_say);
            ;
        ##Burn:
            BurnDbg(n, s, for_say);
            ;
        ##Wake:
            WakeDbg(n, s, for_say);
            ;
        ##Think:
            ThinkDbg(n, s, for_say);
            ;
        ##Smell:
            SmellDbg(n, s, for_say);
            ;
        ##Listen:
            ListenDbg(n, s, for_say);
            ;
        ##Taste:
            TasteDbg(n, s, for_say);
            ;
        ##Cut:
            CutDbg(n, s, for_say);
            ;
        ##Jump:
            JumpDbg(n, s, for_say);
            ;
        ##Tie:
            TieDbg(n, s, for_say);
            ;
        ##Drink:
            DrinkDbg(n, s, for_say);
            ;
        ##Sorry:
            SorryDbg(n, s, for_say);
            ;
        ##Swing:
            SwingDbg(n, s, for_say);
            ;
        ##Rub:
            RubDbg(n, s, for_say);
            ;
        ##SetTo:
            SetToDbg(n, s, for_say);
            ;
        ##WaveHands:
            WaveHandsDbg(n, s, for_say);
            ;
        ##Buy:
            BuyDbg(n, s, for_say);
            ;
        ##Climb:
            ClimbDbg(n, s, for_say);
            ;
        ##Sleep:
            SleepDbg(n, s, for_say);
            ;
        ##Quit:
            QuitDbg(n, s, for_say);
            ;
        ##Save:
            SaveDbg(n, s, for_say);
            ;
        ##Restore:
            RestoreDbg(n, s, for_say);
            ;
        ##Restart:
            RestartDbg(n, s, for_say);
            ;
        ##Verify:
            VerifyDbg(n, s, for_say);
            ;
        ##ScriptOn:
            ScriptOnDbg(n, s, for_say);
            ;
        ##ScriptOff:
            ScriptOffDbg(n, s, for_say);
            ;
        ##Version:
            VersionDbg(n, s, for_say);
            ;
        ##Score:
            ScoreDbg(n, s, for_say);
            ;
        ##LMode3:
            LMode3Dbg(n, s, for_say);
            ;
        ##LMode2:
            LMode2Dbg(n, s, for_say);
            ;
        ##LMode1:
            LMode1Dbg(n, s, for_say);
            ;
        ##NotifyOn:
            NotifyOnDbg(n, s, for_say);
            ;
        ##NotifyOff:
            NotifyOffDbg(n, s, for_say);
            ;
        ##Pronouns:
            PronounsDbg(n, s, for_say);
            ;
        ##A_unlocking_keylessly:
            A_unlocking_keylesslyDbg(n, s, for_say);
            ;
        ##A_locking_keylessly:
            A_locking_keylesslyDbg(n, s, for_say);
            ;
        ##A_asking_for_help:
            A_asking_for_helpDbg(n, s, for_say);
            ;
        ##A_mounting:
            A_mountingDbg(n, s, for_say);
            ;
        ##A_dismounting:
            A_dismountingDbg(n, s, for_say);
            ;
        ##Strong:
            StrongDbg(n, s, for_say);
            ;
        ##Mild:
            MildDbg(n, s, for_say);
            ;
        ##Sing:
            SingDbg(n, s, for_say);
            ;
        ##A_pouring_it_into:
            A_pouring_it_intoDbg(n, s, for_say);
            ;
        ##A_hiding_it_under:
            A_hiding_it_underDbg(n, s, for_say);
            ;
        ##A_hi_speaking:
            A_hi_speakingDbg(n, s, for_say);
            ;
        ##A_casting_xyzzy:
            A_casting_xyzzyDbg(n, s, for_say);
            ;
        ##A_hitting:
            A_hittingDbg(n, s, for_say);
            ;
        ##A_spinning_it_to:
            A_spinning_it_toDbg(n, s, for_say);
            ;
    }
];
[ TestSinglePastState past_flag pt turn_end wanted old new trips consecutives;
    if (past_flag) {
        (new = (((past_chronological_record-->(pt)))&(1)));
        (trips = ((((past_chronological_record-->(pt)))&(254))/2));
        (consecutives = ((((past_chronological_record-->(pt)))&(65280))/256));
    } else {
        (old = (((present_chronological_record-->(pt)))&(1)));
        (trips = ((((present_chronological_record-->(pt)))&(254))/2));
        (consecutives = ((((present_chronological_record-->(pt)))&(65280))/256));
        switch (pt) {
            0:
                (new = PCONR1());
                ;
            1:
                (new = PCONR2());
                ;
            default:
                print "*** No such past tense condition ***^";
                (new = 0);
                ;
        }
        if (new) {
            if ((old == 0)) {
                (trips)++;
                if ((trips > 127)) {
                    (trips = 127);
                }
            }
            if (turn_end) {
                (consecutives)++;
                if ((consecutives > 127)) {
                    (consecutives = 127);
                }
            }
        } else {
            (consecutives = 0);
        }
        ((present_chronological_record-->(pt)) = (new + ((trips*2) + (consecutives*256))));
    }
    switch (wanted) {
        0:
            if (new) {
                return new;
            }
            ;
        1:
            if (new) {
                return trips;
            }
            ;
        2:
            if (new) {
                return (consecutives + 1);
            }
            ;
        4:
            return new;
            ;
        5:
            return trips;
            ;
        6:
            return consecutives;
            ;
    }
    rfalse;
];
[ ShowExtensionVersions;
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Swearing Reloaded version 1 by Shin^";
    print "Singing Reloaded version 1 by Shin^";
];
[ ShowFullExtensionVersions;
    print "Basic Inform version 1 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Standard Rules version 6 by Graham Nelson^";
    print "Locksmith version 13 by Emily Short^";
    print "Basic Screen Effects version 8 by Emily Short^";
    print "Menus version 3 by Emily Short^";
    print "Basic Help Menu version 1 by Emily Short^";
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Swearing Reloaded version 1 by Shin^";
    print "Singing Reloaded version 1 by Shin^";
];
[ ShowOneExtension id;
    if ((id == 1)) {
        print "Basic Inform version 1 by Graham Nelson";
    }
    if ((id == 2)) {
        print "English Language version 1 by Graham Nelson";
    }
    if ((id == 3)) {
        print "Standard Rules version 6 by Graham Nelson";
    }
    if ((id == 4)) {
        print "Locksmith version 13 by Emily Short";
    }
    if ((id == 5)) {
        print "Basic Screen Effects version 8 by Emily Short";
    }
    if ((id == 6)) {
        print "Menus version 3 by Emily Short";
    }
    if ((id == 7)) {
        print "Basic Help Menu version 1 by Emily Short";
    }
    if ((id == 8)) {
        print "Rideable Vehicles version 3 by Graham Nelson";
    }
    if ((id == 9)) {
        print "Swearing Reloaded version 1 by Shin";
    }
    if ((id == 10)) {
        print "Singing Reloaded version 1 by Shin";
    }
];
[ ShowMeInstanceDetails which na t_0;
    (na = call_U2233(which, na, t_0));
    (na = call_U2237(which, na, t_0));
    (na = call_U2241(which, na, t_0));
    (na = call_U2245(which, na, t_0));
    (na = call_U2249(which, na, t_0));
    return na;
];
[ DefaultValueOfKOV sk k;
    (k = KindAtomic(sk));
    switch (k) {
        WEAK_ID_47:
            return call_U126(sk);
            ;
        WEAK_ID_52:
            return call_U1821(sk);
            ;
        WEAK_ID_53:
            return call_U1823(sk);
            ;
        WEAK_ID_54:
            return call_U1825(sk);
            ;
        WEAK_ID_55:
            return call_U1827(sk);
            ;
        WEAK_ID_56:
            return call_U1829(sk);
            ;
        WEAK_ID_57:
            return call_U1831(sk);
            ;
        WEAK_ID_58:
            return call_U1833(sk);
            ;
        WEAK_ID_59:
            return call_U1834(sk);
            ;
        WEAK_ID_60:
            return call_U1836(sk);
            ;
        WEAK_ID_61:
            return call_U1837(sk);
            ;
        WEAK_ID_62:
            return call_U1838(sk);
            ;
        WEAK_ID_63:
            return call_U1839(sk);
            ;
        WEAK_ID_64:
            return call_U1840(sk);
            ;
        WEAK_ID_65:
            return call_U1842(sk);
            ;
        WEAK_ID_66:
            return call_U1843(sk);
            ;
        WEAK_ID_67:
            return call_U1844(sk);
            ;
        WEAK_ID_48:
            return call_U154(sk);
            ;
        WEAK_ID_49:
            return call_U158(sk);
            ;
        WEAK_ID_50:
            return call_U162(sk);
            ;
        WEAK_ID_51:
            return call_U166(sk);
            ;
        WEAK_ID_68:
            return call_U1942(sk);
            ;
        WEAK_ID_69:
            return call_U1943(sk);
            ;
        WEAK_ID_70:
            return call_U2035(sk);
            ;
        WEAK_ID_71:
            return call_U2063(sk);
            ;
        WEAK_ID_72:
            return call_U2064(sk);
            ;
        WEAK_ID_73:
            return call_U2311(sk);
            ;
        WEAK_ID_74:
            return call_U2313(sk);
            ;
        WEAK_ID_75:
            return call_U2315(sk);
            ;
        WEAK_ID_76:
            return call_U2317(sk);
            ;
        WEAK_ID_77:
            return call_U2323(sk);
            ;
        WEAK_ID_78:
            return call_U2324(sk);
            ;
        WEAK_ID_79:
            return call_U2325(sk);
            ;
        WEAK_ID_80:
            return call_U2327(sk);
            ;
        WEAK_ID_81:
            return call_U2329(sk);
            ;
        WEAK_ID_82:
            return call_U2333(sk);
            ;
        WEAK_ID_83:
            return call_U2334(sk);
            ;
        WEAK_ID_84:
            return call_U2335(sk);
            ;
        OBJECT_TY:
            return call_U1(sk);
            ;
        SCENE_TY:
            return call_U3(sk);
            ;
        NUMBER_TY:
            return call_U7(sk);
            ;
        REAL_NUMBER_TY:
            return call_U10(sk);
            ;
        TRUTH_STATE_TY:
            return call_U12(sk);
            ;
        TEXT_TY:
            return call_U13(sk);
            ;
        SNIPPET_TY:
            return call_U14(sk);
            ;
        UNICODE_CHARACTER_TY:
            return call_U15(sk);
            ;
        USE_OPTION_TY:
            return call_U16(sk);
            ;
        RESPONSE_TY:
            return call_U17(sk);
            ;
        VERB_TY:
            return call_U18(sk);
            ;
        TABLE_TY:
            return call_U19(sk);
            ;
        EQUATION_TY:
            return call_U20(sk);
            ;
        RULEBOOK_OUTCOME_TY:
            return call_U21(sk);
            ;
        EXTERNAL_FILE_TY:
            return call_U22(sk);
            ;
        DESCRIPTION_OF_ACTION_TY:
            return call_U26(sk);
            ;
        STORED_ACTION_TY:
            return call_U27(sk);
            ;
        ACTION_NAME_TY:
            return call_U28(sk);
            ;
        TIME_TY:
            return call_U29(sk);
            ;
        FIGURE_NAME_TY:
            return call_U31(sk);
            ;
        SOUND_NAME_TY:
            return call_U35(sk);
            ;
        UNDERSTANDING_TY:
            return call_U39(sk);
            ;
        LIST_OF_TY:
            return call_U40(sk);
            ;
        NIL_TY:
            return call_U41(sk);
            ;
        VOID_TY:
            return call_U42(sk);
            ;
    }
    rfalse;
];
[ DefaultValueFinder k;
    rfalse;
];
[ PrintKindValuePair k v;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            E1(v);
            ;
        WEAK_ID_67:
            E7(v);
            ;
        WEAK_ID_48:
            E2(v);
            ;
        WEAK_ID_49:
            E3(v);
            ;
        WEAK_ID_50:
            E4(v);
            ;
        WEAK_ID_51:
            E5(v);
            ;
        WEAK_ID_70:
            E8(v);
            ;
        WEAK_ID_73:
            E6(v);
            ;
        WEAK_ID_74:
            E9(v);
            ;
        WEAK_ID_76:
            E10(v);
            ;
        WEAK_ID_81:
            E11(v);
            ;
        OBJECT_TY:
            PrintShortName(v);
            ;
        SCENE_TY:
            PrintSceneName(v);
            ;
        NUMBER_TY:
            DecimalNumber(v);
            ;
        REAL_NUMBER_TY:
            REAL_NUMBER_TY_Say(v);
            ;
        TRUTH_STATE_TY:
            DA_TruthState(v);
            ;
        TEXT_TY:
            TEXT_TY_Say(v);
            ;
        SNIPPET_TY:
            PrintSnippet(v);
            ;
        UNICODE_CHARACTER_TY:
            DecimalNumber(v);
            ;
        USE_OPTION_TY:
            PrintUseOption(v);
            ;
        RESPONSE_TY:
            PrintResponse(v);
            ;
        VERB_TY:
            PrintVerbAsValue(v);
            ;
        TABLE_TY:
            PrintTableName(v);
            ;
        EQUATION_TY:
            DA_Number(v);
            ;
        RULEBOOK_OUTCOME_TY:
            RulebookOutcomePrintingRule(v);
            ;
        EXTERNAL_FILE_TY:
            PrintExternalFileName(v);
            ;
        DESCRIPTION_OF_ACTION_TY:
            DecimalNumber(v);
            ;
        STORED_ACTION_TY:
            STORED_ACTION_TY_Say(v);
            ;
        ACTION_NAME_TY:
            SayActionName(v);
            ;
        TIME_TY:
            PrintTimeOfDay(v);
            ;
        FIGURE_NAME_TY:
            PrintFigureName(v);
            ;
        SOUND_NAME_TY:
            PrintSoundName(v);
            ;
        UNDERSTANDING_TY:
            DecimalNumber(v);
            ;
        LIST_OF_TY:
            LIST_OF_TY_Say(v);
            ;
        VALUE_TY:
            DecimalNumber(v);
            ;
        STORED_VALUE_TY:
            DecimalNumber(v);
            ;
        SAYABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        UNDERSTANDABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        REAL_ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        ENUMERATED_VALUE_TY:
            DecimalNumber(v);
            ;
        POINTER_VALUE_TY:
            DecimalNumber(v);
            ;
        PHRASE_TY:
            SayPhraseName(v);
            ;
        VARIABLE_TY:
            DecimalNumber(v);
            ;
        RELATION_TY:
            RELATION_TY_Say(v);
            ;
        RULE_TY:
            RulePrintingRule(v);
            ;
        RULEBOOK_TY:
            RulePrintingRule(v);
            ;
        ACTIVITY_TY:
            DecimalNumber(v);
            ;
        DESCRIPTION_OF_TY:
            DecimalNumber(v);
            ;
        PROPERTY_TY:
            PROPERTY_TY_Say(v);
            ;
        TABLE_COLUMN_TY:
            DecimalNumber(v);
            ;
        COMBINATION_TY:
            COMBINATION_TY_Say(v);
            ;
        NIL_TY:
            DecimalNumber(v);
            ;
        UNKNOWN_TY:
            DecimalNumber(v);
            ;
        VOID_TY:
            DecimalNumber(v);
            ;
        TUPLE_ENTRY_TY:
            DecimalNumber(v);
            ;
        default:
            print v;
            ;
    }
];
[ KOVComparisonFunction k;
    (k = KindAtomic(k));
    switch (k) {
        OBJECT_TY:
            return UnsignedCompare;
            ;
        SCENE_TY:
            return UnsignedCompare;
            ;
        REAL_NUMBER_TY:
            return REAL_NUMBER_TY_Compare;
            ;
        TRUTH_STATE_TY:
            return UnsignedCompare;
            ;
        TEXT_TY:
            return BlkValueCompare;
            ;
        SNIPPET_TY:
            return UnsignedCompare;
            ;
        UNICODE_CHARACTER_TY:
            return UnsignedCompare;
            ;
        USE_OPTION_TY:
            return UnsignedCompare;
            ;
        RESPONSE_TY:
            return UnsignedCompare;
            ;
        VERB_TY:
            return UnsignedCompare;
            ;
        TABLE_TY:
            return UnsignedCompare;
            ;
        EQUATION_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_OUTCOME_TY:
            return UnsignedCompare;
            ;
        EXTERNAL_FILE_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_ACTION_TY:
            return UnsignedCompare;
            ;
        STORED_ACTION_TY:
            return BlkValueCompare;
            ;
        ACTION_NAME_TY:
            return UnsignedCompare;
            ;
        FIGURE_NAME_TY:
            return UnsignedCompare;
            ;
        SOUND_NAME_TY:
            return UnsignedCompare;
            ;
        UNDERSTANDING_TY:
            return UnsignedCompare;
            ;
        LIST_OF_TY:
            return BlkValueCompare;
            ;
        PHRASE_TY:
            return UnsignedCompare;
            ;
        VARIABLE_TY:
            return UnsignedCompare;
            ;
        RELATION_TY:
            return BlkValueCompare;
            ;
        RULE_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_TY:
            return UnsignedCompare;
            ;
        ACTIVITY_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_TY:
            return UnsignedCompare;
            ;
        PROPERTY_TY:
            return UnsignedCompare;
            ;
        TABLE_COLUMN_TY:
            return UnsignedCompare;
            ;
        COMBINATION_TY:
            return BlkValueCompare;
            ;
        NIL_TY:
            return UnsignedCompare;
            ;
        VOID_TY:
            return UnsignedCompare;
            ;
        TUPLE_ENTRY_TY:
            return UnsignedCompare;
            ;
    }
    rfalse;
];
[ KOVDomainSize k;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            return 6;
            ;
        WEAK_ID_67:
            return 25;
            ;
        WEAK_ID_48:
            return 5;
            ;
        WEAK_ID_49:
            return 6;
            ;
        WEAK_ID_50:
            return 2;
            ;
        WEAK_ID_51:
            return 3;
            ;
        WEAK_ID_70:
            return 3;
            ;
        WEAK_ID_76:
            return 5;
            ;
        WEAK_ID_81:
            return 5;
            ;
        SCENE_TY:
            return 3;
            ;
        FIGURE_NAME_TY:
            return 17;
            ;
        SOUND_NAME_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ KOVIsBlockValue k;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            rtrue;
            ;
        STORED_ACTION_TY:
            rtrue;
            ;
        LIST_OF_TY:
            rtrue;
            ;
        RELATION_TY:
            rtrue;
            ;
        COMBINATION_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ I7_Kind_Name k;
    if ((k == K1_room)) {
        print "room";
    }
    if ((k == K2_thing)) {
        print "thing";
    }
    if ((k == K3_direction)) {
        print "direction";
    }
    if ((k == K4_door)) {
        print "door";
    }
    if ((k == K5_container)) {
        print "container";
    }
    if ((k == K6_supporter)) {
        print "supporter";
    }
    if ((k == K7_backdrop)) {
        print "backdrop";
    }
    if ((k == K8_person)) {
        print "person";
    }
    if ((k == K9_region)) {
        print "region";
    }
    if ((k == K10_man)) {
        print "man";
    }
    if ((k == K11_woman)) {
        print "woman";
    }
    if ((k == K12_animal)) {
        print "animal";
    }
    if ((k == K13_device)) {
        print "device";
    }
    if ((k == K14_vehicle)) {
        print "vehicle";
    }
    if ((k == K15_player_s_holdall)) {
        print "player's holdall";
    }
    if ((k == K16_passkey)) {
        print "passkey";
    }
    if ((k == K17_keychain)) {
        print "keychain";
    }
    if ((k == K18_rideable_animal)) {
        print "rideable animal";
    }
    if ((k == K19_rideable_vehicle)) {
        print "rideable vehicle";
    }
    if ((k == K20_fluid_container)) {
        print "fluid container";
    }
    if ((k == K21_electric_lamp)) {
        print "electric lamp";
    }
    if ((k == K22_switch)) {
        print "switch";
    }
    if ((k == K23_socket)) {
        print "socket";
    }
    if ((k == K24_colored_fuse)) {
        print "colored fuse";
    }
    if ((k == K25_colored_light)) {
        print "colored light";
    }
    if ((k == K26_colored_button)) {
        print "colored button";
    }
    if ((k == K27_colored_dial)) {
        print "colored dial";
    }
];
[ KOVSupportFunction k fail;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            return TEXT_TY_Support;
            ;
        STORED_ACTION_TY:
            return STORED_ACTION_TY_Support;
            ;
        LIST_OF_TY:
            return LIST_OF_TY_Support;
            ;
        RELATION_TY:
            return RELATION_TY_Support;
            ;
        COMBINATION_TY:
            return COMBINATION_TY_Support;
            ;
    }
    if (fail) {
        BlkValueError(fail);
    }
    rfalse;
];
[ ShowMeKindDetails which na t_0;
    (na = call_U1822(which, na, t_0));
    (na = call_U1824(which, na, t_0));
    (na = call_U1826(which, na, t_0));
    (na = call_U1828(which, na, t_0));
    (na = call_U1830(which, na, t_0));
    (na = call_U1832(which, na, t_0));
    (na = call_U1835(which, na, t_0));
    (na = call_U1841(which, na, t_0));
    (na = call_U2316(which, na, t_0));
    (na = call_U2326(which, na, t_0));
    (na = call_U2328(which, na, t_0));
    (na = call_U2336(which, na, t_0));
    (na = call_U2(which, na, t_0));
    return na;
];
[ CreateDynamicRelations;
];
[ IterateRelations callback;
    (callback)(Rel_Record1);
    (callback)(Rel_Record2);
    (callback)(Rel_Record3);
    (callback)(Rel_Record4);
    (callback)(Rel_Record5);
    (callback)(Rel_Record6);
    (callback)(Rel_Record7);
    (callback)(Rel_Record8);
    (callback)(Rel_Record9);
    (callback)(Rel_Record10);
    (callback)(Rel_Record11);
    (callback)(Rel_Record12);
    (callback)(Rel_Record13);
    (callback)(Rel_Record14);
    (callback)(Rel_Record15);
    (callback)(Rel_Record16);
    (callback)(Rel_Record17);
    (callback)(Rel_Record18);
    (callback)(Rel_Record19);
    (callback)(Rel_Record20);
];
[ RProperty obj cl pr;
    if ((obj ofclass cl)) {
        return _final_propertyvalue(OBJECT_TY, obj, pr);
    }
    rfalse;
];
[ MStack_GetRBVarCreator rb;
    return (rulebook_var_creators-->(rb));
];
[ RulePrintingRule R;
    if ((((R >= 0)) && ((R < 420)))) {
        print (string) (RulebookNames-->(R));
    } else {
        if ((R == FINAL_CODE_STARTUP_R)) {
            print "final code startup rule";
            rtrue;
        }
        if ((R == STANDARD_NAME_PRINTING_R)) {
            print "standard name printing rule";
            rtrue;
        }
        if ((R == STANDARD_PLURAL_NAME_PRINTING_R)) {
            print "standard printing the plural name rule";
            rtrue;
        }
        if ((R == ADJUST_LIGHT_R)) {
            print "adjust light rule";
            rtrue;
        }
        if ((R == GENERATE_ACTION_R)) {
            print "generate action rule";
            rtrue;
        }
        if ((R == BASIC_ACCESSIBILITY_R)) {
            print "basic accessibility rule";
            rtrue;
        }
        if ((R == BASIC_VISIBILITY_R)) {
            print "basic visibility rule";
            rtrue;
        }
        if ((R == REQUESTED_ACTIONS_REQUIRE_R)) {
            print "requested actions require persuasion rule";
            rtrue;
        }
        if ((R == CARRY_OUT_REQUESTED_ACTIONS_R)) {
            print "carry out requested actions rule";
            rtrue;
        }
        if ((R == ACCESS_THROUGH_BARRIERS_R)) {
            print "access through barriers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_CLOSED_R)) {
            print "can't reach inside closed containers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_ROOMS_R)) {
            print "can't reach inside rooms rule";
            rtrue;
        }
        if ((R == CANT_REACH_OUTSIDE_CLOSED_R)) {
            print "can't reach outside closed containers rule";
            rtrue;
        }
        if ((R == LIST_WRITER_INTERNAL_R)) {
            print "list writer internal rule";
            rtrue;
        }
        if ((R == ACTION_PROCESSING_INTERNAL_R)) {
            print "action processing internal rule";
            rtrue;
        }
        if ((R == PARSER_ERROR_INTERNAL_R)) {
            print "parser error internal rule";
            rtrue;
        }
        if ((R == PARSER_N_ERROR_INTERNAL_R)) {
            print "parser nothing error internal rule";
            rtrue;
        }
        if ((R == DARKNESS_NAME_INTERNAL_R)) {
            print "darkness name internal rule";
            rtrue;
        }
        if ((R == PARSER_COMMAND_INTERNAL_R)) {
            print "parser command internal rule";
            rtrue;
        }
        if ((R == PARSER_CLARIF_INTERNAL_R)) {
            print "parser clarification internal rule";
            rtrue;
        }
        if ((R == YES_OR_NO_QUESTION_INTERNAL_R)) {
            print "yes or no question internal rule";
            rtrue;
        }
        if ((R == PRINT_PROTAGONIST_INTERNAL_R)) {
            print "print protagonist internal rule";
            rtrue;
        }
        if ((R == STANDARD_IMPLICIT_TAKING_R)) {
            print "standard implicit taking rule";
            rtrue;
        }
        if ((R == PRINT_OBITUARY_HEADLINE_R)) {
            print "print obituary headline rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_UNDO_R)) {
            print "immediately undo rule";
            rtrue;
        }
        if ((R == QUIT_THE_GAME_R)) {
            print "quit the game rule";
            rtrue;
        }
        if ((R == SAVE_THE_GAME_R)) {
            print "save the game rule";
            rtrue;
        }
        if ((R == RESTORE_THE_GAME_R)) {
            print "restore the game rule";
            rtrue;
        }
        if ((R == RESTART_THE_GAME_R)) {
            print "restart the game rule";
            rtrue;
        }
        if ((R == VERIFY_THE_STORY_FILE_R)) {
            print "verify the story file rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_ON_R)) {
            print "switch the story transcript on rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_OFF_R)) {
            print "switch the story transcript off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_SCORE_R)) {
            print "announce the score rule";
            rtrue;
        }
        if ((R == REP_PREFER_ABBREVIATED_R)) {
            print "standard report preferring abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_UNABBREVIATED_R)) {
            print "standard report preferring unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_SOMETIMES_ABBR_R)) {
            print "standard report preferring sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_ON_R)) {
            print "standard report switching score notification on rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_OFF_R)) {
            print "standard report switching score notification off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_PRONOUN_MEANINGS_R)) {
            print "announce the pronoun meanings rule";
            rtrue;
        }
        if ((R == call_U989)) {
            print "declare everything initially unmentioned rule";
            rtrue;
        }
        if ((R == call_U991)) {
            print "start in the correct scenes rule";
            rtrue;
        }
        if ((R == call_U992)) {
            print "when play begins stage rule";
            rtrue;
        }
        if ((R == call_U993)) {
            print "fix baseline scoring rule";
            rtrue;
        }
        if ((R == call_U994)) {
            print "display banner rule";
            rtrue;
        }
        if ((R == call_U995)) {
            print "initial room description rule";
            rtrue;
        }
        if ((R == call_U996)) {
            print "every turn stage rule";
            rtrue;
        }
        if ((R == call_U997)) {
            print "A first turn sequence rule";
            rtrue;
        }
        if ((R == call_U998)) {
            print "A last turn sequence rule";
            rtrue;
        }
        if ((R == call_U999)) {
            print "notify score changes rule";
            rtrue;
        }
        if ((R == call_U1000)) {
            print "when play ends stage rule";
            rtrue;
        }
        if ((R == call_U1001)) {
            print "print player's obituary rule";
            rtrue;
        }
        if ((R == call_U1002)) {
            print "set pronouns from items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U1003)) {
            print "announce items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U1006)) {
            print "before stage rule";
            rtrue;
        }
        if ((R == call_U1007)) {
            print "instead stage rule";
            rtrue;
        }
        if ((R == call_U1008)) {
            print "end action-processing in success rule";
            rtrue;
        }
        if ((R == call_U1009)) {
            print "investigate player's awareness before action rule";
            rtrue;
        }
        if ((R == call_U1010)) {
            print "check stage rule";
            rtrue;
        }
        if ((R == call_U1011)) {
            print "carry out stage rule";
            rtrue;
        }
        if ((R == call_U1012)) {
            print "after stage rule";
            rtrue;
        }
        if ((R == call_U1013)) {
            print "investigate player's awareness after action rule";
            rtrue;
        }
        if ((R == call_U1014)) {
            print "report stage rule";
            rtrue;
        }
        if ((R == call_U1015)) {
            print "last specific action-processing rule";
            rtrue;
        }
        if ((R == call_U1016)) {
            print "player aware of his own actions rule";
            rtrue;
        }
        if ((R == call_U1017)) {
            print "player aware of actions by visible actors rule";
            rtrue;
        }
        if ((R == call_U1018)) {
            print "player aware of actions on visible nouns rule";
            rtrue;
        }
        if ((R == call_U1019)) {
            print "player aware of actions on visible second nouns rule";
            rtrue;
        }
        if ((R == call_U1020)) {
            print "can't act in the dark rule";
            rtrue;
        }
        if ((R == call_U1021)) {
            print "very unlikely to mean taking what's already carried rule";
            rtrue;
        }
        if ((R == call_U1022)) {
            print "scene description text rule";
            rtrue;
        }
        if ((R == call_U1023)) {
            print "make named things mentioned rule";
            rtrue;
        }
        if ((R == call_U1024)) {
            print "standard printing a number of something rule";
            rtrue;
        }
        if ((R == call_U1025)) {
            print "look around once light available rule";
            rtrue;
        }
        if ((R == call_U1026)) {
            print "exclude scenery from take all rule";
            rtrue;
        }
        if ((R == call_U1027)) {
            print "exclude people from take all rule";
            rtrue;
        }
        if ((R == call_U1028)) {
            print "exclude fixed in place things from take all rule";
            rtrue;
        }
        if ((R == call_U1029)) {
            print "exclude indirect possessions from take all rule";
            rtrue;
        }
        if ((R == call_U1030)) {
            print "exclude people from drop all rule";
            rtrue;
        }
        if ((R == call_U1031)) {
            print "ambient odour rule";
            rtrue;
        }
        if ((R == call_U1032)) {
            print "ambient sound rule";
            rtrue;
        }
        if ((R == call_U1033)) {
            print "block vaguely going rule";
            rtrue;
        }
        if ((R == call_U1036)) {
            print "print the final prompt rule";
            rtrue;
        }
        if ((R == call_U1039)) {
            print "print the final question rule";
            rtrue;
        }
        if ((R == call_U1044)) {
            print "standard respond to final question rule";
            rtrue;
        }
        if ((R == call_U1047)) {
            print "initialise locale description rule";
            rtrue;
        }
        if ((R == call_U1048)) {
            print "find notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1049)) {
            print "interesting locale paragraphs rule";
            rtrue;
        }
        if ((R == call_U1050)) {
            print "you-can-also-see rule";
            rtrue;
        }
        if ((R == call_U1068)) {
            print "standard notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1069)) {
            print "don't mention player's supporter in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1070)) {
            print "don't mention scenery in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1071)) {
            print "don't mention undescribed items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1072)) {
            print "set pronouns from items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1073)) {
            print "offer items to writing a paragraph about rule";
            rtrue;
        }
        if ((R == call_U1074)) {
            print "use initial appearance in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1079)) {
            print "initial appearance on supporters rule";
            rtrue;
        }
        if ((R == call_U1081)) {
            print "describe what's on scenery supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1086)) {
            print "describe what's on mentioned supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1091)) {
            print "print empty inventory rule";
            rtrue;
        }
        if ((R == call_U1094)) {
            print "print standard inventory rule";
            rtrue;
        }
        if ((R == call_U1097)) {
            print "report other people taking inventory rule";
            rtrue;
        }
        if ((R == call_U1100)) {
            print "can't take yourself rule";
            rtrue;
        }
        if ((R == call_U1103)) {
            print "can't take other people rule";
            rtrue;
        }
        if ((R == call_U1106)) {
            print "can't take component parts rule";
            rtrue;
        }
        if ((R == call_U1109)) {
            print "can't take people's possessions rule";
            rtrue;
        }
        if ((R == call_U1112)) {
            print "can't take items out of play rule";
            rtrue;
        }
        if ((R == call_U1115)) {
            print "can't take what you're inside rule";
            rtrue;
        }
        if ((R == call_U1118)) {
            print "can't take what's already taken rule";
            rtrue;
        }
        if ((R == call_U1121)) {
            print "can't take scenery rule";
            rtrue;
        }
        if ((R == call_U1124)) {
            print "can only take things rule";
            rtrue;
        }
        if ((R == call_U1127)) {
            print "can't take what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1130)) {
            print "use player's holdall to avoid exceeding carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1136)) {
            print "can't exceed carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1140)) {
            print "standard taking rule";
            rtrue;
        }
        if ((R == call_U1141)) {
            print "standard report taking rule";
            rtrue;
        }
        if ((R == call_U1146)) {
            print "can't remove what's not inside rule";
            rtrue;
        }
        if ((R == call_U1149)) {
            print "can't remove from people rule";
            rtrue;
        }
        if ((R == call_U1152)) {
            print "convert remove to take rule";
            rtrue;
        }
        if ((R == call_U1153)) {
            print "can't drop yourself rule";
            rtrue;
        }
        if ((R == call_U1156)) {
            print "can't drop body parts rule";
            rtrue;
        }
        if ((R == call_U1159)) {
            print "can't drop what's already dropped rule";
            rtrue;
        }
        if ((R == call_U1162)) {
            print "can't drop what's not held rule";
            rtrue;
        }
        if ((R == call_U1165)) {
            print "can't drop clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1168)) {
            print "can't drop if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1175)) {
            print "standard dropping rule";
            rtrue;
        }
        if ((R == call_U1176)) {
            print "standard report dropping rule";
            rtrue;
        }
        if ((R == call_U1181)) {
            print "convert put to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1182)) {
            print "can't put what's not held rule";
            rtrue;
        }
        if ((R == call_U1183)) {
            print "can't put something on itself rule";
            rtrue;
        }
        if ((R == call_U1186)) {
            print "can't put onto what's not a supporter rule";
            rtrue;
        }
        if ((R == call_U1189)) {
            print "can't put clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1192)) {
            print "can't put if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1196)) {
            print "standard putting rule";
            rtrue;
        }
        if ((R == call_U1197)) {
            print "concise report putting rule";
            rtrue;
        }
        if ((R == call_U1200)) {
            print "standard report putting rule";
            rtrue;
        }
        if ((R == call_U1203)) {
            print "convert insert to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1204)) {
            print "can't insert what's already inserted rule";
            rtrue;
        }
        if ((R == call_U1207)) {
            print "can't insert something into itself rule";
            rtrue;
        }
        if ((R == call_U1210)) {
            print "can't insert what's not held rule";
            rtrue;
        }
        if ((R == call_U1211)) {
            print "can't insert into closed containers rule";
            rtrue;
        }
        if ((R == call_U1214)) {
            print "can't insert into what's not a container rule";
            rtrue;
        }
        if ((R == call_U1217)) {
            print "can't insert clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1220)) {
            print "can't insert if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1224)) {
            print "standard inserting rule";
            rtrue;
        }
        if ((R == call_U1225)) {
            print "concise report inserting rule";
            rtrue;
        }
        if ((R == call_U1228)) {
            print "standard report inserting rule";
            rtrue;
        }
        if ((R == call_U1231)) {
            print "can't eat unless edible rule";
            rtrue;
        }
        if ((R == call_U1234)) {
            print "can't eat clothing without removing it first rule";
            rtrue;
        }
        if ((R == call_U1237)) {
            print "can't eat other people's food rule";
            rtrue;
        }
        if ((R == call_U1241)) {
            print "can't eat portable food without carrying it rule";
            rtrue;
        }
        if ((R == call_U1242)) {
            print "standard eating rule";
            rtrue;
        }
        if ((R == call_U1243)) {
            print "standard report eating rule";
            rtrue;
        }
        if ((R == call_U1248)) {
            print "standard set going variables rule";
            rtrue;
        }
        if ((R == call_U1249)) {
            print "stand up before going rule";
            rtrue;
        }
        if ((R == call_U1252)) {
            print "can't travel in what's not a vehicle rule";
            rtrue;
        }
        if ((R == call_U1257)) {
            print "can't go through undescribed doors rule";
            rtrue;
        }
        if ((R == call_U1260)) {
            print "can't go through closed doors rule";
            rtrue;
        }
        if ((R == call_U1263)) {
            print "determine map connection rule";
            rtrue;
        }
        if ((R == call_U1264)) {
            print "can't go that way rule";
            rtrue;
        }
        if ((R == call_U1269)) {
            print "move player and vehicle rule";
            rtrue;
        }
        if ((R == call_U1270)) {
            print "move floating objects rule";
            rtrue;
        }
        if ((R == call_U1271)) {
            print "check light in new location rule";
            rtrue;
        }
        if ((R == call_U1272)) {
            print "describe room gone into rule";
            rtrue;
        }
        if ((R == call_U1311)) {
            print "find what to enter rule";
            rtrue;
        }
        if ((R == call_U1313)) {
            print "convert enter door into go rule";
            rtrue;
        }
        if ((R == call_U1314)) {
            print "convert enter compass direction into go rule";
            rtrue;
        }
        if ((R == call_U1315)) {
            print "can't enter what's already entered rule";
            rtrue;
        }
        if ((R == call_U1320)) {
            print "can't enter what's not enterable rule";
            rtrue;
        }
        if ((R == call_U1329)) {
            print "can't enter closed containers rule";
            rtrue;
        }
        if ((R == call_U1332)) {
            print "can't enter if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1339)) {
            print "can't enter something carried rule";
            rtrue;
        }
        if ((R == call_U1342)) {
            print "implicitly pass through other barriers rule";
            rtrue;
        }
        if ((R == call_U1353)) {
            print "standard entering rule";
            rtrue;
        }
        if ((R == call_U1354)) {
            print "standard report entering rule";
            rtrue;
        }
        if ((R == call_U1363)) {
            print "describe contents entered into rule";
            rtrue;
        }
        if ((R == call_U1364)) {
            print "standard set exiting variables rule";
            rtrue;
        }
        if ((R == call_U1365)) {
            print "convert exit into go out rule";
            rtrue;
        }
        if ((R == call_U1366)) {
            print "can't exit when not inside anything rule";
            rtrue;
        }
        if ((R == call_U1369)) {
            print "can't exit closed containers rule";
            rtrue;
        }
        if ((R == call_U1372)) {
            print "convert exit into get off rule";
            rtrue;
        }
        if ((R == call_U1373)) {
            print "standard exiting rule";
            rtrue;
        }
        if ((R == call_U1374)) {
            print "standard report exiting rule";
            rtrue;
        }
        if ((R == call_U1381)) {
            print "describe room emerged into rule";
            rtrue;
        }
        if ((R == call_U1382)) {
            print "can't get off things rule";
            rtrue;
        }
        if ((R == call_U1385)) {
            print "standard getting off rule";
            rtrue;
        }
        if ((R == call_U1386)) {
            print "standard report getting off rule";
            rtrue;
        }
        if ((R == call_U1389)) {
            print "describe room stood up into rule";
            rtrue;
        }
        if ((R == call_U1390)) {
            print "determine visibility ceiling rule";
            rtrue;
        }
        if ((R == call_U1391)) {
            print "declare everything unmentioned rule";
            rtrue;
        }
        if ((R == call_U1393)) {
            print "room description heading rule";
            rtrue;
        }
        if ((R == call_U1400)) {
            print "room description body text rule";
            rtrue;
        }
        if ((R == call_U1403)) {
            print "room description paragraphs about objects rule";
            rtrue;
        }
        if ((R == call_U1404)) {
            print "check new arrival rule";
            rtrue;
        }
        if ((R == call_U1405)) {
            print "other people looking rule";
            rtrue;
        }
        if ((R == call_U1408)) {
            print "standard examining rule";
            rtrue;
        }
        if ((R == call_U1409)) {
            print "examine directions rule";
            rtrue;
        }
        if ((R == call_U1412)) {
            print "examine containers rule";
            rtrue;
        }
        if ((R == call_U1419)) {
            print "examine supporters rule";
            rtrue;
        }
        if ((R == call_U1424)) {
            print "examine devices rule";
            rtrue;
        }
        if ((R == call_U1427)) {
            print "examine undescribed things rule";
            rtrue;
        }
        if ((R == call_U1430)) {
            print "report other people examining rule";
            rtrue;
        }
        if ((R == call_U1433)) {
            print "standard looking under rule";
            rtrue;
        }
        if ((R == call_U1436)) {
            print "report other people looking under rule";
            rtrue;
        }
        if ((R == call_U1439)) {
            print "can't search unless container or supporter rule";
            rtrue;
        }
        if ((R == call_U1442)) {
            print "can't search closed opaque containers rule";
            rtrue;
        }
        if ((R == call_U1445)) {
            print "standard search containers rule";
            rtrue;
        }
        if ((R == call_U1451)) {
            print "standard search supporters rule";
            rtrue;
        }
        if ((R == call_U1457)) {
            print "report other people searching rule";
            rtrue;
        }
        if ((R == call_U1460)) {
            print "block consulting rule";
            rtrue;
        }
        if ((R == call_U1465)) {
            print "can't lock without a lock rule";
            rtrue;
        }
        if ((R == call_U1468)) {
            print "can't lock what's already locked rule";
            rtrue;
        }
        if ((R == call_U1471)) {
            print "can't lock what's open rule";
            rtrue;
        }
        if ((R == call_U1474)) {
            print "can't lock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1477)) {
            print "standard locking rule";
            rtrue;
        }
        if ((R == call_U1478)) {
            print "standard report locking rule";
            rtrue;
        }
        if ((R == call_U1483)) {
            print "can't unlock without a lock rule";
            rtrue;
        }
        if ((R == call_U1486)) {
            print "can't unlock what's already unlocked rule";
            rtrue;
        }
        if ((R == call_U1489)) {
            print "can't unlock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1492)) {
            print "standard unlocking rule";
            rtrue;
        }
        if ((R == call_U1493)) {
            print "standard report unlocking rule";
            rtrue;
        }
        if ((R == call_U1498)) {
            print "can't switch on unless switchable rule";
            rtrue;
        }
        if ((R == call_U1501)) {
            print "can't switch on what's already on rule";
            rtrue;
        }
        if ((R == call_U1504)) {
            print "standard switching on rule";
            rtrue;
        }
        if ((R == call_U1505)) {
            print "standard report switching on rule";
            rtrue;
        }
        if ((R == call_U1508)) {
            print "can't switch off unless switchable rule";
            rtrue;
        }
        if ((R == call_U1511)) {
            print "can't switch off what's already off rule";
            rtrue;
        }
        if ((R == call_U1514)) {
            print "standard switching off rule";
            rtrue;
        }
        if ((R == call_U1515)) {
            print "standard report switching off rule";
            rtrue;
        }
        if ((R == call_U1518)) {
            print "can't open unless openable rule";
            rtrue;
        }
        if ((R == call_U1521)) {
            print "can't open what's locked rule";
            rtrue;
        }
        if ((R == call_U1524)) {
            print "can't open what's already open rule";
            rtrue;
        }
        if ((R == call_U1527)) {
            print "standard opening rule";
            rtrue;
        }
        if ((R == call_U1528)) {
            print "reveal any newly visible interior rule";
            rtrue;
        }
        if ((R == call_U1531)) {
            print "standard report opening rule";
            rtrue;
        }
        if ((R == call_U1538)) {
            print "can't close unless openable rule";
            rtrue;
        }
        if ((R == call_U1541)) {
            print "can't close what's already closed rule";
            rtrue;
        }
        if ((R == call_U1544)) {
            print "standard closing rule";
            rtrue;
        }
        if ((R == call_U1545)) {
            print "standard report closing rule";
            rtrue;
        }
        if ((R == call_U1552)) {
            print "can't wear what's not clothing rule";
            rtrue;
        }
        if ((R == call_U1555)) {
            print "can't wear what's not held rule";
            rtrue;
        }
        if ((R == call_U1558)) {
            print "can't wear what's already worn rule";
            rtrue;
        }
        if ((R == call_U1561)) {
            print "standard wearing rule";
            rtrue;
        }
        if ((R == call_U1562)) {
            print "standard report wearing rule";
            rtrue;
        }
        if ((R == call_U1567)) {
            print "Does the player mean taking off something worn";
            rtrue;
        }
        if ((R == call_U1568)) {
            print "can't take off what's not worn rule";
            rtrue;
        }
        if ((R == call_U1571)) {
            print "can't exceed carrying capacity when taking off rule";
            rtrue;
        }
        if ((R == call_U1575)) {
            print "standard taking off rule";
            rtrue;
        }
        if ((R == call_U1576)) {
            print "standard report taking off rule";
            rtrue;
        }
        if ((R == call_U1581)) {
            print "can't give what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1584)) {
            print "can't give to yourself rule";
            rtrue;
        }
        if ((R == call_U1587)) {
            print "can't give to a non-person rule";
            rtrue;
        }
        if ((R == call_U1590)) {
            print "can't give clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1593)) {
            print "block giving rule";
            rtrue;
        }
        if ((R == call_U1596)) {
            print "can't exceed carrying capacity when giving rule";
            rtrue;
        }
        if ((R == call_U1600)) {
            print "standard giving rule";
            rtrue;
        }
        if ((R == call_U1601)) {
            print "standard report giving rule";
            rtrue;
        }
        if ((R == call_U1608)) {
            print "can't show what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1611)) {
            print "convert show to yourself to examine rule";
            rtrue;
        }
        if ((R == call_U1612)) {
            print "block showing rule";
            rtrue;
        }
        if ((R == call_U1615)) {
            print "block waking rule";
            rtrue;
        }
        if ((R == call_U1618)) {
            print "implicitly remove thrown clothing rule";
            rtrue;
        }
        if ((R == call_U1621)) {
            print "futile to throw things at inanimate objects rule";
            rtrue;
        }
        if ((R == call_U1624)) {
            print "block throwing at rule";
            rtrue;
        }
        if ((R == call_U1627)) {
            print "block attacking rule";
            rtrue;
        }
        if ((R == call_U1630)) {
            print "kissing yourself rule";
            rtrue;
        }
        if ((R == call_U1633)) {
            print "block kissing rule";
            rtrue;
        }
        if ((R == call_U1636)) {
            print "block answering rule";
            rtrue;
        }
        if ((R == call_U1639)) {
            print "telling yourself rule";
            rtrue;
        }
        if ((R == call_U1642)) {
            print "block telling rule";
            rtrue;
        }
        if ((R == call_U1645)) {
            print "block asking rule";
            rtrue;
        }
        if ((R == call_U1648)) {
            print "asking yourself for something rule";
            rtrue;
        }
        if ((R == call_U1649)) {
            print "translate asking for to giving rule";
            rtrue;
        }
        if ((R == call_U1650)) {
            print "standard report waiting rule";
            rtrue;
        }
        if ((R == call_U1655)) {
            print "report touching yourself rule";
            rtrue;
        }
        if ((R == call_U1660)) {
            print "report touching other people rule";
            rtrue;
        }
        if ((R == call_U1667)) {
            print "report touching things rule";
            rtrue;
        }
        if ((R == call_U1672)) {
            print "can't wave what's not held rule";
            rtrue;
        }
        if ((R == call_U1675)) {
            print "report waving things rule";
            rtrue;
        }
        if ((R == call_U1680)) {
            print "can't pull what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1683)) {
            print "can't pull scenery rule";
            rtrue;
        }
        if ((R == call_U1686)) {
            print "can't pull people rule";
            rtrue;
        }
        if ((R == call_U1689)) {
            print "report pulling rule";
            rtrue;
        }
        if ((R == call_U1694)) {
            print "can't push what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1697)) {
            print "can't push scenery rule";
            rtrue;
        }
        if ((R == call_U1700)) {
            print "can't push people rule";
            rtrue;
        }
        if ((R == call_U1703)) {
            print "report pushing rule";
            rtrue;
        }
        if ((R == call_U1708)) {
            print "can't turn what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1711)) {
            print "can't turn scenery rule";
            rtrue;
        }
        if ((R == call_U1714)) {
            print "can't turn people rule";
            rtrue;
        }
        if ((R == call_U1717)) {
            print "report turning rule";
            rtrue;
        }
        if ((R == call_U1722)) {
            print "can't push unpushable things rule";
            rtrue;
        }
        if ((R == call_U1725)) {
            print "can't push to non-directions rule";
            rtrue;
        }
        if ((R == call_U1728)) {
            print "can't push vertically rule";
            rtrue;
        }
        if ((R == call_U1731)) {
            print "can't push from within rule";
            rtrue;
        }
        if ((R == call_U1734)) {
            print "standard pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1735)) {
            print "block pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1738)) {
            print "innuendo about squeezing people rule";
            rtrue;
        }
        if ((R == call_U1741)) {
            print "report squeezing rule";
            rtrue;
        }
        if ((R == call_U1746)) {
            print "block saying yes rule";
            rtrue;
        }
        if ((R == call_U1749)) {
            print "block saying no rule";
            rtrue;
        }
        if ((R == call_U1752)) {
            print "block burning rule";
            rtrue;
        }
        if ((R == call_U1755)) {
            print "block waking up rule";
            rtrue;
        }
        if ((R == call_U1758)) {
            print "block thinking rule";
            rtrue;
        }
        if ((R == call_U1761)) {
            print "report smelling rule";
            rtrue;
        }
        if ((R == call_U1766)) {
            print "report listening rule";
            rtrue;
        }
        if ((R == call_U1771)) {
            print "report tasting rule";
            rtrue;
        }
        if ((R == call_U1776)) {
            print "block cutting rule";
            rtrue;
        }
        if ((R == call_U1779)) {
            print "report jumping rule";
            rtrue;
        }
        if ((R == call_U1784)) {
            print "block tying rule";
            rtrue;
        }
        if ((R == call_U1787)) {
            print "block drinking rule";
            rtrue;
        }
        if ((R == call_U1790)) {
            print "block saying sorry rule";
            rtrue;
        }
        if ((R == call_U1793)) {
            print "block swinging rule";
            rtrue;
        }
        if ((R == call_U1796)) {
            print "can't rub another person rule";
            rtrue;
        }
        if ((R == call_U1799)) {
            print "report rubbing rule";
            rtrue;
        }
        if ((R == call_U1804)) {
            print "block setting it to rule";
            rtrue;
        }
        if ((R == call_U1807)) {
            print "report waving hands rule";
            rtrue;
        }
        if ((R == call_U1812)) {
            print "block buying rule";
            rtrue;
        }
        if ((R == call_U1815)) {
            print "block climbing rule";
            rtrue;
        }
        if ((R == call_U1818)) {
            print "block sleeping rule";
            rtrue;
        }
        if ((R == LITTLE_USED_DO_NOTHING_R)) {
            print "little-used do nothing rule";
            rtrue;
        }
        if ((R == VIRTUAL_MACHINE_STARTUP_R)) {
            print "virtual machine startup rule";
            rtrue;
        }
        if ((R == INITIALISE_MEMORY_R)) {
            print "initialise memory rule";
            rtrue;
        }
        if ((R == SEED_RANDOM_NUMBER_GENERATOR_R)) {
            print "seed random number generator rule";
            rtrue;
        }
        if ((R == UPDATE_CHRONOLOGICAL_RECORDS_R)) {
            print "update chronological records rule";
            rtrue;
        }
        if ((R == POSITION_PLAYER_IN_MODEL_R)) {
            print "position player in model world rule";
            rtrue;
        }
        if ((R == ADVANCE_TIME_R)) {
            print "advance time rule";
            rtrue;
        }
        if ((R == NOTE_OBJECT_ACQUISITIONS_R)) {
            print "note object acquisitions rule";
            rtrue;
        }
        if ((R == PARSE_COMMAND_R)) {
            print "parse command rule";
            rtrue;
        }
        if ((R == TIMED_EVENTS_R)) {
            print "timed events rule";
            rtrue;
        }
        if ((R == RESURRECT_PLAYER_IF_ASKED_R)) {
            print "resurrect player if asked rule";
            rtrue;
        }
        if ((R == ASK_FINAL_QUESTION_R)) {
            print "ask the final question rule";
            rtrue;
        }
        if ((R == SCENE_CHANGE_MACHINERY_R)) {
            print "scene change machinery rule";
            rtrue;
        }
        if ((R == CARRYING_REQUIREMENTS_R)) {
            print "carrying requirements rule";
            rtrue;
        }
        if ((R == DESCEND_TO_SPECIFIC_ACTION_R)) {
            print "descend to specific action-processing rule";
            rtrue;
        }
        if ((R == WORK_OUT_DETAILS_OF_SPECIFIC_R)) {
            print "work out details of specific action rule";
            rtrue;
        }
        if ((R == STANDARD_RESPONSE_ISSUING_R)) {
            print "standard issuing the response text rule";
            rtrue;
        }
        if ((R == STANDARD_CONTENTS_LISTING_R)) {
            print "standard contents listing rule";
            rtrue;
        }
        if ((R == PRINT_FINAL_SCORE_R)) {
            print "print final score rule";
            rtrue;
        }
        if ((R == DISPLAY_FINAL_STATUS_LINE_R)) {
            print "display final status line rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTART_VM_R)) {
            print "immediately restart the VM rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTORE_SAVED_R)) {
            print "immediately restore saved game rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_QUIT_R)) {
            print "immediately quit rule";
            rtrue;
        }
        if ((R == READ_FINAL_ANSWER_R)) {
            print "read the final answer rule";
            rtrue;
        }
        if ((R == ANNOUNCE_STORY_FILE_VERSION_R)) {
            print "announce the story file version rule";
            rtrue;
        }
        if ((R == PREFER_ABBREVIATED_R)) {
            print "prefer abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_UNABBREVIATED_R)) {
            print "prefer unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_SOMETIMES_ABBREVIATED_R)) {
            print "prefer sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_ON_R)) {
            print "switch score notification on rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_OFF_R)) {
            print "switch score notification off rule";
            rtrue;
        }
        if ((R == call_U1944)) {
            print "opening doors before entering rule";
            rtrue;
        }
        if ((R == call_U1947)) {
            print "closing doors before locking rule";
            rtrue;
        }
        if ((R == call_U1950)) {
            print "closing doors before locking keylessly rule";
            rtrue;
        }
        if ((R == call_U1953)) {
            print "unlocking before opening rule";
            rtrue;
        }
        if ((R == call_U1956)) {
            print "intelligently opening doors rule";
            rtrue;
        }
        if ((R == call_U1957)) {
            print "intelligently closing doors rule";
            rtrue;
        }
        if ((R == call_U1958)) {
            print "intelligently closing keyless doors rule";
            rtrue;
        }
        if ((R == call_U1959)) {
            print "intelligently opening containers rule";
            rtrue;
        }
        if ((R == call_U1960)) {
            print "need a matching key rule";
            rtrue;
        }
        if ((R == call_U1961)) {
            print "standard printing key lack rule";
            rtrue;
        }
        if ((R == call_U1964)) {
            print "must be able to reach the key rule";
            rtrue;
        }
        if ((R == call_U1965)) {
            print "right second rule";
            rtrue;
        }
        if ((R == call_U1968)) {
            print "check keylessly unlocking rule";
            rtrue;
        }
        if ((R == call_U1969)) {
            print "standard keylessly unlocking rule";
            rtrue;
        }
        if ((R == call_U1972)) {
            print "Check locking it with";
            rtrue;
        }
        if ((R == call_U1973)) {
            print "check keylessly locking rule";
            rtrue;
        }
        if ((R == call_U1974)) {
            print "standard keylessly locking rule";
            rtrue;
        }
        if ((R == call_U1977)) {
            print "identify passkeys in inventory rule";
            rtrue;
        }
        if ((R == call_U1980)) {
            print "passkey description rule";
            rtrue;
        }
        if ((R == call_U1983)) {
            print "standard passkey unlocking rule";
            rtrue;
        }
        if ((R == call_U1984)) {
            print "observe someone unlocking rule";
            rtrue;
        }
        if ((R == call_U1985)) {
            print "standard passkey locking rule";
            rtrue;
        }
        if ((R == call_U1986)) {
            print "observe someone locking rule";
            rtrue;
        }
        if ((R == call_U1987)) {
            print "limiting keychains rule";
            rtrue;
        }
        if ((R == call_U1990)) {
            print "keychain-aware carrying requirements rule";
            rtrue;
        }
        if ((R == call_U1991)) {
            print "don't strip keys rule";
            rtrue;
        }
        if ((R == call_U1992)) {
            print "noun autotaking rule";
            rtrue;
        }
        if ((R == call_U1993)) {
            print "second noun autotaking rule";
            rtrue;
        }
        if ((R == call_U1994)) {
            print "must hold the noun rule";
            rtrue;
        }
        if ((R == call_U1995)) {
            print "must hold the second noun rule";
            rtrue;
        }
        if ((R == call_U1996)) {
            print "noun must be accessible rule";
            rtrue;
        }
        if ((R == call_U1999)) {
            print "second noun must be accessible rule";
            rtrue;
        }
        if ((R == call_U2008)) {
            print "standard pausing the game rule";
            rtrue;
        }
        if ((R == call_U2018)) {
            print "quit rule";
            rtrue;
        }
        if ((R == call_U2019)) {
            print "move down rule";
            rtrue;
        }
        if ((R == call_U2020)) {
            print "move up rule";
            rtrue;
        }
        if ((R == call_U2021)) {
            print "select rule";
            rtrue;
        }
        if ((R == call_U2022)) {
            print "basic menu contents rule";
            rtrue;
        }
        if ((R == call_U2023)) {
            print "constructing status line while displaying rule";
            rtrue;
        }
        if ((R == call_U2024)) {
            print "hint toggle rule";
            rtrue;
        }
        if ((R == call_U2039)) {
            print "switch notification status rule";
            rtrue;
        }
        if ((R == call_U2040)) {
            print "switch description types rule";
            rtrue;
        }
        if ((R == call_U2041)) {
            print "help request rule";
            rtrue;
        }
        if ((R == call_U2065)) {
            print "allow rideables to be going vehicles rule";
            rtrue;
        }
        if ((R == call_U2066)) {
            print "Before an actor entering a rideable animal ( called the steed )";
            rtrue;
        }
        if ((R == call_U2067)) {
            print "Before an actor entering a rideable vehicle ( called the conveyance )";
            rtrue;
        }
        if ((R == call_U2068)) {
            print "Before an actor getting off a rideable animal ( called the steed )";
            rtrue;
        }
        if ((R == call_U2069)) {
            print "Before an actor getting off a rideable vehicle ( called the conveyance )";
            rtrue;
        }
        if ((R == call_U2070)) {
            print "Before an actor exiting";
            rtrue;
        }
        if ((R == call_U2071)) {
            print "can't mount when mounted on an animal rule";
            rtrue;
        }
        if ((R == call_U2074)) {
            print "can't mount when mounted on a vehicle rule";
            rtrue;
        }
        if ((R == call_U2077)) {
            print "can't mount something unrideable rule";
            rtrue;
        }
        if ((R == call_U2080)) {
            print "can't mount something carried rule";
            rtrue;
        }
        if ((R == call_U2081)) {
            print "can't mount something unreachable rule";
            rtrue;
        }
        if ((R == call_U2082)) {
            print "standard mounting rule";
            rtrue;
        }
        if ((R == call_U2083)) {
            print "standard report mounting rule";
            rtrue;
        }
        if ((R == call_U2088)) {
            print "mounting excuses rule";
            rtrue;
        }
        if ((R == call_U2097)) {
            print "can't dismount when not mounted rule";
            rtrue;
        }
        if ((R == call_U2102)) {
            print "standard dismounting rule";
            rtrue;
        }
        if ((R == call_U2103)) {
            print "standard report dismounting rule";
            rtrue;
        }
        if ((R == call_U2108)) {
            print "dismounting excuses rule";
            rtrue;
        }
        if ((R == call_U2111)) {
            print "Before asking a rideable animal ( called the mount ) to try going a direction ( called the way )";
            rtrue;
        }
        if ((R == call_U2120)) {
            print "block swearing obscenely rule";
            rtrue;
        }
        if ((R == call_U2121)) {
            print "block swearing mildly rule";
            rtrue;
        }
        if ((R == call_U2125)) {
            print "block singing rule";
            rtrue;
        }
        if ((R == call_U2337)) {
            print "After examining something for sale";
            rtrue;
        }
        if ((R == call_U2338)) {
            print "Instead of taking something for sale";
            rtrue;
        }
        if ((R == call_U2339)) {
            print "Before buying something for sale when the money is not in the wallet";
            rtrue;
        }
        if ((R == call_U2340)) {
            print "Before buying something for sale when the money is free";
            rtrue;
        }
        if ((R == call_U2341)) {
            print "Before buying something for sale when the price of the money is less than the price of the noun";
            rtrue;
        }
        if ((R == call_U2342)) {
            print "Instead of buying something";
            rtrue;
        }
        if ((R == call_U2343)) {
            print "Instead of taking the money";
            rtrue;
        }
        if ((R == call_U2344)) {
            print "Instead of buying something free";
            rtrue;
        }
        if ((R == call_U2345)) {
            print "Instead of buying the money";
            rtrue;
        }
        if ((R == call_U2346)) {
            print "Instead of examining a fluid container";
            rtrue;
        }
        if ((R == call_U2347)) {
            print "Before printing the name of a fluid container ( called the target ) while not drinking";
            rtrue;
        }
        if ((R == call_U2348)) {
            print "After printing the name of a fluid container ( called the target ) while not examining";
            rtrue;
        }
        if ((R == call_U2349)) {
            print "Instead of inserting something into a fluid container";
            rtrue;
        }
        if ((R == call_U2350)) {
            print "Instead of drinking a fluid container";
            rtrue;
        }
        if ((R == call_U2351)) {
            print "Check pouring it into";
            rtrue;
        }
        if ((R == call_U2352)) {
            print "Carry out pouring it into";
            rtrue;
        }
        if ((R == call_U2353)) {
            print "Report pouring it into";
            rtrue;
        }
        if ((R == call_U2354)) {
            print "Check hiding it under";
            rtrue;
        }
        if ((R == call_U2355)) {
            print "Carry out hiding it under";
            rtrue;
        }
        if ((R == call_U2356)) {
            print "Report hiding it under";
            rtrue;
        }
        if ((R == call_U2357)) {
            print "Rule for showing action of something ( called item )";
            rtrue;
        }
        if ((R == call_U2358)) {
            print "new described devices rule";
            rtrue;
        }
        if ((R == call_U2359)) {
            print "Report switching on something";
            rtrue;
        }
        if ((R == call_U2360)) {
            print "Rule for showing action of an electric lamp ( called item )";
            rtrue;
        }
        if ((R == call_U2362)) {
            print "Carry out switching on an electric lamp";
            rtrue;
        }
        if ((R == call_U2363)) {
            print "Carry out switching off an electric lamp";
            rtrue;
        }
        if ((R == call_U2364)) {
            print "Rule for showing action of the flashlight";
            rtrue;
        }
        if ((R == call_U2365)) {
            print "Before printing the name of a lit electric lamp";
            rtrue;
        }
        if ((R == call_U2366)) {
            print "Before printing the name of an unlit lit electric lamp";
            rtrue;
        }
        if ((R == call_U2367)) {
            print "Rule for printing the description of a dark room";
            rtrue;
        }
        if ((R == call_U2368)) {
            print "Rule for printing a refusal to act in the dark";
            rtrue;
        }
        if ((R == call_U2369)) {
            print "Setting action variables for going";
            rtrue;
        }
        if ((R == call_U2370)) {
            print "last carry out going rule";
            rtrue;
        }
        if ((R == call_U2371)) {
            print "After going";
            rtrue;
        }
        if ((R == call_U2372)) {
            print "Carry out examining a thing";
            rtrue;
        }
        if ((R == call_U2373)) {
            print "Carry out going to a unvisited scored room";
            rtrue;
        }
        if ((R == call_U2374)) {
            print "Check hi-speaking";
            rtrue;
        }
        if ((R == call_U2375)) {
            print "Carry out hi-speaking";
            rtrue;
        }
        if ((R == call_U2376)) {
            print "Check hi-speaking the sailor for the tenth time";
            rtrue;
        }
        if ((R == call_U2377)) {
            print "Check hi-speaking the sailor for the 20th time";
            rtrue;
        }
        if ((R == call_U2378)) {
            print "Carry out casting xyzzy";
            rtrue;
        }
        if ((R == call_U2379)) {
            print "Instead of examining the player";
            rtrue;
        }
        if ((R == call_U2380)) {
            print "every turn when examining the coupon";
            rtrue;
        }
        if ((R == call_U2381)) {
            print "After reading a command";
            rtrue;
        }
        if ((R == call_U2382)) {
            print "every turn";
            rtrue;
        }
        if ((R == call_U2383)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2385)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2386)) {
            print "Instead of going from the Electrical Room";
            rtrue;
        }
        if ((R == call_U2388)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2389)) {
            print "Instead of looking under a thing which is underlaid by the dime";
            rtrue;
        }
        if ((R == call_U2392)) {
            print "After taking blueberries";
            rtrue;
        }
        if ((R == call_U2393)) {
            print "instead of giving the coupon to the parking attendant";
            rtrue;
        }
        if ((R == call_U2394)) {
            print "before buying the parking ticket";
            rtrue;
        }
        if ((R == call_U2395)) {
            print "instead of going south when the location is the parking lot and the player does not carry the parking ticket";
            rtrue;
        }
        if ((R == call_U2396)) {
            print "instead of going south when the location is the parking lot and the player is in the beater car";
            rtrue;
        }
        if ((R == call_U2397)) {
            print "After going south from the parking lot when the Kiosk is unvisited and the player carries the parking ticket";
            rtrue;
        }
        if ((R == call_U2398)) {
            print "Before looking when the location is the Kiosk";
            rtrue;
        }
        if ((R == call_U2399)) {
            print "After buying the hell ride ticket";
            rtrue;
        }
        if ((R == call_U2400)) {
            print "Before going southwest when the location is the kiosk and the Concession Stand is unvisited";
            rtrue;
        }
        if ((R == call_U2401)) {
            print "Before looking when the location is the Concession Stand";
            rtrue;
        }
        if ((R == call_U2402)) {
            print "Instead of player drinking a fluid container";
            rtrue;
        }
        if ((R == call_U2403)) {
            print "Before going east when the location is the kiosk and the High Striker is unvisited";
            rtrue;
        }
        if ((R == call_U2404)) {
            print "Before looking when the location is the High Striker";
            rtrue;
        }
        if ((R == call_U2405)) {
            print "instead of taking when the noun is in the swiss army knife";
            rtrue;
        }
        if ((R == call_U2406)) {
            print "Check hitting";
            rtrue;
        }
        if ((R == call_U2407)) {
            print "Carry out hitting when the player is carrying the mallet";
            rtrue;
        }
        if ((R == call_U2408)) {
            print "After hitting the lever when second noun is the mallet 5 times";
            rtrue;
        }
        if ((R == call_U2409)) {
            print "after Reading a command";
            rtrue;
        }
        if ((R == call_U2410)) {
            print "after Reading a command";
            rtrue;
        }
        if ((R == call_U2411)) {
            print "after Reading a command";
            rtrue;
        }
        if ((R == call_U2412)) {
            print "after Reading a command";
            rtrue;
        }
        if ((R == call_U2413)) {
            print "Before going west when the location is the kiosk and the Show Facade is unvisited";
            rtrue;
        }
        if ((R == call_U2414)) {
            print "Before looking when the location is the Show Facade";
            rtrue;
        }
        if ((R == call_U2415)) {
            print "Check going west when the location is the Show Facade and the barker is not carrying the dime";
            rtrue;
        }
        if ((R == call_U2416)) {
            print "Check going west when the location is the Show Facade and the barker is carrying the dime";
            rtrue;
        }
        if ((R == call_U2417)) {
            print "After giving when the noun is dime and the second noun is barker";
            rtrue;
        }
        if ((R == call_U2418)) {
            print "Before going west when the location is the Show Facade and the Show Tent is unvisited and barker is carrying the dime";
            rtrue;
        }
        if ((R == call_U2419)) {
            print "Before looking when the location is the the Show Tent";
            rtrue;
        }
        if ((R == call_U2420)) {
            print "When LittleEgyptAuto ends";
            rtrue;
        }
        if ((R == call_U2421)) {
            print "Every turn during LittleEgyptAuto";
            rtrue;
        }
        if ((R == call_U2422)) {
            print "Instead of doing something other than waiting , looking , listening or examining during LittleEgyptAuto";
            rtrue;
        }
        if ((R == call_U2423)) {
            print "Check going south when the location is Head of the Line and the Ride Attendant does not have the hell ride ticket";
            rtrue;
        }
        if ((R == call_U2424)) {
            print "Before going south when the location is the kiosk and the Head of the Line is unvisited";
            rtrue;
        }
        if ((R == call_U2425)) {
            print "Before looking when the location is the Head of the Line";
            rtrue;
        }
        if ((R == call_U2426)) {
            print "When HellRideAuto begins";
            rtrue;
        }
        if ((R == call_U2427)) {
            print "Every turn during HellRideAuto";
            rtrue;
        }
        if ((R == call_U2428)) {
            print "Instead of doing something other than waiting , looking , listening or examining during HellRideAuto";
            rtrue;
        }
        if ((R == call_U2429)) {
            print "When HellRideAuto ends";
            rtrue;
        }
        if ((R == call_U2430)) {
            print "Before going south when the player is in the Ride Entrance";
            rtrue;
        }
        if ((R == call_U2431)) {
            print "Instead of looking under a thing which is underlaid by the aqua fuse when the aqua fuse is lost";
            rtrue;
        }
        if ((R == call_U2434)) {
            print "Instead of looking under a thing which is underlaid by the crimson fuse when the crimson fuse is lost";
            rtrue;
        }
        if ((R == call_U2437)) {
            print "Instead of taking the emerald fuse when the emerald fuse is lost";
            rtrue;
        }
        if ((R == call_U2440)) {
            print "Instead of looking under a thing which is underlaid by the gray fuse when the gray fuse is lost";
            rtrue;
        }
        if ((R == call_U2443)) {
            print "Instead of looking under a thing which is underlaid by the indigo fuse when the indigo fuse is lost";
            rtrue;
        }
        if ((R == call_U2446)) {
            print "Instead of taking the khaki fuse when the khaki fuse is lost";
            rtrue;
        }
        if ((R == call_U2449)) {
            print "instead of looking under when the noun is the pile of junk";
            rtrue;
        }
        if ((R == call_U2450)) {
            print "after examining when the noun is pile of junk";
            rtrue;
        }
        if ((R == call_U2451)) {
            print "after taking the flashlight for the first time";
            rtrue;
        }
        if ((R == call_U2452)) {
            print "Every turn when the radio is switched on and the location is Maintenance Office";
            rtrue;
        }
        if ((R == call_U2453)) {
            print "Rule for showing action of the radio";
            rtrue;
        }
        if ((R == call_U2454)) {
            print "Instead of listening in the presence of the switched on radio";
            rtrue;
        }
        if ((R == call_U2455)) {
            print "Instead of climbing a ladder";
            rtrue;
        }
        if ((R == call_U2456)) {
            print "every turn when the location is the electrical room";
            rtrue;
        }
        if ((R == call_U2457)) {
            print "Instead of switching on or pushing Switch Eleven";
            rtrue;
        }
        if ((R == call_U2458)) {
            print "Instead of switching on Indicator Light Eleven";
            rtrue;
        }
        if ((R == call_U2459)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2460)) {
            print "instead of inserting when Socket Eleven is filled";
            rtrue;
        }
        if ((R == call_U2461)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2462)) {
            print "instead of inserting when the noun is the Khaki Fuse and the second noun is Socket Eleven and Socket Eleven is unfilled and panel eleven is open";
            rtrue;
        }
        if ((R == call_U2463)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket Eleven and Socket Eleven is unfilled";
            rtrue;
        }
        if ((R == call_U2464)) {
            print "instead of unlocking when the location is Electrical Closet Eleven";
            rtrue;
        }
        if ((R == call_U2465)) {
            print "instead of locking when the location is Electrical Closet Eleven";
            rtrue;
        }
        if ((R == call_U2466)) {
            print "Instead of switching on or pushing Switch Nine";
            rtrue;
        }
        if ((R == call_U2467)) {
            print "Instead of switching on Indicator Light Nine";
            rtrue;
        }
        if ((R == call_U2468)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2469)) {
            print "instead of inserting when Socket Nine is filled";
            rtrue;
        }
        if ((R == call_U2470)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2471)) {
            print "instead of inserting when the noun is the Indigo Fuse and the second noun is Socket Nine and Socket Nine is unfilled and panel Nine is open";
            rtrue;
        }
        if ((R == call_U2472)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket Nine and Socket Nine is unfilled";
            rtrue;
        }
        if ((R == call_U2473)) {
            print "instead of unlocking when the location is Electrical Closet Nine";
            rtrue;
        }
        if ((R == call_U2474)) {
            print "instead of locking when the location is Electrical Closet Nine";
            rtrue;
        }
        if ((R == call_U2475)) {
            print "Instead of switching on or pushing Switch Seven";
            rtrue;
        }
        if ((R == call_U2476)) {
            print "Instead of switching on Indicator Light Seven";
            rtrue;
        }
        if ((R == call_U2477)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2478)) {
            print "instead of inserting when Socket Seven is filled";
            rtrue;
        }
        if ((R == call_U2479)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2480)) {
            print "instead of inserting when the noun is the Gray Fuse and the second noun is Socket Seven and Socket Seven is unfilled and panel Seven is open";
            rtrue;
        }
        if ((R == call_U2481)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket Seven and Socket Seven is unfilled";
            rtrue;
        }
        if ((R == call_U2482)) {
            print "instead of unlocking when the location is Electrical Closet Seven";
            rtrue;
        }
        if ((R == call_U2483)) {
            print "instead of locking when the location is Electrical Closet Seven";
            rtrue;
        }
        if ((R == call_U2484)) {
            print "Instead of switching on or pushing Switch Five";
            rtrue;
        }
        if ((R == call_U2485)) {
            print "Instead of switching on Indicator Light Five";
            rtrue;
        }
        if ((R == call_U2486)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2487)) {
            print "instead of inserting when Socket Five is filled";
            rtrue;
        }
        if ((R == call_U2488)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2489)) {
            print "instead of inserting when the noun is the Emerald Fuse and the second noun is Socket Five and Socket Five is unfilled and panel Five is open";
            rtrue;
        }
        if ((R == call_U2490)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket Five and Socket Five is unfilled";
            rtrue;
        }
        if ((R == call_U2491)) {
            print "instead of unlocking when the location is Electrical Closet Five";
            rtrue;
        }
        if ((R == call_U2492)) {
            print "instead of locking when the location is Electrical Closet Five";
            rtrue;
        }
        if ((R == call_U2493)) {
            print "Instead of switching on or pushing Switch Three";
            rtrue;
        }
        if ((R == call_U2494)) {
            print "Instead of switching on Indicator Light Three";
            rtrue;
        }
        if ((R == call_U2495)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2496)) {
            print "instead of inserting when Socket Three is filled";
            rtrue;
        }
        if ((R == call_U2497)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2498)) {
            print "instead of inserting when the noun is the Crimson Fuse and the second noun is Socket Three and Socket Three is unfilled and panel Three is open";
            rtrue;
        }
        if ((R == call_U2499)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket Three and Socket Three is unfilled";
            rtrue;
        }
        if ((R == call_U2500)) {
            print "instead of unlocking when the location is Electrical Closet Three";
            rtrue;
        }
        if ((R == call_U2501)) {
            print "instead of locking when the location is Electrical Closet Three";
            rtrue;
        }
        if ((R == call_U2502)) {
            print "Instead of switching on or pushing Switch One";
            rtrue;
        }
        if ((R == call_U2503)) {
            print "Instead of switching on Indicator Light One";
            rtrue;
        }
        if ((R == call_U2504)) {
            print "instead of inserting when the noun is not a colored fuse";
            rtrue;
        }
        if ((R == call_U2505)) {
            print "instead of inserting when Socket One is filled";
            rtrue;
        }
        if ((R == call_U2506)) {
            print "before taking";
            rtrue;
        }
        if ((R == call_U2507)) {
            print "instead of inserting when the noun is the Aqua Fuse and the second noun is Socket One and Socket One is unfilled and panel One is open";
            rtrue;
        }
        if ((R == call_U2508)) {
            print "instead of inserting when the noun is a colored fuse and the second noun is Socket One and Socket One is unfilled";
            rtrue;
        }
        if ((R == call_U2509)) {
            print "instead of unlocking when the location is Electrical Closet One";
            rtrue;
        }
        if ((R == call_U2510)) {
            print "instead of locking when the location is Electrical Closet One";
            rtrue;
        }
        if ((R == call_U2511)) {
            print "instead of examining the control panel";
            rtrue;
        }
        if ((R == call_U2513)) {
            print "every turn when the location is the Control Room";
            rtrue;
        }
        if ((R == call_U2517)) {
            print "every turn when the location is the control room";
            rtrue;
        }
        if ((R == call_U2518)) {
            print "instead of switching on a colored light";
            rtrue;
        }
        if ((R == call_U2519)) {
            print "instead of switching off a colored light";
            rtrue;
        }
        if ((R == call_U2520)) {
            print "every turn";
            rtrue;
        }
        if ((R == call_U2521)) {
            print "Instead of switching on or pushing the indigo button";
            rtrue;
        }
        if ((R == call_U2526)) {
            print "Instead of switching on or pushing the aqua button";
            rtrue;
        }
        if ((R == call_U2531)) {
            print "Instead of switching on or pushing the crimson button";
            rtrue;
        }
        if ((R == call_U2536)) {
            print "Instead of switching on or pushing the emerald button";
            rtrue;
        }
        if ((R == call_U2541)) {
            print "Instead of switching on or pushing the gray button";
            rtrue;
        }
        if ((R == call_U2546)) {
            print "Instead of Switching on or pushing the khaki button";
            rtrue;
        }
        if ((R == call_U2551)) {
            print "instead of examining the monitor";
            rtrue;
        }
        if ((R == call_U2552)) {
            print "Check spinning it to";
            rtrue;
        }
        if ((R == call_U2553)) {
            print "Report spinning it to";
            rtrue;
        }
        print "(nameless rule at address ";
        print R;
        print ")";
    }
];
[ PrintResponse R;
    if ((R == 1)) {
        RulePrintingRule(ADJUST_LIGHT_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 2)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 3)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 4)) {
        RulePrintingRule(BASIC_ACCESSIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 5)) {
        RulePrintingRule(BASIC_VISIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 6)) {
        RulePrintingRule(REQUESTED_ACTIONS_REQUIRE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 7)) {
        RulePrintingRule(CARRY_OUT_REQUESTED_ACTIONS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 8)) {
        RulePrintingRule(ACCESS_THROUGH_BARRIERS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 9)) {
        RulePrintingRule(CANT_REACH_INSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 10)) {
        RulePrintingRule(CANT_REACH_INSIDE_ROOMS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 11)) {
        RulePrintingRule(CANT_REACH_OUTSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 12)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 13)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 14)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 15)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 16)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 17)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 18)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 19)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 20)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 21)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 22)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 23)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 24)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 25)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 26)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 27)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 28)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 29)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 30)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 31)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 32)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 33)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 34)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 35)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 36)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 89;
        print ")";
    }
    if ((R == 37)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 38)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 39)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 40)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 41)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 42)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 43)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 44)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 45)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 46)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 47)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 48)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 49)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 50)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 51)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 52)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 53)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 54)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 55)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 56)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 57)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 58)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 59)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 60)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 61)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 62)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 63)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 64)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 65)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 66)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 67)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 68)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 69)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 70)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 71)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 72)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 73)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 74)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 75)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 76)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 77)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 78)) {
        RulePrintingRule(DARKNESS_NAME_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 79)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 80)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 81)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 82)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 83)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 84)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 85)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 86)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 87)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 88)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 89)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 90)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 91)) {
        RulePrintingRule(YES_OR_NO_QUESTION_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 92)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 93)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 94)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 95)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 96)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 97)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 98)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 99)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 100)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 101)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 102)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 103)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 104)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 105)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 106)) {
        RulePrintingRule(QUIT_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 107)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 108)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 109)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 110)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 111)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 112)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 113)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 114)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 115)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 116)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 117)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 118)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 119)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 120)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 121)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 122)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 123)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 124)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 125)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 126)) {
        RulePrintingRule(REP_PREFER_ABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 127)) {
        RulePrintingRule(REP_PREFER_UNABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 128)) {
        RulePrintingRule(REP_PREFER_SOMETIMES_ABBR_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 129)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 130)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 131)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 132)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 133)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 134)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 135)) {
        RulePrintingRule(call_U1003);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 136)) {
        RulePrintingRule(call_U1033);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 137)) {
        RulePrintingRule(call_U1036);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 138)) {
        RulePrintingRule(call_U1039);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 139)) {
        RulePrintingRule(call_U1039);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 140)) {
        RulePrintingRule(call_U1044);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 141)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 142)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 143)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 144)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 145)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 146)) {
        RulePrintingRule(call_U1050);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 147)) {
        RulePrintingRule(call_U1074);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 148)) {
        RulePrintingRule(call_U1081);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 149)) {
        RulePrintingRule(call_U1086);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 150)) {
        RulePrintingRule(call_U1091);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 151)) {
        RulePrintingRule(call_U1094);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 152)) {
        RulePrintingRule(call_U1097);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 153)) {
        RulePrintingRule(call_U1100);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 154)) {
        RulePrintingRule(call_U1103);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 155)) {
        RulePrintingRule(call_U1106);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 156)) {
        RulePrintingRule(call_U1109);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 157)) {
        RulePrintingRule(call_U1112);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 158)) {
        RulePrintingRule(call_U1115);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 159)) {
        RulePrintingRule(call_U1118);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 160)) {
        RulePrintingRule(call_U1121);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 161)) {
        RulePrintingRule(call_U1124);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 162)) {
        RulePrintingRule(call_U1127);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 163)) {
        RulePrintingRule(call_U1130);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 164)) {
        RulePrintingRule(call_U1136);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 165)) {
        RulePrintingRule(call_U1141);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 166)) {
        RulePrintingRule(call_U1141);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 167)) {
        RulePrintingRule(call_U1146);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 168)) {
        RulePrintingRule(call_U1149);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 169)) {
        RulePrintingRule(call_U1153);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 170)) {
        RulePrintingRule(call_U1156);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 171)) {
        RulePrintingRule(call_U1159);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 172)) {
        RulePrintingRule(call_U1162);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 173)) {
        RulePrintingRule(call_U1165);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 174)) {
        RulePrintingRule(call_U1168);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 175)) {
        RulePrintingRule(call_U1168);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 176)) {
        RulePrintingRule(call_U1176);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 177)) {
        RulePrintingRule(call_U1176);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 178)) {
        RulePrintingRule(call_U1183);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 179)) {
        RulePrintingRule(call_U1186);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 180)) {
        RulePrintingRule(call_U1189);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 181)) {
        RulePrintingRule(call_U1192);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 182)) {
        RulePrintingRule(call_U1197);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 183)) {
        RulePrintingRule(call_U1200);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 184)) {
        RulePrintingRule(call_U1204);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 185)) {
        RulePrintingRule(call_U1207);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 186)) {
        RulePrintingRule(call_U1211);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 187)) {
        RulePrintingRule(call_U1214);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 188)) {
        RulePrintingRule(call_U1217);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 189)) {
        RulePrintingRule(call_U1220);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 190)) {
        RulePrintingRule(call_U1225);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 191)) {
        RulePrintingRule(call_U1228);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 192)) {
        RulePrintingRule(call_U1231);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 193)) {
        RulePrintingRule(call_U1234);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 194)) {
        RulePrintingRule(call_U1237);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 195)) {
        RulePrintingRule(call_U1243);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 196)) {
        RulePrintingRule(call_U1243);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 197)) {
        RulePrintingRule(call_U1249);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 198)) {
        RulePrintingRule(call_U1252);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 199)) {
        RulePrintingRule(call_U1252);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 200)) {
        RulePrintingRule(call_U1257);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 201)) {
        RulePrintingRule(call_U1260);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 202)) {
        RulePrintingRule(call_U1264);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 203)) {
        RulePrintingRule(call_U1264);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 204)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 205)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 206)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 207)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 208)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 209)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 210)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 211)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 212)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 213)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 214)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 215)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 216)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 217)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 218)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 219)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 220)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 221)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 222)) {
        RulePrintingRule(call_U1272);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 223)) {
        RulePrintingRule(call_U1315);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 224)) {
        RulePrintingRule(call_U1315);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 225)) {
        RulePrintingRule(call_U1320);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 226)) {
        RulePrintingRule(call_U1320);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 227)) {
        RulePrintingRule(call_U1320);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 228)) {
        RulePrintingRule(call_U1320);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 229)) {
        RulePrintingRule(call_U1329);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 230)) {
        RulePrintingRule(call_U1332);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 231)) {
        RulePrintingRule(call_U1332);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 232)) {
        RulePrintingRule(call_U1339);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 233)) {
        RulePrintingRule(call_U1342);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 234)) {
        RulePrintingRule(call_U1342);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 235)) {
        RulePrintingRule(call_U1342);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 236)) {
        RulePrintingRule(call_U1342);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 237)) {
        RulePrintingRule(call_U1342);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 238)) {
        RulePrintingRule(call_U1354);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 239)) {
        RulePrintingRule(call_U1354);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 240)) {
        RulePrintingRule(call_U1354);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 241)) {
        RulePrintingRule(call_U1354);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 242)) {
        RulePrintingRule(call_U1366);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 243)) {
        RulePrintingRule(call_U1369);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 244)) {
        RulePrintingRule(call_U1374);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 245)) {
        RulePrintingRule(call_U1374);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 246)) {
        RulePrintingRule(call_U1374);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 247)) {
        RulePrintingRule(call_U1382);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 248)) {
        RulePrintingRule(call_U1386);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 249)) {
        RulePrintingRule(call_U1393);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 250)) {
        RulePrintingRule(call_U1393);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 251)) {
        RulePrintingRule(call_U1393);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 252)) {
        RulePrintingRule(call_U1400);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 253)) {
        RulePrintingRule(call_U1405);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 254)) {
        RulePrintingRule(call_U1409);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 255)) {
        RulePrintingRule(call_U1412);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 256)) {
        RulePrintingRule(call_U1412);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 257)) {
        RulePrintingRule(call_U1419);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 258)) {
        RulePrintingRule(call_U1424);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 259)) {
        RulePrintingRule(call_U1427);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 260)) {
        RulePrintingRule(call_U1430);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 261)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 262)) {
        RulePrintingRule(call_U1436);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 263)) {
        RulePrintingRule(call_U1439);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 264)) {
        RulePrintingRule(call_U1442);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 265)) {
        RulePrintingRule(call_U1445);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 266)) {
        RulePrintingRule(call_U1445);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 267)) {
        RulePrintingRule(call_U1451);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 268)) {
        RulePrintingRule(call_U1451);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 269)) {
        RulePrintingRule(call_U1457);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 270)) {
        RulePrintingRule(call_U1460);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 271)) {
        RulePrintingRule(call_U1460);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 272)) {
        RulePrintingRule(call_U1465);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 273)) {
        RulePrintingRule(call_U1468);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 274)) {
        RulePrintingRule(call_U1471);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 275)) {
        RulePrintingRule(call_U1474);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 276)) {
        RulePrintingRule(call_U1478);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 277)) {
        RulePrintingRule(call_U1478);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 278)) {
        RulePrintingRule(call_U1483);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 279)) {
        RulePrintingRule(call_U1486);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 280)) {
        RulePrintingRule(call_U1489);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 281)) {
        RulePrintingRule(call_U1493);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 282)) {
        RulePrintingRule(call_U1493);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 283)) {
        RulePrintingRule(call_U1498);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 284)) {
        RulePrintingRule(call_U1501);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 285)) {
        RulePrintingRule(call_U1505);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 286)) {
        RulePrintingRule(call_U1508);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 287)) {
        RulePrintingRule(call_U1511);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 288)) {
        RulePrintingRule(call_U1515);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 289)) {
        RulePrintingRule(call_U1518);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 290)) {
        RulePrintingRule(call_U1521);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 291)) {
        RulePrintingRule(call_U1524);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 292)) {
        RulePrintingRule(call_U1528);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 293)) {
        RulePrintingRule(call_U1531);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 294)) {
        RulePrintingRule(call_U1531);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 295)) {
        RulePrintingRule(call_U1531);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 296)) {
        RulePrintingRule(call_U1538);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 297)) {
        RulePrintingRule(call_U1541);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 298)) {
        RulePrintingRule(call_U1545);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 299)) {
        RulePrintingRule(call_U1545);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 300)) {
        RulePrintingRule(call_U1545);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 301)) {
        RulePrintingRule(call_U1552);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 302)) {
        RulePrintingRule(call_U1555);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 303)) {
        RulePrintingRule(call_U1558);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 304)) {
        RulePrintingRule(call_U1562);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 305)) {
        RulePrintingRule(call_U1562);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 306)) {
        RulePrintingRule(call_U1568);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 307)) {
        RulePrintingRule(call_U1571);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 308)) {
        RulePrintingRule(call_U1576);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 309)) {
        RulePrintingRule(call_U1576);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 310)) {
        RulePrintingRule(call_U1581);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 311)) {
        RulePrintingRule(call_U1584);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 312)) {
        RulePrintingRule(call_U1587);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 313)) {
        RulePrintingRule(call_U1590);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 314)) {
        RulePrintingRule(call_U1593);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 315)) {
        RulePrintingRule(call_U1596);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 316)) {
        RulePrintingRule(call_U1601);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 317)) {
        RulePrintingRule(call_U1601);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 318)) {
        RulePrintingRule(call_U1601);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 319)) {
        RulePrintingRule(call_U1608);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 320)) {
        RulePrintingRule(call_U1612);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 321)) {
        RulePrintingRule(call_U1615);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 322)) {
        RulePrintingRule(call_U1618);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 323)) {
        RulePrintingRule(call_U1621);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 324)) {
        RulePrintingRule(call_U1624);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 325)) {
        RulePrintingRule(call_U1627);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 326)) {
        RulePrintingRule(call_U1630);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 327)) {
        RulePrintingRule(call_U1633);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 328)) {
        RulePrintingRule(call_U1636);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 329)) {
        RulePrintingRule(call_U1639);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 330)) {
        RulePrintingRule(call_U1642);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 331)) {
        RulePrintingRule(call_U1645);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 332)) {
        RulePrintingRule(call_U1650);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 333)) {
        RulePrintingRule(call_U1650);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 334)) {
        RulePrintingRule(call_U1655);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 335)) {
        RulePrintingRule(call_U1655);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 336)) {
        RulePrintingRule(call_U1660);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 337)) {
        RulePrintingRule(call_U1660);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 338)) {
        RulePrintingRule(call_U1660);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 339)) {
        RulePrintingRule(call_U1667);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 340)) {
        RulePrintingRule(call_U1667);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 341)) {
        RulePrintingRule(call_U1672);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 342)) {
        RulePrintingRule(call_U1675);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 343)) {
        RulePrintingRule(call_U1675);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 344)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 345)) {
        RulePrintingRule(call_U1683);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 346)) {
        RulePrintingRule(call_U1686);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 347)) {
        RulePrintingRule(call_U1689);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 348)) {
        RulePrintingRule(call_U1689);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 349)) {
        RulePrintingRule(call_U1694);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 350)) {
        RulePrintingRule(call_U1697);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 351)) {
        RulePrintingRule(call_U1700);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 352)) {
        RulePrintingRule(call_U1703);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 353)) {
        RulePrintingRule(call_U1703);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 354)) {
        RulePrintingRule(call_U1708);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 355)) {
        RulePrintingRule(call_U1711);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 356)) {
        RulePrintingRule(call_U1714);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 357)) {
        RulePrintingRule(call_U1717);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 358)) {
        RulePrintingRule(call_U1717);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 359)) {
        RulePrintingRule(call_U1722);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 360)) {
        RulePrintingRule(call_U1725);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 361)) {
        RulePrintingRule(call_U1728);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 362)) {
        RulePrintingRule(call_U1731);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 363)) {
        RulePrintingRule(call_U1735);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 364)) {
        RulePrintingRule(call_U1738);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 365)) {
        RulePrintingRule(call_U1741);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 366)) {
        RulePrintingRule(call_U1741);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 367)) {
        RulePrintingRule(call_U1746);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 368)) {
        RulePrintingRule(call_U1749);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 369)) {
        RulePrintingRule(call_U1752);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 370)) {
        RulePrintingRule(call_U1755);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 371)) {
        RulePrintingRule(call_U1758);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 372)) {
        RulePrintingRule(call_U1761);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 373)) {
        RulePrintingRule(call_U1761);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 374)) {
        RulePrintingRule(call_U1766);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 375)) {
        RulePrintingRule(call_U1766);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 376)) {
        RulePrintingRule(call_U1771);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 377)) {
        RulePrintingRule(call_U1771);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 378)) {
        RulePrintingRule(call_U1776);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 379)) {
        RulePrintingRule(call_U1779);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 380)) {
        RulePrintingRule(call_U1779);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 381)) {
        RulePrintingRule(call_U1784);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 382)) {
        RulePrintingRule(call_U1787);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 383)) {
        RulePrintingRule(call_U1790);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 384)) {
        RulePrintingRule(call_U1793);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 385)) {
        RulePrintingRule(call_U1796);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 386)) {
        RulePrintingRule(call_U1799);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 387)) {
        RulePrintingRule(call_U1799);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 388)) {
        RulePrintingRule(call_U1804);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 389)) {
        RulePrintingRule(call_U1807);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 390)) {
        RulePrintingRule(call_U1807);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 391)) {
        RulePrintingRule(call_U1812);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 392)) {
        RulePrintingRule(call_U1815);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 393)) {
        RulePrintingRule(call_U1818);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 394)) {
        RulePrintingRule(call_U1944);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 395)) {
        RulePrintingRule(call_U1947);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 396)) {
        RulePrintingRule(call_U1950);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 397)) {
        RulePrintingRule(call_U1953);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 398)) {
        RulePrintingRule(call_U1961);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 399)) {
        RulePrintingRule(call_U1965);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 400)) {
        RulePrintingRule(call_U1969);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 401)) {
        RulePrintingRule(call_U1974);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 402)) {
        RulePrintingRule(call_U1977);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 403)) {
        RulePrintingRule(call_U1980);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 404)) {
        RulePrintingRule(call_U1987);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 405)) {
        RulePrintingRule(call_U1996);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 406)) {
        RulePrintingRule(call_U1999);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 407)) {
        RulePrintingRule(call_U2008);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 408)) {
        RulePrintingRule(call_U2071);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 409)) {
        RulePrintingRule(call_U2074);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 410)) {
        RulePrintingRule(call_U2077);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 411)) {
        RulePrintingRule(call_U2083);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 412)) {
        RulePrintingRule(call_U2083);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 413)) {
        RulePrintingRule(call_U2088);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 414)) {
        RulePrintingRule(call_U2088);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 415)) {
        RulePrintingRule(call_U2088);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 416)) {
        RulePrintingRule(call_U2097);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 417)) {
        RulePrintingRule(call_U2103);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 418)) {
        RulePrintingRule(call_U2103);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 419)) {
        RulePrintingRule(call_U2108);
        print " response (";
        print (char) 65;
        print ")";
    }
];
[ ShowSceneStatus;
    call_U355();
    call_U2212();
    call_U2214();
];
[ DetectSceneChange chs;
    .Again;
    if (call_U354()) {
        jump CScene;
    }
    if (call_U2211()) {
        jump CScene;
    }
    if (call_U2213()) {
        jump CScene;
    }
    rfalse;
    .CScene;
    if ((chs > 20)) {
        print ">--> The scene change machinery is stuck.^";
        rtrue;
    }
    ++(chs);
    jump Again;
];
[ PrintTableName T;
    switch (T) {
        TheEmptyTable:
            print "(the empty table)";
            rtrue;
            ;
        table_data_U1:
            print "Table of Final Question Options";
            rtrue;
            ;
        table_data_U2:
            print "Table of Locale Priorities";
            rtrue;
            ;
        table_data_U3:
            print "Table of Ordinary Status";
            rtrue;
            ;
        table_data_U4:
            print "Table of Sample Options";
            rtrue;
            ;
        table_data_U5:
            print "Table of Menu Commands";
            rtrue;
            ;
        table_data_U6:
            print "Table of Shallow Menu Status";
            rtrue;
            ;
        table_data_U7:
            print "Table of Deep Menu Status";
            rtrue;
            ;
        table_data_U8:
            print "Table of Sample Hints";
            rtrue;
            ;
        table_data_U9:
            print "Table of Basic Help Options";
            rtrue;
            ;
        table_data_U10:
            print "Table of Instruction Options";
            rtrue;
            ;
        table_data_U11:
            print "Table of IF Elements";
            rtrue;
            ;
        table_data_U12:
            print "Table of Stuckness Advice";
            rtrue;
            ;
        table_data_U13:
            print "Table of Setting Options";
            rtrue;
            ;
        table_data_U14:
            print "Table of LittleEgypt Events";
            rtrue;
            ;
        table_data_U15:
            print "Table of HellRide Events";
            rtrue;
            ;
        default:
            print "** No such table **";
            rtrue;
            ;
    }
];
[ TC_KOV tc unk;
    switch (tc) {
        100:
            return TEXT_TY;
            ;
        101:
            return TRUTH_STATE_TY;
            ;
        102:
            return UNDERSTANDING_TY;
            ;
        103:
            return DK1_rule;
            ;
        104:
            return DK2_activity_on_objects;
            ;
        105:
            return OBJECT_TY;
            ;
        106:
            return NUMBER_TY;
            ;
        107:
            return TEXT_TY;
            ;
        108:
            return TEXT_TY;
            ;
        109:
            return TEXT_TY;
            ;
        110:
            return TEXT_TY;
            ;
        111:
            return TABLE_TY;
            ;
        112:
            return TEXT_TY;
            ;
        113:
            return DK1_rule;
            ;
        114:
            return NUMBER_TY;
            ;
        115:
            return DK1_rule;
            ;
        116:
            return TEXT_TY;
            ;
        117:
            return NUMBER_TY;
            ;
        118:
            return TEXT_TY;
            ;
    }
    return unk;
];
[ TestScriptSub;
    print ">--> No test scripts exist for this game.^";
];
[ TestUseOption UO;
    if ((UO == 1)) {
        rtrue;
    }
    if ((UO == 2)) {
        rtrue;
    }
    if ((UO == 14)) {
        rtrue;
    }
    if ((UO == 15)) {
        rtrue;
    }
    if ((UO == 16)) {
        rtrue;
    }
    if ((UO == 20)) {
        rtrue;
    }
    if ((UO == 27)) {
        rtrue;
    }
    rfalse;
];
[ PrintUseOption UO;
    switch (UO) {
        0:
            print "ineffectual option";
            ;
        1:
            print "american dialect option";
            ;
        2:
            print "serial comma option";
            ;
        3:
            print "memory economy option";
            ;
        4:
            print "engineering notation option";
            ;
        5:
            print "unabbreviated object names option";
            ;
        6:
            print "predictable randomisation option";
            ;
        7:
            print "fast route-finding option";
            ;
        8:
            print "slow route-finding option";
            ;
        9:
            print "numbered rules option";
            ;
        10:
            print "telemetry recordings option";
            ;
        11:
            print "no deprecated features option";
            ;
        12:
            print "gn testing version option";
            ;
        13:
            print "authorial modesty option";
            ;
        14:
            print "dynamic memory allocation option [65536]";
            ;
        15:
            print "maximum text length option [4096]";
            ;
        16:
            print "index figure thumbnails option [50]";
            ;
        17:
            print "command line echoing option";
            ;
        18:
            print "full-length room descriptions option";
            ;
        19:
            print "abbreviated room descriptions option";
            ;
        20:
            print "scoring option";
            ;
        21:
            print "no scoring option";
            ;
        22:
            print "manual pronouns option";
            ;
        23:
            print "undo prevention option";
            ;
        24:
            print "verbose room descriptions option";
            ;
        25:
            print "brief room descriptions option";
            ;
        26:
            print "superbrief room descriptions option";
            ;
        27:
            print "maximum things understood at once option [200]";
            ;
        28:
            print "sequential action option";
            ;
    }
];
[ call_U43 t_0;
    if (1) {
        return (IntegerRemainder(t_0, 2) == 0);
    }
    rfalse;
];
[ call_U44 t_0;
    if (1) {
        return (~~((IntegerRemainder(t_0, 2) == 0)));
    }
    rfalse;
];
[ call_U45 t_0;
    if (1) {
        return (t_0 > 0);
    }
    rfalse;
];
[ call_U46 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0);
    }
    rfalse;
];
[ call_U47 t_0;
    if (1) {
        return (t_0 < 0);
    }
    rfalse;
];
[ call_U48 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0);
    }
    rfalse;
];
[ call_U49 t_0;
    if (1) {
        return TEXT_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U50 t_0;
    if (1) {
        return (TableFilledRows(t_0) == 0);
    }
    rfalse;
];
[ call_U51 t_0;
    if (1) {
        return RulebookEmpty(t_0);
    }
    rfalse;
];
[ call_U52 t_0;
    if (1) {
        return ActivityEmpty(t_0);
    }
    rfalse;
];
[ call_U53 t_0;
    if (1) {
        return LIST_OF_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U54 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, (-(1)));
    }
    rfalse;
];
[ call_U55 t_0;
    if ((t_0 ofclass K20_fluid_container)) {
        return (GProperty(OBJECT_TY, t_0, A_P_current_volume) == 0);
    }
    rfalse;
];
[ call_U56 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U57 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U58 t_0;
    if (1) {
        return (~~(TEXT_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U59 t_0;
    if (1) {
        return (~~((TableFilledRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U60 t_0;
    if (1) {
        return (~~(RulebookEmpty(t_0)));
    }
    rfalse;
];
[ call_U61 t_0;
    if (1) {
        return (~~(ActivityEmpty(t_0)));
    }
    rfalse;
];
[ call_U62 t_0;
    if (1) {
        return (~~(LIST_OF_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U63 t_0;
    if (1) {
        return (~~(RELATION_TY_Empty(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U64 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U65 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U66 t_0;
    if (1) {
        return TEXT_TY_IsSubstituted(t_0);
    }
    rfalse;
];
[ call_U67 t_0;
    if (1) {
        return (~~(TEXT_TY_IsSubstituted(t_0)));
    }
    rfalse;
];
[ call_U68 t_0;
    if (1) {
        return (TableBlankRows(t_0) == 0);
    }
    rfalse;
];
[ call_U69 t_0;
    if ((t_0 ofclass K20_fluid_container)) {
        return (GProperty(OBJECT_TY, t_0, A_P_current_volume) == GProperty(OBJECT_TY, t_0, A_P_fluid_capacity));
    }
    rfalse;
];
[ call_U70 t_0;
    if (1) {
        return (~~((TableBlankRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U71 t_0;
    if (1) {
        return TestActivity(t_0);
    }
    rfalse;
];
[ call_U72 t_0;
    if (1) {
        return TestUseOption(t_0);
    }
    rfalse;
];
[ call_U73 t_0;
    if (1) {
        return (~~(TestUseOption(t_0)));
    }
    rfalse;
];
[ call_U74 t_0;
    if (1) {
        return VerbIsModal(t_0);
    }
    rfalse;
];
[ call_U75 t_0;
    if (1) {
        return (~~(VerbIsModal(t_0)));
    }
    rfalse;
];
[ call_U76 t_0;
    if (1) {
        return VerbIsMeaningful(t_0);
    }
    rfalse;
];
[ call_U77 t_0;
    if (1) {
        return (~~(VerbIsMeaningful(t_0)));
    }
    rfalse;
];
[ call_U78 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U79 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U80 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U81 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U82 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U83 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U84 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U85 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U86 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U87 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U88 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U89 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U90 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U91 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U92 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U93 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U94 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U95 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U96 t_0;
    if (1) {
        return ((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)));
    }
    rfalse;
];
[ call_U97 t_0;
    if (1) {
        return (~~(((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)))));
    }
    rfalse;
];
[ call_U98 t_0;
    if (1) {
        return REAL_NUMBER_TY_Nan(t_0);
    }
    rfalse;
];
[ call_U99 t_0;
    if (1) {
        return (~~(REAL_NUMBER_TY_Nan(t_0)));
    }
    rfalse;
];
[ call_U100 t_0;
    if (t_0) {
        return (t_0 has pluralname);
    }
    rfalse;
];
[ call_U101 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U102 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U103 t_0;
    if (t_0) {
        return ((t_0 has pluralname) == 0);
    }
    rfalse;
];
[ call_U104 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U105 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U106 t_0;
    if (t_0) {
        return (t_0 has proper);
    }
    rfalse;
];
[ call_U107 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U108 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U109 t_0;
    if (t_0) {
        return ((t_0 has proper) == 0);
    }
    rfalse;
];
[ call_U110 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U111 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U112 t_0;
    if (t_0) {
        return (t_0 has ambigpluralname);
    }
    rfalse;
];
[ call_U113 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 1);
    }
    rfalse;
];
[ call_U114 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 0);
    }
    rfalse;
];
[ ADJDEFN2 t_0;
    rfalse;
];
[ ADJDEFN3 t_0;
    rfalse;
];
[ ADJDEFN4 t_0;
    rfalse;
];
[ ADJDEFN5 t_0;
    rfalse;
];
[ ADJDEFN6 t_0;
    rfalse;
];
[ ADJDEFN7 t_0;
    rfalse;
];
[ ADJDEFN8 t_0;
    rfalse;
];
[ ADJDEFN9 t_0;
    rfalse;
];
[ ADJDEFN10 t_0;
    rfalse;
];
[ ADJDEFN11 t_0;
    rfalse;
];
[ ADJDEFN12 t_0;
    rfalse;
];
[ ADJDEFN13 t_0;
    rfalse;
];
[ ADJDEFN14 t_0;
    rfalse;
];
[ ADJDEFN15 t_0;
    rfalse;
];
[ ADJDEFN16 t_0;
    rfalse;
];
[ ADJDEFN17 t_0;
    rfalse;
];
[ ADJDEFN18 t_0;
    rfalse;
];
[ ADJDEFN19 t_0;
    rfalse;
];
[ ADJDEFN20 t_0;
    rfalse;
];
[ ADJDEFN21 t_0;
    rfalse;
];
[ ADJDEFN22 t_0;
    rfalse;
];
[ ADJDEFN23 t_0;
    rfalse;
];
[ ADJDEFN24 t_0;
    rfalse;
];
[ ADJDEFN25 t_0;
    rfalse;
];
[ ADJDEFN26 t_0;
    rfalse;
];
[ call_U115 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(INITIALISE_MEMORY_R, 0, 0);
    }
    (rv = (INITIALISE_MEMORY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return INITIALISE_MEMORY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(VIRTUAL_MACHINE_STARTUP_R, 0, 0);
    }
    (rv = (VIRTUAL_MACHINE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VIRTUAL_MACHINE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(SEED_RANDOM_NUMBER_GENERATOR_R, 0, 0);
    }
    (rv = (SEED_RANDOM_NUMBER_GENERATOR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U989)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U989;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(POSITION_PLAYER_IN_MODEL_R, 0, 0);
    }
    (rv = (POSITION_PLAYER_IN_MODEL_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return POSITION_PLAYER_IN_MODEL_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U991)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U991;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U992)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U992;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U993)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U993;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U994)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U994;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U995)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U995;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U116 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1000)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1000;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(RESURRECT_PLAYER_IF_ASKED_R, 0, 0);
    }
    (rv = (RESURRECT_PLAYER_IF_ASKED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1001)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1001;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ASK_FINAL_QUESTION_R, 0, 0);
    }
    (rv = (ASK_FINAL_QUESTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ASK_FINAL_QUESTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U118 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(FINAL_CODE_STARTUP_R, 0, 0);
    }
    (rv = (FINAL_CODE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return FINAL_CODE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U120 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2347)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2347;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2366)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2366;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2365)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2365;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1023)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1023;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U121 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U122 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1977)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1977;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2348)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2348;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U124 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_PLURAL_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_PLURAL_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_PLURAL_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U126 sk;
    return I_english_language_U1;
];
[ E1 value;
    switch (value) {
        I_english_language_U1:
            print "English language";
            ;
        I_french_language_U1:
            print "French language";
            ;
        I_german_language_U1:
            print "German language";
            ;
        I_italian_language_U1:
            print "Italian language";
            ;
        I_spanish_language_U1:
            print "Spanish language";
            ;
        I_swedish_language_U1:
            print "Swedish language";
            ;
        default:
            print "<illegal natural language>";
            ;
    }
];
[ call_U127 x;
    return ((x%6) + 1);
];
[ call_U128 x;
    return (((x + 4)%6) + 1);
];
[ call_U129 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U130;
    rfalse;
];
[ call_U131 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)));
    return tmp_0;
    rfalse;
];
[ call_U132 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Plus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U133 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Minus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U134 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Times(1056964608, REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)), (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))));
    return tmp_0;
    rfalse;
];
[ ConjugateVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record7;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has had";
                    } else {
                        print "have had";
                    }
                    ;
                4:
                    print "had had";
                    ;
                5:
                    print "will have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not have";
                    } else {
                        print "do not have";
                    }
                    ;
                2:
                    print "did not have";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not had";
                    } else {
                        print "have not had";
                    }
                    ;
                4:
                    print "had not had";
                    ;
                5:
                    print "will not have";
                    ;
            }
            ;
    }
];
[ call_U135 fn vp t modal_to;
    (t = ConjugateVerb4(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record7;
    }
];
[ ConjugateVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U136 fn vp t modal_to;
    (t = ConjugateVerb8(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb64 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record6;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ call_U137 fn vp t modal_to;
    (t = ConjugateVerb64(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ ConjugateVerb65 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to be";
            ;
        2:
            print "been able to be";
            ;
        3:
            print "being able to be";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can be";
                    ;
                2:
                    print "could be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to be";
                    } else {
                        print "have been able to be";
                    }
                    ;
                4:
                    print "had been able to be";
                    ;
                5:
                    print "will be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot be";
                    ;
                2:
                    print "could not be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to be";
                    } else {
                        print "have not been able to be";
                    }
                    ;
                4:
                    print "had not been able to be";
                    ;
                5:
                    print "will not be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
    }
];
[ call_U138 fn vp t modal_to;
    (t = ConjugateVerb65(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb66 fn vp t modal_to;
    switch (fn) {
        1:
            print "specify";
            ;
        2:
            print "specified";
            ;
        3:
            print "specifying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "specifies";
                    } else {
                        print "specify";
                    }
                    ;
                2:
                    print "specified";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has specified";
                    } else {
                        print "have specified";
                    }
                    ;
                4:
                    print "had specified";
                    ;
                5:
                    print "will specify";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not specify";
                    } else {
                        print "do not specify";
                    }
                    ;
                2:
                    print "did not specify";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not specified";
                    } else {
                        print "have not specified";
                    }
                    ;
                4:
                    print "had not specified";
                    ;
                5:
                    print "will not specify";
                    ;
            }
            ;
    }
];
[ call_U139 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb67 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record8;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ call_U140 fn vp t modal_to;
    (t = ConjugateVerb67(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb68 fn vp t modal_to;
    switch (fn) {
        1:
            print "substitute";
            ;
        2:
            print "substituted";
            ;
        3:
            print "substituting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "substitutes";
                    } else {
                        print "substitute";
                    }
                    ;
                2:
                    print "substituted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has substituted";
                    } else {
                        print "have substituted";
                    }
                    ;
                4:
                    print "had substituted";
                    ;
                5:
                    print "will substitute";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not substitute";
                    } else {
                        print "do not substitute";
                    }
                    ;
                2:
                    print "did not substitute";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not substituted";
                    } else {
                        print "have not substituted";
                    }
                    ;
                4:
                    print "had not substituted";
                    ;
                5:
                    print "will not substitute";
                    ;
            }
            ;
    }
];
[ call_U141 fn vp t modal_to;
    (t = ConjugateVerb68(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U142 fn vp t modal_to;
    (t = ConjugateVerb68(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " for";
];
[ ConjugateModalVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateVerb69 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ call_U143 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U144 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " into";
];
[ call_U145 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " as";
];
[ ConjugateModalVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb70 fn vp t modal_to;
    switch (fn) {
        1:
            print "provide";
            ;
        2:
            print "provided";
            ;
        3:
            print "providing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record9;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provides";
                    } else {
                        print "provide";
                    }
                    ;
                2:
                    print "provided";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provided";
                    } else {
                        print "have provided";
                    }
                    ;
                4:
                    print "had provided";
                    ;
                5:
                    print "will provide";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provide";
                    } else {
                        print "do not provide";
                    }
                    ;
                2:
                    print "did not provide";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provided";
                    } else {
                        print "have not provided";
                    }
                    ;
                4:
                    print "had not provided";
                    ;
                5:
                    print "will not provide";
                    ;
            }
            ;
    }
];
[ call_U146 fn vp t modal_to;
    (t = ConjugateVerb70(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record9;
    }
];
[ ConjugateVerb71 fn vp t modal_to;
    switch (fn) {
        1:
            print "use";
            ;
        2:
            print "used";
            ;
        3:
            print "using";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "uses";
                    } else {
                        print "use";
                    }
                    ;
                2:
                    print "used";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has used";
                    } else {
                        print "have used";
                    }
                    ;
                4:
                    print "had used";
                    ;
                5:
                    print "will use";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not use";
                    } else {
                        print "do not use";
                    }
                    ;
                2:
                    print "did not use";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not used";
                    } else {
                        print "have not used";
                    }
                    ;
                4:
                    print "had not used";
                    ;
                5:
                    print "will not use";
                    ;
            }
            ;
    }
];
[ call_U147 fn vp t modal_to;
    (t = ConjugateVerb71(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb72 fn vp t modal_to;
    switch (fn) {
        1:
            print "include";
            ;
        2:
            print "included";
            ;
        3:
            print "including";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "includes";
                    } else {
                        print "include";
                    }
                    ;
                2:
                    print "included";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has included";
                    } else {
                        print "have included";
                    }
                    ;
                4:
                    print "had included";
                    ;
                5:
                    print "will include";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not include";
                    } else {
                        print "do not include";
                    }
                    ;
                2:
                    print "did not include";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not included";
                    } else {
                        print "have not included";
                    }
                    ;
                4:
                    print "had not included";
                    ;
                5:
                    print "will not include";
                    ;
            }
            ;
    }
];
[ call_U148 fn vp t modal_to;
    (t = ConjugateVerb72(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U149 fn vp t modal_to;
    (t = ConjugateVerb72(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb73 fn vp t modal_to;
    switch (fn) {
        1:
            print "omit";
            ;
        2:
            print "omitted";
            ;
        3:
            print "omitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "omits";
                    } else {
                        print "omit";
                    }
                    ;
                2:
                    print "omitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has omitted";
                    } else {
                        print "have omitted";
                    }
                    ;
                4:
                    print "had omitted";
                    ;
                5:
                    print "will omit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not omit";
                    } else {
                        print "do not omit";
                    }
                    ;
                2:
                    print "did not omit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not omitted";
                    } else {
                        print "have not omitted";
                    }
                    ;
                4:
                    print "had not omitted";
                    ;
                5:
                    print "will not omit";
                    ;
            }
            ;
    }
];
[ call_U150 fn vp t modal_to;
    (t = ConjugateVerb73(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U151 fn vp t modal_to;
    (t = ConjugateVerb73(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb74 fn vp t modal_to;
    switch (fn) {
        1:
            print "test";
            ;
        2:
            print "tested";
            ;
        3:
            print "testing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tests";
                    } else {
                        print "test";
                    }
                    ;
                2:
                    print "tested";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tested";
                    } else {
                        print "have tested";
                    }
                    ;
                4:
                    print "had tested";
                    ;
                5:
                    print "will test";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not test";
                    } else {
                        print "do not test";
                    }
                    ;
                2:
                    print "did not test";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tested";
                    } else {
                        print "have not tested";
                    }
                    ;
                4:
                    print "had not tested";
                    ;
                5:
                    print "will not test";
                    ;
            }
            ;
    }
];
[ call_U152 fn vp t modal_to;
    (t = ConjugateVerb74(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U153 fn vp t modal_to;
    (t = ConjugateVerb74(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U154 sk;
    return I_present_tense_U1;
];
[ E2 value;
    switch (value) {
        I_present_tense_U1:
            print "present tense";
            ;
        I_past_tense_U1:
            print "past tense";
            ;
        I_perfect_tense_U1:
            print "perfect tense";
            ;
        I_past_perfect_tense_U1:
            print "past perfect tense";
            ;
        I_future_tense_U1:
            print "future tense";
            ;
        default:
            print "<illegal grammatical tense>";
            ;
    }
];
[ call_U155 x;
    return ((x%5) + 1);
];
[ call_U156 x;
    return (((x + 3)%5) + 1);
];
[ call_U157 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U158 sk;
    return I_first_person_singular_U1;
];
[ E3 value;
    switch (value) {
        I_first_person_singular_U1:
            print "first person singular";
            ;
        I_second_person_singular_U1:
            print "second person singular";
            ;
        I_third_person_singular_U1:
            print "third person singular";
            ;
        I_first_person_plural_U1:
            print "first person plural";
            ;
        I_second_person_plural_U1:
            print "second person plural";
            ;
        I_third_person_plural_U1:
            print "third person plural";
            ;
        default:
            print "<illegal narrative viewpoint>";
            ;
    }
];
[ call_U159 x;
    return ((x%6) + 1);
];
[ call_U160 x;
    return (((x + 4)%6) + 1);
];
[ call_U161 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U162 sk;
    return I_nominative_U1;
];
[ E4 value;
    switch (value) {
        I_nominative_U1:
            print "nominative";
            ;
        I_accusative_U1:
            print "accusative";
            ;
        default:
            print "<illegal grammatical case>";
            ;
    }
];
[ call_U163 x;
    return ((x%2) + 1);
];
[ call_U164 x;
    return ((x%2) + 1);
];
[ call_U165 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(2);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U166 sk;
    return I_neuter_gender_U1;
];
[ E5 value;
    switch (value) {
        I_neuter_gender_U1:
            print "neuter gender";
            ;
        I_masculine_gender_U1:
            print "masculine gender";
            ;
        I_feminine_gender_U1:
            print "feminine gender";
            ;
        default:
            print "<illegal grammatical gender>";
            ;
    }
];
[ call_U167 x;
    return ((x%3) + 1);
];
[ call_U168 x;
    return (((x + 1)%3) + 1);
];
[ call_U169 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U170;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "he";
        } else {
            (say__p = 1);
            ParaContent();
            print "she";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "we";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "they";
    }
    rfalse;
];
[ call_U171;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "him";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "them";
    }
    rfalse;
];
[ call_U172;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    }
    rfalse;
];
[ call_U173;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    }
    rfalse;
];
[ call_U174;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "my";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "their";
    }
    rfalse;
];
[ call_U175;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "He";
        } else {
            (say__p = 1);
            ParaContent();
            print "She";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "We";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "They";
    }
    rfalse;
];
[ call_U176;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "Him";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Them";
    }
    rfalse;
];
[ call_U177;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    }
    rfalse;
];
[ call_U178;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "Himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "Herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    }
    rfalse;
];
[ call_U179;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "My";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U330(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Their";
    }
    rfalse;
];
[ call_U180;
    (say__p = 1);
    ParaContent();
    call_U182(I_accusative_U1);
    rfalse;
];
[ call_U181;
    (say__p = 1);
    ParaContent();
    call_U183(I_nominative_U1);
    rfalse;
];
[ call_U182 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U170();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "he";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "she";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U170();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U183 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U175();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "He";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "She";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U175();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "Her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U184 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U170();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U185 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U175();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U186 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U174();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U187 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U179();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U188 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U171();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U189 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U176();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U190 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U172();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U191 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U177();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U192 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U173();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U193 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U178();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U194 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U170();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "that";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U195 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U175();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U330(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U333(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "That";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U196;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    rfalse;
];
[ call_U197;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    rfalse;
];
[ call_U198;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    rfalse;
];
[ call_U199;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    rfalse;
];
[ call_U200;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U201;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U202;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U203;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U204 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U174();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ call_U205 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U179();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ ConjugateVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "can't";
            ;
        2:
            print "can'ted";
            ;
        3:
            print "can'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "aren't";
            ;
        2:
            print "aren'ted";
            ;
        3:
            print "aren'ting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "aren't";
                            ;
                        2:
                            print "aren't";
                            ;
                        5:
                            print "aren't";
                            ;
                        3:
                            print "isn't";
                            ;
                        6:
                            print "aren't";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wasn't";
                            ;
                        4:
                            print "weren't";
                            ;
                        2:
                            print "weren't";
                            ;
                        5:
                            print "weren't";
                            ;
                        3:
                            print "wasn't";
                            ;
                        6:
                            print "weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "hasn't been";
                    } else {
                        print "haven't been";
                    }
                    ;
                4:
                    print "hadn't been";
                    ;
                5:
                    print "won't be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "'re";
            ;
        2:
            print " been";
            ;
        3:
            print " being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m";
                            ;
                        4:
                            print "'re";
                            ;
                        2:
                            print "'re";
                            ;
                        5:
                            print "'re";
                            ;
                        3:
                            print "'s";
                            ;
                        6:
                            print "'re";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " was";
                            ;
                        4:
                            print " were";
                            ;
                        2:
                            print " were";
                            ;
                        5:
                            print " were";
                            ;
                        3:
                            print " was";
                            ;
                        6:
                            print " were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s been";
                    } else {
                        print "'ve been";
                    }
                    ;
                4:
                    print "'d been";
                    ;
                5:
                    print "'ll be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m not";
                            ;
                        4:
                            print "'re not";
                            ;
                        2:
                            print "'re not";
                            ;
                        5:
                            print "'re not";
                            ;
                        3:
                            print "'s not";
                            ;
                        6:
                            print "'re not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " wasn't";
                            ;
                        4:
                            print " weren't";
                            ;
                        2:
                            print " weren't";
                            ;
                        5:
                            print " weren't";
                            ;
                        3:
                            print " wasn't";
                            ;
                        6:
                            print " weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not been";
                    } else {
                        print "'ve not been";
                    }
                    ;
                4:
                    print "'d not been";
                    ;
                5:
                    print "'ll not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "would";
            ;
        2:
            print "woulded";
            ;
        3:
            print "woulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U206 fn vp t modal_to;
    (t = ConjugateVerb10(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "might";
            ;
        2:
            print "mighted";
            ;
        3:
            print "mighting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U207 fn vp t modal_to;
    (t = ConjugateVerb19(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "don't";
            ;
        2:
            print "don'ted";
            ;
        3:
            print "don'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "doesn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateModalVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ ConjugateVerb75 fn vp t modal_to;
    switch (fn) {
        1:
            print "could";
            ;
        2:
            print "coulded";
            ;
        3:
            print "coulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U208 fn vp t modal_to;
    (t = ConjugateVerb75(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb76 fn vp t modal_to;
    switch (fn) {
        1:
            print "may";
            ;
        2:
            print "mayed";
            ;
        3:
            print "maying";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U209 fn vp t modal_to;
    (t = ConjugateVerb76(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb77 fn vp t modal_to;
    switch (fn) {
        1:
            print "must";
            ;
        2:
            print "musted";
            ;
        3:
            print "musting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U210 fn vp t modal_to;
    (t = ConjugateVerb77(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb78 fn vp t modal_to;
    switch (fn) {
        1:
            print "should";
            ;
        2:
            print "shoulded";
            ;
        3:
            print "shoulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U211 fn vp t modal_to;
    (t = ConjugateVerb78(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb79 fn vp t modal_to;
    switch (fn) {
        1:
            print "'ve";
            ;
        2:
            print " had";
            ;
        3:
            print " having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s";
                    } else {
                        print "'ve";
                    }
                    ;
                2:
                    print " had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s had";
                    } else {
                        print "'ve had";
                    }
                    ;
                4:
                    print "'d had";
                    ;
                5:
                    print "'ll have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s not";
                    } else {
                        print "'ve not";
                    }
                    ;
                2:
                    print " hadn't";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not had";
                    } else {
                        print "'ve not had";
                    }
                    ;
                4:
                    print "'d not had";
                    ;
                5:
                    print "'ll not have";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb80 fn vp t modal_to;
    switch (fn) {
        1:
            print "mustn't";
            ;
        2:
            print "mustn'ted";
            ;
        3:
            print "mustn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb81 fn vp t modal_to;
    switch (fn) {
        1:
            print "mightn't";
            ;
        2:
            print "mightn'ted";
            ;
        3:
            print "mightn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb82 fn vp t modal_to;
    switch (fn) {
        1:
            print "mayn't";
            ;
        2:
            print "mayn'ted";
            ;
        3:
            print "mayn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb83 fn vp t modal_to;
    switch (fn) {
        1:
            print "wouldn't";
            ;
        2:
            print "wouldn'ted";
            ;
        3:
            print "wouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb84 fn vp t modal_to;
    switch (fn) {
        1:
            print "couldn't";
            ;
        2:
            print "couldn'ted";
            ;
        3:
            print "couldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb85 fn vp t modal_to;
    switch (fn) {
        1:
            print "shouldn't";
            ;
        2:
            print "shouldn'ted";
            ;
        3:
            print "shouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb86 fn vp t modal_to;
    switch (fn) {
        1:
            print "won't";
            ;
        2:
            print "won'ted";
            ;
        3:
            print "won'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ call_U212 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == WearerOf(t_0));
    }
    rfalse;
];
[ call_U213 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == CarrierOf(t_0));
    }
    rfalse;
];
[ call_U214 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == HolderOf(t_0));
    }
    rfalse;
];
[ call_U215 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestVisibility(player, t_0);
    }
    rfalse;
];
[ call_U216 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestVisibility(player, t_0)));
    }
    rfalse;
];
[ call_U217 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestTouchability(player, t_0);
    }
    rfalse;
];
[ call_U218 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestTouchability(player, t_0)));
    }
    rfalse;
];
[ call_U219 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestConcealment(HolderOf(t_0), t_0);
    }
    rfalse;
];
[ call_U220 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestConcealment(HolderOf(t_0), t_0)));
    }
    rfalse;
];
[ call_U221 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, (-(1)));
    }
    rfalse;
];
[ call_U222 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U223 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U224 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(OnStage(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U225 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U226 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U227 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(call_U221(t_0)));
    }
    rfalse;
];
[ call_U228 t_0;
    if (1) {
        return ((scene_status-->((t_0 - 1))) == 1);
    }
    rfalse;
];
[ call_U229 t_0;
    if ((t_0 ofclass K1_room)) {
        return TestAdjacency(real_location, t_0);
    }
    rfalse;
];
[ call_U230 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (((~~(call_U267(t_0)))) && ((((~~(call_U291(t_0)))) && ((~~(call_U279(t_0)))))));
    }
    rfalse;
];
[ call_U231 t_0;
    if (t_0) {
        return (t_0 has privately_named);
    }
    rfalse;
];
[ call_U232 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U233 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U234 t_0;
    if (t_0) {
        return ((t_0 has privately_named) == 0);
    }
    rfalse;
];
[ call_U235 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U236 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U237 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U238 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U239 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U240 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U241 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U242 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U243 t_0;
    if (t_0) {
        return (t_0 has visited);
    }
    rfalse;
];
[ call_U244 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U245 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U246 t_0;
    if (t_0) {
        return ((t_0 has visited) == 0);
    }
    rfalse;
];
[ call_U247 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U248 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U249 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U250 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U251 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U252 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U253 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U254 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U255 t_0;
    if (t_0) {
        return (t_0 has edible);
    }
    rfalse;
];
[ call_U256 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U257 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U258 t_0;
    if (t_0) {
        return ((t_0 has edible) == 0);
    }
    rfalse;
];
[ call_U259 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U260 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U261 t_0;
    if (t_0) {
        return (t_0 has static);
    }
    rfalse;
];
[ call_U262 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U263 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U264 t_0;
    if (t_0) {
        return ((t_0 has static) == 0);
    }
    rfalse;
];
[ call_U265 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U266 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U267 t_0;
    if (t_0) {
        return (t_0 has scenery);
    }
    rfalse;
];
[ call_U268 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 1);
    }
    rfalse;
];
[ call_U269 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 0);
    }
    rfalse;
];
[ call_U270 t_0;
    if (t_0) {
        return (t_0 has clothing);
    }
    rfalse;
];
[ call_U271 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 1);
    }
    rfalse;
];
[ call_U272 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 0);
    }
    rfalse;
];
[ call_U273 t_0;
    if (t_0) {
        return (t_0 has pushable);
    }
    rfalse;
];
[ call_U274 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 1);
    }
    rfalse;
];
[ call_U275 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 0);
    }
    rfalse;
];
[ call_U276 t_0;
    if (t_0) {
        return (t_0 has moved);
    }
    rfalse;
];
[ call_U277 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 1);
    }
    rfalse;
];
[ call_U278 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 0);
    }
    rfalse;
];
[ call_U279 t_0;
    if (t_0) {
        return (t_0 has concealed);
    }
    rfalse;
];
[ call_U280 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U281 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U282 t_0;
    if (t_0) {
        return ((t_0 has concealed) == 0);
    }
    rfalse;
];
[ call_U283 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U284 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U285 t_0;
    if (t_0) {
        return (t_0 has workflag);
    }
    rfalse;
];
[ call_U286 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U287 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U288 t_0;
    if (t_0) {
        return ((t_0 has workflag) == 0);
    }
    rfalse;
];
[ call_U289 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U290 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U291 t_0;
    if (t_0) {
        return (t_0 has mentioned);
    }
    rfalse;
];
[ call_U292 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U293 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U294 t_0;
    if (t_0) {
        return ((t_0 has mentioned) == 0);
    }
    rfalse;
];
[ call_U295 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U296 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U297 t_0;
    if (t_0) {
        return (t_0 has enterable);
    }
    rfalse;
];
[ call_U298 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 1);
    }
    rfalse;
];
[ call_U299 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 0);
    }
    rfalse;
];
[ call_U300 t_0;
    if (t_0) {
        return (t_0 has transparent);
    }
    rfalse;
];
[ call_U301 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U302 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U303 t_0;
    if (t_0) {
        return ((t_0 has transparent) == 0);
    }
    rfalse;
];
[ call_U304 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U305 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U306 t_0;
    if (t_0) {
        return (t_0 has open);
    }
    rfalse;
];
[ call_U307 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U308 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U309 t_0;
    if (t_0) {
        return ((t_0 has open) == 0);
    }
    rfalse;
];
[ call_U310 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U311 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U312 t_0;
    if (t_0) {
        return (t_0 has openable);
    }
    rfalse;
];
[ call_U313 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U314 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U315 t_0;
    if (t_0) {
        return ((t_0 has openable) == 0);
    }
    rfalse;
];
[ call_U316 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U317 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U318 t_0;
    if (t_0) {
        return (t_0 has lockable);
    }
    rfalse;
];
[ call_U319 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 1);
    }
    rfalse;
];
[ call_U320 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 0);
    }
    rfalse;
];
[ call_U321 t_0;
    if (t_0) {
        return (t_0 has locked);
    }
    rfalse;
];
[ call_U322 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U323 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U324 t_0;
    if (t_0) {
        return ((t_0 has locked) == 0);
    }
    rfalse;
];
[ call_U325 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U326 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U327 t_0;
    if (t_0) {
        return (t_0 has female);
    }
    rfalse;
];
[ call_U328 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U329 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U330 t_0;
    if (t_0) {
        return ((t_0 has female) == 0);
    }
    rfalse;
];
[ call_U331 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U332 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U333 t_0;
    if (t_0) {
        return (t_0 has neuter);
    }
    rfalse;
];
[ call_U334 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 1);
    }
    rfalse;
];
[ call_U335 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 0);
    }
    rfalse;
];
[ call_U336 t_0;
    if (t_0) {
        return (t_0 has on);
    }
    rfalse;
];
[ call_U337 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U338 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U339 t_0;
    if (t_0) {
        return ((t_0 has on) == 0);
    }
    rfalse;
];
[ call_U340 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U341 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U342 t_0;
    if (1) {
        return _final_propertyvalue(SCENE_TY, t_0, A_P_recurring);
    }
    rfalse;
];
[ call_U343 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ call_U344 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U345 t_0;
    if (1) {
        return (_final_propertyvalue(SCENE_TY, t_0, A_P_recurring) == 0);
    }
    rfalse;
];
[ call_U346 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U347 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ call_U348 t_0;
    if (t_0) {
        return (t_0 has absent);
    }
    rfalse;
];
[ call_U349 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 1);
    }
    rfalse;
];
[ call_U350 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 0);
    }
    rfalse;
];
[ call_U351 t_0;
    if (t_0) {
        return (t_0 has door);
    }
    rfalse;
];
[ call_U352 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 1);
    }
    rfalse;
];
[ call_U353 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 0);
    }
    rfalse;
];
[ ADJDEFN27 t_0;
    rfalse;
];
[ ADJDEFN28 t_0;
    rfalse;
];
[ ADJDEFN29 t_0;
    rfalse;
];
[ ADJDEFN30 t_0;
    rfalse;
];
[ ADJDEFN31 t_0;
    rfalse;
];
[ ADJDEFN32 t_0;
    rfalse;
];
[ ADJDEFN33 t_0;
    rfalse;
];
[ ADJDEFN34 t_0;
    rfalse;
];
[ ADJDEFN35 t_0;
    rfalse;
];
[ ADJDEFN36 t_0;
    rfalse;
];
[ ADJDEFN37 t_0;
    rfalse;
];
[ call_U354 ch;
    if (((scene_status-->(0)) == 1)) {
        if ((deadflag ~= 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' ends]^";
            }
            if (GProperty(SCENE_TY, 1, A_P_recurring)) {
                ((scene_status-->(0)) = 0);
            } else {
                ((scene_status-->(0)) = 2);
            }
            FollowRulebook(rulebook_id_U38);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            ((scene_ended-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(2)));
            ((scene_latest_ending-->(0)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(0)) == 0)) {
        if ((deadflag == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' begins]^";
            }
            ((scene_status-->(0)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(rulebook_id_U37);
            ((scene_started-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(1)));
            ((scene_latest_ending-->(0)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U355;
    #ifdef DEBUG;
        if (((scene_status-->(0)) == 1)) {
            print "Scene 'Entire Game' playing (for ";
            print (the_time - (scene_started-->(0)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(0)) > 0)) {
                print "Scene 'Entire Game' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U356 X;
    if ((X ofclass K4_door)) {
        return (X.door_to);
    }
    rfalse;
];
[ call_U357 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        ((R.door_to) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U358 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        Relation_NowN1toV(R, A_door_to, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U359 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U356(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    if ((call_U359)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K4_door_First):Z1:(Z1 = (Z1.K4_door_Next))) {
                    if ((call_U359)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                if ((call_U359)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K4_door_First):Z1:(Z1 = (Z1.K4_door_Next))) {
                if ((call_U359)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    for ((Z3 = K4_door_First):Z3:(Z3 = (Z3.K4_door_Next))) {
                        if ((call_U359)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                        for ((Z3 = K4_door_First):Z3:(Z3 = (Z3.K4_door_Next))) {
                            if ((call_U359)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U357(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U358(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U360 X;
    if ((X ofclass K2_thing)) {
        return (X.with_key);
    }
    rfalse;
];
[ call_U361 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        ((R.with_key) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U362 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(R, A_with_key, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U363 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U360(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U363)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U363)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U363)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U363)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U363)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U363)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U361(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U362(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U364 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(PARSE_COMMAND_R, 0, 0);
    }
    (rv = (PARSE_COMMAND_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PARSE_COMMAND_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U989)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U989;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(GENERATE_ACTION_R, 0, 0);
    }
    (rv = (GENERATE_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return GENERATE_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U997)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U997;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U996)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U996;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(TIMED_EVENTS_R, 0, 0);
    }
    (rv = (TIMED_EVENTS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return TIMED_EVENTS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADVANCE_TIME_R, 0, 0);
    }
    (rv = (ADVANCE_TIME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADVANCE_TIME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U998)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U998;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADJUST_LIGHT_R, 0, 0);
    }
    (rv = (ADJUST_LIGHT_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADJUST_LIGHT_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(NOTE_OBJECT_ACQUISITIONS_R, 0, 0);
    }
    (rv = (NOTE_OBJECT_ACQUISITIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U999)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U999;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U365 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SCENE_CHANGE_MACHINERY_R, 0, 0);
    }
    (rv = (SCENE_CHANGE_MACHINERY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SCENE_CHANGE_MACHINERY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U366 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2383)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2383;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2385)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2385;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2388)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2388;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U368 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1022)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1022;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U370 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2452)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2452;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2380)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2380;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2456)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2456;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2513)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2513;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2517)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2517;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2421)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2421;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2427)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2427;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2382)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2382;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2520)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2520;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U371 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1003)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1003;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1002)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1002;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1006)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1006;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_VISIBILITY_R, 0, 0);
    }
    (rv = (BASIC_VISIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_VISIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_ACCESSIBILITY_R, 0, 0);
    }
    (rv = (BASIC_ACCESSIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_ACCESSIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1990)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1990;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1007)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1007;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(REQUESTED_ACTIONS_REQUIRE_R, 0, 0);
    }
    (rv = (REQUESTED_ACTIONS_REQUIRE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(CARRY_OUT_REQUESTED_ACTIONS_R, 0, 0);
    }
    (rv = (CARRY_OUT_REQUESTED_ACTIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(DESCEND_TO_SPECIFIC_ACTION_R, 0, 0);
    }
    (rv = (DESCEND_TO_SPECIFIC_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1008)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1008;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U372 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = selfobj);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ call_U373 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U1248)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1248;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Exit)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1364)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1364;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1390)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1390;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2065)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2065;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2369)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2369;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U374 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(WORK_OUT_DETAILS_OF_SPECIFIC_R, 0, 0);
    }
    (rv = (WORK_OUT_DETAILS_OF_SPECIFIC_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1009)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1009;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1010)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1010;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1011)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1011;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1012)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1012;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1013)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1013;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1014)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1014;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1015)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1015;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U375 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 6;
];
[ call_U376 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1016)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1016;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1017)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1017;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1018)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1018;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1019)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1019;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U377 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ACCESS_THROUGH_BARRIERS_R, 0, 0);
    }
    (rv = (ACCESS_THROUGH_BARRIERS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ACCESS_THROUGH_BARRIERS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U378 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_ROOMS_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_ROOMS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U379 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_OUTSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_OUTSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U380 forbid_breaks rv;
    (rv = (call_U1020)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1020;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U382 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##A_mounting)) {
        (rv = (call_U2088)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2088;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_dismounting)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2108)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2108;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U383 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U1956)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1956;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2418)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2418;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2400)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2400;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2403)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2403;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2413)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2413;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2424)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2424;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2430)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2430;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2339)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2339;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2340)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2340;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2341)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2341;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1944)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1944;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1957)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1957;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1947)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1947;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2394)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2394;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_locking_keylessly)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1958)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1958;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Open)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1959)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1959;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_locking_keylessly)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1950)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1950;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Open)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1953)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1953;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2111)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2111;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Enter)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2066)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2066;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2067)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2067;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##GetOff)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2068)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2068;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2069)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2069;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2398)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2398;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2401)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2401;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2404)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2404;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2414)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2414;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2419)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2419;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2425)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2425;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Exit)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2070)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2070;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2461)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2461;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2470)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2470;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2479)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2479;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2488)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2488;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2497)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2497;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2506)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2506;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U384 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U2395)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2395;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2396)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2396;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2437)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2437;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2446)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2446;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##LookUnder)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2431)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2431;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2434)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2434;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2440)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2440;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2443)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2443;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2386)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2386;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Listen)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2454)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2454;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Give)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2393)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2393;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##PutOn)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1987)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1987;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2349)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2349;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2343)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2343;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2345)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2345;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Climb)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2455)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2455;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##SwitchOn)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2458)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2458;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2467)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2467;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2476)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2476;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2485)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2485;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2494)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2494;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2503)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2503;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2511)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2511;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2551)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2551;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2457)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2457;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2466)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2466;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2475)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2475;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2484)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2484;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2493)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2493;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2502)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2502;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2521)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2521;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2526)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2526;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2531)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2531;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2536)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2536;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2541)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2541;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2546)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2546;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2379)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2379;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##LookUnder)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2389)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2389;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2338)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2338;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2344)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2344;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Drink)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2402)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2402;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2346)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2346;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Drink)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2350)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2350;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##SwitchOn)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2518)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2518;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##SwitchOff)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2519)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2519;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2342)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2342;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2462)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2462;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2471)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2471;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2480)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2480;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2489)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2489;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2498)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2498;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2507)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2507;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2459)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2459;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2463)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2463;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2468)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2468;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2472)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2472;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2477)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2477;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2481)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2481;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2486)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2486;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2490)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2490;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2495)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2495;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2499)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2499;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2504)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2504;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2508)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2508;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2405)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2405;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##LookUnder)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2449)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2449;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2460)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2460;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2464)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2464;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2465)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2465;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2469)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2469;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2473)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2473;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2474)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2474;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2478)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2478;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2482)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2482;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2483)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2483;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2487)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2487;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2491)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2491;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2492)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2492;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2496)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2496;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2500)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2500;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2501)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2501;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2505)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2505;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2509)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2509;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2510)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2510;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2422)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2422;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2428)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2428;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U387 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U2397)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2397;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_hitting)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2408)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2408;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2451)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2451;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2392)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2392;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2399)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2399;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1980)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1980;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2337)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2337;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Give)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2417)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2417;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2450)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2450;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2371)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2371;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U389 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Take)) {
        (rv = (call_U1021)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1021;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Disrobe)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1567)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1567;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U394 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_RESPONSE_ISSUING_R, 0, 0);
    }
    (rv = (STANDARD_RESPONSE_ISSUING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_RESPONSE_ISSUING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U397 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1024)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1024;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U406 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_CONTENTS_LISTING_R, 0, 0);
    }
    (rv = (STANDARD_CONTENTS_LISTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_CONTENTS_LISTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U421 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2367)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2367;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U427 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1025)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1025;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U430 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2368)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2368;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U433 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2023)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2023;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U440 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2381)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2381;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2409)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2409;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2410)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2410;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2411)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2411;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2412)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2412;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U448 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1030)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1030;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1026)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1026;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1028)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1028;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1027)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1027;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1029)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1029;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1991)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1991;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U460 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1031)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1031;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1032)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1032;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1033)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1033;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1311)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1311;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U466 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_IMPLICIT_TAKING_R, 0, 0);
    }
    (rv = (STANDARD_IMPLICIT_TAKING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_IMPLICIT_TAKING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U472 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_OBITUARY_HEADLINE_R, 0, 0);
    }
    (rv = (PRINT_OBITUARY_HEADLINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_OBITUARY_HEADLINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_FINAL_SCORE_R, 0, 0);
    }
    (rv = (PRINT_FINAL_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_FINAL_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(DISPLAY_FINAL_STATUS_LINE_R, 0, 0);
    }
    (rv = (DISPLAY_FINAL_STATUS_LINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U474 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1039)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1039;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1036)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1036;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(READ_FINAL_ANSWER_R, 0, 0);
    }
    (rv = (READ_FINAL_ANSWER_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return READ_FINAL_ANSWER_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U475 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1044)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1044;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U477 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1047)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1047;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1048)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1048;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U478 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1049)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1049;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1050)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1050;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U481 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1068)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1068;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U484 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1079)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1079;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1069)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1069;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1070)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1070;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1071)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1071;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1072)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1072;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1073)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1073;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1074)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1074;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1081)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1081;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1086)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1086;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U487 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1091)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1091;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1094)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1094;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U488 forbid_breaks rv;
    (rv = (call_U1097)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1097;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InvSub;
    return GenericVerbSub(rulebook_id_U132, rulebook_id_U133, rulebook_id_U134);
];
[ InvDbg n s for_say;
    print "taking inventory";
];
[ call_U489 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1100)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1100;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1103)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1103;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1106)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1106;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1109)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1109;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1112)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1112;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1115)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1115;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1118)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1118;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1121)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1121;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1124)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1124;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1127)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1127;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1130)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1130;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1136)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1136;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U490 forbid_breaks rv;
    (rv = (call_U1140)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1140;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U491 forbid_breaks rv;
    (rv = (call_U1141)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1141;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TakeSub;
    return GenericVerbSub(rulebook_id_U135, rulebook_id_U136, rulebook_id_U137);
];
[ TakeDbg n s for_say;
    print "taking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U492 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1106)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1106;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1146)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1146;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1149)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1149;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1152)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1152;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RemoveSub;
    return GenericVerbSub(rulebook_id_U138, rulebook_id_U139, rulebook_id_U140);
];
[ RemoveDbg n s for_say;
    print "removing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "from";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U495 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1156)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1156;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1153)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1153;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1159)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1159;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1162)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1162;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1165)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1165;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1168)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1168;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U496 forbid_breaks rv;
    (rv = (call_U1175)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1175;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U497 forbid_breaks rv;
    (rv = (call_U1176)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1176;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DropSub;
    return GenericVerbSub(rulebook_id_U141, rulebook_id_U142, rulebook_id_U143);
];
[ DropDbg n s for_say;
    print "dropping";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U498 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1181)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1181;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1182)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1182;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1183)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1183;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1186)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1186;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1189)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1189;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1192)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1192;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U499 forbid_breaks rv;
    (rv = (call_U1196)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1196;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U500 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1197)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1197;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1200)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1200;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PutOnSub;
    return GenericVerbSub(rulebook_id_U144, rulebook_id_U145, rulebook_id_U146);
];
[ PutOnDbg n s for_say;
    print "putting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U501 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1203)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1203;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1204)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1204;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1207)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1207;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1210)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1210;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1211)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1211;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1214)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1214;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1217)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1217;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1220)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1220;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U502 forbid_breaks rv;
    (rv = (call_U1224)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1224;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U503 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1225)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1225;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1228)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1228;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InsertSub;
    return GenericVerbSub(rulebook_id_U147, rulebook_id_U148, rulebook_id_U149);
];
[ InsertDbg n s for_say;
    print "inserting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "into";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U504 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1231)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1231;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1234)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1234;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1237)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1237;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1241)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1241;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U505 forbid_breaks rv;
    (rv = (call_U1242)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1242;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U506 forbid_breaks rv;
    (rv = (call_U1243)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1243;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EatSub;
    return GenericVerbSub(rulebook_id_U150, rulebook_id_U151, rulebook_id_U152);
];
[ EatDbg n s for_say;
    print "eating";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U507 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2415)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2415;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2423)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2423;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2416)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2416;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1252)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1252;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1257)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1257;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1260)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1260;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1263)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1263;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1264)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1264;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U508 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2373)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2373;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1269)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1269;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1270)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1270;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1271)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1271;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2370)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2370;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U509 forbid_breaks rv;
    (rv = (call_U1272)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1272;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U510 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = I_parking_lot_U1);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 6;
];
[ GoSub;
    return GenericVerbSub(rulebook_id_U153, rulebook_id_U154, rulebook_id_U155);
];
[ GoDbg n s for_say;
    print "going";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U511 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1313)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1313;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1314)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1314;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1315)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1315;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1320)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1320;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1329)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1329;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1332)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1332;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1339)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1339;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1342)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1342;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U512 forbid_breaks rv;
    (rv = (call_U1353)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1353;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U513 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1354)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1354;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1363)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1363;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EnterSub;
    return GenericVerbSub(rulebook_id_U156, rulebook_id_U157, rulebook_id_U158);
];
[ EnterDbg n s for_say;
    print "entering";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U514 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1365)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1365;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1366)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1366;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1369)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1369;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1372)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1372;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U515 forbid_breaks rv;
    (rv = (call_U1373)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1373;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U516 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1374)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1374;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1381)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1381;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U517 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExitSub;
    return GenericVerbSub(rulebook_id_U159, rulebook_id_U160, rulebook_id_U161);
];
[ ExitDbg n s for_say;
    print "exiting";
];
[ call_U518 forbid_breaks rv;
    (rv = (call_U1382)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1382;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U519 forbid_breaks rv;
    (rv = (call_U1385)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1385;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U520 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1386)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1386;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1389)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1389;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GetOffSub;
    return GenericVerbSub(rulebook_id_U162, rulebook_id_U163, rulebook_id_U164);
];
[ GetOffDbg n s for_say;
    print "getting off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U522 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1391)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1391;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1393)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1393;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1400)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1400;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1403)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1403;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1404)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1404;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U523 forbid_breaks rv;
    (rv = (call_U1405)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1405;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U524 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = ##Wait);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 4;
];
[ LookSub;
    return GenericVerbSub(rulebook_id_U165, rulebook_id_U166, rulebook_id_U167);
];
[ LookDbg n s for_say;
    print "looking";
];
[ call_U526 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2372)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2372;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1408)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1408;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1409)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1409;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1412)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1412;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1419)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1419;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2358)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2358;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1427)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1427;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U527 forbid_breaks rv;
    (rv = (call_U1430)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1430;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U528 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExamineSub;
    return GenericVerbSub(rulebook_id_U168, rulebook_id_U169, rulebook_id_U170);
];
[ ExamineDbg n s for_say;
    print "examining";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U530 forbid_breaks rv;
    (rv = (call_U1433)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1433;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U531 forbid_breaks rv;
    (rv = (call_U1436)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1436;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LookUnderSub;
    return GenericVerbSub(rulebook_id_U171, rulebook_id_U172, rulebook_id_U173);
];
[ LookUnderDbg n s for_say;
    print "looking under";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U532 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1439)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1439;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1442)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1442;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U534 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1445)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1445;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1451)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1451;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1457)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1457;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SearchSub;
    return GenericVerbSub(rulebook_id_U174, rulebook_id_U175, rulebook_id_U176);
];
[ SearchDbg n s for_say;
    print "searching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U537 forbid_breaks rv;
    (rv = (call_U1460)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1460;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ConsultSub;
    return GenericVerbSub(rulebook_id_U177, rulebook_id_U178, rulebook_id_U179);
];
[ ConsultDbg n s for_say;
    print "consulting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U538 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1465)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1465;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1468)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1468;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1471)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1471;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1965)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1965;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1972)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1972;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U539 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1985)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1985;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1477)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1477;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U540 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1986)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1986;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1478)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1478;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LockSub;
    return GenericVerbSub(rulebook_id_U180, rulebook_id_U181, rulebook_id_U182);
];
[ LockDbg n s for_say;
    print "locking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U541 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1483)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1483;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1486)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1486;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1965)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1965;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1964)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1964;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U542 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1983)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1983;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1492)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1492;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U543 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1984)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1984;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1493)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1493;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ UnlockSub;
    return GenericVerbSub(rulebook_id_U183, rulebook_id_U184, rulebook_id_U185);
];
[ UnlockDbg n s for_say;
    print "unlocking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U544 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1498)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1498;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1501)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1501;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U545 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2362)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2362;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1504)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1504;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U546 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2359)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2359;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1505)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1505;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOnSub;
    return GenericVerbSub(rulebook_id_U186, rulebook_id_U187, rulebook_id_U188);
];
[ SwitchOnDbg n s for_say;
    print "switching on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U547 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1508)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1508;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1511)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1511;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U548 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2363)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2363;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1514)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1514;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U549 forbid_breaks rv;
    (rv = (call_U1515)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1515;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOffSub;
    return GenericVerbSub(rulebook_id_U189, rulebook_id_U190, rulebook_id_U191);
];
[ SwitchOffDbg n s for_say;
    print "switching off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U550 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1518)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1518;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1521)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1521;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1524)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1524;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U551 forbid_breaks rv;
    (rv = (call_U1527)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1527;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U552 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1528)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1528;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1531)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1531;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ OpenSub;
    return GenericVerbSub(rulebook_id_U192, rulebook_id_U193, rulebook_id_U194);
];
[ OpenDbg n s for_say;
    print "opening";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U553 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1538)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1538;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1541)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1541;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U554 forbid_breaks rv;
    (rv = (call_U1544)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1544;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U555 forbid_breaks rv;
    (rv = (call_U1545)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1545;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CloseSub;
    return GenericVerbSub(rulebook_id_U195, rulebook_id_U196, rulebook_id_U197);
];
[ CloseDbg n s for_say;
    print "closing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U556 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1552)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1552;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1555)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1555;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1558)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1558;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U557 forbid_breaks rv;
    (rv = (call_U1561)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1561;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U558 forbid_breaks rv;
    (rv = (call_U1562)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1562;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WearSub;
    return GenericVerbSub(rulebook_id_U198, rulebook_id_U199, rulebook_id_U200);
];
[ WearDbg n s for_say;
    print "wearing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U559 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1568)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1568;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1571)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1571;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U560 forbid_breaks rv;
    (rv = (call_U1575)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1575;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U561 forbid_breaks rv;
    (rv = (call_U1576)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1576;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DisrobeSub;
    return GenericVerbSub(rulebook_id_U201, rulebook_id_U202, rulebook_id_U203);
];
[ DisrobeDbg n s for_say;
    print "taking off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U562 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1581)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1581;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1584)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1584;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1587)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1587;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1590)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1590;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1596)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1596;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U563 forbid_breaks rv;
    (rv = (call_U1600)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1600;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U564 forbid_breaks rv;
    (rv = (call_U1601)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1601;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GiveSub;
    return GenericVerbSub(rulebook_id_U204, rulebook_id_U205, rulebook_id_U206);
];
[ GiveDbg n s for_say;
    print "giving";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U565 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1608)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1608;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1611)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1611;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1612)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1612;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ShowSub;
    return GenericVerbSub(rulebook_id_U207, rulebook_id_U208, rulebook_id_U209);
];
[ ShowDbg n s for_say;
    print "showing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U568 forbid_breaks rv;
    (rv = (call_U1615)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1615;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeOtherSub;
    return GenericVerbSub(rulebook_id_U210, rulebook_id_U211, rulebook_id_U212);
];
[ WakeOtherDbg n s for_say;
    print "waking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U571 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1618)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1618;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1621)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1621;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1624)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1624;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThrowAtSub;
    return GenericVerbSub(rulebook_id_U213, rulebook_id_U214, rulebook_id_U215);
];
[ ThrowAtDbg n s for_say;
    print "throwing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "at";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U574 forbid_breaks rv;
    (rv = (call_U1627)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1627;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AttackSub;
    return GenericVerbSub(rulebook_id_U216, rulebook_id_U217, rulebook_id_U218);
];
[ AttackDbg n s for_say;
    print "attacking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U577 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1630)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1630;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1633)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1633;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ KissSub;
    return GenericVerbSub(rulebook_id_U219, rulebook_id_U220, rulebook_id_U221);
];
[ KissDbg n s for_say;
    print "kissing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U582 forbid_breaks rv;
    (rv = (call_U1636)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1636;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AnswerSub;
    return GenericVerbSub(rulebook_id_U222, rulebook_id_U223, rulebook_id_U224);
];
[ AnswerDbg n s for_say;
    print "answering";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "that";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U583 forbid_breaks rv;
    (rv = (call_U1639)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1639;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U585 forbid_breaks rv;
    (rv = (call_U1642)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1642;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TellSub;
    return GenericVerbSub(rulebook_id_U225, rulebook_id_U226, rulebook_id_U227);
];
[ TellDbg n s for_say;
    print "telling";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U588 forbid_breaks rv;
    (rv = (call_U1645)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1645;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskSub;
    return GenericVerbSub(rulebook_id_U228, rulebook_id_U229, rulebook_id_U230);
];
[ AskDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U589 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1648)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1648;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1649)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1649;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskForSub;
    return GenericVerbSub(rulebook_id_U231, rulebook_id_U232, rulebook_id_U233);
];
[ AskForDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "for";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U594 forbid_breaks rv;
    (rv = (call_U1650)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1650;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaitSub;
    return GenericVerbSub(rulebook_id_U234, rulebook_id_U235, rulebook_id_U236);
];
[ WaitDbg n s for_say;
    print "waiting";
];
[ call_U597 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1655)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1655;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1660)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1660;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1667)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1667;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TouchSub;
    return GenericVerbSub(rulebook_id_U237, rulebook_id_U238, rulebook_id_U239);
];
[ TouchDbg n s for_say;
    print "touching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U598 forbid_breaks rv;
    (rv = (call_U1672)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1672;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U600 forbid_breaks rv;
    (rv = (call_U1675)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1675;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveSub;
    return GenericVerbSub(rulebook_id_U240, rulebook_id_U241, rulebook_id_U242);
];
[ WaveDbg n s for_say;
    print "waving";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U601 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1680)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1680;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1683)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1683;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1686)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1686;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U603 forbid_breaks rv;
    (rv = (call_U1689)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1689;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PullSub;
    return GenericVerbSub(rulebook_id_U243, rulebook_id_U244, rulebook_id_U245);
];
[ PullDbg n s for_say;
    print "pulling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U604 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1694)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1694;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1697)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1697;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1700)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1700;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U606 forbid_breaks rv;
    (rv = (call_U1703)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1703;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushSub;
    return GenericVerbSub(rulebook_id_U246, rulebook_id_U247, rulebook_id_U248);
];
[ PushDbg n s for_say;
    print "pushing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U607 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1708)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1708;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1711)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1711;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1714)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1714;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U609 forbid_breaks rv;
    (rv = (call_U1717)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1717;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TurnSub;
    return GenericVerbSub(rulebook_id_U249, rulebook_id_U250, rulebook_id_U251);
];
[ TurnDbg n s for_say;
    print "turning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U610 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1722)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1722;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1725)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1725;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1728)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1728;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1731)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1731;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1734)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1734;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1735)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1735;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushDirSub;
    return GenericVerbSub(rulebook_id_U252, rulebook_id_U253, rulebook_id_U254);
];
[ PushDirDbg n s for_say;
    print "pushing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U613 forbid_breaks rv;
    (rv = (call_U1738)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1738;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U615 forbid_breaks rv;
    (rv = (call_U1741)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1741;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SqueezeSub;
    return GenericVerbSub(rulebook_id_U255, rulebook_id_U256, rulebook_id_U257);
];
[ SqueezeDbg n s for_say;
    print "squeezing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U616 forbid_breaks rv;
    (rv = (call_U1746)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1746;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ YesSub;
    return GenericVerbSub(rulebook_id_U258, rulebook_id_U259, rulebook_id_U260);
];
[ YesDbg n s for_say;
    print "saying yes";
];
[ call_U619 forbid_breaks rv;
    (rv = (call_U1749)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1749;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NoSub;
    return GenericVerbSub(rulebook_id_U261, rulebook_id_U262, rulebook_id_U263);
];
[ NoDbg n s for_say;
    print "saying no";
];
[ call_U622 forbid_breaks rv;
    (rv = (call_U1752)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1752;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BurnSub;
    return GenericVerbSub(rulebook_id_U264, rulebook_id_U265, rulebook_id_U266);
];
[ BurnDbg n s for_say;
    print "burning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U625 forbid_breaks rv;
    (rv = (call_U1755)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1755;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeSub;
    return GenericVerbSub(rulebook_id_U267, rulebook_id_U268, rulebook_id_U269);
];
[ WakeDbg n s for_say;
    print "waking up";
];
[ call_U628 forbid_breaks rv;
    (rv = (call_U1758)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1758;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThinkSub;
    return GenericVerbSub(rulebook_id_U270, rulebook_id_U271, rulebook_id_U272);
];
[ ThinkDbg n s for_say;
    print "thinking";
];
[ call_U633 forbid_breaks rv;
    (rv = (call_U1761)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1761;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SmellSub;
    return GenericVerbSub(rulebook_id_U273, rulebook_id_U274, rulebook_id_U275);
];
[ SmellDbg n s for_say;
    print "smelling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U636 forbid_breaks rv;
    (rv = (call_U1766)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1766;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ListenSub;
    return GenericVerbSub(rulebook_id_U276, rulebook_id_U277, rulebook_id_U278);
];
[ ListenDbg n s for_say;
    print "listening to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U639 forbid_breaks rv;
    (rv = (call_U1771)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1771;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TasteSub;
    return GenericVerbSub(rulebook_id_U279, rulebook_id_U280, rulebook_id_U281);
];
[ TasteDbg n s for_say;
    print "tasting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U640 forbid_breaks rv;
    (rv = (call_U1776)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1776;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CutSub;
    return GenericVerbSub(rulebook_id_U282, rulebook_id_U283, rulebook_id_U284);
];
[ CutDbg n s for_say;
    print "cutting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U645 forbid_breaks rv;
    (rv = (call_U1779)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1779;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ JumpSub;
    return GenericVerbSub(rulebook_id_U285, rulebook_id_U286, rulebook_id_U287);
];
[ JumpDbg n s for_say;
    print "jumping";
];
[ call_U646 forbid_breaks rv;
    (rv = (call_U1784)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1784;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TieSub;
    return GenericVerbSub(rulebook_id_U288, rulebook_id_U289, rulebook_id_U290);
];
[ TieDbg n s for_say;
    print "tying";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U649 forbid_breaks rv;
    (rv = (call_U1787)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1787;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DrinkSub;
    return GenericVerbSub(rulebook_id_U291, rulebook_id_U292, rulebook_id_U293);
];
[ DrinkDbg n s for_say;
    print "drinking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U652 forbid_breaks rv;
    (rv = (call_U1790)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1790;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SorrySub;
    return GenericVerbSub(rulebook_id_U294, rulebook_id_U295, rulebook_id_U296);
];
[ SorryDbg n s for_say;
    print "saying sorry";
];
[ call_U655 forbid_breaks rv;
    (rv = (call_U1793)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1793;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwingSub;
    return GenericVerbSub(rulebook_id_U297, rulebook_id_U298, rulebook_id_U299);
];
[ SwingDbg n s for_say;
    print "swinging";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U658 forbid_breaks rv;
    (rv = (call_U1796)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1796;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U660 forbid_breaks rv;
    (rv = (call_U1799)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1799;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RubSub;
    return GenericVerbSub(rulebook_id_U300, rulebook_id_U301, rulebook_id_U302);
];
[ RubDbg n s for_say;
    print "rubbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U661 forbid_breaks rv;
    (rv = (call_U1804)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1804;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SetToSub;
    return GenericVerbSub(rulebook_id_U303, rulebook_id_U304, rulebook_id_U305);
];
[ SetToDbg n s for_say;
    print "setting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U666 forbid_breaks rv;
    (rv = (call_U1807)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1807;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveHandsSub;
    return GenericVerbSub(rulebook_id_U306, rulebook_id_U307, rulebook_id_U308);
];
[ WaveHandsDbg n s for_say;
    print "waving hands";
];
[ call_U667 forbid_breaks rv;
    (rv = (call_U1812)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1812;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BuySub;
    return GenericVerbSub(rulebook_id_U309, rulebook_id_U310, rulebook_id_U311);
];
[ BuyDbg n s for_say;
    print "buying";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U670 forbid_breaks rv;
    (rv = (call_U1815)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1815;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ClimbSub;
    return GenericVerbSub(rulebook_id_U312, rulebook_id_U313, rulebook_id_U314);
];
[ ClimbDbg n s for_say;
    print "climbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U673 forbid_breaks rv;
    (rv = (call_U1818)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1818;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SleepSub;
    return GenericVerbSub(rulebook_id_U315, rulebook_id_U316, rulebook_id_U317);
];
[ SleepDbg n s for_say;
    print "sleeping";
];
[ call_U677 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(QUIT_THE_GAME_R, 0, 0);
    }
    (rv = (QUIT_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return QUIT_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ QuitSub;
    return GenericVerbSub(rulebook_id_U318, rulebook_id_U319, rulebook_id_U320);
];
[ QuitDbg n s for_say;
    print "quitting the game";
];
[ call_U680 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SAVE_THE_GAME_R, 0, 0);
    }
    (rv = (SAVE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SAVE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SaveSub;
    return GenericVerbSub(rulebook_id_U321, rulebook_id_U322, rulebook_id_U323);
];
[ SaveDbg n s for_say;
    print "saving the game";
];
[ call_U683 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTORE_THE_GAME_R, 0, 0);
    }
    (rv = (RESTORE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTORE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestoreSub;
    return GenericVerbSub(rulebook_id_U324, rulebook_id_U325, rulebook_id_U326);
];
[ RestoreDbg n s for_say;
    print "restoring the game";
];
[ call_U686 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTART_THE_GAME_R, 0, 0);
    }
    (rv = (RESTART_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTART_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestartSub;
    return GenericVerbSub(rulebook_id_U327, rulebook_id_U328, rulebook_id_U329);
];
[ RestartDbg n s for_say;
    print "restarting the game";
];
[ call_U689 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(VERIFY_THE_STORY_FILE_R, 0, 0);
    }
    (rv = (VERIFY_THE_STORY_FILE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VERIFY_THE_STORY_FILE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VerifySub;
    return GenericVerbSub(rulebook_id_U330, rulebook_id_U331, rulebook_id_U332);
];
[ VerifyDbg n s for_say;
    print "verifying the story file";
];
[ call_U692 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_ON_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOnSub;
    return GenericVerbSub(rulebook_id_U333, rulebook_id_U334, rulebook_id_U335);
];
[ ScriptOnDbg n s for_say;
    print "switching the story transcript on";
];
[ call_U695 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_OFF_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOffSub;
    return GenericVerbSub(rulebook_id_U336, rulebook_id_U337, rulebook_id_U338);
];
[ ScriptOffDbg n s for_say;
    print "switching the story transcript off";
];
[ call_U698 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_STORY_FILE_VERSION_R, 0, 0);
    }
    (rv = (ANNOUNCE_STORY_FILE_VERSION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VersionSub;
    return GenericVerbSub(rulebook_id_U339, rulebook_id_U340, rulebook_id_U341);
];
[ VersionDbg n s for_say;
    print "requesting the story file version";
];
[ call_U701 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_SCORE_R, 0, 0);
    }
    (rv = (ANNOUNCE_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScoreSub;
    return GenericVerbSub(rulebook_id_U342, rulebook_id_U343, rulebook_id_U344);
];
[ ScoreDbg n s for_say;
    print "requesting the score";
];
[ call_U704 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U705 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode3Sub;
    return GenericVerbSub(rulebook_id_U345, rulebook_id_U346, rulebook_id_U347);
];
[ LMode3Dbg n s for_say;
    print "preferring abbreviated room descriptions";
];
[ call_U707 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U708 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode2Sub;
    return GenericVerbSub(rulebook_id_U348, rulebook_id_U349, rulebook_id_U350);
];
[ LMode2Dbg n s for_say;
    print "preferring unabbreviated room descriptions";
];
[ call_U710 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_SOMETIMES_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_SOMETIMES_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U711 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_SOMETIMES_ABBR_R, 0, 0);
    }
    (rv = (REP_PREFER_SOMETIMES_ABBR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode1Sub;
    return GenericVerbSub(rulebook_id_U351, rulebook_id_U352, rulebook_id_U353);
];
[ LMode1Dbg n s for_say;
    print "preferring sometimes abbreviated room descriptions";
];
[ call_U713 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_ON_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U714 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_ON_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOnSub;
    return GenericVerbSub(rulebook_id_U354, rulebook_id_U355, rulebook_id_U356);
];
[ NotifyOnDbg n s for_say;
    print "switching score notification on";
];
[ call_U716 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U717 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOffSub;
    return GenericVerbSub(rulebook_id_U357, rulebook_id_U358, rulebook_id_U359);
];
[ NotifyOffDbg n s for_say;
    print "switching score notification off";
];
[ call_U719 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_PRONOUN_MEANINGS_R, 0, 0);
    }
    (rv = (ANNOUNCE_PRONOUN_MEANINGS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PronounsSub;
    return GenericVerbSub(rulebook_id_U360, rulebook_id_U361, rulebook_id_U362);
];
[ PronounsDbg n s for_say;
    print "requesting the pronoun meanings";
];
[ call_U721;
    ResponseViaActivity(response_id_U1);
];
[ call_U722;
    (say__p = 1);
    ParaContent();
    call_U196();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now ";
    .L_Say0;
    ParaContent();
    print "pitch dark in ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say1;
    }
    ParaContent();
    print "here";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "there";
    .L_SayX1;
    ParaContent();
    print "!";
    rtrue;
];
[ ADJUST_LIGHT_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U1);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U723;
    ResponseViaActivity(response_id_U2);
];
[ call_U724;
    (say__p = 1);
    ParaContent();
    print "(considering the first sixteen objects only)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U725;
    ResponseViaActivity(response_id_U3);
];
[ call_U726;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ GENERATE_ACTION_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U2);
            ;
        66:
            (str = as_block_constant_U3);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U727;
    ResponseViaActivity(response_id_U4);
];
[ call_U728;
    (say__p = 1);
    ParaContent();
    print "You must name something more substantial.";
    rtrue;
];
[ BASIC_ACCESSIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U4);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U729;
    ResponseViaActivity(response_id_U5);
];
[ call_U730;
    (say__p = 1);
    ParaContent();
    call_U196();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ BASIC_VISIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U5);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U731;
    ResponseViaActivity(response_id_U6);
];
[ call_U732;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " better things to do.";
    rtrue;
];
[ REQUESTED_ACTIONS_REQUIRE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U6);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U733;
    ResponseViaActivity(response_id_U7);
];
[ call_U734;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to do that.";
    rtrue;
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U7);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U735;
    ResponseViaActivity(response_id_U8);
];
[ call_U736;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ ACCESS_THROUGH_BARRIERS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U8);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U737;
    ResponseViaActivity(response_id_U9);
];
[ call_U738;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U9);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U739;
    ResponseViaActivity(response_id_U10);
];
[ call_U740;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " reach into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ CANT_REACH_INSIDE_ROOMS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U10);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U741;
    ResponseViaActivity(response_id_U11);
];
[ call_U742;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_OUTSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U11);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U743;
    ResponseViaActivity(response_id_U12);
];
[ call_U744;
    (say__p = 1);
    ParaContent();
    print " (";
    rtrue;
];
[ call_U745;
    ResponseViaActivity(response_id_U13);
];
[ call_U746;
    (say__p = 1);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U747;
    ResponseViaActivity(response_id_U14);
];
[ call_U748;
    (say__p = 1);
    ParaContent();
    print " and ";
    rtrue;
];
[ call_U749;
    ResponseViaActivity(response_id_U15);
];
[ call_U750;
    (say__p = 1);
    ParaContent();
    print "providing light";
    rtrue;
];
[ call_U751;
    ResponseViaActivity(response_id_U16);
];
[ call_U752;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U753;
    ResponseViaActivity(response_id_U17);
];
[ call_U754;
    (say__p = 1);
    ParaContent();
    print "empty";
    rtrue;
];
[ call_U755;
    ResponseViaActivity(response_id_U18);
];
[ call_U756;
    (say__p = 1);
    ParaContent();
    print "closed and empty";
    rtrue;
];
[ call_U757;
    ResponseViaActivity(response_id_U19);
];
[ call_U758;
    (say__p = 1);
    ParaContent();
    print "closed and providing light";
    rtrue;
];
[ call_U759;
    ResponseViaActivity(response_id_U20);
];
[ call_U760;
    (say__p = 1);
    ParaContent();
    print "empty and providing light";
    rtrue;
];
[ call_U761;
    ResponseViaActivity(response_id_U21);
];
[ call_U762;
    (say__p = 1);
    ParaContent();
    print "closed, empty";
    if ((~~(call_U72(use_option_id_U3)))) {
        jump L_Say0;
    }
    ParaContent();
    print ",";
    .L_Say0;
    ParaContent();
    print " and providing light";
    rtrue;
];
[ call_U763;
    ResponseViaActivity(response_id_U22);
];
[ call_U764;
    (say__p = 1);
    ParaContent();
    print "providing light and being worn";
    rtrue;
];
[ call_U765;
    ResponseViaActivity(response_id_U23);
];
[ call_U766;
    (say__p = 1);
    ParaContent();
    print "being worn";
    rtrue;
];
[ call_U767;
    ResponseViaActivity(response_id_U24);
];
[ call_U768;
    (say__p = 1);
    ParaContent();
    print "open";
    rtrue;
];
[ call_U769;
    ResponseViaActivity(response_id_U25);
];
[ call_U770;
    (say__p = 1);
    ParaContent();
    print "open but empty";
    rtrue;
];
[ call_U771;
    ResponseViaActivity(response_id_U26);
];
[ call_U772;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U773;
    ResponseViaActivity(response_id_U27);
];
[ call_U774;
    (say__p = 1);
    ParaContent();
    print "closed and locked";
    rtrue;
];
[ call_U775;
    ResponseViaActivity(response_id_U28);
];
[ call_U776;
    (say__p = 1);
    ParaContent();
    print "containing";
    rtrue;
];
[ call_U777;
    ResponseViaActivity(response_id_U29);
];
[ call_U778;
    (say__p = 1);
    ParaContent();
    print "on ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U779;
    ResponseViaActivity(response_id_U30);
];
[ call_U780;
    (say__p = 1);
    ParaContent();
    print ", on top of ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U781;
    ResponseViaActivity(response_id_U31);
];
[ call_U782;
    (say__p = 1);
    ParaContent();
    print "in ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U783;
    ResponseViaActivity(response_id_U32);
];
[ call_U784;
    (say__p = 1);
    ParaContent();
    print ", inside ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U785;
    ResponseViaActivity(response_id_U33);
];
[ call_U786;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U787;
    ResponseViaActivity(response_id_U34);
];
[ call_U788;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing";
    rtrue;
];
[ call_U789;
    ResponseViaActivity(response_id_U35);
];
[ call_U790;
    (say__p = 1);
    ParaContent();
    print "Nothing";
    rtrue;
];
[ call_U791;
    ResponseViaActivity(response_id_U36);
];
[ call_U792;
    (say__p = 1);
    ParaContent();
    print "nothing";
    rtrue;
];
[ LIST_WRITER_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U12);
            ;
        66:
            (str = as_block_constant_U13);
            ;
        67:
            (str = as_block_constant_U14);
            ;
        68:
            (str = as_block_constant_U15);
            ;
        69:
            (str = as_block_constant_U16);
            ;
        70:
            (str = as_block_constant_U17);
            ;
        71:
            (str = as_block_constant_U18);
            ;
        72:
            (str = as_block_constant_U19);
            ;
        73:
            (str = as_block_constant_U20);
            ;
        74:
            (str = as_block_constant_U21);
            ;
        75:
            (str = as_block_constant_U22);
            ;
        76:
            (str = as_block_constant_U23);
            ;
        77:
            (str = as_block_constant_U24);
            ;
        78:
            (str = as_block_constant_U25);
            ;
        79:
            (str = as_block_constant_U26);
            ;
        80:
            (str = as_block_constant_U27);
            ;
        81:
            (str = as_block_constant_U28);
            ;
        82:
            (str = as_block_constant_U29);
            ;
        83:
            (str = as_block_constant_U30);
            ;
        84:
            (str = as_block_constant_U31);
            ;
        85:
            (str = as_block_constant_U32);
            ;
        86:
            (str = as_block_constant_U33);
            ;
        87:
            (str = as_block_constant_U34);
            ;
        88:
            (str = as_block_constant_U35);
            ;
        89:
            (str = as_block_constant_U36);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U793;
    ResponseViaActivity(response_id_U37);
];
[ call_U794;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "That command asks to do something outside of play, so it can only make sense from you to me. ";
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " cannot be asked to do this.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U795;
    ResponseViaActivity(response_id_U38);
];
[ call_U796;
    (say__p = 1);
    ParaContent();
    print "You must name an object.";
    rtrue;
];
[ call_U797;
    ResponseViaActivity(response_id_U39);
];
[ call_U798;
    (say__p = 1);
    ParaContent();
    print "You may not name an object.";
    rtrue;
];
[ call_U799;
    ResponseViaActivity(response_id_U40);
];
[ call_U800;
    (say__p = 1);
    ParaContent();
    print "You must supply a noun.";
    rtrue;
];
[ call_U801;
    ResponseViaActivity(response_id_U41);
];
[ call_U802;
    (say__p = 1);
    ParaContent();
    print "You may not supply a noun.";
    rtrue;
];
[ call_U803;
    ResponseViaActivity(response_id_U42);
];
[ call_U804;
    (say__p = 1);
    ParaContent();
    print "You must name a second object.";
    rtrue;
];
[ call_U805;
    ResponseViaActivity(response_id_U43);
];
[ call_U806;
    (say__p = 1);
    ParaContent();
    print "You may not name a second object.";
    rtrue;
];
[ call_U807;
    ResponseViaActivity(response_id_U44);
];
[ call_U808;
    (say__p = 1);
    ParaContent();
    print "You must supply a second noun.";
    rtrue;
];
[ call_U809;
    ResponseViaActivity(response_id_U45);
];
[ call_U810;
    (say__p = 1);
    ParaContent();
    print "You may not supply a second noun.";
    rtrue;
];
[ call_U811;
    ResponseViaActivity(response_id_U46);
];
[ call_U812;
    (say__p = 1);
    ParaContent();
    print "(Since something dramatic has happened, your list of commands has been cut short.)";
    rtrue;
];
[ call_U813;
    ResponseViaActivity(response_id_U47);
];
[ call_U814;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that instruction.";
    rtrue;
];
[ ACTION_PROCESSING_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U37);
            ;
        66:
            (str = as_block_constant_U38);
            ;
        67:
            (str = as_block_constant_U39);
            ;
        68:
            (str = as_block_constant_U40);
            ;
        69:
            (str = as_block_constant_U41);
            ;
        70:
            (str = as_block_constant_U42);
            ;
        71:
            (str = as_block_constant_U43);
            ;
        72:
            (str = as_block_constant_U44);
            ;
        73:
            (str = as_block_constant_U45);
            ;
        74:
            (str = as_block_constant_U46);
            ;
        75:
            (str = as_block_constant_U47);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U815;
    ResponseViaActivity(response_id_U48);
];
[ call_U816;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that sentence.";
    rtrue;
];
[ call_U817;
    ResponseViaActivity(response_id_U49);
];
[ call_U818;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to ";
    rtrue;
];
[ call_U819;
    ResponseViaActivity(response_id_U50);
];
[ call_U820;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to (go) ";
    rtrue;
];
[ call_U821;
    ResponseViaActivity(response_id_U51);
];
[ call_U822;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that number.";
    rtrue;
];
[ call_U823;
    ResponseViaActivity(response_id_U52);
];
[ call_U824;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see any such thing.";
    rtrue;
];
[ call_U825;
    ResponseViaActivity(response_id_U53);
];
[ call_U826;
    (say__p = 1);
    ParaContent();
    print "You seem to have said too little!";
    rtrue;
];
[ call_U827;
    ResponseViaActivity(response_id_U54);
];
[ call_U828;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding that!";
    rtrue;
];
[ call_U829;
    ResponseViaActivity(response_id_U55);
];
[ call_U830;
    (say__p = 1);
    ParaContent();
    print "You can't use multiple objects with that verb.";
    rtrue;
];
[ call_U831;
    ResponseViaActivity(response_id_U56);
];
[ call_U832;
    (say__p = 1);
    ParaContent();
    print "You can only use multiple objects once on a line.";
    rtrue;
];
[ call_U833;
    ResponseViaActivity(response_id_U57);
];
[ call_U834;
    (say__p = 1);
    ParaContent();
    print "I'm not sure what ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " refers to.";
    rtrue;
];
[ call_U835;
    ResponseViaActivity(response_id_U58);
];
[ call_U836;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " (";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ") at the moment.";
    rtrue;
];
[ call_U837;
    ResponseViaActivity(response_id_U59);
];
[ call_U838;
    (say__p = 1);
    ParaContent();
    print "You excepted something not included anyway!";
    rtrue;
];
[ call_U839;
    ResponseViaActivity(response_id_U60);
];
[ call_U840;
    (say__p = 1);
    ParaContent();
    print "You can only do that to something animate.";
    rtrue;
];
[ call_U841;
    ResponseViaActivity(response_id_U61);
];
[ call_U842;
    (say__p = 1);
    ParaContent();
    print "That's not a verb I ";
    if ((~~(call_U72(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "recognize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "recognise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U843;
    ResponseViaActivity(response_id_U62);
];
[ call_U844;
    (say__p = 1);
    ParaContent();
    print "That's not something you need to refer to in the course of this game.";
    rtrue;
];
[ call_U845;
    ResponseViaActivity(response_id_U63);
];
[ call_U846;
    (say__p = 1);
    ParaContent();
    print "I didn't understand the way that finished.";
    rtrue;
];
[ call_U847;
    ResponseViaActivity(response_id_U64);
];
[ call_U848;
    (say__p = 1);
    if ((~~((parsed_number == 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "None";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Only ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    .L_SayX0;
    ParaContent();
    print " of those ";
    ParaContent();
    RegardingNumber(parsed_number);
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U849;
    ResponseViaActivity(response_id_U65);
];
[ call_U850;
    (say__p = 1);
    ParaContent();
    print "That noun did not make sense in this context.";
    rtrue;
];
[ call_U851;
    ResponseViaActivity(response_id_U66);
];
[ call_U852;
    (say__p = 1);
    ParaContent();
    print "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
    rtrue;
];
[ call_U853;
    ResponseViaActivity(response_id_U67);
];
[ call_U854;
    (say__p = 1);
    ParaContent();
    print "You can't begin with a comma.";
    rtrue;
];
[ call_U855;
    ResponseViaActivity(response_id_U68);
];
[ call_U856;
    (say__p = 1);
    ParaContent();
    print "You seem to want to talk to someone, but I can't see whom.";
    rtrue;
];
[ call_U857;
    ResponseViaActivity(response_id_U69);
];
[ call_U858;
    (say__p = 1);
    ParaContent();
    print "You can't talk to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U859;
    ResponseViaActivity(response_id_U70);
];
[ call_U860;
    (say__p = 1);
    ParaContent();
    print "To talk to someone, try ~someone, hello~ or some such.";
    rtrue;
];
[ call_U861;
    ResponseViaActivity(response_id_U71);
];
[ call_U862;
    (say__p = 1);
    ParaContent();
    print "I beg your pardon?";
    rtrue;
];
[ PARSER_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U48);
            ;
        66:
            (str = as_block_constant_U49);
            ;
        67:
            (str = as_block_constant_U50);
            ;
        68:
            (str = as_block_constant_U51);
            ;
        69:
            (str = as_block_constant_U52);
            ;
        70:
            (str = as_block_constant_U53);
            ;
        71:
            (str = as_block_constant_U54);
            ;
        72:
            (str = as_block_constant_U55);
            ;
        73:
            (str = as_block_constant_U56);
            ;
        74:
            (str = as_block_constant_U57);
            ;
        75:
            (str = as_block_constant_U58);
            ;
        76:
            (str = as_block_constant_U59);
            ;
        77:
            (str = as_block_constant_U60);
            ;
        78:
            (str = as_block_constant_U61);
            ;
        79:
            (str = as_block_constant_U62);
            ;
        80:
            (str = as_block_constant_U63);
            ;
        81:
            (str = as_block_constant_U64);
            ;
        82:
            (str = as_block_constant_U65);
            ;
        83:
            (str = as_block_constant_U66);
            ;
        84:
            (str = as_block_constant_U67);
            ;
        85:
            (str = as_block_constant_U68);
            ;
        86:
            (str = as_block_constant_U69);
            ;
        87:
            (str = as_block_constant_U70);
            ;
        88:
            (str = as_block_constant_U71);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U863;
    ResponseViaActivity(response_id_U72);
];
[ call_U864;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ call_U865;
    ResponseViaActivity(response_id_U73);
];
[ call_U866;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ParaContent();
    (call_U2561)(CV_POS,I_third_person_plural_U1,story_tense);
    ParaContent();
    print " none at all available!";
    rtrue;
];
[ call_U867;
    ResponseViaActivity(response_id_U74);
];
[ call_U868;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U869;
    ResponseViaActivity(response_id_U75);
];
[ call_U870;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " contain things.";
    rtrue;
];
[ call_U871;
    ResponseViaActivity(response_id_U76);
];
[ call_U872;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U873;
    ResponseViaActivity(response_id_U77);
];
[ call_U874;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ PARSER_N_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U72);
            ;
        66:
            (str = as_block_constant_U73);
            ;
        67:
            (str = as_block_constant_U74);
            ;
        68:
            (str = as_block_constant_U75);
            ;
        69:
            (str = as_block_constant_U76);
            ;
        70:
            (str = as_block_constant_U77);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U875;
    ResponseViaActivity(response_id_U78);
];
[ call_U876;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ DARKNESS_NAME_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U78);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U877;
    ResponseViaActivity(response_id_U79);
];
[ call_U878;
    (say__p = 1);
    ParaContent();
    print "Sorry, that can't be corrected.";
    rtrue;
];
[ call_U879;
    ResponseViaActivity(response_id_U80);
];
[ call_U880;
    (say__p = 1);
    ParaContent();
    print "Think nothing of it.";
    rtrue;
];
[ call_U881;
    ResponseViaActivity(response_id_U81);
];
[ call_U882;
    (say__p = 1);
    ParaContent();
    print "~Oops~ can only correct a single word.";
    rtrue;
];
[ call_U883;
    ResponseViaActivity(response_id_U82);
];
[ call_U884;
    (say__p = 1);
    ParaContent();
    print "You can hardly repeat that.";
    rtrue;
];
[ PARSER_COMMAND_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U79);
            ;
        66:
            (str = as_block_constant_U80);
            ;
        67:
            (str = as_block_constant_U81);
            ;
        68:
            (str = as_block_constant_U82);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U885;
    ResponseViaActivity(response_id_U83);
];
[ call_U886;
    (say__p = 1);
    ParaContent();
    print "Who do you mean, ";
    rtrue;
];
[ call_U887;
    ResponseViaActivity(response_id_U84);
];
[ call_U888;
    (say__p = 1);
    ParaContent();
    print "Which do you mean, ";
    rtrue;
];
[ call_U889;
    ResponseViaActivity(response_id_U85);
];
[ call_U890;
    (say__p = 1);
    ParaContent();
    print "Sorry, you can only have one item here. Which exactly?";
    rtrue;
];
[ call_U891;
    ResponseViaActivity(response_id_U86);
];
[ call_U892;
    (say__p = 1);
    ParaContent();
    print "Whom do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U893;
    ResponseViaActivity(response_id_U87);
];
[ call_U894;
    (say__p = 1);
    ParaContent();
    print "What do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U895;
    ResponseViaActivity(response_id_U88);
];
[ call_U896;
    (say__p = 1);
    ParaContent();
    print "those things";
    rtrue;
];
[ call_U897;
    ResponseViaActivity(response_id_U89);
];
[ call_U898;
    (say__p = 1);
    ParaContent();
    print "that";
    rtrue;
];
[ call_U899;
    ResponseViaActivity(response_id_U90);
];
[ call_U900;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ PARSER_CLARIF_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U83);
            ;
        66:
            (str = as_block_constant_U84);
            ;
        67:
            (str = as_block_constant_U85);
            ;
        68:
            (str = as_block_constant_U86);
            ;
        69:
            (str = as_block_constant_U87);
            ;
        70:
            (str = as_block_constant_U88);
            ;
        71:
            (str = as_block_constant_U89);
            ;
        72:
            (str = as_block_constant_U90);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U901;
    ResponseViaActivity(response_id_U91);
];
[ call_U902;
    (say__p = 1);
    ParaContent();
    print "Please answer yes or no.";
    rtrue;
];
[ YES_OR_NO_QUESTION_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U91);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U903;
    ResponseViaActivity(response_id_U92);
];
[ call_U904;
    (say__p = 1);
    ParaContent();
    call_U175();
    rtrue;
];
[ call_U905;
    ResponseViaActivity(response_id_U93);
];
[ call_U906;
    (say__p = 1);
    ParaContent();
    call_U173();
    rtrue;
];
[ call_U907;
    ResponseViaActivity(response_id_U94);
];
[ call_U908;
    (say__p = 1);
    ParaContent();
    call_U174();
    ParaContent();
    print " former self";
    rtrue;
];
[ PRINT_PROTAGONIST_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U92);
            ;
        66:
            (str = as_block_constant_U93);
            ;
        67:
            (str = as_block_constant_U94);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U909;
    ResponseViaActivity(response_id_U95);
];
[ call_U910;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U911;
    ResponseViaActivity(response_id_U96);
];
[ call_U912;
    (say__p = 1);
    ParaContent();
    print "(";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ STANDARD_IMPLICIT_TAKING_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U95);
            ;
        66:
            (str = as_block_constant_U96);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U913;
    ResponseViaActivity(response_id_U97);
];
[ call_U914;
    (say__p = 1);
    ParaContent();
    print " You have died ";
    rtrue;
];
[ call_U915;
    ResponseViaActivity(response_id_U98);
];
[ call_U916;
    (say__p = 1);
    ParaContent();
    print " You have won ";
    rtrue;
];
[ call_U917;
    ResponseViaActivity(response_id_U99);
];
[ call_U918;
    (say__p = 1);
    ParaContent();
    print " The End ";
    rtrue;
];
[ PRINT_OBITUARY_HEADLINE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U97);
            ;
        66:
            (str = as_block_constant_U98);
            ;
        67:
            (str = as_block_constant_U99);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U919;
    ResponseViaActivity(response_id_U100);
];
[ call_U920;
    (say__p = 1);
    ParaContent();
    print "The use of ~undo~ is forbidden in this story.";
    rtrue;
];
[ call_U921;
    ResponseViaActivity(response_id_U101);
];
[ call_U922;
    (say__p = 1);
    ParaContent();
    print "You can't ~undo~ what hasn't been done!";
    rtrue;
];
[ call_U923;
    ResponseViaActivity(response_id_U102);
];
[ call_U924;
    (say__p = 1);
    ParaContent();
    print "Your interpreter does not provide ~undo~. Sorry!";
    rtrue;
];
[ call_U925;
    ResponseViaActivity(response_id_U103);
];
[ call_U926;
    (say__p = 1);
    ParaContent();
    print "~Undo~ failed. Sorry!";
    rtrue;
];
[ call_U927;
    ResponseViaActivity(response_id_U104);
];
[ call_U928;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Previous turn undone.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U929;
    ResponseViaActivity(response_id_U105);
];
[ call_U930;
    (say__p = 1);
    ParaContent();
    print "~Undo~ capacity exhausted. Sorry!";
    rtrue;
];
[ IMMEDIATELY_UNDO_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U100);
            ;
        66:
            (str = as_block_constant_U101);
            ;
        67:
            (str = as_block_constant_U102);
            ;
        68:
            (str = as_block_constant_U103);
            ;
        69:
            (str = as_block_constant_U104);
            ;
        70:
            (str = as_block_constant_U105);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U931;
    ResponseViaActivity(response_id_U106);
];
[ call_U932;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to quit? ";
    rtrue;
];
[ QUIT_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U106);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U933;
    ResponseViaActivity(response_id_U107);
];
[ call_U934;
    (say__p = 1);
    ParaContent();
    print "Save failed.";
    rtrue;
];
[ call_U935;
    ResponseViaActivity(response_id_U108);
];
[ call_U936;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ SAVE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U107);
            ;
        66:
            (str = as_block_constant_U108);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U937;
    ResponseViaActivity(response_id_U109);
];
[ call_U938;
    (say__p = 1);
    ParaContent();
    print "Restore failed.";
    rtrue;
];
[ call_U939;
    ResponseViaActivity(response_id_U110);
];
[ call_U940;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ RESTORE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U109);
            ;
        66:
            (str = as_block_constant_U110);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U941;
    ResponseViaActivity(response_id_U111);
];
[ call_U942;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to restart? ";
    rtrue;
];
[ call_U943;
    ResponseViaActivity(response_id_U112);
];
[ call_U944;
    (say__p = 1);
    ParaContent();
    print "Failed.";
    rtrue;
];
[ RESTART_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U111);
            ;
        66:
            (str = as_block_constant_U112);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U945;
    ResponseViaActivity(response_id_U113);
];
[ call_U946;
    (say__p = 1);
    ParaContent();
    print "The game file has verified as intact.";
    rtrue;
];
[ call_U947;
    ResponseViaActivity(response_id_U114);
];
[ call_U948;
    (say__p = 1);
    ParaContent();
    print "The game file did not verify as intact, and may be corrupt.";
    rtrue;
];
[ VERIFY_THE_STORY_FILE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U113);
            ;
        66:
            (str = as_block_constant_U114);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U949;
    ResponseViaActivity(response_id_U115);
];
[ call_U950;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already on.";
    rtrue;
];
[ call_U951;
    ResponseViaActivity(response_id_U116);
];
[ call_U952;
    (say__p = 1);
    ParaContent();
    print "Start of a transcript of:";
    rtrue;
];
[ call_U953;
    ResponseViaActivity(response_id_U117);
];
[ call_U954;
    (say__p = 1);
    ParaContent();
    print "Attempt to begin transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U115);
            ;
        66:
            (str = as_block_constant_U116);
            ;
        67:
            (str = as_block_constant_U117);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U955;
    ResponseViaActivity(response_id_U118);
];
[ call_U956;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already off.";
    rtrue;
];
[ call_U957;
    ResponseViaActivity(response_id_U119);
];
[ call_U958;
    (say__p = 1);
    ParaContent();
    print "^";
    ParaContent();
    print "End of transcript.";
    rtrue;
];
[ call_U959;
    ResponseViaActivity(response_id_U120);
];
[ call_U960;
    (say__p = 1);
    ParaContent();
    print "Attempt to end transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U118);
            ;
        66:
            (str = as_block_constant_U119);
            ;
        67:
            (str = as_block_constant_U120);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U961;
    ResponseViaActivity(response_id_U121);
];
[ call_U962;
    (say__p = 1);
    if ((~~((deadflag ~= 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "In that game you scored";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "You have so far scored";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    print (say__n = score);
    ParaContent();
    print " out of a possible ";
    ParaContent();
    print (say__n = MAX_SCORE);
    ParaContent();
    print ", in ";
    ParaContent();
    print (say__n = turns);
    ParaContent();
    print " turn";
    ParaContent();
    STextSubstitution();
    rtrue;
];
[ call_U963;
    ResponseViaActivity(response_id_U122);
];
[ call_U964;
    (say__p = 1);
    ParaContent();
    print ", earning you the rank of ";
    rtrue;
];
[ call_U965;
    ResponseViaActivity(response_id_U123);
];
[ call_U966;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no score in this story.";
    rtrue;
];
[ call_U967;
    ResponseViaActivity(response_id_U124);
];
[ call_U968;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone up by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U969;
    ResponseViaActivity(response_id_U125);
];
[ call_U970;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone down by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ ANNOUNCE_SCORE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U121);
            ;
        66:
            (str = as_block_constant_U122);
            ;
        67:
            (str = as_block_constant_U123);
            ;
        68:
            (str = as_block_constant_U124);
            ;
        69:
            (str = as_block_constant_U125);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U971;
    ResponseViaActivity(response_id_U126);
];
[ call_U972;
    (say__p = 1);
    ParaContent();
    print " is now in its ~superbrief~ mode, which always gives short descriptions of locations (even if you haven't been there before).";
    rtrue;
];
[ REP_PREFER_ABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U126);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U973;
    ResponseViaActivity(response_id_U127);
];
[ call_U974;
    (say__p = 1);
    ParaContent();
    print " is now in its ~verbose~ mode, which always gives long descriptions of locations (even if you've been there before).";
    rtrue;
];
[ REP_PREFER_UNABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U127);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U975;
    ResponseViaActivity(response_id_U128);
];
[ call_U976;
    (say__p = 1);
    ParaContent();
    print " is now in its ~brief~ printing mode, which gives long descriptions of places never before visited and short descriptions otherwise.";
    rtrue;
];
[ REP_PREFER_SOMETIMES_ABBR_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U128);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U977;
    ResponseViaActivity(response_id_U129);
];
[ call_U978;
    (say__p = 1);
    ParaContent();
    print "Score notification on.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U129);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U979;
    ResponseViaActivity(response_id_U130);
];
[ call_U980;
    (say__p = 1);
    ParaContent();
    print "Score notification off.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U130);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U981;
    ResponseViaActivity(response_id_U131);
];
[ call_U982;
    (say__p = 1);
    ParaContent();
    print "At the moment, ";
    rtrue;
];
[ call_U983;
    ResponseViaActivity(response_id_U132);
];
[ call_U984;
    (say__p = 1);
    ParaContent();
    print "means ";
    rtrue;
];
[ call_U985;
    ResponseViaActivity(response_id_U133);
];
[ call_U986;
    (say__p = 1);
    ParaContent();
    print "is unset";
    rtrue;
];
[ call_U987;
    ResponseViaActivity(response_id_U134);
];
[ call_U988;
    (say__p = 1);
    ParaContent();
    print "no pronouns are known to the game.";
    rtrue;
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U131);
            ;
        66:
            (str = as_block_constant_U132);
            ;
        67:
            (str = as_block_constant_U133);
            ;
        68:
            (str = as_block_constant_U134);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U989 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U989, 368, 0);
    }
    for (((tmp_0 = (call_U990)(0)),(tmp_1 = (call_U990)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U990)(tmp_1)))) {
        call_U293(tmp_0);
    }
    rfalse;
];
[ call_U990 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U991;
    if (debug_rules) {
        DB_Rule(call_U991, 369, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U992;
    if (debug_rules) {
        DB_Rule(call_U992, 370, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U14));
    rfalse;
];
[ call_U993;
    if (debug_rules) {
        DB_Rule(call_U993, 371, 0);
    }
    (last_score = score);
    rfalse;
];
[ call_U994;
    if (debug_rules) {
        DB_Rule(call_U994, 372, 0);
    }
    (say__p = 1);
    ParaContent();
    Banner();
    rfalse;
];
[ call_U995;
    if (debug_rules) {
        DB_Rule(call_U995, 373, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U996;
    if (debug_rules) {
        DB_Rule(call_U996, 374, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U18));
    rfalse;
];
[ call_U997;
    if (debug_rules) {
        DB_Rule(call_U997, 375, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U998;
    if (debug_rules) {
        DB_Rule(call_U998, 376, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U999;
    if (debug_rules) {
        DB_Rule(call_U999, 377, 0);
    }
    if ((~~((score == last_score)))) {
        NotifyTheScore();
        (last_score = score);
    }
    rfalse;
];
[ call_U1000;
    if (debug_rules) {
        DB_Rule(call_U1000, 378, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U15));
    rfalse;
];
[ call_U1001;
    if (debug_rules) {
        DB_Rule(call_U1001, 379, 0);
    }
    CarryOutActivity(V30_printing_the_player_s_obi);
    rfalse;
];
[ call_U1002;
    if (debug_rules) {
        DB_Rule(call_U1002, 380, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        PronounNotice(multiple_object_item);
    }
    rfalse;
];
[ call_U1003;
    if (debug_rules) {
        DB_Rule(call_U1003, 381, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U135);
    }
    rfalse;
];
[ call_U1004;
    ResponseViaActivity(response_id_U135);
];
[ call_U1005;
    (say__p = 1);
    ParaContent();
    PrintShortName(multiple_object_item);
    ParaContent();
    print ": ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U1006;
    if (debug_rules) {
        DB_Rule(call_U1006, 382, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U29))) {
        rtrue;
    }
    rfalse;
];
[ call_U1007;
    if (debug_rules) {
        DB_Rule(call_U1007, 383, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U30))) {
        rtrue;
    }
    rfalse;
];
[ call_U1008;
    if (debug_rules) {
        DB_Rule(call_U1008, 384, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1009;
    if (debug_rules) {
        DB_Rule(call_U1009, 385, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
    if (RulebookSucceeded()) {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
    } else {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 0);
    }
    rfalse;
];
[ call_U1010;
    if (debug_rules) {
        DB_Rule(call_U1010, 386, 0);
    }
    if ((temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 2))))))) {
        if (RulebookSucceeded()) {
            ActRulebookSucceeds(temporary_value);
        } else {
            ActRulebookFails(temporary_value);
        }
        return 2;
    }
    rfalse;
];
[ call_U1011;
    if (debug_rules) {
        DB_Rule(call_U1011, 387, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 3)))));
    rfalse;
];
[ call_U1012;
    if (debug_rules) {
        DB_Rule(call_U1012, 388, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 0))) == 1)) {
        if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U33))) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1013;
    if (debug_rules) {
        DB_Rule(call_U1013, 389, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 5))) == 0)) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
        if (RulebookSucceeded()) {
            ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
        }
    }
    rfalse;
];
[ call_U1014;
    if (debug_rules) {
        DB_Rule(call_U1014, 390, 0);
    }
    if (((((MStack-->(MstVO(rulebook_id_U21, 5))) == 1)) && (((MStack-->(MstVO(rulebook_id_U21, 1))) == 0)))) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 4)))));
    }
    rfalse;
];
[ call_U1015;
    if (debug_rules) {
        DB_Rule(call_U1015, 391, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1016;
    if (debug_rules) {
        DB_Rule(call_U1016, 392, 0);
    }
    if ((player == actor)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1017;
    if (debug_rules) {
        DB_Rule(call_U1017, 393, 0);
    }
    if ((((~~((player == actor)))) && (TestVisibility(player, actor)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1018;
    if (debug_rules) {
        DB_Rule(call_U1018, 394, 0);
    }
    if ((((noun ofclass K2_thing)) && (TestVisibility(player, noun)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1019;
    if (debug_rules) {
        DB_Rule(call_U1019, 395, 0);
    }
    if ((((second ofclass K2_thing)) && (TestVisibility(player, second)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1020;
    if (debug_rules) {
        DB_Rule(call_U1020, 396, 0);
    }
    if ((location == thedark)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1021;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((player == CarrierOf(noun))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1021, 397, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_unlikely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1021, 397, 2);
        }
    }
    rfalse;
];
[ call_U1022 tmp_0;
    if (((((tmp_0 = parameter_value),((1) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = I_entire_game_U1),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1022, 398, 0);
        }
        if ((~~(((BlkValueCompare)(GProperty(SCENE_TY, tmp_0, A_description),bc_U63) == 0)))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(SCENE_TY, (self = tmp_0), A_description));
            @pull self;
            ParaContent();
            DivideParagraphPoint();
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1022, 398, 2);
        }
    }
    rfalse;
];
[ call_U1023 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1023, 399, 0);
        }
        if (say__comp) {
            rfalse;
        }
        call_U292(tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1023, 399, 2);
        }
    }
    rfalse;
];
[ call_U1024 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1024, 400, 0);
        }
        (say__p = 1);
        ParaContent();
        LanguageNumber((say__n = listing_size));
        ParaContent();
        print " ";
        CarryOutActivity(V3_printing_the_plural_name, tmp_0);
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1024, 400, 2);
        }
    }
    rfalse;
];
[ call_U1025;
    if (debug_rules) {
        DB_Rule(call_U1025, 401, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U1026;
    if (call_U267(parameter_value)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1026, 402, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1026, 402, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1026, 402, 2);
        }
    }
    rfalse;
];
[ call_U1027;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1027, 403, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1027, 403, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1027, 403, 2);
        }
    }
    rfalse;
];
[ call_U1028;
    if ((((parameter_value ofclass K2_thing)) && (call_U261(parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1028, 404, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1028, 404, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1028, 404, 2);
        }
    }
    rfalse;
];
[ call_U1029;
    if ((((parameter_value ofclass K2_thing)) && (IndirectlyContains(actor, parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((action == ##Disrobe)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U1029, 405, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1029, 405, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1029, 405, 2);
        }
    }
    rfalse;
];
[ call_U1030;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Drop)) && ((actor == player)))) || ((((((action == ##ThrowAt)) && ((actor == player)))) || ((((((action == ##Insert)) && ((actor == player)))) || ((((action == ##PutOn)) && ((actor == player)))))))))) {
            if (debug_rules) {
                DB_Rule(call_U1030, 406, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1030, 406, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1030, 406, 2);
        }
    }
    rfalse;
];
[ call_U1031;
    if ((((action == ##Smell)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1031, 407, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1031, 407, 4);
        }
    }
    rfalse;
];
[ call_U1032;
    if ((((action == ##Listen)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1032, 408, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1032, 408, 4);
        }
    }
    rfalse;
];
[ call_U1033;
    if ((((action == ##Go)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1033, 409, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U136);
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1033, 409, 4);
        }
    }
    rfalse;
];
[ call_U1034;
    ResponseViaActivity(response_id_U136);
];
[ call_U1035;
    (say__p = 1);
    ParaContent();
    print "You'll have to say which compass direction to go in.";
    rtrue;
];
[ call_U1036;
    if (debug_rules) {
        DB_Rule(call_U1036, 410, 0);
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(as_block_constant_U137);
    rfalse;
];
[ call_U1037;
    ResponseViaActivity(response_id_U137);
];
[ call_U1038;
    (say__p = 1);
    ParaContent();
    print "> ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U1039 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1039, 411, 0);
    }
    (tmp_0 = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U52(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (tmp_0 = (tmp_0 + 1));
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_0 < 1)) {
        if (FollowRulebook(IMMEDIATELY_QUIT_R)) {
            rtrue;
        }
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U138))))));
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U52(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U1, ct_1));
                        (tmp_0 = (tmp_0 - 1));
                        if ((tmp_0 == 1)) {
                            if (call_U72(use_option_id_U3)) {
                                (say__p = 1);
                                ParaContent();
                                print ",";
                            }
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U139))))));
                        } else {
                            if ((tmp_0 == 0)) {
                                (say__p = 1);
                                ParaContent();
                                print "?";
                                ParaContent();
                                print "^";
                            } else {
                                (say__p = 1);
                                ParaContent();
                                print ", ";
                            }
                        }
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1040;
    ResponseViaActivity(response_id_U138);
];
[ call_U1041 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    print "Would you like to ";
    rtrue;
];
[ call_U1042;
    ResponseViaActivity(response_id_U139);
];
[ call_U1043 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ call_U1044 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1044, 412, 0);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U1),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U52(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (SnippetMatches(players_command, TableLookUpEntry(ct_0, table_column_id_U3, ct_1))) {
                        if (ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) {
                            if (FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U4, ct_1))) {
                                rtrue;
                            }
                        } else {
                            CarryOutActivity(TableLookUpEntry(ct_0, table_column_id_U5, ct_1));
                        }
                        RulebookSucceeds();
                        rtrue;
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = ct_0),(((LocalParking-->(1)) = ct_1),(((LocalParking-->(2)) = tmp_0),(((LocalParking-->(3)) = tmp_1),as_block_constant_U140)))));
    print "^";
    rfalse;
];
[ call_U1045;
    ResponseViaActivity(response_id_U140);
];
[ call_U1046 tmp_0 tmp_1 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    print "Please give one of the answers above.";
    rtrue;
];
[ call_U1047 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1047, 415, 0);
    }
    ((Global_Vars-->29) = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U2),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            TableBlankOutRow(ct_0, ct_1);
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1048 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U1048, 416, 0);
    }
    (tmp_0 = parameter_value);
    CarryOutActivity(V33_choosing_notable_locale_o, tmp_0);
    rfalse;
    rfalse;
];
[ call_U1049 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1049, 417, 0);
    }
    (tmp_0 = parameter_value);
    TableSort(table_data_U2, table_column_id_U7, 1);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U2),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            CarryOutActivity(V34_printing_a_locale_paragra, TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1050 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1 tmp_4 tmp_5;
    if (debug_rules) {
        DB_Rule(call_U1050, 418, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = 0);
    for (((tmp_2 = (call_U1051)(0)),(tmp_3 = (call_U1051)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1051)(tmp_3)))) {
        call_U287(tmp_2);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_2 = table_data_U2),((tmp_3 = 1),((ct_0 = tmp_2),(ct_1 = tmp_3)))):(tmp_3 <= TableRows(tmp_2)):((tmp_3)++,((ct_0 = tmp_2),(ct_1 = tmp_3)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((TableLookUpEntry(ct_0, table_column_id_U7, ct_1) > 0)) {
                call_U286(TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
            }
            (tmp_1 = (tmp_1 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_1 > 0)) {
        for (((tmp_2 = (call_U1052)(0)),(tmp_3 = (call_U1052)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1052)(tmp_3)))) {
            if (call_U291(tmp_2)) {
                call_U287(tmp_2);
            }
        }
        BeginActivity(V11_listing_nondescript_items, tmp_0);
        if (((call_U1053)() == 0)) {
            AbandonActivity(V11_listing_nondescript_items, tmp_0);
        } else {
            if ((~~(ForActivity(V11_listing_nondescript_items, tmp_0)))) {
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U141)))))));
                } else {
                    if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U142)))))));
                    } else {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U143)))))));
                    }
                }
                if (((Global_Vars-->29) > 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U144)))))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U145)))))));
                }
                (tmp_2 = 0);
                (tmp_3 = 1);
                for (((tmp_4 = (call_U1054)(0)),(tmp_5 = (call_U1054)(tmp_4))):tmp_4:((tmp_4 = tmp_5),(tmp_5 = (call_U1054)(tmp_5)))) {
                    if ((~~((HolderOf(tmp_4) == tmp_2)))) {
                        if ((tmp_2 == 0)) {
                            (tmp_2 = HolderOf(tmp_4));
                        } else {
                            (tmp_3 = 0);
                        }
                    }
                    if (call_U291(tmp_4)) {
                        call_U287(tmp_4);
                    }
                }
                (list_filter_routine = call_U1055);
                if ((((tmp_3 == 1)) && ((~~((tmp_2 == 0)))))) {
                    WriteListFrom(child(tmp_2), 2776);
                } else {
                    (say__p = 1);
                    ParaContent();
                    objectloop (tmp_4 ofclass Object && (tmp_4 ofclass Object)) {
                        if ((((tmp_4 ofclass K2_thing)) && (call_U285(tmp_4)))) {
                            give tmp_4 workflag2;
                        } else {
                            give tmp_4 ~workflag2;
                        }
                    }
                    WriteListOfMarkedObjects(((((ENGLISH_BIT + RECURSE_BIT) + PARTINV_BIT) + TERSE_BIT) + CONCEAL_BIT));
                }
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),(((LocalParking-->(6)) = tmp_4),(((LocalParking-->(7)) = tmp_5),as_block_constant_U146)))))))));
                }
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
                (list_filter_routine = 0);
            }
            EndActivity(V11_listing_nondescript_items, tmp_0);
        }
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1051 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1052 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1053 x x_ix counter;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U285(x)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1054 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U285(x)) {
            return x;
        }
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1055 reason x x_ix total counter selection best best_with;
    if ((reason >= 0)) {
        (x = reason);
        (reason = -1);
    }
    switch (reason) {
        -7:
            if ((property_loop_sign > 0)) {
                (best = MIN_NEGATIVE_NUMBER);
            } else {
                (best = MAX_POSITIVE_NUMBER);
            }
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                    if ((property_loop_sign > 0)) {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) >= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    } else {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) <= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    }
                }
            }
            return best_with;
            ;
        -6:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                    (total = REAL_NUMBER_TY_Plus(total, _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_7;
                }
                .NextOuterLoop_7;
            }
            return total;
            ;
        -5:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                    (total = (total + _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
            ;
        -4:
            (selection = -1);
            while (1) {
                (counter = 0);
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                        (counter)++;
                        if ((counter == selection)) {
                            return x;
                        }
                        jump NextOuterLoop_8;
                    }
                    .NextOuterLoop_8;
                }
                if ((((counter == 0)) || ((selection >= 0)))) {
                    rfalse;
                }
                (selection = random(counter));
            }
            -3:
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                        (counter)++;
                        jump NextOuterLoop_5;
                    }
                    .NextOuterLoop_5;
                }
                return counter;
                ;
            -2:
                if ((x_ix > 0)) {
                    (x_ix)--;
                    jump NextOuterLoop_4;
                }
                if (x) {
                    jump NextOuterLoop_4;
                }
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U294(x)))) {
                        return x;
                    }
                    .NextOuterLoop_4;
                }
                rfalse;
                ;
            -1:
                if ((((x ofclass K2_thing)) && ((((x ofclass K2_thing)) && (call_U294(x)))))) {
                    rtrue;
                }
                rfalse;
                ;
            ;
    }
];
[ call_U1056;
    ResponseViaActivity(response_id_U141);
];
[ call_U1057 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1058;
    ResponseViaActivity(response_id_U142);
];
[ call_U1059 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1060;
    ResponseViaActivity(response_id_U143);
];
[ call_U1061 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1062;
    ResponseViaActivity(response_id_U144);
];
[ call_U1063 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " also see ";
    rtrue;
];
[ call_U1064;
    ResponseViaActivity(response_id_U145);
];
[ call_U1065 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    rtrue;
];
[ call_U1066;
    ResponseViaActivity(response_id_U146);
];
[ call_U1067 tmp_0 tmp_1 tmp_2 tmp_3 tmp_4 tmp_5 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    print " here";
    rtrue;
];
[ call_U1068 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1068, 419, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = child(tmp_0));
    while ((tmp_1 ofclass K2_thing)) {
        call_U1849(tmp_1, 5);
        (tmp_1 = sibling(tmp_1));
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1069 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1069, 420, 0);
        }
        if (IndirectlyContains(tmp_0, player)) {
            call_U1849(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1069, 420, 2);
        }
    }
    rfalse;
];
[ call_U1070 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1070, 421, 0);
        }
        if (call_U267(tmp_0)) {
            call_U1849(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1070, 421, 2);
        }
    }
    rfalse;
];
[ call_U1071 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1071, 422, 0);
        }
        if (call_U279(tmp_0)) {
            call_U1849(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1071, 422, 2);
        }
    }
    rfalse;
];
[ call_U1072 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1072, 423, 0);
        }
        if ((~~(call_U291(tmp_0)))) {
            PronounNotice(tmp_0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1072, 423, 2);
        }
    }
    rfalse;
];
[ call_U1073 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1073, 424, 0);
        }
        if ((~~(call_U291(tmp_0)))) {
            if (say__p) {
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
            CarryOutActivity(V10_writing_a_paragraph_about, tmp_0);
            if (say__p) {
                ((Global_Vars-->29) = ((Global_Vars-->29) + 1));
                call_U292(tmp_0);
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1073, 424, 2);
        }
    }
    rfalse;
];
[ call_U1074 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1074, 425, 0);
        }
        if ((~~(call_U291(tmp_0)))) {
            if (((ProvidesProperty(OBJECT_TY, tmp_0, A_initial)) && ((((~~(call_U276(tmp_0)))) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_0, A_initial),bc_U64) == 0)))))))) {
                ((Global_Vars-->29) = ((Global_Vars-->29) + 1));
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_0), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
                if (call_U1075(tmp_0)) {
                    for (((tmp_1 = (call_U1076)(tmp_0,0)),(tmp_2 = (call_U1076)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1076)(tmp_0,tmp_2)))) {
                        call_U286(tmp_1);
                        if (call_U291(tmp_1)) {
                            call_U287(tmp_1);
                        }
                    }
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U147))));
                    WriteListFrom(child(tmp_0), 3800);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                }
                call_U292(tmp_0);
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1074, 425, 2);
        }
    }
    rfalse;
];
[ call_U1075 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U230(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1076 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1077;
    ResponseViaActivity(response_id_U147);
];
[ call_U1078 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1079 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K6_supporter)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1079, 426, 0);
        }
        for (((tmp_1 = (call_U1080)(tmp_0,tmp_0,tmp_0,0)),(tmp_2 = (call_U1080)(tmp_0,tmp_0,tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1080)(tmp_0,tmp_0,tmp_0,tmp_2)))) {
            if ((((~~((tmp_1 ofclass K8_person)))) && ((((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_1, A_initial),bc_U65) == 0)))) && ((~~(call_U279(tmp_1)))))))) {
                call_U292(tmp_1);
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_1), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1079, 426, 2);
        }
    }
    rfalse;
];
[ call_U1080 const_0 const_1 const_2 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_2) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && ((((~~(call_U276(x)))) && ((((const_0 ofclass K6_supporter)) && (ProvidesProperty(OBJECT_TY, const_1, A_initial)))))))) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1081 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1081, 428, 0);
        }
        if (((call_U267(tmp_0)) && ((~~(IndirectlyContains(tmp_0, player)))))) {
            if (call_U1082(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1083)(tmp_0,0)),(tmp_2 = (call_U1083)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1083)(tmp_0,tmp_2)))) {
                    call_U286(tmp_1);
                    if (call_U291(tmp_1)) {
                        call_U287(tmp_1);
                    }
                }
                ((Global_Vars-->29) = ((Global_Vars-->29) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U148))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1081, 428, 2);
        }
    }
    rfalse;
];
[ call_U1082 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U230(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1083 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1084;
    ResponseViaActivity(response_id_U148);
];
[ call_U1085 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1086 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1086, 429, 0);
        }
        if (((call_U291(tmp_0)) && ((((~~(call_U279(tmp_0)))) && ((((~~(call_U267(tmp_0)))) && ((~~(IndirectlyContains(tmp_0, player)))))))))) {
            if (call_U1087(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1088)(tmp_0,0)),(tmp_2 = (call_U1088)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1088)(tmp_0,tmp_2)))) {
                    call_U286(tmp_1);
                    if (call_U291(tmp_1)) {
                        call_U287(tmp_1);
                    }
                }
                ((Global_Vars-->29) = ((Global_Vars-->29) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U149))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1086, 429, 2);
        }
    }
    rfalse;
];
[ call_U1087 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U230(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1088 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1089;
    ResponseViaActivity(response_id_U149);
];
[ call_U1090 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1091;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1091, 430, 0);
        }
        if ((child(player) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U150);
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1091, 430, 3);
        }
    }
    rfalse;
];
[ call_U1092;
    ResponseViaActivity(response_id_U150);
];
[ call_U1093;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying nothing.";
    rtrue;
];
[ call_U1094;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1094, 431, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U151);
        WriteListFrom(child(player), 8215);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1094, 431, 3);
        }
    }
    rfalse;
];
[ call_U1095;
    ResponseViaActivity(response_id_U151);
];
[ call_U1096;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying:";
    ParaContent();
    print "^";
    rtrue;
];
[ call_U1097;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1097, 432, 0);
        }
        if ((((~~((actor == player)))) && ((keep_silent == 0)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U152);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1097, 432, 2);
        }
    }
    rfalse;
];
[ call_U1098;
    ResponseViaActivity(response_id_U152);
];
[ call_U1099;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    call_U186();
    ParaContent();
    print " possessions.";
    rtrue;
];
[ call_U1100;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1100, 433, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U153);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1100, 433, 2);
        }
    }
    rfalse;
];
[ call_U1101;
    ResponseViaActivity(response_id_U153);
];
[ call_U1102;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " always self-possessed.";
    rtrue;
];
[ call_U1103;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1103, 434, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U154);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1103, 434, 2);
        }
    }
    rfalse;
];
[ call_U1104;
    ResponseViaActivity(response_id_U154);
];
[ call_U1105;
    (say__p = 1);
    ParaContent();
    print "I don't suppose ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb11);
    (say__p = 1);
    ParaContent();
    print " for that.";
    rtrue;
];
[ call_U1106 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1106, 435, 0);
        }
        if ((((PartOf(noun) ofclass K2_thing)) && (((tmp_0 = PartOf(noun)),1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U155));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1106, 435, 2);
        }
    }
    rfalse;
];
[ call_U1107;
    ResponseViaActivity(response_id_U155);
];
[ call_U1108 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be a part of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1109 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1109, 436, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        (tmp_1 = CoreOfParentOfCoreOf(noun));
        while ((((~~((tmp_1 == 0)))) && ((~~((tmp_1 == tmp_0)))))) {
            if ((tmp_1 ofclass K8_person)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U156)));
                    print "^";
                }
                rtrue;
            }
            (tmp_1 = CoreOfParentOfCoreOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1109, 436, 2);
        }
    }
    rfalse;
];
[ call_U1110;
    ResponseViaActivity(response_id_U156);
];
[ call_U1111 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1112 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1112, 437, 0);
        }
        (tmp_0 = noun);
        while ((((~~((tmp_0 == 0)))) && ((~~((tmp_0 ofclass K1_room)))))) {
            (tmp_0 = CoreOfParentOfCoreOf(tmp_0));
        }
        if ((tmp_0 == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U157));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1112, 437, 2);
        }
    }
    rfalse;
];
[ call_U1113;
    ResponseViaActivity(response_id_U157);
];
[ call_U1114 tmp_0;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U1115 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1115, 438, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U158));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1115, 438, 2);
        }
    }
    rfalse;
];
[ call_U1116;
    ResponseViaActivity(response_id_U158);
];
[ call_U1117 tmp_0;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get ";
    if ((~~((noun ofclass K6_supporter)))) {
        jump L_Say0;
    }
    ParaContent();
    print "off";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "out of";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1118;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1118, 439, 0);
        }
        if ((((actor == CarrierOf(noun))) || ((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U159);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1118, 439, 2);
        }
    }
    rfalse;
];
[ call_U1119;
    ResponseViaActivity(response_id_U159);
];
[ call_U1120;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " already ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1121;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1121, 440, 0);
        }
        if (call_U267(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U160);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1121, 440, 2);
        }
    }
    rfalse;
];
[ call_U1122;
    ResponseViaActivity(response_id_U160);
];
[ call_U1123;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " hardly portable.";
    rtrue;
];
[ call_U1124;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1124, 441, 0);
        }
        if ((~~((noun ofclass K2_thing)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U161);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1124, 441, 2);
        }
    }
    rfalse;
];
[ call_U1125;
    ResponseViaActivity(response_id_U161);
];
[ call_U1126;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carry ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1127;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1127, 442, 0);
        }
        if (call_U261(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U162);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1127, 442, 2);
        }
    }
    rfalse;
];
[ call_U1128;
    ResponseViaActivity(response_id_U162);
];
[ call_U1129;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1130 tmp_0 tmp_1 tmp_2 tmp_3;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1130, 443, 0);
        }
        if (((call_U1131)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if (((((call_U1132()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
                (tmp_1 = 0);
                for (((tmp_2 = (call_U1133)(0)),(tmp_3 = (call_U1133)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1133)(tmp_3)))) {
                    if ((((~~(call_U249(tmp_2)))) && ((~~((tmp_2 == tmp_0)))))) {
                        (tmp_1 = tmp_2);
                    }
                }
                if ((~~((tmp_1 == 0)))) {
                    if ((actor == player)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),as_block_constant_U163)))));
                    }
                    @push keep_silent;
                    (keep_silent = 1);
                    @push say__p;
                    @push say__pc;
                    ClearParagraphing(1);
                    TryAction(0, actor, ##Insert, tmp_1, tmp_0);
                    DivideParagraphPoint();
                    @pull say__pc;
                    @pull say__p;
                    AdjustParagraphPoint();
                    @pull keep_silent;
                    if ((~~((tmp_0 == ContainerOf(tmp_1))))) {
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1130, 443, 2);
        }
    }
    rfalse;
];
[ call_U1131 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1132 x x_ix;
    for ((x = 0):0:) {
        if ((actor == HolderOf(x))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1133 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1134;
    ResponseViaActivity(response_id_U163);
];
[ call_U1135 tmp_1 tmp_0 tmp_2 tmp_3;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (say__p = 1);
    ParaContent();
    print "(putting ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " to make room)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1136;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1136, 444, 0);
        }
        if (((call_U1137)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U164);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1136, 444, 2);
        }
    }
    rfalse;
];
[ call_U1137 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1138;
    ResponseViaActivity(response_id_U164);
];
[ call_U1139;
    (say__p = 1);
    ParaContent();
    call_U175();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1140;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1140, 445, 0);
        }
        MoveObject(noun, actor);
        if ((actor == player)) {
            call_U277(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1140, 445, 2);
        }
    }
    rfalse;
];
[ call_U1141;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1141, 446, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U165);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U166);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1141, 446, 2);
        }
    }
    rfalse;
];
[ call_U1142;
    ResponseViaActivity(response_id_U165);
];
[ call_U1143;
    (say__p = 1);
    ParaContent();
    print "Taken.";
    rtrue;
];
[ call_U1144;
    ResponseViaActivity(response_id_U166);
];
[ call_U1145;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb12(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1146;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1146, 447, 0);
        }
        if ((~~((HolderOf(noun) == second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U167);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1146, 447, 2);
        }
    }
    rfalse;
];
[ call_U1147;
    ResponseViaActivity(response_id_U167);
];
[ call_U1148;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U184();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " there now.";
    rtrue;
];
[ call_U1149 tmp_0;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1149, 448, 0);
        }
        (tmp_0 = HolderOf(noun));
        if ((tmp_0 ofclass K8_person)) {
            if ((tmp_0 == actor)) {
                return GVS_Convert(##Disrobe, noun, 0);
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U168));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1149, 448, 2);
        }
    }
    rfalse;
];
[ call_U1150;
    ResponseViaActivity(response_id_U168);
];
[ call_U1151 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1152;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1152, 449, 0);
        }
        return GVS_Convert(##Take, noun, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1152, 449, 2);
        }
    }
    rfalse;
];
[ call_U1153;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1153, 450, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U169);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1153, 450, 2);
        }
    }
    rfalse;
];
[ call_U1154;
    ResponseViaActivity(response_id_U169);
];
[ call_U1155;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the dexterity.";
    rtrue;
];
[ call_U1156;
    if ((((act_requester == 0)) && ((((noun ofclass K2_thing)) && ((actor == PartOf(noun))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1156, 451, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U170);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1156, 451, 2);
        }
    }
    rfalse;
];
[ call_U1157;
    ResponseViaActivity(response_id_U170);
];
[ call_U1158;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb14);
    (say__p = 1);
    ParaContent();
    print " part of ";
    ParaContent();
    call_U173();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1159;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1159, 452, 0);
        }
        if ((HolderOf(actor) == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U171);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1159, 452, 2);
        }
    }
    rfalse;
];
[ call_U1160;
    ResponseViaActivity(response_id_U171);
];
[ call_U1161;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already here.";
    rtrue;
];
[ call_U1162;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1162, 453, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U172);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1162, 453, 2);
        }
    }
    rfalse;
];
[ call_U1163;
    ResponseViaActivity(response_id_U172);
];
[ call_U1164;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb15(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " got ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1165;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1165, 454, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U173);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1165, 454, 2);
        }
    }
    rfalse;
];
[ call_U1166;
    ResponseViaActivity(response_id_U173);
];
[ call_U1167;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1168 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1168, 455, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 ofclass K1_room)) {
            rfalse;
        }
        if (ProvidesProperty(OBJECT_TY, tmp_0, A_capacity)) {
            if ((tmp_0 ofclass K6_supporter)) {
                if (((call_U1169)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U174));
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((tmp_0 ofclass K5_container)) {
                    if (((call_U1170)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U175));
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1168, 455, 2);
        }
    }
    rfalse;
];
[ call_U1169 const_0 x x_ix counter;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1170 const_0 x x_ix counter;
    for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1171;
    ResponseViaActivity(response_id_U174);
];
[ call_U1172 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1173;
    ResponseViaActivity(response_id_U175);
];
[ call_U1174 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1175;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1175, 456, 0);
        }
        MoveObject(noun, HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1175, 456, 2);
        }
    }
    rfalse;
];
[ call_U1176;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1176, 457, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U176);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U177);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1176, 457, 2);
        }
    }
    rfalse;
];
[ call_U1177;
    ResponseViaActivity(response_id_U176);
];
[ call_U1178;
    (say__p = 1);
    ParaContent();
    print "Dropped.";
    rtrue;
];
[ call_U1179;
    ResponseViaActivity(response_id_U177);
];
[ call_U1180;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1181;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1181, 458, 0);
        }
        if ((((second == I_down_U1)) || ((second == SupporterOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1181, 458, 2);
        }
    }
    rfalse;
];
[ call_U1182;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1182, 459, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1182, 459, 2);
        }
    }
    rfalse;
];
[ call_U1183 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1183, 460, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U178))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1183, 460, 2);
        }
    }
    rfalse;
];
[ call_U1184;
    ResponseViaActivity(response_id_U178);
];
[ call_U1185 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something on top of itself.";
    rtrue;
];
[ call_U1186;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1186, 461, 0);
        }
        if ((~~((second ofclass K6_supporter)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U179);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1186, 461, 2);
        }
    }
    rfalse;
];
[ call_U1187;
    ResponseViaActivity(response_id_U179);
];
[ call_U1188;
    (say__p = 1);
    ParaContent();
    print "Putting things on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing.";
    rtrue;
];
[ call_U1189;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1189, 462, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U180);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1189, 462, 2);
        }
    }
    rfalse;
];
[ call_U1190;
    ResponseViaActivity(response_id_U180);
];
[ call_U1191;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U188();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1192;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1192, 463, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1193)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U181);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1192, 463, 2);
        }
    }
    rfalse;
];
[ call_U1193 x x_ix counter;
    objectloop (x in second) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1194;
    ResponseViaActivity(response_id_U181);
];
[ call_U1195;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1196;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1196, 464, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1196, 464, 2);
        }
    }
    rfalse;
];
[ call_U1197;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1197, 465, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U182);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1197, 465, 2);
        }
    }
    rfalse;
];
[ call_U1198;
    ResponseViaActivity(response_id_U182);
];
[ call_U1199;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1200;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1200, 466, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U183);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1200, 466, 2);
        }
    }
    rfalse;
];
[ call_U1201;
    ResponseViaActivity(response_id_U183);
];
[ call_U1202;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1203;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1203, 467, 0);
        }
        if ((((second == I_down_U1)) || ((second == ContainerOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1203, 467, 2);
        }
    }
    rfalse;
];
[ call_U1204;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1204, 468, 0);
        }
        if ((second == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U184);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1204, 468, 2);
        }
    }
    rfalse;
];
[ call_U1205;
    ResponseViaActivity(response_id_U184);
];
[ call_U1206;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already there.";
    rtrue;
];
[ call_U1207 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1207, 469, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U185))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1207, 469, 2);
        }
    }
    rfalse;
];
[ call_U1208;
    ResponseViaActivity(response_id_U185);
];
[ call_U1209 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something inside itself.";
    rtrue;
];
[ call_U1210;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1210, 470, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1210, 470, 2);
        }
    }
    rfalse;
];
[ call_U1211;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1211, 471, 0);
        }
        if ((((second ofclass K5_container)) && (call_U309(second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U186);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1211, 471, 2);
        }
    }
    rfalse;
];
[ call_U1212;
    ResponseViaActivity(response_id_U186);
];
[ call_U1213;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1214;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1214, 472, 0);
        }
        if ((~~((second ofclass K5_container)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U187);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1214, 472, 2);
        }
    }
    rfalse;
];
[ call_U1215;
    ResponseViaActivity(response_id_U187);
];
[ call_U1216;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb18);
    (say__p = 1);
    ParaContent();
    print " things.";
    rtrue;
];
[ call_U1217;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1217, 473, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U188);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1217, 473, 2);
        }
    }
    rfalse;
];
[ call_U1218;
    ResponseViaActivity(response_id_U188);
];
[ call_U1219;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U188();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1220;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1220, 474, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1221)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (prior_named_noun = 0);
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U189);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1220, 474, 2);
        }
    }
    rfalse;
];
[ call_U1221 x x_ix counter;
    for ((x = TestContainmentRange(second)):x:(x = TestContainmentRange(second, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1222;
    ResponseViaActivity(response_id_U189);
];
[ call_U1223;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1224;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1224, 475, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1224, 475, 2);
        }
    }
    rfalse;
];
[ call_U1225;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1225, 476, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U190);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1225, 476, 2);
        }
    }
    rfalse;
];
[ call_U1226;
    ResponseViaActivity(response_id_U190);
];
[ call_U1227;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1228;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1228, 477, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U191);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1228, 477, 2);
        }
    }
    rfalse;
];
[ call_U1229;
    ResponseViaActivity(response_id_U191);
];
[ call_U1230;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1231;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1231, 478, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U255(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U192);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1231, 478, 2);
        }
    }
    rfalse;
];
[ call_U1232;
    ResponseViaActivity(response_id_U192);
];
[ call_U1233;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " plainly inedible.";
    rtrue;
];
[ call_U1234;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1234, 479, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U193);
            }
            TryAction(0, actor, ##Disrobe, noun, 0);
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1234, 479, 2);
        }
    }
    rfalse;
];
[ call_U1235;
    ResponseViaActivity(response_id_U193);
];
[ call_U1236;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1237 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1237, 480, 0);
        }
        if ((((~~((actor == HolderOf(noun))))) && (call_U1238()))) {
            (tmp_0 = HolderOf(noun));
            while ((~~((tmp_0 ofclass K8_person)))) {
                (tmp_0 = HolderOf(tmp_0));
            }
            if ((~~((tmp_0 == actor)))) {
                if ((((actor == player)) && ((keep_silent == 0)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U194));
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1237, 480, 2);
        }
    }
    rfalse;
];
[ call_U1238 x x_ix;
    for ((x = K8_person_First):x:(x = (x.K8_person_Next))) {
        if (IndirectlyContains(x, noun)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1239;
    ResponseViaActivity(response_id_U194);
];
[ call_U1240 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    CDefArt(tmp_0);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb20);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1241;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1241, 481, 0);
        }
        if (((call_U264(noun)) && ((~~((actor == CarrierOf(noun))))))) {
            CarryOutActivity(V28_implicitly_taking, noun);
            if ((~~((actor == CarrierOf(noun))))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1241, 481, 2);
        }
    }
    rfalse;
];
[ call_U1242;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1242, 482, 0);
        }
        RemoveFromPlay(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1242, 482, 2);
        }
    }
    rfalse;
];
[ call_U1243;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1243, 483, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U195);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U196);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1243, 483, 2);
        }
    }
    rfalse;
];
[ call_U1244;
    ResponseViaActivity(response_id_U195);
];
[ call_U1245;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ". Not bad.";
    rtrue;
];
[ call_U1246;
    ResponseViaActivity(response_id_U196);
];
[ call_U1247;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1248 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U1());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U1 tmp_0 tmp_1 tmp_2;
    if ((action == ##Go)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1248, 484, 0);
        }
        ((MStack-->(MstVO(var_id_U42, 4))) = move_pushing);
        ((MStack-->(MstVO(var_id_U42, 0))) = LocationOf(actor));
        if ((((ContainerOf(actor) ofclass K14_vehicle)) && (((call_U297(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            ((MStack-->(MstVO(var_id_U42, 3))) = tmp_0);
        }
        (tmp_1 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_2 = noun);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1815, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_2))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_1 = noun);
            }
        }
        if ((tmp_1 ofclass K4_door)) {
            ((MStack-->(MstVO(var_id_U42, 2))) = tmp_1);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1820, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_1);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1248, 484, 2);
        }
    }
    rfalse;
];
[ call_U1249 tmp_0;
    if ((((act_requester == 0)) && (((((self = actor),1)) && ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1249, 485, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U197));
        }
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1249, 485, 2);
        }
    }
    rfalse;
];
[ call_U1250;
    ResponseViaActivity(response_id_U197);
];
[ call_U1251 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "(first getting off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1252 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1252, 486, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 0))))) {
            rfalse;
        }
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 3))))) {
            rfalse;
        }
        if ((actor == player)) {
            if ((tmp_0 ofclass K6_supporter)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U198));
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U199));
                print "^";
            }
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1252, 486, 2);
        }
    }
    rfalse;
];
[ call_U1253;
    ResponseViaActivity(response_id_U198);
];
[ call_U1254 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1255;
    ResponseViaActivity(response_id_U199);
];
[ call_U1256 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get out of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1257;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1257, 487, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U279((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U200);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1257, 487, 2);
        }
    }
    rfalse;
];
[ call_U1258;
    ResponseViaActivity(response_id_U200);
];
[ call_U1259;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1260;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1260, 488, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U309((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U201);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Open, (MStack-->(MstVO(var_id_U42, 2))), 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if (call_U306((MStack-->(MstVO(var_id_U42, 2))))) {
                rfalse;
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1260, 488, 2);
        }
    }
    rfalse;
];
[ call_U1261;
    ResponseViaActivity(response_id_U201);
];
[ call_U1262;
    (say__p = 1);
    ParaContent();
    print "(first opening ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1263 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U2());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U2 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1263, 489, 0);
        }
        (tmp_0 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_1 = noun);
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1858, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_0 = noun);
            }
        }
        if ((tmp_0 ofclass K4_door)) {
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1862, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_0))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1263, 489, 2);
        }
    }
    rfalse;
];
[ call_U1264;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1264, 490, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 1))) == 0)) {
            if (((MStack-->(MstVO(var_id_U42, 2))) == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U202);
                    print "^";
                }
                rtrue;
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U203);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1264, 490, 2);
        }
    }
    rfalse;
];
[ call_U1265;
    ResponseViaActivity(response_id_U202);
];
[ call_U1266;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1267;
    ResponseViaActivity(response_id_U203);
];
[ call_U1268;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", since ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print " ";
    ConjugateVerb23(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nowhere.";
    rtrue;
];
[ call_U1269;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1269, 491, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 3))) == 0)) {
            MoveDuringGoing(actor, (MStack-->(MstVO(var_id_U42, 1))));
        } else {
            MoveDuringGoing((MStack-->(MstVO(var_id_U42, 3))), (MStack-->(MstVO(var_id_U42, 1))));
        }
        if ((~~((real_location == LocationOf(player))))) {
            (real_location = LocationOf(player));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1269, 491, 2);
        }
    }
    rfalse;
];
[ call_U1270;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1270, 492, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            MoveFloatingObjects();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1270, 492, 2);
        }
    }
    rfalse;
];
[ call_U1271;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1271, 493, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            SilentlyConsiderLight();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1271, 493, 2);
        }
    }
    rfalse;
];
[ call_U1272 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U3());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U3 tmp_0 tmp_1 tmp_2;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1272, 494, 0);
        }
        if ((player == actor)) {
            if ((keep_silent == 0)) {
                LookAfterGoing();
            }
        } else {
            if ((noun ofclass K3_direction)) {
                if ((((real_location == (MStack-->(MstVO(var_id_U42, 0))))) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                    if (((MStack-->(MstVO(var_id_U42, 0))) == (MStack-->(MstVO(var_id_U42, 1))))) {
                        rfalse;
                    } else {
                        if ((noun == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U204);
                        } else {
                            if ((noun == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U205);
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U206);
                            }
                        }
                    }
                } else {
                    (tmp_0 = GProperty(OBJECT_TY, noun, A_P_opposite));
                    if ((real_location == (MStack-->(MstVO(var_id_U42, 1))))) {
                        (tmp_1 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1913, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = real_location) + (formal_par0 = tmp_0))))
                        )
                        );
                        (tmp_2 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1915, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = noun))))
                        )
                        );
                        if ((((tmp_1 == (MStack-->(MstVO(var_id_U42, 0))))) || ((tmp_1 == tmp_2)))) {
                            if ((tmp_0 == I_up_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U207))));
                            } else {
                                if ((tmp_0 == I_down_U1)) {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U208))));
                                } else {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U209))));
                                }
                            }
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U210))));
                        }
                    } else {
                        if ((tmp_0 == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U211))));
                        } else {
                            if ((tmp_0 == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U212))));
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U213))));
                            }
                        }
                    }
                }
            } else {
                if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U214))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U215))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 3))) == 0)))) {
                (say__p = 1);
                ParaContent();
                print " ";
                if (((MStack-->(MstVO(var_id_U42, 3))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U216))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U217))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 4))) == 0)))) {
                if (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U218))));
                } else {
                    if (((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U219))));
                    } else {
                        if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U220))));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U221))));
                        }
                    }
                }
            }
            if (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) && ((~~(((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U222))));
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                TryAction(0, player, ##Look, 0, 0);
                rfalse;
            }
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1272, 494, 2);
        }
    }
    rfalse;
];
[ call_U1273;
    ResponseViaActivity(response_id_U204);
];
[ call_U1274;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up";
    rtrue;
];
[ call_U1275;
    ResponseViaActivity(response_id_U205);
];
[ call_U1276;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down";
    rtrue;
];
[ call_U1277;
    ResponseViaActivity(response_id_U206);
];
[ call_U1278;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    PrintShortName(noun);
    rtrue;
];
[ call_U1279;
    ResponseViaActivity(response_id_U207);
];
[ call_U1280 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1281;
    ResponseViaActivity(response_id_U208);
];
[ call_U1282 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1283;
    ResponseViaActivity(response_id_U209);
];
[ call_U1284 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1285;
    ResponseViaActivity(response_id_U210);
];
[ call_U1286 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U1287;
    ResponseViaActivity(response_id_U211);
];
[ call_U1288 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1289;
    ResponseViaActivity(response_id_U212);
];
[ call_U1290 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1291;
    ResponseViaActivity(response_id_U213);
];
[ call_U1292 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1293;
    ResponseViaActivity(response_id_U214);
];
[ call_U1294 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1295;
    ResponseViaActivity(response_id_U215);
];
[ call_U1296 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1297;
    ResponseViaActivity(response_id_U216);
];
[ call_U1298 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print "on ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1299;
    ResponseViaActivity(response_id_U217);
];
[ call_U1300 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print "in ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1301;
    ResponseViaActivity(response_id_U218);
];
[ call_U1302 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front, and ";
    ParaContent();
    call_U171();
    ParaContent();
    print " along too";
    rtrue;
];
[ call_U1303;
    ResponseViaActivity(response_id_U219);
];
[ call_U1304 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front";
    rtrue;
];
[ call_U1305;
    ResponseViaActivity(response_id_U220);
];
[ call_U1306 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " away";
    rtrue;
];
[ call_U1307;
    ResponseViaActivity(response_id_U221);
];
[ call_U1308 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in";
    rtrue;
];
[ call_U1309;
    ResponseViaActivity(response_id_U222);
];
[ call_U1310 tmp_0 tmp_1 tmp_2;
    (say__p = 1);
    ParaContent();
    print ", taking ";
    ParaContent();
    call_U171();
    ParaContent();
    print " along";
    rtrue;
];
[ call_U1311 tmp_0;
    if ((((action == ##Enter)) && ((actor == player)))) {
        if (debug_rules) {
            DB_Rule(call_U1311, 495, 0);
        }
        if (((((call_U1312()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
            (noun = tmp_0);
        } else {
            rfalse;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1311, 495, 4);
        }
    }
    rfalse;
];
[ call_U1312 x x_ix;
    for ((x = TestContainmentRange(real_location)):x:(x = TestContainmentRange(real_location, x))) {
        if ((((x ofclass K2_thing)) && (call_U297(x)))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1313;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1313, 496, 0);
        }
        if ((noun ofclass K4_door)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1313, 496, 2);
        }
    }
    rfalse;
];
[ call_U1314;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1314, 497, 0);
        }
        if ((noun ofclass K3_direction)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1314, 497, 2);
        }
    }
    rfalse;
];
[ call_U1315 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1315, 498, 0);
        }
        if ((actor == noun)) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((player == actor)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U223));
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U224));
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1315, 498, 2);
        }
    }
    rfalse;
];
[ call_U1316;
    ResponseViaActivity(response_id_U223);
];
[ call_U1317 tmp_0;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U170();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1318;
    ResponseViaActivity(response_id_U224);
];
[ call_U1319 tmp_0;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U170();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1320;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1320, 499, 0);
        }
        if ((~~(call_U297(noun)))) {
            if ((player == actor)) {
                if ((matched_text = SnippetIncludes(Consult_Grammar6, players_command))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U225);
                    print "^";
                } else {
                    if ((matched_text = SnippetIncludes(Consult_Grammar7, players_command))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U226);
                        print "^";
                    } else {
                        if ((matched_text = SnippetIncludes(Consult_Grammar8, players_command))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U227);
                            print "^";
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U228);
                            print "^";
                        }
                    }
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1320, 499, 2);
        }
    }
    rfalse;
];
[ call_U1321;
    ResponseViaActivity(response_id_U225);
];
[ call_U1322;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " stand on.";
    rtrue;
];
[ call_U1323;
    ResponseViaActivity(response_id_U226);
];
[ call_U1324;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " sit down on.";
    rtrue;
];
[ call_U1325;
    ResponseViaActivity(response_id_U227);
];
[ call_U1326;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lie down on.";
    rtrue;
];
[ call_U1327;
    ResponseViaActivity(response_id_U228);
];
[ call_U1328;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " enter.";
    rtrue;
];
[ call_U1329;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1329, 500, 0);
        }
        if ((((noun ofclass K5_container)) && (call_U309(noun)))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U229);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1329, 500, 2);
        }
    }
    rfalse;
];
[ call_U1330;
    ResponseViaActivity(response_id_U229);
];
[ call_U1331;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb25);
    (say__p = 1);
    ParaContent();
    print " into the closed ";
    ParaContent();
    PrintShortName(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1332;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1332, 501, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_capacity)) {
            if ((noun ofclass K6_supporter)) {
                if (((call_U1333)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U230);
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((noun ofclass K5_container)) {
                    if (((call_U1334)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U231);
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1332, 501, 2);
        }
    }
    rfalse;
];
[ call_U1333 x x_ix counter;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1334 x x_ix counter;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1335;
    ResponseViaActivity(response_id_U230);
];
[ call_U1336;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1337;
    ResponseViaActivity(response_id_U231);
];
[ call_U1338;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1339 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1339, 502, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == actor)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U232));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1339, 502, 2);
        }
    }
    rfalse;
];
[ call_U1340;
    ResponseViaActivity(response_id_U232);
];
[ call_U1341 tmp_0;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " only get into something free-standing.";
    rtrue;
];
[ call_U1342 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1342, 503, 0);
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        while ((~~((HolderOf(actor) == tmp_0)))) {
            (tmp_1 = HolderOf(actor));
            if ((player == actor)) {
                if ((((tmp_1 ofclass K6_supporter)) || ((tmp_1 ofclass K12_animal)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U233)));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U234)));
                }
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Exit, 0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((HolderOf(actor) == tmp_1)) {
                rtrue;
            }
        }
        if ((HolderOf(actor) == noun)) {
            rtrue;
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_1 = HolderOf(noun));
        if ((tmp_1 == PartOf(noun))) {
            (tmp_1 = HolderOf(tmp_1));
        }
        while ((tmp_1 ofclass K2_thing)) {
            if ((HolderOf(tmp_1) == tmp_0)) {
                if ((player == actor)) {
                    if ((tmp_1 ofclass K6_supporter)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U235)));
                    } else {
                        if ((tmp_1 ofclass K5_container)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U236)));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U237)));
                        }
                    }
                }
                @push keep_silent;
                (keep_silent = 1);
                @push say__p;
                @push say__pc;
                ClearParagraphing(1);
                TryAction(0, actor, ##Enter, tmp_1, 0);
                DivideParagraphPoint();
                @pull say__pc;
                @pull say__p;
                AdjustParagraphPoint();
                @pull keep_silent;
                if ((~~((HolderOf(actor) == tmp_1)))) {
                    rtrue;
                }
                return GVS_Convert(##Enter, noun, 0);
                rfalse;
            }
            (tmp_1 = HolderOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1342, 503, 2);
        }
    }
    rfalse;
];
[ call_U1343;
    ResponseViaActivity(response_id_U233);
];
[ call_U1344 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print "(getting off ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1345;
    ResponseViaActivity(response_id_U234);
];
[ call_U1346 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print "(getting out of ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1347;
    ResponseViaActivity(response_id_U235);
];
[ call_U1348 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print "(getting onto ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1349;
    ResponseViaActivity(response_id_U236);
];
[ call_U1350 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print "(getting into ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1351;
    ResponseViaActivity(response_id_U237);
];
[ call_U1352 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print "(entering ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1353;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1353, 504, 0);
        }
        move actor to noun;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1353, 504, 2);
        }
    }
    rfalse;
];
[ call_U1354;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1354, 505, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U238);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U239);
                    print "^";
                }
            }
        } else {
            if ((noun ofclass K5_container)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U240);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U241);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1354, 505, 2);
        }
    }
    rfalse;
];
[ call_U1355;
    ResponseViaActivity(response_id_U238);
];
[ call_U1356;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1357;
    ResponseViaActivity(response_id_U239);
];
[ call_U1358;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1359;
    ResponseViaActivity(response_id_U240);
];
[ call_U1360;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1361;
    ResponseViaActivity(response_id_U241);
];
[ call_U1362;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1363;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1363, 506, 0);
        }
        if ((actor == player)) {
            call_U1848(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1363, 506, 2);
        }
    }
    rfalse;
];
[ call_U1364;
    if ((action == ##Exit)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1364, 507, 0);
        }
        ((MStack-->(MstVO(var_id_U44, 0))) = HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1364, 507, 2);
        }
    }
    rfalse;
];
[ call_U1365 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1365, 508, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((~~((RoomOrDoorFrom(tmp_0, out_obj) == 0)))) {
                return GVS_Convert(##Go, out_obj, 0);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1365, 508, 2);
        }
    }
    rfalse;
];
[ call_U1366 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1366, 509, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U242));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1366, 509, 2);
        }
    }
    rfalse;
];
[ call_U1367;
    ResponseViaActivity(response_id_U242);
];
[ call_U1368 tmp_0;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " in anything at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1369 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1369, 510, 0);
        }
        if ((((ContainerOf(actor) ofclass K5_container)) && (((call_U309(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U243));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1369, 510, 2);
        }
    }
    rfalse;
];
[ call_U1370;
    ResponseViaActivity(response_id_U243);
];
[ call_U1371 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "You can't get out of the closed ";
    ParaContent();
    PrintShortName(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1372 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1372, 511, 0);
        }
        if ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))) {
            return GVS_Convert(##GetOff, tmp_0, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1372, 511, 2);
        }
    }
    rfalse;
];
[ call_U1373 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1373, 512, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf((MStack-->(MstVO(var_id_U44, 0)))));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1373, 512, 2);
        }
    }
    rfalse;
];
[ call_U1374;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1374, 513, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                if (((MStack-->(MstVO(var_id_U44, 0))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U244);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U245);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U246);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1374, 513, 2);
        }
    }
    rfalse;
];
[ call_U1375;
    ResponseViaActivity(response_id_U244);
];
[ call_U1376;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1377;
    ResponseViaActivity(response_id_U245);
];
[ call_U1378;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1379;
    ResponseViaActivity(response_id_U246);
];
[ call_U1380;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1381;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1381, 514, 0);
        }
        if ((actor == player)) {
            SilentlyConsiderLight();
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1381, 514, 2);
        }
    }
    rfalse;
];
[ call_U1382;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1382, 515, 0);
        }
        if ((noun == SupporterOf(actor))) {
            rfalse;
        }
        if ((noun == CarrierOf(actor))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U247);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1382, 515, 2);
        }
    }
    rfalse;
];
[ call_U1383;
    ResponseViaActivity(response_id_U247);
];
[ call_U1384;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1385 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1385, 516, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf(noun));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1385, 516, 2);
        }
    }
    rfalse;
];
[ call_U1386;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1386, 517, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U248);
            print "^";
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1386, 517, 2);
        }
    }
    rfalse;
];
[ call_U1387;
    ResponseViaActivity(response_id_U248);
];
[ call_U1388;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1389;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1389, 518, 0);
        }
        if ((actor == player)) {
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1389, 518, 2);
        }
    }
    rfalse;
];
[ call_U1390;
    if ((action == ##Look)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1390, 519, 0);
        }
        if ((actor == player)) {
            FindVisibilityLevels();
        }
        ((MStack-->(MstVO(var_id_U46, 2))) = visibility_levels);
        ((MStack-->(MstVO(var_id_U46, 3))) = visibility_ceiling);
        ((MStack-->(MstVO(var_id_U46, 0))) = ##Look);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1390, 519, 2);
        }
    }
    rfalse;
];
[ call_U1391 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1391, 520, 0);
        }
        for (((tmp_0 = (call_U1392)(0)),(tmp_1 = (call_U1392)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U1392)(tmp_1)))) {
            call_U293(tmp_0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1391, 520, 3);
        }
    }
    rfalse;
];
[ call_U1392 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1393 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1393, 521, 0);
        }
        (say__p = 1);
        ParaContent();
        style bold;
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            BeginActivity(V12_printing_the_name_of_a_da);
            if ((~~(ForActivity(V12_printing_the_name_of_a_da)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U249);
            }
            EndActivity(V12_printing_the_name_of_a_da);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                (say__p = 1);
                ParaContent();
                PrintShortName((MStack-->(MstVO(var_id_U46, 3))));
            } else {
                (say__p = 1);
                ParaContent();
                CDefArt((MStack-->(MstVO(var_id_U46, 3))));
            }
        }
        (say__p = 1);
        ParaContent();
        style roman;
        (tmp_0 = VisibilityParent(actor));
        for ((tmp_1 = 2):(tmp_1 <= (MStack-->(MstVO(var_id_U46, 2)))):(tmp_1)++) {
            if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U250)));
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U251)));
            }
            (tmp_0 = VisibilityParent(tmp_0));
        }
        (say__p = 1);
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        SpecialLookSpacingBreak();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1393, 521, 3);
        }
    }
    rfalse;
];
[ call_U1394;
    ResponseViaActivity(response_id_U249);
];
[ call_U1395;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ call_U1396;
    ResponseViaActivity(response_id_U250);
];
[ call_U1397 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print " (on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1398;
    ResponseViaActivity(response_id_U251);
];
[ call_U1399 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (say__p = 1);
    ParaContent();
    print " (in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1400;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1400, 522, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            if ((lookmode == 3)) {
                rfalse;
            }
            if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (((Global_Vars-->21) == 1)))))) {
                rfalse;
            }
            BeginActivity(V13_printing_the_description_);
            if ((~~(ForActivity(V13_printing_the_description_)))) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U252);
                print "^";
            }
            EndActivity(V13_printing_the_description_);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                if ((lookmode == 3)) {
                    rfalse;
                }
                if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (call_U243(real_location)))))) {
                    rfalse;
                }
                PrintOrRun(location, A_description);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1400, 522, 3);
        }
    }
    rfalse;
];
[ call_U1401;
    ResponseViaActivity(response_id_U252);
];
[ call_U1402;
    (say__p = 1);
    ParaContent();
    call_U196();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ call_U1403 tmp_0 tmp_1 tmp_2;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1403, 523, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) > 0)) {
            (tmp_0 = actor);
            (tmp_1 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_1 > 0)) {
                call_U286(tmp_0);
                (tmp_0 = VisibilityParent(tmp_0));
                (tmp_1 = (tmp_1 - 1));
            }
            (tmp_2 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_2 > 0)) {
                (tmp_0 = actor);
                (tmp_1 = 0);
                while ((tmp_1 < tmp_2)) {
                    (tmp_0 = VisibilityParent(tmp_0));
                    (tmp_1 = (tmp_1 + 1));
                }
                call_U1848(tmp_0);
                (tmp_2 = (tmp_2 - 1));
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1403, 523, 3);
        }
    }
    rfalse;
];
[ call_U1404;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1404, 524, 0);
        }
        if ((location == thedark)) {
            ((Global_Vars-->21) = 1);
        } else {
            if ((real_location ofclass K1_room)) {
                call_U244(real_location);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1404, 524, 3);
        }
    }
    rfalse;
];
[ call_U1405;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1405, 525, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U253);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1405, 525, 2);
        }
    }
    rfalse;
];
[ call_U1406;
    ResponseViaActivity(response_id_U253);
];
[ call_U1407;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " around.";
    rtrue;
];
[ call_U1408;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1408, 526, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_description)) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, noun, A_description),bc_U66) == 0)))))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(OBJECT_TY, (self = noun), A_description));
            @pull self;
            ParaContent();
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1408, 526, 3);
        }
    }
    rfalse;
];
[ call_U1409;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1409, 527, 0);
        }
        if ((noun ofclass K3_direction)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U254);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1409, 527, 3);
        }
    }
    rfalse;
];
[ call_U1410;
    ResponseViaActivity(response_id_U254);
];
[ call_U1411;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected in that direction.";
    rtrue;
];
[ call_U1412;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1412, 528, 0);
        }
        if ((noun ofclass K5_container)) {
            if (((call_U306(noun)) || (call_U300(noun)))) {
                if (((call_U1413()) && (call_U1414()))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U255);
                    WriteListFrom(child(noun), 3144);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                    ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                } else {
                    if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
                        if ((noun == ContainerOf(player))) {
                            rfalse;
                        }
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U256);
                        print "^";
                        ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1412, 528, 3);
        }
    }
    rfalse;
];
[ call_U1413 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U282(x)))) {
            if ((~~(call_U267(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1414 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            if ((~~((x == player)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1415;
    ResponseViaActivity(response_id_U255);
];
[ call_U1416;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1417;
    ResponseViaActivity(response_id_U256);
];
[ call_U1418;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1419;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1419, 529, 0);
        }
        if ((noun ofclass K6_supporter)) {
            if (((call_U1420()) && (call_U1421()))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U257);
                WriteListFrom(child(noun), 3288);
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                ((MStack-->(MstVO(var_id_U47, 0))) = 1);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1419, 529, 3);
        }
    }
    rfalse;
];
[ call_U1420 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U282(x)))) {
                if ((~~(call_U267(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1421 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                if ((~~((x == player)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1422;
    ResponseViaActivity(response_id_U257);
];
[ call_U1423;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1424;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1424, 530, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U258);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1424, 530, 3);
        }
    }
    rfalse;
];
[ call_U1425;
    ResponseViaActivity(response_id_U258);
];
[ call_U1426;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "currently ";
    .L_Say0;
    ParaContent();
    print "switched ";
    if ((~~(call_U336(noun)))) {
        jump L_Say1;
    }
    ParaContent();
    print "on";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "off";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1427;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1427, 531, 0);
        }
        if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U259);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1427, 531, 3);
        }
    }
    rfalse;
];
[ call_U1428;
    ResponseViaActivity(response_id_U259);
];
[ call_U1429;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing special about ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1430;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1430, 532, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U260);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1430, 532, 2);
        }
    }
    rfalse;
];
[ call_U1431;
    ResponseViaActivity(response_id_U260);
];
[ call_U1432;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closely at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1433;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1433, 533, 0);
        }
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U261);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1433, 533, 2);
        }
    }
    rfalse;
];
[ call_U1434;
    ResponseViaActivity(response_id_U261);
];
[ call_U1435;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1436;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1436, 534, 0);
        }
        if ((keep_silent == 0)) {
            if ((~~((actor == player)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U262);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1436, 534, 2);
        }
    }
    rfalse;
];
[ call_U1437;
    ResponseViaActivity(response_id_U262);
];
[ call_U1438;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " under ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1439;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1439, 535, 0);
        }
        if ((((~~((noun ofclass K5_container)))) && ((~~((noun ofclass K6_supporter)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U263);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1439, 535, 2);
        }
    }
    rfalse;
];
[ call_U1440;
    ResponseViaActivity(response_id_U263);
];
[ call_U1441;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1442;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1442, 536, 0);
        }
        if ((((noun ofclass K5_container)) && (((call_U309(noun)) && (call_U303(noun)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U264);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1442, 536, 2);
        }
    }
    rfalse;
];
[ call_U1443;
    ResponseViaActivity(response_id_U264);
];
[ call_U1444;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " inside, since ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1445;
    if ((((actor == player)) && ((noun ofclass K5_container)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1445, 537, 0);
        }
        if (call_U1446()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U265);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U266);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1445, 537, 2);
        }
    }
    rfalse;
];
[ call_U1446 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U282(x)))) {
            if ((~~(call_U267(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1447;
    ResponseViaActivity(response_id_U265);
];
[ call_U1448;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1449;
    ResponseViaActivity(response_id_U266);
];
[ call_U1450;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1451;
    if ((((actor == player)) && ((noun ofclass K6_supporter)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1451, 538, 0);
        }
        if (call_U1452()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U267);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U268);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1451, 538, 2);
        }
    }
    rfalse;
];
[ call_U1452 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U282(x)))) {
                if ((~~(call_U267(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1453;
    ResponseViaActivity(response_id_U267);
];
[ call_U1454;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1455;
    ResponseViaActivity(response_id_U268);
];
[ call_U1456;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1457;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1457, 539, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U269);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1457, 539, 2);
        }
    }
    rfalse;
];
[ call_U1458;
    ResponseViaActivity(response_id_U269);
];
[ call_U1459;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb27(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1460;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1460, 540, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U270);
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U271);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1460, 540, 2);
        }
    }
    rfalse;
];
[ call_U1461;
    ResponseViaActivity(response_id_U270);
];
[ call_U1462;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb28(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1463;
    ResponseViaActivity(response_id_U271);
];
[ call_U1464;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1465;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1465, 541, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U318(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U272);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1465, 541, 2);
        }
    }
    rfalse;
];
[ call_U1466;
    ResponseViaActivity(response_id_U272);
];
[ call_U1467;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lock.";
    rtrue;
];
[ call_U1468;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1468, 542, 0);
        }
        if (call_U321(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U273);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1468, 542, 2);
        }
    }
    rfalse;
];
[ call_U1469;
    ResponseViaActivity(response_id_U273);
];
[ call_U1470;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " locked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1471;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1471, 543, 0);
        }
        if (call_U306(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U274);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1471, 543, 2);
        }
    }
    rfalse;
];
[ call_U1472;
    ResponseViaActivity(response_id_U274);
];
[ call_U1473;
    (say__p = 1);
    ParaContent();
    print "First ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to close ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1474;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1474, 544, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U275);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1474, 544, 2);
        }
    }
    rfalse;
];
[ call_U1475;
    ResponseViaActivity(response_id_U275);
];
[ call_U1476;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1477;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1477, 545, 0);
        }
        call_U322(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1477, 545, 2);
        }
    }
    rfalse;
];
[ call_U1478;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1478, 546, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U276);
                print "^";
            }
        } else {
            if (call_U215(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U277);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1478, 546, 2);
        }
    }
    rfalse;
];
[ call_U1479;
    ResponseViaActivity(response_id_U276);
];
[ call_U1480;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1481;
    ResponseViaActivity(response_id_U277);
];
[ call_U1482;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1483;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1483, 547, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U318(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U278);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1483, 547, 2);
        }
    }
    rfalse;
];
[ call_U1484;
    ResponseViaActivity(response_id_U278);
];
[ call_U1485;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unlock.";
    rtrue;
];
[ call_U1486;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1486, 548, 0);
        }
        if ((~~(call_U321(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U279);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1486, 548, 2);
        }
    }
    rfalse;
];
[ call_U1487;
    ResponseViaActivity(response_id_U279);
];
[ call_U1488;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " unlocked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1489;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1489, 549, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U280);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1489, 549, 2);
        }
    }
    rfalse;
];
[ call_U1490;
    ResponseViaActivity(response_id_U280);
];
[ call_U1491;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1492;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1492, 550, 0);
        }
        call_U323(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1492, 550, 2);
        }
    }
    rfalse;
];
[ call_U1493;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1493, 551, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U281);
                print "^";
            }
        } else {
            if (call_U215(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U282);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1493, 551, 2);
        }
    }
    rfalse;
];
[ call_U1494;
    ResponseViaActivity(response_id_U281);
];
[ call_U1495;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1496;
    ResponseViaActivity(response_id_U282);
];
[ call_U1497;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1498;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1498, 552, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U283);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1498, 552, 2);
        }
    }
    rfalse;
];
[ call_U1499;
    ResponseViaActivity(response_id_U283);
];
[ call_U1500;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1501;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1501, 553, 0);
        }
        if (call_U336(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U284);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1501, 553, 2);
        }
    }
    rfalse;
];
[ call_U1502;
    ResponseViaActivity(response_id_U284);
];
[ call_U1503;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " already on.";
    rtrue;
];
[ call_U1504;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1504, 554, 0);
        }
        call_U337(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1504, 554, 2);
        }
    }
    rfalse;
];
[ call_U1505;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1505, 555, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U285);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1505, 555, 2);
        }
    }
    rfalse;
];
[ call_U1506;
    ResponseViaActivity(response_id_U285);
];
[ call_U1507;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on.";
    rtrue;
];
[ call_U1508;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1508, 556, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U286);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1508, 556, 2);
        }
    }
    rfalse;
];
[ call_U1509;
    ResponseViaActivity(response_id_U286);
];
[ call_U1510;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1511;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1511, 557, 0);
        }
        if (call_U339(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U287);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1511, 557, 2);
        }
    }
    rfalse;
];
[ call_U1512;
    ResponseViaActivity(response_id_U287);
];
[ call_U1513;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " already off.";
    rtrue;
];
[ call_U1514;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1514, 558, 0);
        }
        call_U340(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1514, 558, 2);
        }
    }
    rfalse;
];
[ call_U1515;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1515, 559, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U288);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1515, 559, 2);
        }
    }
    rfalse;
];
[ call_U1516;
    ResponseViaActivity(response_id_U288);
];
[ call_U1517;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off.";
    rtrue;
];
[ call_U1518;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1518, 560, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U312(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U289);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1518, 560, 2);
        }
    }
    rfalse;
];
[ call_U1519;
    ResponseViaActivity(response_id_U289);
];
[ call_U1520;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U1521;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1521, 561, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U321(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U290);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1521, 561, 2);
        }
    }
    rfalse;
];
[ call_U1522;
    ResponseViaActivity(response_id_U290);
];
[ call_U1523;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be locked.";
    rtrue;
];
[ call_U1524;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1524, 562, 0);
        }
        if (call_U306(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U291);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1524, 562, 2);
        }
    }
    rfalse;
];
[ call_U1525;
    ResponseViaActivity(response_id_U291);
];
[ call_U1526;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " already open.";
    rtrue;
];
[ call_U1527;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1527, 563, 0);
        }
        call_U307(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1527, 563, 2);
        }
    }
    rfalse;
];
[ call_U1528;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1528, 564, 0);
        }
        if ((((actor == player)) && ((((((noun ofclass K5_container)) && (call_U303(noun)))) && ((((~~((child(noun) == 0)))) && ((~~(IndirectlyContains(noun, actor)))))))))) {
            if ((keep_silent == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U292);
                    WriteListFrom(child(noun), 2120);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1528, 564, 2);
        }
    }
    rfalse;
];
[ call_U1529;
    ResponseViaActivity(response_id_U292);
];
[ call_U1530;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ", revealing ";
    rtrue;
];
[ call_U1531;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1531, 565, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U293);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U294);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U295);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1531, 565, 2);
        }
    }
    rfalse;
];
[ call_U1532;
    ResponseViaActivity(response_id_U293);
];
[ call_U1533;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1534;
    ResponseViaActivity(response_id_U294);
];
[ call_U1535;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1536;
    ResponseViaActivity(response_id_U295);
];
[ call_U1537;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1538;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1538, 566, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U312(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U296);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1538, 566, 2);
        }
    }
    rfalse;
];
[ call_U1539;
    ResponseViaActivity(response_id_U296);
];
[ call_U1540;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " close.";
    rtrue;
];
[ call_U1541;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1541, 567, 0);
        }
        if (call_U309(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U297);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1541, 567, 2);
        }
    }
    rfalse;
];
[ call_U1542;
    ResponseViaActivity(response_id_U297);
];
[ call_U1543;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U195();
    ParaContent();
    print " already closed.";
    rtrue;
];
[ call_U1544;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1544, 568, 0);
        }
        call_U310(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1544, 568, 2);
        }
    }
    rfalse;
];
[ call_U1545;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1545, 569, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U298);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U299);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U300);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1545, 569, 2);
        }
    }
    rfalse;
];
[ call_U1546;
    ResponseViaActivity(response_id_U298);
];
[ call_U1547;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1548;
    ResponseViaActivity(response_id_U299);
];
[ call_U1549;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1550;
    ResponseViaActivity(response_id_U300);
];
[ call_U1551;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1552;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1552, 570, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U270(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U301);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1552, 570, 2);
        }
    }
    rfalse;
];
[ call_U1553;
    ResponseViaActivity(response_id_U301);
];
[ call_U1554;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb35);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1555;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1555, 571, 0);
        }
        if ((~~((HolderOf(noun) == actor)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U302);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1555, 571, 2);
        }
    }
    rfalse;
];
[ call_U1556;
    ResponseViaActivity(response_id_U302);
];
[ call_U1557;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1558;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1558, 572, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U303);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1558, 572, 2);
        }
    }
    rfalse;
];
[ call_U1559;
    ResponseViaActivity(response_id_U303);
];
[ call_U1560;
    (say__p = 1);
    ParaContent();
    call_U175();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already wearing ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1561;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1561, 573, 0);
        }
        WearObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1561, 573, 2);
        }
    }
    rfalse;
];
[ call_U1562;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1562, 574, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U304);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U305);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1562, 574, 2);
        }
    }
    rfalse;
];
[ call_U1563;
    ResponseViaActivity(response_id_U304);
];
[ call_U1564;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1565;
    ResponseViaActivity(response_id_U305);
];
[ call_U1566;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1567;
    if ((((action == ##Disrobe)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U212(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1567, 575, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_likely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1567, 575, 2);
        }
    }
    rfalse;
];
[ call_U1568;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1568, 576, 0);
        }
        if ((~~((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U306);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1568, 576, 2);
        }
    }
    rfalse;
];
[ call_U1569;
    ResponseViaActivity(response_id_U306);
];
[ call_U1570;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " wearing ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1571;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1571, 577, 0);
        }
        if (((call_U1572)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U307);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1571, 577, 2);
        }
    }
    rfalse;
];
[ call_U1572 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1573;
    ResponseViaActivity(response_id_U307);
];
[ call_U1574;
    (say__p = 1);
    ParaContent();
    call_U175();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1575;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1575, 578, 0);
        }
        MoveObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1575, 578, 2);
        }
    }
    rfalse;
];
[ call_U1576;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1576, 579, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U308);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U309);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1576, 579, 2);
        }
    }
    rfalse;
];
[ call_U1577;
    ResponseViaActivity(response_id_U308);
];
[ call_U1578;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1579;
    ResponseViaActivity(response_id_U309);
];
[ call_U1580;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1581;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1581, 580, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U310);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1581, 580, 2);
        }
    }
    rfalse;
];
[ call_U1582;
    ResponseViaActivity(response_id_U310);
];
[ call_U1583;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1584;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1584, 581, 0);
        }
        if ((actor == second)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U311);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1584, 581, 2);
        }
    }
    rfalse;
];
[ call_U1585;
    ResponseViaActivity(response_id_U311);
];
[ call_U1586;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb37);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U173();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1587;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1587, 582, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U312);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1587, 582, 2);
        }
    }
    rfalse;
];
[ call_U1588;
    ResponseViaActivity(response_id_U312);
];
[ call_U1589;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " able to receive things.";
    rtrue;
];
[ call_U1590;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1590, 583, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U313);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1590, 583, 2);
        }
    }
    rfalse;
];
[ call_U1591;
    ResponseViaActivity(response_id_U313);
];
[ call_U1592;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1593;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1593, 584, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U314);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1593, 584, 2);
        }
    }
    rfalse;
];
[ call_U1594;
    ResponseViaActivity(response_id_U314);
];
[ call_U1595;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem interested.";
    rtrue;
];
[ call_U1596;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1596, 585, 0);
        }
        if (((call_U1597)() >= GProperty(OBJECT_TY, second, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U315);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1596, 585, 2);
        }
    }
    rfalse;
];
[ call_U1597 x x_ix counter;
    objectloop (x in second) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1598;
    ResponseViaActivity(response_id_U315);
];
[ call_U1599;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1600;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1600, 586, 0);
        }
        MoveObject(noun, second, 0, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1600, 586, 2);
        }
    }
    rfalse;
];
[ call_U1601;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1601, 587, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U316);
            print "^";
        } else {
            if ((second == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U317);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U318);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1601, 587, 2);
        }
    }
    rfalse;
];
[ call_U1602;
    ResponseViaActivity(response_id_U316);
];
[ call_U1603;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1604;
    ResponseViaActivity(response_id_U317);
];
[ call_U1605;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U171();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1606;
    ResponseViaActivity(response_id_U318);
];
[ call_U1607;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1608;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1608, 588, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U319);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1608, 588, 2);
        }
    }
    rfalse;
];
[ call_U1609;
    ResponseViaActivity(response_id_U319);
];
[ call_U1610;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1611;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1611, 589, 0);
        }
        if ((actor == second)) {
            return GVS_Convert(##Examine, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1611, 589, 2);
        }
    }
    rfalse;
];
[ call_U1612;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1612, 590, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U320);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1612, 590, 2);
        }
    }
    rfalse;
];
[ call_U1613;
    ResponseViaActivity(response_id_U320);
];
[ call_U1614;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unimpressed.";
    rtrue;
];
[ call_U1615;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1615, 591, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U321);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1615, 591, 2);
        }
    }
    rfalse;
];
[ call_U1616;
    ResponseViaActivity(response_id_U321);
];
[ call_U1617;
    (say__p = 1);
    ParaContent();
    print "That ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unnecessary.";
    rtrue;
];
[ call_U1618;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1618, 592, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U322);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1618, 592, 2);
        }
    }
    rfalse;
];
[ call_U1619;
    ResponseViaActivity(response_id_U322);
];
[ call_U1620;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1621;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1621, 593, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U323);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1621, 593, 2);
        }
    }
    rfalse;
];
[ call_U1622;
    ResponseViaActivity(response_id_U323);
];
[ call_U1623;
    (say__p = 1);
    ParaContent();
    print "Futile.";
    rtrue;
];
[ call_U1624;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1624, 594, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U324);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1624, 594, 2);
        }
    }
    rfalse;
];
[ call_U1625;
    ResponseViaActivity(response_id_U324);
];
[ call_U1626;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the nerve when it ";
    if ((~~((story_tense == I_past_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "came";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "comes";
    .L_SayX0;
    ParaContent();
    print " to the crucial moment.";
    rtrue;
];
[ call_U1627;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1627, 595, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U325);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1627, 595, 2);
        }
    }
    rfalse;
];
[ call_U1628;
    ResponseViaActivity(response_id_U325);
];
[ call_U1629;
    (say__p = 1);
    ParaContent();
    print "Violence ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the answer to this one.";
    rtrue;
];
[ call_U1630;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1630, 596, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U326);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1630, 596, 2);
        }
    }
    rfalse;
];
[ call_U1631;
    ResponseViaActivity(response_id_U326);
];
[ call_U1632;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " get much from that.";
    rtrue;
];
[ call_U1633;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1633, 597, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U327);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1633, 597, 2);
        }
    }
    rfalse;
];
[ call_U1634;
    ResponseViaActivity(response_id_U327);
];
[ call_U1635;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " like that.";
    rtrue;
];
[ call_U1636;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1636, 598, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U328);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1636, 598, 2);
        }
    }
    rfalse;
];
[ call_U1637;
    ResponseViaActivity(response_id_U328);
];
[ call_U1638;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1639;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1639, 599, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U329);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1639, 599, 2);
        }
    }
    rfalse;
];
[ call_U1640;
    ResponseViaActivity(response_id_U329);
];
[ call_U1641;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb38(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to ";
    ParaContent();
    call_U173();
    ParaContent();
    print " a while.";
    rtrue;
];
[ call_U1642;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1642, 600, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U330);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1642, 600, 2);
        }
    }
    rfalse;
];
[ call_U1643;
    ResponseViaActivity(response_id_U330);
];
[ call_U1644;
    (say__p = 1);
    ParaContent();
    print "This ";
    ConjugateVerb39(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reaction.";
    rtrue;
];
[ call_U1645;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1645, 601, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U331);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1645, 601, 2);
        }
    }
    rfalse;
];
[ call_U1646;
    ResponseViaActivity(response_id_U331);
];
[ call_U1647;
    (say__p = 1);
    ParaContent();
    call_U197();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1648;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1648, 602, 0);
        }
        if ((((actor == noun)) && ((actor == player)))) {
            TryAction(0, player, ##Inv, 0, 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1648, 602, 2);
        }
    }
    rfalse;
];
[ call_U1649;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1649, 603, 0);
        }
        return ConvertToRequest(noun, ##Give, second, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1649, 603, 2);
        }
    }
    rfalse;
];
[ call_U1650;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1650, 604, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U332);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U333);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1650, 604, 2);
        }
    }
    rfalse;
];
[ call_U1651;
    ResponseViaActivity(response_id_U332);
];
[ call_U1652;
    (say__p = 1);
    ParaContent();
    print "Time ";
    ConjugateVerb40(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1653;
    ResponseViaActivity(response_id_U333);
];
[ call_U1654;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb41(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1655;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1655, 605, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U334);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U335);
                print "^";
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1655, 605, 2);
        }
    }
    rfalse;
];
[ call_U1656;
    ResponseViaActivity(response_id_U334);
];
[ call_U1657;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1658;
    ResponseViaActivity(response_id_U335);
];
[ call_U1659;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U192();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1660;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1660, 606, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U336);
                    print "^";
                }
            } else {
                if ((noun == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U337);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U338);
                    print "^";
                }
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1660, 606, 2);
        }
    }
    rfalse;
];
[ call_U1661;
    ResponseViaActivity(response_id_U336);
];
[ call_U1662;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1663;
    ResponseViaActivity(response_id_U337);
];
[ call_U1664;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U171();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1665;
    ResponseViaActivity(response_id_U338);
];
[ call_U1666;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1667;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1667, 607, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U339);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U340);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1667, 607, 2);
        }
    }
    rfalse;
];
[ call_U1668;
    ResponseViaActivity(response_id_U339);
];
[ call_U1669;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb44(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1670;
    ResponseViaActivity(response_id_U340);
];
[ call_U1671;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1672;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1672, 608, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U341);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1672, 608, 2);
        }
    }
    rfalse;
];
[ call_U1673;
    ResponseViaActivity(response_id_U341);
];
[ call_U1674;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1675;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1675, 609, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U342);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U343);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1675, 609, 2);
        }
    }
    rfalse;
];
[ call_U1676;
    ResponseViaActivity(response_id_U342);
];
[ call_U1677;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1678;
    ResponseViaActivity(response_id_U343);
];
[ call_U1679;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1680;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1680, 610, 0);
        }
        if (call_U261(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U344);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1680, 610, 2);
        }
    }
    rfalse;
];
[ call_U1681;
    ResponseViaActivity(response_id_U344);
];
[ call_U1682;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1683;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1683, 611, 0);
        }
        if (call_U267(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U345);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1683, 611, 2);
        }
    }
    rfalse;
];
[ call_U1684;
    ResponseViaActivity(response_id_U345);
];
[ call_U1685;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1686;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1686, 612, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U346);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1686, 612, 2);
        }
    }
    rfalse;
];
[ call_U1687;
    ResponseViaActivity(response_id_U346);
];
[ call_U1688;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1689;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1689, 613, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U347);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U348);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1689, 613, 2);
        }
    }
    rfalse;
];
[ call_U1690;
    ResponseViaActivity(response_id_U347);
];
[ call_U1691;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1692;
    ResponseViaActivity(response_id_U348);
];
[ call_U1693;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb47(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1694;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1694, 614, 0);
        }
        if (call_U261(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U349);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1694, 614, 2);
        }
    }
    rfalse;
];
[ call_U1695;
    ResponseViaActivity(response_id_U349);
];
[ call_U1696;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1697;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1697, 615, 0);
        }
        if (call_U267(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U350);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1697, 615, 2);
        }
    }
    rfalse;
];
[ call_U1698;
    ResponseViaActivity(response_id_U350);
];
[ call_U1699;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1700;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1700, 616, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U351);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1700, 616, 2);
        }
    }
    rfalse;
];
[ call_U1701;
    ResponseViaActivity(response_id_U351);
];
[ call_U1702;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1703;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1703, 617, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U352);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U353);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1703, 617, 2);
        }
    }
    rfalse;
];
[ call_U1704;
    ResponseViaActivity(response_id_U352);
];
[ call_U1705;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1706;
    ResponseViaActivity(response_id_U353);
];
[ call_U1707;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb48(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1708;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1708, 618, 0);
        }
        if (call_U261(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U354);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1708, 618, 2);
        }
    }
    rfalse;
];
[ call_U1709;
    ResponseViaActivity(response_id_U354);
];
[ call_U1710;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1711;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1711, 619, 0);
        }
        if (call_U267(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U355);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1711, 619, 2);
        }
    }
    rfalse;
];
[ call_U1712;
    ResponseViaActivity(response_id_U355);
];
[ call_U1713;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1714;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1714, 620, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U356);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1714, 620, 2);
        }
    }
    rfalse;
];
[ call_U1715;
    ResponseViaActivity(response_id_U356);
];
[ call_U1716;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1717;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1717, 621, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U357);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U358);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1717, 621, 2);
        }
    }
    rfalse;
];
[ call_U1718;
    ResponseViaActivity(response_id_U357);
];
[ call_U1719;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1720;
    ResponseViaActivity(response_id_U358);
];
[ call_U1721;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb49(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1722;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1722, 622, 0);
        }
        if ((~~(call_U273(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U359);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1722, 622, 2);
        }
    }
    rfalse;
];
[ call_U1723;
    ResponseViaActivity(response_id_U359);
];
[ call_U1724;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1725;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1725, 623, 0);
        }
        if ((~~((second ofclass K3_direction)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U360);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1725, 623, 2);
        }
    }
    rfalse;
];
[ call_U1726;
    ResponseViaActivity(response_id_U360);
];
[ call_U1727;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a direction.";
    rtrue;
];
[ call_U1728;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1728, 624, 0);
        }
        if ((((second == I_up_U1)) || ((second == I_down_U1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U361);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1728, 624, 2);
        }
    }
    rfalse;
];
[ call_U1729;
    ResponseViaActivity(response_id_U361);
];
[ call_U1730;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed up or down.";
    rtrue;
];
[ call_U1731;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1731, 625, 0);
        }
        if (IndirectlyContains(noun, actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U362);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1731, 625, 2);
        }
    }
    rfalse;
];
[ call_U1732;
    ResponseViaActivity(response_id_U362);
];
[ call_U1733;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from here.";
    rtrue;
];
[ call_U1734;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1734, 626, 0);
        }
        return ConvertToGoingWithPush();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1734, 626, 2);
        }
    }
    rfalse;
];
[ call_U1735;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1735, 627, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U363);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1735, 627, 2);
        }
    }
    rfalse;
];
[ call_U1736;
    ResponseViaActivity(response_id_U363);
];
[ call_U1737;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1738;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1738, 628, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U364);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1738, 628, 2);
        }
    }
    rfalse;
];
[ call_U1739;
    ResponseViaActivity(response_id_U364);
];
[ call_U1740;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1741;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1741, 629, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U365);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U366);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1741, 629, 2);
        }
    }
    rfalse;
];
[ call_U1742;
    ResponseViaActivity(response_id_U365);
];
[ call_U1743;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1744;
    ResponseViaActivity(response_id_U366);
];
[ call_U1745;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb50(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1746;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1746, 630, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U367);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1746, 630, 2);
        }
    }
    rfalse;
];
[ call_U1747;
    ResponseViaActivity(response_id_U367);
];
[ call_U1748;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1749;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1749, 631, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U368);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1749, 631, 2);
        }
    }
    rfalse;
];
[ call_U1750;
    ResponseViaActivity(response_id_U368);
];
[ call_U1751;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1752;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1752, 632, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U369);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1752, 632, 2);
        }
    }
    rfalse;
];
[ call_U1753;
    ResponseViaActivity(response_id_U369);
];
[ call_U1754;
    (say__p = 1);
    ParaContent();
    print "This dangerous act ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1755;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1755, 633, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U370);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1755, 633, 2);
        }
    }
    rfalse;
];
[ call_U1756;
    ResponseViaActivity(response_id_U370);
];
[ call_U1757;
    (say__p = 1);
    ParaContent();
    print "The dreadful truth ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", this ";
    ConjugateVerb1(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a dream.";
    rtrue;
];
[ call_U1758;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1758, 634, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U371);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1758, 634, 2);
        }
    }
    rfalse;
];
[ call_U1759;
    ResponseViaActivity(response_id_U371);
];
[ call_U1760;
    (say__p = 1);
    ParaContent();
    print "What a good idea.";
    rtrue;
];
[ call_U1761;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1761, 635, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U372);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U373);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1761, 635, 2);
        }
    }
    rfalse;
];
[ call_U1762;
    ResponseViaActivity(response_id_U372);
];
[ call_U1763;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb51(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1764;
    ResponseViaActivity(response_id_U373);
];
[ call_U1765;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb52(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1766;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1766, 636, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U374);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U375);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1766, 636, 2);
        }
    }
    rfalse;
];
[ call_U1767;
    ResponseViaActivity(response_id_U374);
];
[ call_U1768;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb53(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1769;
    ResponseViaActivity(response_id_U375);
];
[ call_U1770;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb54(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1771;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1771, 637, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U376);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U377);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1771, 637, 2);
        }
    }
    rfalse;
];
[ call_U1772;
    ResponseViaActivity(response_id_U376);
];
[ call_U1773;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1774;
    ResponseViaActivity(response_id_U377);
];
[ call_U1775;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1776;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1776, 638, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U378);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1776, 638, 2);
        }
    }
    rfalse;
];
[ call_U1777;
    ResponseViaActivity(response_id_U378);
];
[ call_U1778;
    (say__p = 1);
    ParaContent();
    print "Cutting ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U188();
    ParaContent();
    print " up ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1779;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1779, 639, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U379);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U380);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1779, 639, 2);
        }
    }
    rfalse;
];
[ call_U1780;
    ResponseViaActivity(response_id_U379);
];
[ call_U1781;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1782;
    ResponseViaActivity(response_id_U380);
];
[ call_U1783;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1784;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1784, 640, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U381);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1784, 640, 2);
        }
    }
    rfalse;
];
[ call_U1785;
    ResponseViaActivity(response_id_U381);
];
[ call_U1786;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1787;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1787, 641, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U382);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1787, 641, 2);
        }
    }
    rfalse;
];
[ call_U1788;
    ResponseViaActivity(response_id_U382);
];
[ call_U1789;
    (say__p = 1);
    ParaContent();
    call_U201();
    ParaContent();
    print " nothing suitable to drink here.";
    rtrue;
];
[ call_U1790;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1790, 642, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U383);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1790, 642, 2);
        }
    }
    rfalse;
];
[ call_U1791;
    ResponseViaActivity(response_id_U383);
];
[ call_U1792;
    (say__p = 1);
    ParaContent();
    print "Oh, don't ";
    if ((~~(call_U72(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "apologize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "apologise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1793;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1793, 643, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U384);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1793, 643, 2);
        }
    }
    rfalse;
];
[ call_U1794;
    ResponseViaActivity(response_id_U384);
];
[ call_U1795;
    (say__p = 1);
    ParaContent();
    call_U201();
    ParaContent();
    print " nothing sensible to swing here.";
    rtrue;
];
[ call_U1796;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1796, 644, 0);
        }
        if ((((noun ofclass K8_person)) && ((~~((noun == actor)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U385);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1796, 644, 2);
        }
    }
    rfalse;
];
[ call_U1797;
    ResponseViaActivity(response_id_U385);
];
[ call_U1798;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1799;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1799, 645, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U386);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U387);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1799, 645, 2);
        }
    }
    rfalse;
];
[ call_U1800;
    ResponseViaActivity(response_id_U386);
];
[ call_U1801;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1802;
    ResponseViaActivity(response_id_U387);
];
[ call_U1803;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1804;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1804, 646, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U388);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1804, 646, 2);
        }
    }
    rfalse;
];
[ call_U1805;
    ResponseViaActivity(response_id_U388);
];
[ call_U1806;
    (say__p = 1);
    ParaContent();
    print "No, ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb58);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U180();
    ParaContent();
    print " to anything.";
    rtrue;
];
[ call_U1807;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1807, 647, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U389);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U390);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1807, 647, 2);
        }
    }
    rfalse;
];
[ call_U1808;
    ResponseViaActivity(response_id_U389);
];
[ call_U1809;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1810;
    ResponseViaActivity(response_id_U390);
];
[ call_U1811;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1812;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1812, 648, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U391);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1812, 648, 2);
        }
    }
    rfalse;
];
[ call_U1813;
    ResponseViaActivity(response_id_U391);
];
[ call_U1814;
    (say__p = 1);
    ParaContent();
    print "Nothing ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on sale.";
    rtrue;
];
[ call_U1815;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1815, 649, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U392);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1815, 649, 2);
        }
    }
    rfalse;
];
[ call_U1816;
    ResponseViaActivity(response_id_U392);
];
[ call_U1817;
    (say__p = 1);
    ParaContent();
    print "Little ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be achieved by that.";
    rtrue;
];
[ call_U1818;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1818, 650, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U393);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1818, 650, 2);
        }
    }
    rfalse;
];
[ call_U1819;
    ResponseViaActivity(response_id_U393);
];
[ call_U1820;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " feeling especially drowsy.";
    rtrue;
];
[ call_U1821 sk;
    rfalse;
];
[ call_U1822 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_map_region)) {
                    print "map region: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_map_region));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lighted";
                }
                if (((0) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "dark";
                }
                if (((0) && ((t_0 has visited)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "visited";
                }
                if (((0) && ((~~((t_0 has visited)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unvisited";
                }
                if (((0) && ((t_0 has P_scored)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scored";
                }
                if (((0) && ((~~((t_0 has P_scored)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unscored";
                }
                if (((0) && ((t_0 has P_indoors)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "indoors";
                }
                if (((0) && ((~~((t_0 has P_indoors)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "outdoors";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1823 sk;
    rfalse;
];
[ call_U1824 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                print "initial appearance: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_initial), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_initial));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_with_key)) {
                    print "matching key: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_with_key));
                    print "^";
                }
                print "price: ";
                (E6)(GProperty(OBJECT_TY, t_0, A_P_price));
                print "^";
            }
        } else {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lit";
                }
                if (((0) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlit";
                }
                if (((0) && ((t_0 has edible)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "edible";
                }
                if (((0) && ((~~((t_0 has edible)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "inedible";
                }
                if (((0) && ((t_0 has static)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "fixed in place";
                }
                if (((0) && ((~~((t_0 has static)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "portable";
                }
                if (((0) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((0) && ((t_0 has clothing)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "wearable";
                }
                if (((0) && ((t_0 has pushable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "pushable between rooms";
                }
                if (((0) && ((t_0 has moved)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "handled";
                }
                if (((0) && ((t_0 has concealed)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "undescribed";
                }
                if (((0) && ((~~((t_0 has concealed)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "described";
                }
                if (((0) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((0) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
                if (((0) && ((t_0 has mentioned)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "mentioned";
                }
                if (((0) && ((~~((t_0 has mentioned)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmentioned";
                }
                if (((0) && ((t_0 has P_broken)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "broken";
                }
                if (((0) && ((~~((t_0 has P_broken)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unbroken";
                }
                if (((0) && ((t_0 has P_seen)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "seen";
                }
                if (((0) && ((~~((t_0 has P_seen)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unseen";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1825 sk;
    rfalse;
];
[ call_U1826 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_P_opposite)) {
                    print "opposite: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_P_opposite));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((0) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((0) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1827 sk;
    rfalse;
];
[ call_U1828 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_door_to)) {
                    print "leading-through destination: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_door_to));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((0) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((0) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((0) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((0) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((0) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((0) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1829 sk;
    rfalse;
];
[ call_U1830 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((0) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((0) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((0) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((0) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((0) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((0) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((0) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((0) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((0) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1831 sk;
    rfalse;
];
[ call_U1832 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((0) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((0) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1833 sk;
    rfalse;
];
[ call_U1834 sk;
    rfalse;
];
[ call_U1835 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((0) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((0) && ((t_0 has female)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "female";
                }
                if (((0) && ((~~((t_0 has female)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "male";
                }
                if (((0) && ((t_0 has neuter)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "neuter";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1836 sk;
    rfalse;
];
[ call_U1837 sk;
    rfalse;
];
[ call_U1838 sk;
    rfalse;
];
[ call_U1839 sk;
    rfalse;
];
[ call_U1840 sk;
    rfalse;
];
[ call_U1841 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 ofclass K13_device)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has on)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched on";
                }
                if (((0) && ((~~((t_0 has on)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched off";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1842 sk;
    rfalse;
];
[ call_U1843 sk;
    rfalse;
];
[ call_U1844 sk;
    return I_didn_t_understand_error_U1;
];
[ E7 value;
    switch (value) {
        I_didn_t_understand_error_U1:
            print "didn't understand error";
            ;
        I_only_understood_as_far_as__U1:
            print "only understood as far as error";
            ;
        I_didn_t_understand_that_num_U1:
            print "didn't understand that number error";
            ;
        I_can_only_do_that_to_someth_U1:
            print "can only do that to something animate error";
            ;
        I_can_t_see_any_such_thing_e_U1:
            print "can't see any such thing error";
            ;
        I_said_too_little_error_U1:
            print "said too little error";
            ;
        I_aren_t_holding_that_error_U1:
            print "aren't holding that error";
            ;
        I_can_t_use_multiple_objects_U1:
            print "can't use multiple objects error";
            ;
        I_can_only_use_multiple_obje_U1:
            print "can only use multiple objects error";
            ;
        I_not_sure_what_it_refers_to_U1:
            print "not sure what it refers to error";
            ;
        I_excepted_something_not_inc_U1:
            print "excepted something not included error";
            ;
        I_not_a_verb_i_recognise_err_U1:
            print "not a verb I recognise error";
            ;
        I_not_something_you_need_to__U1:
            print "not something you need to refer to error";
            ;
        I_can_t_see_it_at_the_moment_U1:
            print "can't see it at the moment error";
            ;
        I_didn_t_understand_the_way__U1:
            print "didn't understand the way that finished error";
            ;
        I_not_enough_of_those_availa_U1:
            print "not enough of those available error";
            ;
        I_nothing_to_do_error_U1:
            print "nothing to do error";
            ;
        I_referred_to_a_determinatio_U1:
            print "referred to a determination of scope error";
            ;
        I_noun_did_not_make_sense_in_U1:
            print "noun did not make sense in that context error";
            ;
        I_i_beg_your_pardon_error_U1:
            print "I beg your pardon error";
            ;
        I_can_t_again_the_addressee__U1:
            print "can't again the addressee error";
            ;
        I_comma_can_t_begin_error_U1:
            print "comma can't begin error";
            ;
        I_can_t_see_whom_to_talk_to__U1:
            print "can't see whom to talk to error";
            ;
        I_can_t_talk_to_inanimate_th_U1:
            print "can't talk to inanimate things error";
            ;
        I_didn_t_understand_addresse_U1:
            print "didn't understand addressee's last name error";
            ;
        default:
            print "<illegal command parser error>";
            ;
    }
];
[ call_U1845 x;
    return ((x%25) + 1);
];
[ call_U1846 x;
    return (((x + 23)%25) + 1);
];
[ call_U1847 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(25);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ CommandPromptText;
    return (Global_Vars-->22);
];
[ call_U1848 t_0;
    CarryOutActivity(V32_printing_the_locale_descr, t_0);
    rfalse;
];
[ call_U1849 t_0 t_1 ct_0 ct_1;
    if ((t_0 ofclass K2_thing)) {
        if ((t_1 <= 0)) {
            call_U292(t_0);
        }
        if (ExistsTableLookUpCorr(table_data_U2, table_column_id_U6, table_column_id_U6, t_0)) {
            (ct_0 = table_data_U2);
            (ct_1 = TableRowCorr(ct_0, table_column_id_U6, t_0));
            if ((t_1 <= 0)) {
                TableBlankOutRow(ct_0, ct_1);
            } else {
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        } else {
            if ((t_1 > 0)) {
                (ct_0 = table_data_U2);
                (ct_1 = TableBlankRow(ct_0));
                (TableLookUpEntry)(ct_0,table_column_id_U6,ct_1,1,t_0);
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        }
    }
    rfalse;
];
[ call_U1850;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "here";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "there";
    .L_SayX0;
    rfalse;
];
[ call_U1851;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "then";
    .L_SayX0;
    rfalse;
];
[ call_U1852 t_0;
    CarryOutActivity(V4_issuing_the_response_text, t_0);
    rfalse;
];
[ ConjugateVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ call_U1853 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "seem";
            ;
        2:
            print "seemed";
            ;
        3:
            print "seeming";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "seems";
                    } else {
                        print "seem";
                    }
                    ;
                2:
                    print "seemed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seemed";
                    } else {
                        print "have seemed";
                    }
                    ;
                4:
                    print "had seemed";
                    ;
                5:
                    print "will seem";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not seem";
                    } else {
                        print "do not seem";
                    }
                    ;
                2:
                    print "did not seem";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seemed";
                    } else {
                        print "have not seemed";
                    }
                    ;
                4:
                    print "had not seemed";
                    ;
                5:
                    print "will not seem";
                    ;
            }
            ;
    }
];
[ call_U1854 fn vp t modal_to;
    (t = ConjugateVerb6(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "look";
            ;
        2:
            print "looked";
            ;
        3:
            print "looking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "looks";
                    } else {
                        print "look";
                    }
                    ;
                2:
                    print "looked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has looked";
                    } else {
                        print "have looked";
                    }
                    ;
                4:
                    print "had looked";
                    ;
                5:
                    print "will look";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not look";
                    } else {
                        print "do not look";
                    }
                    ;
                2:
                    print "did not look";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not looked";
                    } else {
                        print "have not looked";
                    }
                    ;
                4:
                    print "had not looked";
                    ;
                5:
                    print "will not look";
                    ;
            }
            ;
    }
];
[ call_U1855 fn vp t modal_to;
    (t = ConjugateVerb9(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "care";
            ;
        2:
            print "cared";
            ;
        3:
            print "caring";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "cares";
                    } else {
                        print "care";
                    }
                    ;
                2:
                    print "cared";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has cared";
                    } else {
                        print "have cared";
                    }
                    ;
                4:
                    print "had cared";
                    ;
                5:
                    print "will care";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not care";
                    } else {
                        print "do not care";
                    }
                    ;
                2:
                    print "did not care";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not cared";
                    } else {
                        print "have not cared";
                    }
                    ;
                4:
                    print "had not cared";
                    ;
                5:
                    print "will not care";
                    ;
            }
            ;
    }
];
[ call_U1856 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "pick";
            ;
        2:
            print "picked";
            ;
        3:
            print "picking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "picks";
                    } else {
                        print "pick";
                    }
                    ;
                2:
                    print "picked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has picked";
                    } else {
                        print "have picked";
                    }
                    ;
                4:
                    print "had picked";
                    ;
                5:
                    print "will pick";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pick";
                    } else {
                        print "do not pick";
                    }
                    ;
                2:
                    print "did not pick";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not picked";
                    } else {
                        print "have not picked";
                    }
                    ;
                4:
                    print "had not picked";
                    ;
                5:
                    print "will not pick";
                    ;
            }
            ;
    }
];
[ call_U1857 fn vp t modal_to;
    (t = ConjugateVerb12(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "lack";
            ;
        2:
            print "lacked";
            ;
        3:
            print "lacking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "lacks";
                    } else {
                        print "lack";
                    }
                    ;
                2:
                    print "lacked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has lacked";
                    } else {
                        print "have lacked";
                    }
                    ;
                4:
                    print "had lacked";
                    ;
                5:
                    print "will lack";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lack";
                    } else {
                        print "do not lack";
                    }
                    ;
                2:
                    print "did not lack";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not lacked";
                    } else {
                        print "have not lacked";
                    }
                    ;
                4:
                    print "had not lacked";
                    ;
                5:
                    print "will not lack";
                    ;
            }
            ;
    }
];
[ call_U1858 fn vp t modal_to;
    (t = ConjugateVerb13(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "drop";
            ;
        2:
            print "dropped";
            ;
        3:
            print "dropping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "drops";
                    } else {
                        print "drop";
                    }
                    ;
                2:
                    print "dropped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has dropped";
                    } else {
                        print "have dropped";
                    }
                    ;
                4:
                    print "had dropped";
                    ;
                5:
                    print "will drop";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not drop";
                    } else {
                        print "do not drop";
                    }
                    ;
                2:
                    print "did not drop";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not dropped";
                    } else {
                        print "have not dropped";
                    }
                    ;
                4:
                    print "had not dropped";
                    ;
                5:
                    print "will not drop";
                    ;
            }
            ;
    }
];
[ call_U1859 fn vp t modal_to;
    (t = ConjugateVerb14(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "put";
            ;
        2:
            print "put";
            ;
        3:
            print "putting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "puts";
                    } else {
                        print "put";
                    }
                    ;
                2:
                    print "put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has put";
                    } else {
                        print "have put";
                    }
                    ;
                4:
                    print "had put";
                    ;
                5:
                    print "will put";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not put";
                    } else {
                        print "do not put";
                    }
                    ;
                2:
                    print "did not put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not put";
                    } else {
                        print "have not put";
                    }
                    ;
                4:
                    print "had not put";
                    ;
                5:
                    print "will not put";
                    ;
            }
            ;
    }
];
[ call_U1860 fn vp t modal_to;
    (t = ConjugateVerb16(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "achieve";
            ;
        2:
            print "achieved";
            ;
        3:
            print "achieving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "achieves";
                    } else {
                        print "achieve";
                    }
                    ;
                2:
                    print "achieved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has achieved";
                    } else {
                        print "have achieved";
                    }
                    ;
                4:
                    print "had achieved";
                    ;
                5:
                    print "will achieve";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not achieve";
                    } else {
                        print "do not achieve";
                    }
                    ;
                2:
                    print "did not achieve";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not achieved";
                    } else {
                        print "have not achieved";
                    }
                    ;
                4:
                    print "had not achieved";
                    ;
                5:
                    print "will not achieve";
                    ;
            }
            ;
    }
];
[ call_U1861 fn vp t modal_to;
    (t = ConjugateVerb17(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "contain";
            ;
        2:
            print "contained";
            ;
        3:
            print "containing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record10;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "contains";
                    } else {
                        print "contain";
                    }
                    ;
                2:
                    print "contained";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has contained";
                    } else {
                        print "have contained";
                    }
                    ;
                4:
                    print "had contained";
                    ;
                5:
                    print "will contain";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not contain";
                    } else {
                        print "do not contain";
                    }
                    ;
                2:
                    print "did not contain";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not contained";
                    } else {
                        print "have not contained";
                    }
                    ;
                4:
                    print "had not contained";
                    ;
                5:
                    print "will not contain";
                    ;
            }
            ;
    }
];
[ call_U1862 fn vp t modal_to;
    (t = ConjugateVerb18(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record10;
    }
];
[ ConjugateVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "appreciate";
            ;
        2:
            print "appreciated";
            ;
        3:
            print "appreciating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "appreciates";
                    } else {
                        print "appreciate";
                    }
                    ;
                2:
                    print "appreciated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has appreciated";
                    } else {
                        print "have appreciated";
                    }
                    ;
                4:
                    print "had appreciated";
                    ;
                5:
                    print "will appreciate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not appreciate";
                    } else {
                        print "do not appreciate";
                    }
                    ;
                2:
                    print "did not appreciate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not appreciated";
                    } else {
                        print "have not appreciated";
                    }
                    ;
                4:
                    print "had not appreciated";
                    ;
                5:
                    print "will not appreciate";
                    ;
            }
            ;
    }
];
[ call_U1863 fn vp t modal_to;
    (t = ConjugateVerb20(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "eat";
            ;
        2:
            print "eaten";
            ;
        3:
            print "eating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "eats";
                    } else {
                        print "eat";
                    }
                    ;
                2:
                    print "ate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has eaten";
                    } else {
                        print "have eaten";
                    }
                    ;
                4:
                    print "had eaten";
                    ;
                5:
                    print "will eat";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not eat";
                    } else {
                        print "do not eat";
                    }
                    ;
                2:
                    print "did not eat";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not eaten";
                    } else {
                        print "have not eaten";
                    }
                    ;
                4:
                    print "had not eaten";
                    ;
                5:
                    print "will not eat";
                    ;
            }
            ;
    }
];
[ call_U1864 fn vp t modal_to;
    (t = ConjugateVerb21(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "go";
            ;
        2:
            print "gone";
            ;
        3:
            print "going";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "goes";
                    } else {
                        print "go";
                    }
                    ;
                2:
                    print "went";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has gone";
                    } else {
                        print "have gone";
                    }
                    ;
                4:
                    print "had gone";
                    ;
                5:
                    print "will go";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not go";
                    } else {
                        print "do not go";
                    }
                    ;
                2:
                    print "did not go";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not gone";
                    } else {
                        print "have not gone";
                    }
                    ;
                4:
                    print "had not gone";
                    ;
                5:
                    print "will not go";
                    ;
            }
            ;
    }
];
[ call_U1865 fn vp t modal_to;
    (t = ConjugateVerb22(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "lead";
            ;
        2:
            print "led";
            ;
        3:
            print "leading";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "leads";
                    } else {
                        print "lead";
                    }
                    ;
                2:
                    print "led";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has led";
                    } else {
                        print "have led";
                    }
                    ;
                4:
                    print "had led";
                    ;
                5:
                    print "will lead";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lead";
                    } else {
                        print "do not lead";
                    }
                    ;
                2:
                    print "did not lead";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not led";
                    } else {
                        print "have not led";
                    }
                    ;
                4:
                    print "had not led";
                    ;
                5:
                    print "will not lead";
                    ;
            }
            ;
    }
];
[ call_U1866 fn vp t modal_to;
    (t = ConjugateVerb23(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "arrive";
            ;
        2:
            print "arrived";
            ;
        3:
            print "arriving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "arrives";
                    } else {
                        print "arrive";
                    }
                    ;
                2:
                    print "arrived";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has arrived";
                    } else {
                        print "have arrived";
                    }
                    ;
                4:
                    print "had arrived";
                    ;
                5:
                    print "will arrive";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not arrive";
                    } else {
                        print "do not arrive";
                    }
                    ;
                2:
                    print "did not arrive";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not arrived";
                    } else {
                        print "have not arrived";
                    }
                    ;
                4:
                    print "had not arrived";
                    ;
                5:
                    print "will not arrive";
                    ;
            }
            ;
    }
];
[ call_U1867 fn vp t modal_to;
    (t = ConjugateVerb24(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "get";
            ;
        2:
            print "got";
            ;
        3:
            print "getting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gets";
                    } else {
                        print "get";
                    }
                    ;
                2:
                    print "got";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has got";
                    } else {
                        print "have got";
                    }
                    ;
                4:
                    print "had got";
                    ;
                5:
                    print "will get";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not get";
                    } else {
                        print "do not get";
                    }
                    ;
                2:
                    print "did not get";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not got";
                    } else {
                        print "have not got";
                    }
                    ;
                4:
                    print "had not got";
                    ;
                5:
                    print "will not get";
                    ;
            }
            ;
    }
];
[ call_U1868 fn vp t modal_to;
    (t = ConjugateVerb25(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "find";
            ;
        2:
            print "found";
            ;
        3:
            print "finding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "finds";
                    } else {
                        print "find";
                    }
                    ;
                2:
                    print "found";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has found";
                    } else {
                        print "have found";
                    }
                    ;
                4:
                    print "had found";
                    ;
                5:
                    print "will find";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not find";
                    } else {
                        print "do not find";
                    }
                    ;
                2:
                    print "did not find";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not found";
                    } else {
                        print "have not found";
                    }
                    ;
                4:
                    print "had not found";
                    ;
                5:
                    print "will not find";
                    ;
            }
            ;
    }
];
[ call_U1869 fn vp t modal_to;
    (t = ConjugateVerb26(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "search";
            ;
        2:
            print "searched";
            ;
        3:
            print "searching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "searches";
                    } else {
                        print "search";
                    }
                    ;
                2:
                    print "searched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has searched";
                    } else {
                        print "have searched";
                    }
                    ;
                4:
                    print "had searched";
                    ;
                5:
                    print "will search";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not search";
                    } else {
                        print "do not search";
                    }
                    ;
                2:
                    print "did not search";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not searched";
                    } else {
                        print "have not searched";
                    }
                    ;
                4:
                    print "had not searched";
                    ;
                5:
                    print "will not search";
                    ;
            }
            ;
    }
];
[ call_U1870 fn vp t modal_to;
    (t = ConjugateVerb27(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "discover";
            ;
        2:
            print "discovered";
            ;
        3:
            print "discovering";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "discovers";
                    } else {
                        print "discover";
                    }
                    ;
                2:
                    print "discovered";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has discovered";
                    } else {
                        print "have discovered";
                    }
                    ;
                4:
                    print "had discovered";
                    ;
                5:
                    print "will discover";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not discover";
                    } else {
                        print "do not discover";
                    }
                    ;
                2:
                    print "did not discover";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not discovered";
                    } else {
                        print "have not discovered";
                    }
                    ;
                4:
                    print "had not discovered";
                    ;
                5:
                    print "will not discover";
                    ;
            }
            ;
    }
];
[ call_U1871 fn vp t modal_to;
    (t = ConjugateVerb28(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "lock";
            ;
        2:
            print "locked";
            ;
        3:
            print "locking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "locks";
                    } else {
                        print "lock";
                    }
                    ;
                2:
                    print "locked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has locked";
                    } else {
                        print "have locked";
                    }
                    ;
                4:
                    print "had locked";
                    ;
                5:
                    print "will lock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lock";
                    } else {
                        print "do not lock";
                    }
                    ;
                2:
                    print "did not lock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not locked";
                    } else {
                        print "have not locked";
                    }
                    ;
                4:
                    print "had not locked";
                    ;
                5:
                    print "will not lock";
                    ;
            }
            ;
    }
];
[ call_U1872 fn vp t modal_to;
    (t = ConjugateVerb30(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "unlock";
            ;
        2:
            print "unlocked";
            ;
        3:
            print "unlocking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record2;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unlocks";
                    } else {
                        print "unlock";
                    }
                    ;
                2:
                    print "unlocked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unlocked";
                    } else {
                        print "have unlocked";
                    }
                    ;
                4:
                    print "had unlocked";
                    ;
                5:
                    print "will unlock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unlock";
                    } else {
                        print "do not unlock";
                    }
                    ;
                2:
                    print "did not unlock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unlocked";
                    } else {
                        print "have not unlocked";
                    }
                    ;
                4:
                    print "had not unlocked";
                    ;
                5:
                    print "will not unlock";
                    ;
            }
            ;
    }
];
[ call_U1873 fn vp t modal_to;
    (t = ConjugateVerb31(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record2;
    }
];
[ ConjugateVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "switch";
            ;
        2:
            print "switched";
            ;
        3:
            print "switching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "switches";
                    } else {
                        print "switch";
                    }
                    ;
                2:
                    print "switched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has switched";
                    } else {
                        print "have switched";
                    }
                    ;
                4:
                    print "had switched";
                    ;
                5:
                    print "will switch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not switch";
                    } else {
                        print "do not switch";
                    }
                    ;
                2:
                    print "did not switch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not switched";
                    } else {
                        print "have not switched";
                    }
                    ;
                4:
                    print "had not switched";
                    ;
                5:
                    print "will not switch";
                    ;
            }
            ;
    }
];
[ call_U1874 fn vp t modal_to;
    (t = ConjugateVerb32(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "open";
            ;
        2:
            print "opened";
            ;
        3:
            print "opening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "opens";
                    } else {
                        print "open";
                    }
                    ;
                2:
                    print "opened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has opened";
                    } else {
                        print "have opened";
                    }
                    ;
                4:
                    print "had opened";
                    ;
                5:
                    print "will open";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not open";
                    } else {
                        print "do not open";
                    }
                    ;
                2:
                    print "did not open";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not opened";
                    } else {
                        print "have not opened";
                    }
                    ;
                4:
                    print "had not opened";
                    ;
                5:
                    print "will not open";
                    ;
            }
            ;
    }
];
[ call_U1875 fn vp t modal_to;
    (t = ConjugateVerb33(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "close";
            ;
        2:
            print "closed";
            ;
        3:
            print "closing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "closes";
                    } else {
                        print "close";
                    }
                    ;
                2:
                    print "closed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has closed";
                    } else {
                        print "have closed";
                    }
                    ;
                4:
                    print "had closed";
                    ;
                5:
                    print "will close";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not close";
                    } else {
                        print "do not close";
                    }
                    ;
                2:
                    print "did not close";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not closed";
                    } else {
                        print "have not closed";
                    }
                    ;
                4:
                    print "had not closed";
                    ;
                5:
                    print "will not close";
                    ;
            }
            ;
    }
];
[ call_U1876 fn vp t modal_to;
    (t = ConjugateVerb34(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "wear";
            ;
        2:
            print "worn";
            ;
        3:
            print "wearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record16;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wears";
                    } else {
                        print "wear";
                    }
                    ;
                2:
                    print "wore";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has worn";
                    } else {
                        print "have worn";
                    }
                    ;
                4:
                    print "had worn";
                    ;
                5:
                    print "will wear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wear";
                    } else {
                        print "do not wear";
                    }
                    ;
                2:
                    print "did not wear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not worn";
                    } else {
                        print "have not worn";
                    }
                    ;
                4:
                    print "had not worn";
                    ;
                5:
                    print "will not wear";
                    ;
            }
            ;
    }
];
[ call_U1877 fn vp t modal_to;
    (t = ConjugateVerb35(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record16;
    }
];
[ ConjugateVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "take";
            ;
        2:
            print "taken";
            ;
        3:
            print "taking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "takes";
                    } else {
                        print "take";
                    }
                    ;
                2:
                    print "took";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has taken";
                    } else {
                        print "have taken";
                    }
                    ;
                4:
                    print "had taken";
                    ;
                5:
                    print "will take";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not take";
                    } else {
                        print "do not take";
                    }
                    ;
                2:
                    print "did not take";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not taken";
                    } else {
                        print "have not taken";
                    }
                    ;
                4:
                    print "had not taken";
                    ;
                5:
                    print "will not take";
                    ;
            }
            ;
    }
];
[ call_U1878 fn vp t modal_to;
    (t = ConjugateVerb36(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "give";
            ;
        2:
            print "given";
            ;
        3:
            print "giving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gives";
                    } else {
                        print "give";
                    }
                    ;
                2:
                    print "gave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has given";
                    } else {
                        print "have given";
                    }
                    ;
                4:
                    print "had given";
                    ;
                5:
                    print "will give";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not give";
                    } else {
                        print "do not give";
                    }
                    ;
                2:
                    print "did not give";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not given";
                    } else {
                        print "have not given";
                    }
                    ;
                4:
                    print "had not given";
                    ;
                5:
                    print "will not give";
                    ;
            }
            ;
    }
];
[ call_U1879 fn vp t modal_to;
    (t = ConjugateVerb37(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "talk";
            ;
        2:
            print "talked";
            ;
        3:
            print "talking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "talks";
                    } else {
                        print "talk";
                    }
                    ;
                2:
                    print "talked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has talked";
                    } else {
                        print "have talked";
                    }
                    ;
                4:
                    print "had talked";
                    ;
                5:
                    print "will talk";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not talk";
                    } else {
                        print "do not talk";
                    }
                    ;
                2:
                    print "did not talk";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not talked";
                    } else {
                        print "have not talked";
                    }
                    ;
                4:
                    print "had not talked";
                    ;
                5:
                    print "will not talk";
                    ;
            }
            ;
    }
];
[ call_U1880 fn vp t modal_to;
    (t = ConjugateVerb38(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "provoke";
            ;
        2:
            print "provoked";
            ;
        3:
            print "provoking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provokes";
                    } else {
                        print "provoke";
                    }
                    ;
                2:
                    print "provoked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provoked";
                    } else {
                        print "have provoked";
                    }
                    ;
                4:
                    print "had provoked";
                    ;
                5:
                    print "will provoke";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provoke";
                    } else {
                        print "do not provoke";
                    }
                    ;
                2:
                    print "did not provoke";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provoked";
                    } else {
                        print "have not provoked";
                    }
                    ;
                4:
                    print "had not provoked";
                    ;
                5:
                    print "will not provoke";
                    ;
            }
            ;
    }
];
[ call_U1881 fn vp t modal_to;
    (t = ConjugateVerb39(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "pass";
            ;
        2:
            print "passed";
            ;
        3:
            print "passing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "passes";
                    } else {
                        print "pass";
                    }
                    ;
                2:
                    print "passed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has passed";
                    } else {
                        print "have passed";
                    }
                    ;
                4:
                    print "had passed";
                    ;
                5:
                    print "will pass";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pass";
                    } else {
                        print "do not pass";
                    }
                    ;
                2:
                    print "did not pass";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not passed";
                    } else {
                        print "have not passed";
                    }
                    ;
                4:
                    print "had not passed";
                    ;
                5:
                    print "will not pass";
                    ;
            }
            ;
    }
];
[ call_U1882 fn vp t modal_to;
    (t = ConjugateVerb40(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "wait";
            ;
        2:
            print "waited";
            ;
        3:
            print "waiting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waits";
                    } else {
                        print "wait";
                    }
                    ;
                2:
                    print "waited";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waited";
                    } else {
                        print "have waited";
                    }
                    ;
                4:
                    print "had waited";
                    ;
                5:
                    print "will wait";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wait";
                    } else {
                        print "do not wait";
                    }
                    ;
                2:
                    print "did not wait";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waited";
                    } else {
                        print "have not waited";
                    }
                    ;
                4:
                    print "had not waited";
                    ;
                5:
                    print "will not wait";
                    ;
            }
            ;
    }
];
[ call_U1883 fn vp t modal_to;
    (t = ConjugateVerb41(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ call_U1884 fn vp t modal_to;
    (t = ConjugateVerb42(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "like";
            ;
        2:
            print "liked";
            ;
        3:
            print "liking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "likes";
                    } else {
                        print "like";
                    }
                    ;
                2:
                    print "liked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has liked";
                    } else {
                        print "have liked";
                    }
                    ;
                4:
                    print "had liked";
                    ;
                5:
                    print "will like";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not like";
                    } else {
                        print "do not like";
                    }
                    ;
                2:
                    print "did not like";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not liked";
                    } else {
                        print "have not liked";
                    }
                    ;
                4:
                    print "had not liked";
                    ;
                5:
                    print "will not like";
                    ;
            }
            ;
    }
];
[ call_U1885 fn vp t modal_to;
    (t = ConjugateVerb43(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "feel";
            ;
        2:
            print "felt";
            ;
        3:
            print "feeling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "feels";
                    } else {
                        print "feel";
                    }
                    ;
                2:
                    print "felt";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has felt";
                    } else {
                        print "have felt";
                    }
                    ;
                4:
                    print "had felt";
                    ;
                5:
                    print "will feel";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not feel";
                    } else {
                        print "do not feel";
                    }
                    ;
                2:
                    print "did not feel";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not felt";
                    } else {
                        print "have not felt";
                    }
                    ;
                4:
                    print "had not felt";
                    ;
                5:
                    print "will not feel";
                    ;
            }
            ;
    }
];
[ call_U1886 fn vp t modal_to;
    (t = ConjugateVerb44(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "wave";
            ;
        2:
            print "waved";
            ;
        3:
            print "waving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waves";
                    } else {
                        print "wave";
                    }
                    ;
                2:
                    print "waved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waved";
                    } else {
                        print "have waved";
                    }
                    ;
                4:
                    print "had waved";
                    ;
                5:
                    print "will wave";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wave";
                    } else {
                        print "do not wave";
                    }
                    ;
                2:
                    print "did not wave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waved";
                    } else {
                        print "have not waved";
                    }
                    ;
                4:
                    print "had not waved";
                    ;
                5:
                    print "will not wave";
                    ;
            }
            ;
    }
];
[ call_U1887 fn vp t modal_to;
    (t = ConjugateVerb45(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "happen";
            ;
        2:
            print "happened";
            ;
        3:
            print "happening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "happens";
                    } else {
                        print "happen";
                    }
                    ;
                2:
                    print "happened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has happened";
                    } else {
                        print "have happened";
                    }
                    ;
                4:
                    print "had happened";
                    ;
                5:
                    print "will happen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not happen";
                    } else {
                        print "do not happen";
                    }
                    ;
                2:
                    print "did not happen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not happened";
                    } else {
                        print "have not happened";
                    }
                    ;
                4:
                    print "had not happened";
                    ;
                5:
                    print "will not happen";
                    ;
            }
            ;
    }
];
[ call_U1888 fn vp t modal_to;
    (t = ConjugateVerb46(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "pull";
            ;
        2:
            print "pulled";
            ;
        3:
            print "pulling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pulls";
                    } else {
                        print "pull";
                    }
                    ;
                2:
                    print "pulled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pulled";
                    } else {
                        print "have pulled";
                    }
                    ;
                4:
                    print "had pulled";
                    ;
                5:
                    print "will pull";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pull";
                    } else {
                        print "do not pull";
                    }
                    ;
                2:
                    print "did not pull";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pulled";
                    } else {
                        print "have not pulled";
                    }
                    ;
                4:
                    print "had not pulled";
                    ;
                5:
                    print "will not pull";
                    ;
            }
            ;
    }
];
[ call_U1889 fn vp t modal_to;
    (t = ConjugateVerb47(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "push";
            ;
        2:
            print "pushed";
            ;
        3:
            print "pushing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pushes";
                    } else {
                        print "push";
                    }
                    ;
                2:
                    print "pushed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pushed";
                    } else {
                        print "have pushed";
                    }
                    ;
                4:
                    print "had pushed";
                    ;
                5:
                    print "will push";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not push";
                    } else {
                        print "do not push";
                    }
                    ;
                2:
                    print "did not push";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pushed";
                    } else {
                        print "have not pushed";
                    }
                    ;
                4:
                    print "had not pushed";
                    ;
                5:
                    print "will not push";
                    ;
            }
            ;
    }
];
[ call_U1890 fn vp t modal_to;
    (t = ConjugateVerb48(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "turn";
            ;
        2:
            print "turned";
            ;
        3:
            print "turning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "turns";
                    } else {
                        print "turn";
                    }
                    ;
                2:
                    print "turned";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has turned";
                    } else {
                        print "have turned";
                    }
                    ;
                4:
                    print "had turned";
                    ;
                5:
                    print "will turn";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not turn";
                    } else {
                        print "do not turn";
                    }
                    ;
                2:
                    print "did not turn";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not turned";
                    } else {
                        print "have not turned";
                    }
                    ;
                4:
                    print "had not turned";
                    ;
                5:
                    print "will not turn";
                    ;
            }
            ;
    }
];
[ call_U1891 fn vp t modal_to;
    (t = ConjugateVerb49(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "squeeze";
            ;
        2:
            print "squeezed";
            ;
        3:
            print "squeezing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "squeezes";
                    } else {
                        print "squeeze";
                    }
                    ;
                2:
                    print "squeezed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has squeezed";
                    } else {
                        print "have squeezed";
                    }
                    ;
                4:
                    print "had squeezed";
                    ;
                5:
                    print "will squeeze";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not squeeze";
                    } else {
                        print "do not squeeze";
                    }
                    ;
                2:
                    print "did not squeeze";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not squeezed";
                    } else {
                        print "have not squeezed";
                    }
                    ;
                4:
                    print "had not squeezed";
                    ;
                5:
                    print "will not squeeze";
                    ;
            }
            ;
    }
];
[ call_U1892 fn vp t modal_to;
    (t = ConjugateVerb50(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "smell";
            ;
        2:
            print "smelled";
            ;
        3:
            print "smelling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "smells";
                    } else {
                        print "smell";
                    }
                    ;
                2:
                    print "smelled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has smelled";
                    } else {
                        print "have smelled";
                    }
                    ;
                4:
                    print "had smelled";
                    ;
                5:
                    print "will smell";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not smell";
                    } else {
                        print "do not smell";
                    }
                    ;
                2:
                    print "did not smell";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not smelled";
                    } else {
                        print "have not smelled";
                    }
                    ;
                4:
                    print "had not smelled";
                    ;
                5:
                    print "will not smell";
                    ;
            }
            ;
    }
];
[ call_U1893 fn vp t modal_to;
    (t = ConjugateVerb51(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "sniff";
            ;
        2:
            print "sniffed";
            ;
        3:
            print "sniffing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sniffs";
                    } else {
                        print "sniff";
                    }
                    ;
                2:
                    print "sniffed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has sniffed";
                    } else {
                        print "have sniffed";
                    }
                    ;
                4:
                    print "had sniffed";
                    ;
                5:
                    print "will sniff";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not sniff";
                    } else {
                        print "do not sniff";
                    }
                    ;
                2:
                    print "did not sniff";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not sniffed";
                    } else {
                        print "have not sniffed";
                    }
                    ;
                4:
                    print "had not sniffed";
                    ;
                5:
                    print "will not sniff";
                    ;
            }
            ;
    }
];
[ call_U1894 fn vp t modal_to;
    (t = ConjugateVerb52(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb53 fn vp t modal_to;
    switch (fn) {
        1:
            print "hear";
            ;
        2:
            print "heard";
            ;
        3:
            print "hearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "hears";
                    } else {
                        print "hear";
                    }
                    ;
                2:
                    print "heard";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has heard";
                    } else {
                        print "have heard";
                    }
                    ;
                4:
                    print "had heard";
                    ;
                5:
                    print "will hear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hear";
                    } else {
                        print "do not hear";
                    }
                    ;
                2:
                    print "did not hear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not heard";
                    } else {
                        print "have not heard";
                    }
                    ;
                4:
                    print "had not heard";
                    ;
                5:
                    print "will not hear";
                    ;
            }
            ;
    }
];
[ call_U1895 fn vp t modal_to;
    (t = ConjugateVerb53(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb54 fn vp t modal_to;
    switch (fn) {
        1:
            print "listen";
            ;
        2:
            print "listened";
            ;
        3:
            print "listening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "listens";
                    } else {
                        print "listen";
                    }
                    ;
                2:
                    print "listened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has listened";
                    } else {
                        print "have listened";
                    }
                    ;
                4:
                    print "had listened";
                    ;
                5:
                    print "will listen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not listen";
                    } else {
                        print "do not listen";
                    }
                    ;
                2:
                    print "did not listen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not listened";
                    } else {
                        print "have not listened";
                    }
                    ;
                4:
                    print "had not listened";
                    ;
                5:
                    print "will not listen";
                    ;
            }
            ;
    }
];
[ call_U1896 fn vp t modal_to;
    (t = ConjugateVerb54(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb55 fn vp t modal_to;
    switch (fn) {
        1:
            print "taste";
            ;
        2:
            print "tasted";
            ;
        3:
            print "tasting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tastes";
                    } else {
                        print "taste";
                    }
                    ;
                2:
                    print "tasted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tasted";
                    } else {
                        print "have tasted";
                    }
                    ;
                4:
                    print "had tasted";
                    ;
                5:
                    print "will taste";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not taste";
                    } else {
                        print "do not taste";
                    }
                    ;
                2:
                    print "did not taste";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tasted";
                    } else {
                        print "have not tasted";
                    }
                    ;
                4:
                    print "had not tasted";
                    ;
                5:
                    print "will not taste";
                    ;
            }
            ;
    }
];
[ call_U1897 fn vp t modal_to;
    (t = ConjugateVerb55(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb56 fn vp t modal_to;
    switch (fn) {
        1:
            print "jump";
            ;
        2:
            print "jumped";
            ;
        3:
            print "jumping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "jumps";
                    } else {
                        print "jump";
                    }
                    ;
                2:
                    print "jumped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has jumped";
                    } else {
                        print "have jumped";
                    }
                    ;
                4:
                    print "had jumped";
                    ;
                5:
                    print "will jump";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not jump";
                    } else {
                        print "do not jump";
                    }
                    ;
                2:
                    print "did not jump";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not jumped";
                    } else {
                        print "have not jumped";
                    }
                    ;
                4:
                    print "had not jumped";
                    ;
                5:
                    print "will not jump";
                    ;
            }
            ;
    }
];
[ call_U1898 fn vp t modal_to;
    (t = ConjugateVerb56(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb57 fn vp t modal_to;
    switch (fn) {
        1:
            print "rub";
            ;
        2:
            print "rubbed";
            ;
        3:
            print "rubbing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "rubs";
                    } else {
                        print "rub";
                    }
                    ;
                2:
                    print "rubbed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has rubbed";
                    } else {
                        print "have rubbed";
                    }
                    ;
                4:
                    print "had rubbed";
                    ;
                5:
                    print "will rub";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not rub";
                    } else {
                        print "do not rub";
                    }
                    ;
                2:
                    print "did not rub";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not rubbed";
                    } else {
                        print "have not rubbed";
                    }
                    ;
                4:
                    print "had not rubbed";
                    ;
                5:
                    print "will not rub";
                    ;
            }
            ;
    }
];
[ call_U1899 fn vp t modal_to;
    (t = ConjugateVerb57(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb58 fn vp t modal_to;
    switch (fn) {
        1:
            print "set";
            ;
        2:
            print "set";
            ;
        3:
            print "setting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sets";
                    } else {
                        print "set";
                    }
                    ;
                2:
                    print "set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has set";
                    } else {
                        print "have set";
                    }
                    ;
                4:
                    print "had set";
                    ;
                5:
                    print "will set";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not set";
                    } else {
                        print "do not set";
                    }
                    ;
                2:
                    print "did not set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not set";
                    } else {
                        print "have not set";
                    }
                    ;
                4:
                    print "had not set";
                    ;
                5:
                    print "will not set";
                    ;
            }
            ;
    }
];
[ call_U1900 fn vp t modal_to;
    (t = ConjugateVerb58(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb87 fn vp t modal_to;
    switch (fn) {
        1:
            print "begin";
            ;
        2:
            print "begun";
            ;
        3:
            print "beginning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "begins";
                    } else {
                        print "begin";
                    }
                    ;
                2:
                    print "began";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has begun";
                    } else {
                        print "have begun";
                    }
                    ;
                4:
                    print "had begun";
                    ;
                5:
                    print "will begin";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not begin";
                    } else {
                        print "do not begin";
                    }
                    ;
                2:
                    print "did not begin";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not begun";
                    } else {
                        print "have not begun";
                    }
                    ;
                4:
                    print "had not begun";
                    ;
                5:
                    print "will not begin";
                    ;
            }
            ;
    }
];
[ call_U1901 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1902 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ ConjugateVerb88 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ call_U1903 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1904 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ call_U1905 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ ConjugateVerb89 fn vp t modal_to;
    switch (fn) {
        1:
            print "understand";
            ;
        2:
            print "understood";
            ;
        3:
            print "understanding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "understands";
                    } else {
                        print "understand";
                    }
                    ;
                2:
                    print "understood";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has understood";
                    } else {
                        print "have understood";
                    }
                    ;
                4:
                    print "had understood";
                    ;
                5:
                    print "will understand";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not understand";
                    } else {
                        print "do not understand";
                    }
                    ;
                2:
                    print "did not understand";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not understood";
                    } else {
                        print "have not understood";
                    }
                    ;
                4:
                    print "had not understood";
                    ;
                5:
                    print "will not understand";
                    ;
            }
            ;
    }
];
[ call_U1906 fn vp t modal_to;
    (t = ConjugateVerb89(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1907 fn vp t modal_to;
    (t = ConjugateVerb89(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb90 fn vp t modal_to;
    switch (fn) {
        1:
            print "release";
            ;
        2:
            print "released";
            ;
        3:
            print "releasing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "releases";
                    } else {
                        print "release";
                    }
                    ;
                2:
                    print "released";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has released";
                    } else {
                        print "have released";
                    }
                    ;
                4:
                    print "had released";
                    ;
                5:
                    print "will release";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not release";
                    } else {
                        print "do not release";
                    }
                    ;
                2:
                    print "did not release";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not released";
                    } else {
                        print "have not released";
                    }
                    ;
                4:
                    print "had not released";
                    ;
                5:
                    print "will not release";
                    ;
            }
            ;
    }
];
[ call_U1908 fn vp t modal_to;
    (t = ConjugateVerb90(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1909 fn vp t modal_to;
    (t = ConjugateVerb90(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " along with";
];
[ ConjugateVerb91 fn vp t modal_to;
    switch (fn) {
        1:
            print "index";
            ;
        2:
            print "indexed";
            ;
        3:
            print "indexing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "indexes";
                    } else {
                        print "index";
                    }
                    ;
                2:
                    print "indexed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has indexed";
                    } else {
                        print "have indexed";
                    }
                    ;
                4:
                    print "had indexed";
                    ;
                5:
                    print "will index";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not index";
                    } else {
                        print "do not index";
                    }
                    ;
                2:
                    print "did not index";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not indexed";
                    } else {
                        print "have not indexed";
                    }
                    ;
                4:
                    print "had not indexed";
                    ;
                5:
                    print "will not index";
                    ;
            }
            ;
    }
];
[ call_U1910 fn vp t modal_to;
    (t = ConjugateVerb91(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1911 fn vp t modal_to;
    (t = ConjugateVerb91(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " map with";
];
[ ConjugateModalVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb92 fn vp t modal_to;
    switch (fn) {
        1:
            print "support";
            ;
        2:
            print "supported";
            ;
        3:
            print "supporting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record11;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "supports";
                    } else {
                        print "support";
                    }
                    ;
                2:
                    print "supported";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has supported";
                    } else {
                        print "have supported";
                    }
                    ;
                4:
                    print "had supported";
                    ;
                5:
                    print "will support";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not support";
                    } else {
                        print "do not support";
                    }
                    ;
                2:
                    print "did not support";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not supported";
                    } else {
                        print "have not supported";
                    }
                    ;
                4:
                    print "had not supported";
                    ;
                5:
                    print "will not support";
                    ;
            }
            ;
    }
];
[ call_U1912 fn vp t modal_to;
    (t = ConjugateVerb92(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record11;
    }
];
[ ConjugateModalVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb93 fn vp t modal_to;
    switch (fn) {
        1:
            print "incorporate";
            ;
        2:
            print "incorporated";
            ;
        3:
            print "incorporating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record12;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "incorporates";
                    } else {
                        print "incorporate";
                    }
                    ;
                2:
                    print "incorporated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has incorporated";
                    } else {
                        print "have incorporated";
                    }
                    ;
                4:
                    print "had incorporated";
                    ;
                5:
                    print "will incorporate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not incorporate";
                    } else {
                        print "do not incorporate";
                    }
                    ;
                2:
                    print "did not incorporate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not incorporated";
                    } else {
                        print "have not incorporated";
                    }
                    ;
                4:
                    print "had not incorporated";
                    ;
                5:
                    print "will not incorporate";
                    ;
            }
            ;
    }
];
[ call_U1913 fn vp t modal_to;
    (t = ConjugateVerb93(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record12;
    }
];
[ ConjugateModalVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb94 fn vp t modal_to;
    switch (fn) {
        1:
            print "enclose";
            ;
        2:
            print "enclosed";
            ;
        3:
            print "enclosing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record13;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "encloses";
                    } else {
                        print "enclose";
                    }
                    ;
                2:
                    print "enclosed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has enclosed";
                    } else {
                        print "have enclosed";
                    }
                    ;
                4:
                    print "had enclosed";
                    ;
                5:
                    print "will enclose";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not enclose";
                    } else {
                        print "do not enclose";
                    }
                    ;
                2:
                    print "did not enclose";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not enclosed";
                    } else {
                        print "have not enclosed";
                    }
                    ;
                4:
                    print "had not enclosed";
                    ;
                5:
                    print "will not enclose";
                    ;
            }
            ;
    }
];
[ call_U1914 fn vp t modal_to;
    (t = ConjugateVerb94(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record13;
    }
];
[ ConjugateVerb95 fn vp t modal_to;
    switch (fn) {
        1:
            print "carry";
            ;
        2:
            print "carried";
            ;
        3:
            print "carrying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record14;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "carries";
                    } else {
                        print "carry";
                    }
                    ;
                2:
                    print "carried";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has carried";
                    } else {
                        print "have carried";
                    }
                    ;
                4:
                    print "had carried";
                    ;
                5:
                    print "will carry";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not carry";
                    } else {
                        print "do not carry";
                    }
                    ;
                2:
                    print "did not carry";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not carried";
                    } else {
                        print "have not carried";
                    }
                    ;
                4:
                    print "had not carried";
                    ;
                5:
                    print "will not carry";
                    ;
            }
            ;
    }
];
[ call_U1915 fn vp t modal_to;
    (t = ConjugateVerb95(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record14;
    }
];
[ ConjugateVerb96 fn vp t modal_to;
    switch (fn) {
        1:
            print "hold";
            ;
        2:
            print "held";
            ;
        3:
            print "holding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record15;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "holds";
                    } else {
                        print "hold";
                    }
                    ;
                2:
                    print "held";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has held";
                    } else {
                        print "have held";
                    }
                    ;
                4:
                    print "had held";
                    ;
                5:
                    print "will hold";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hold";
                    } else {
                        print "do not hold";
                    }
                    ;
                2:
                    print "did not hold";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not held";
                    } else {
                        print "have not held";
                    }
                    ;
                4:
                    print "had not held";
                    ;
                5:
                    print "will not hold";
                    ;
            }
            ;
    }
];
[ call_U1916 fn vp t modal_to;
    (t = ConjugateVerb96(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record15;
    }
];
[ ConjugateVerb97 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to see";
            ;
        2:
            print "been able to see";
            ;
        3:
            print "being able to see";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record17;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can see";
                    ;
                2:
                    print "could see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to see";
                    } else {
                        print "have been able to see";
                    }
                    ;
                4:
                    print "had been able to see";
                    ;
                5:
                    print "will be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot see";
                    ;
                2:
                    print "could not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to see";
                    } else {
                        print "have not been able to see";
                    }
                    ;
                4:
                    print "had not been able to see";
                    ;
                5:
                    print "will not be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
    }
];
[ call_U1917 fn vp t modal_to;
    (t = ConjugateVerb97(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record17;
    }
];
[ ConjugateVerb98 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to touch";
            ;
        2:
            print "been able to touch";
            ;
        3:
            print "being able to touch";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record18;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can touch";
                    ;
                2:
                    print "could touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to touch";
                    } else {
                        print "have been able to touch";
                    }
                    ;
                4:
                    print "had been able to touch";
                    ;
                5:
                    print "will be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot touch";
                    ;
                2:
                    print "could not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to touch";
                    } else {
                        print "have not been able to touch";
                    }
                    ;
                4:
                    print "had not been able to touch";
                    ;
                5:
                    print "will not be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
    }
];
[ call_U1918 fn vp t modal_to;
    (t = ConjugateVerb98(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record18;
    }
];
[ ConjugateVerb99 fn vp t modal_to;
    switch (fn) {
        1:
            print "conceal";
            ;
        2:
            print "concealed";
            ;
        3:
            print "concealing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record19;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "conceals";
                    } else {
                        print "conceal";
                    }
                    ;
                2:
                    print "concealed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has concealed";
                    } else {
                        print "have concealed";
                    }
                    ;
                4:
                    print "had concealed";
                    ;
                5:
                    print "will conceal";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not conceal";
                    } else {
                        print "do not conceal";
                    }
                    ;
                2:
                    print "did not conceal";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not concealed";
                    } else {
                        print "have not concealed";
                    }
                    ;
                4:
                    print "had not concealed";
                    ;
                5:
                    print "will not conceal";
                    ;
            }
            ;
    }
];
[ call_U1919 fn vp t modal_to;
    (t = ConjugateVerb99(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record19;
    }
];
[ ConjugateModalVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb100 fn vp t modal_to;
    switch (fn) {
        1:
            print "die";
            ;
        2:
            print "died";
            ;
        3:
            print "dying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "dies";
                    } else {
                        print "die";
                    }
                    ;
                2:
                    print "died";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has died";
                    } else {
                        print "have died";
                    }
                    ;
                4:
                    print "had died";
                    ;
                5:
                    print "will die";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not die";
                    } else {
                        print "do not die";
                    }
                    ;
                2:
                    print "did not die";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not died";
                    } else {
                        print "have not died";
                    }
                    ;
                4:
                    print "had not died";
                    ;
                5:
                    print "will not die";
                    ;
            }
            ;
    }
];
[ call_U1920 fn vp t modal_to;
    (t = ConjugateVerb100(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb101 fn vp t modal_to;
    switch (fn) {
        1:
            print "need";
            ;
        2:
            print "needed";
            ;
        3:
            print "needing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "needs";
                    } else {
                        print "need";
                    }
                    ;
                2:
                    print "needed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has needed";
                    } else {
                        print "have needed";
                    }
                    ;
                4:
                    print "had needed";
                    ;
                5:
                    print "will need";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not need";
                    } else {
                        print "do not need";
                    }
                    ;
                2:
                    print "did not need";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not needed";
                    } else {
                        print "have not needed";
                    }
                    ;
                4:
                    print "had not needed";
                    ;
                5:
                    print "will not need";
                    ;
            }
            ;
    }
];
[ call_U1921 fn vp t modal_to;
    (t = ConjugateVerb101(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb102 fn vp t modal_to;
    switch (fn) {
        1:
            print "say";
            ;
        2:
            print "said";
            ;
        3:
            print "saying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "says";
                    } else {
                        print "say";
                    }
                    ;
                2:
                    print "said";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has said";
                    } else {
                        print "have said";
                    }
                    ;
                4:
                    print "had said";
                    ;
                5:
                    print "will say";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not say";
                    } else {
                        print "do not say";
                    }
                    ;
                2:
                    print "did not say";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not said";
                    } else {
                        print "have not said";
                    }
                    ;
                4:
                    print "had not said";
                    ;
                5:
                    print "will not say";
                    ;
            }
            ;
    }
];
[ call_U1922 fn vp t modal_to;
    (t = ConjugateVerb102(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ ConjugateVerb103 fn vp t modal_to;
    switch (fn) {
        1:
            print "win";
            ;
        2:
            print "won";
            ;
        3:
            print "winning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wins";
                    } else {
                        print "win";
                    }
                    ;
                2:
                    print "won";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has won";
                    } else {
                        print "have won";
                    }
                    ;
                4:
                    print "had won";
                    ;
                5:
                    print "will win";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not win";
                    } else {
                        print "do not win";
                    }
                    ;
                2:
                    print "did not win";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not won";
                    } else {
                        print "have not won";
                    }
                    ;
                4:
                    print "had not won";
                    ;
                5:
                    print "will not win";
                    ;
            }
            ;
    }
];
[ call_U1923 fn vp t modal_to;
    (t = ConjugateVerb103(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ Noun_Filter3 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter4 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter5 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter6 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U336(noun)));
];
[ call_U1924 t_0;
    if ((t_0 ofclass K2_thing)) {
        return ADJDEFN1(t_0);
    }
    rfalse;
];
[ call_U1925 t_0;
    if ((t_0 ofclass K16_passkey)) {
        return call_U1926(t_0);
    }
    rfalse;
];
[ call_U1926 const_0 x x_ix;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((const_0 == call_U1938(x))) {
            rtrue;
        }
    }
    rfalse;
];
[ ADJDEFN1 t_0;
    if ((actor == CarrierOf(t_0))) {
        rtrue;
    }
    if ((((SupporterOf(t_0) ofclass K17_keychain)) && ((actor == CarrierOf(SupporterOf(t_0)))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ ADJDEFN38 t_0;
    rfalse;
];
[ call_U1928 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1961)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1961;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U1930 forbid_breaks rv;
    (rv = (call_U1968)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1968;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U1931 forbid_breaks rv;
    (rv = (call_U1969)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1969;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U1933 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ A_unlocking_keylesslySub;
    return GenericVerbSub(rulebook_id_U366, rulebook_id_U367, rulebook_id_U368);
];
[ A_unlocking_keylesslyDbg n s for_say;
    print "unlocking keylessly";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U1934 forbid_breaks rv;
    (rv = (call_U1973)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1973;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U1935 forbid_breaks rv;
    (rv = (call_U1974)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1974;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U1937 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ A_locking_keylesslySub;
    return GenericVerbSub(rulebook_id_U369, rulebook_id_U370, rulebook_id_U371);
];
[ A_locking_keylesslyDbg n s for_say;
    print "locking keylessly";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U1938 X;
    if ((X ofclass K2_thing)) {
        return (X.P_unbolting_relation_storage);
    }
    rfalse;
];
[ call_U1939 L R;
    if ((((L ofclass K16_passkey)) && ((R ofclass K2_thing)))) {
        ((R.P_unbolting_relation_storage) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record3);
];
[ call_U1940 L R;
    if ((((L ofclass K16_passkey)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(R, A_P_unbolting_relation_storage, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record3);
];
[ call_U1941 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U1938(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = 0):0:) {
                    if ((call_U1941)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1941)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = 0):0:) {
                if ((call_U1941)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1941)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = 0):0:) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1941)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = 0):0:) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1941)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U1939(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U1940(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U1942 sk;
    rfalse;
];
[ call_U1943 sk;
    rfalse;
];
[ call_U1944 tmp_0;
    if ((((((action == ##Go)) && ((((actor == player)) && (((((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),((((MStack-->(MstVON(var_id_U42, 2))) ofclass K4_door)) && (((call_U309((MStack-->(MstVON(var_id_U42, 2))))) && (((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),1))))))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1944, 800, 0);
        }
        if (call_U72(use_option_id_U29)) {
            TryAction(0, player, ##Open, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U394));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Open, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U309(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1944, 800, 2);
        }
    }
    rfalse;
];
[ call_U1945;
    ResponseViaActivity(response_id_U394);
];
[ call_U1946 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "(first opening ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1947 tmp_0;
    if ((((((action == ##Lock)) && ((((actor == player)) && (((((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U306(noun)) && (((tmp_0 = noun),1))))))) && ((second ofclass K2_thing)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1947, 801, 0);
        }
        if (call_U72(use_option_id_U29)) {
            TryAction(0, player, ##Close, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U395));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Close, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U306(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1947, 801, 2);
        }
    }
    rfalse;
];
[ call_U1948;
    ResponseViaActivity(response_id_U395);
];
[ call_U1949 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "(first closing ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1950 tmp_0;
    if ((((((action == ##A_locking_keylessly)) && ((((actor == player)) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U306(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1950, 802, 0);
        }
        if (call_U72(use_option_id_U29)) {
            TryAction(0, player, ##Close, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U396));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Close, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U306(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1950, 802, 2);
        }
    }
    rfalse;
];
[ call_U1951;
    ResponseViaActivity(response_id_U396);
];
[ call_U1952 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "(first closing ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1953 tmp_0;
    if ((((((action == ##Open)) && ((((actor == player)) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U321(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1953, 803, 0);
        }
        if (call_U72(use_option_id_U29)) {
            TryAction(0, player, ##A_unlocking_keylessly, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U397));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##A_unlocking_keylessly, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U321(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1953, 803, 2);
        }
    }
    rfalse;
];
[ call_U1954;
    ResponseViaActivity(response_id_U397);
];
[ call_U1955 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print "(first unlocking ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1956 tmp_0;
    if ((((((action == ##Go)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),((((MStack-->(MstVON(var_id_U42, 2))) ofclass K4_door)) && (((call_U309((MStack-->(MstVON(var_id_U42, 2))))) && (((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),1))))))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1956, 804, 0);
        }
        TryAction(0, actor, ##Open, tmp_0, 0);
        if (call_U309(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1956, 804, 2);
        }
    }
    rfalse;
];
[ call_U1957 tmp_0;
    if ((((((action == ##Lock)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U306(noun)) && (((tmp_0 = noun),1))))))) && ((second ofclass K2_thing)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1957, 805, 0);
        }
        TryAction(0, actor, ##Close, tmp_0, 0);
        if (call_U306(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1957, 805, 2);
        }
    }
    rfalse;
];
[ call_U1958 tmp_0;
    if ((((((action == ##A_locking_keylessly)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U306(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1958, 806, 0);
        }
        TryAction(0, actor, ##Close, tmp_0, 0);
        if (call_U306(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1958, 806, 2);
        }
    }
    rfalse;
];
[ call_U1959 tmp_0;
    if ((((((action == ##Open)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U321(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1959, 807, 0);
        }
        TryAction(0, actor, ##A_unlocking_keylessly, tmp_0, 0);
        if (call_U321(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1959, 807, 2);
        }
    }
    rfalse;
];
[ call_U1960 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U1960, 808, 0);
    }
    if ((((call_U360(noun) ofclass K2_thing)) && (((((tmp_0 = call_U360(noun)),1)) && (IndirectlyContains(actor, call_U360(noun))))))) {
        (second = tmp_0);
        if (FollowRulebook(call_U1999)) {
            rtrue;
        }
    } else {
        if ((((call_U1938(noun) ofclass K16_passkey)) && (((call_U215(call_U1938(noun))) && (((tmp_0 = call_U1938(noun)),1)))))) {
            (second = tmp_0);
            if (FollowRulebook(call_U1999)) {
                rtrue;
            }
        } else {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                call_U2002(noun);
            }
            rtrue;
        }
    }
    rfalse;
];
[ call_U1961 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1961, 810, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U398));
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1961, 810, 2);
        }
    }
    rfalse;
];
[ call_U1962;
    ResponseViaActivity(response_id_U398);
];
[ call_U1963 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a key that fits ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1964;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1964, 812, 0);
        }
        if (FollowRulebook(call_U1999)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1964, 812, 3);
        }
    }
    rfalse;
];
[ call_U1965;
    if (debug_rules) {
        DB_Rule(call_U1965, 813, 0);
    }
    if ((~~((second == call_U360(noun))))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U399);
        print "^";
        rtrue;
    }
    rfalse;
];
[ call_U1966;
    ResponseViaActivity(response_id_U399);
];
[ call_U1967;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb59(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1968;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1968, 814, 0);
        }
        if (FollowRulebook(call_U1483)) {
            rtrue;
        }
        if (FollowRulebook(call_U1486)) {
            rtrue;
        }
        if (FollowRulebook(call_U1960)) {
            rtrue;
        }
        ((MStack-->(MstVO(var_id_U113, 0))) = second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1968, 814, 2);
        }
    }
    rfalse;
];
[ call_U1969;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1969, 815, 0);
        }
        if (call_U72(use_option_id_U29)) {
        } else {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U400);
            }
        }
        TryAction(0, actor, ##Unlock, noun, (MStack-->(MstVO(var_id_U113, 0))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1969, 815, 2);
        }
    }
    rfalse;
];
[ call_U1970;
    ResponseViaActivity(response_id_U400);
];
[ call_U1971;
    (say__p = 1);
    ParaContent();
    print "(with ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U113, 0))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1972;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1972, 816, 0);
        }
        if (FollowRulebook(call_U1999)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1972, 816, 3);
        }
    }
    rfalse;
];
[ call_U1973;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1973, 817, 0);
        }
        if (FollowRulebook(call_U1465)) {
            rtrue;
        }
        if (FollowRulebook(call_U1468)) {
            rtrue;
        }
        if (FollowRulebook(call_U1471)) {
            rtrue;
        }
        if (FollowRulebook(call_U1960)) {
            rtrue;
        }
        ((MStack-->(MstVO(var_id_U114, 0))) = second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1973, 817, 2);
        }
    }
    rfalse;
];
[ call_U1974;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1974, 818, 0);
        }
        if (call_U72(use_option_id_U29)) {
        } else {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U401);
            }
        }
        TryAction(0, actor, ##Lock, noun, (MStack-->(MstVO(var_id_U114, 0))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1974, 818, 2);
        }
    }
    rfalse;
];
[ call_U1975;
    ResponseViaActivity(response_id_U401);
];
[ call_U1976;
    (say__p = 1);
    ParaContent();
    print "(with ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U114, 0))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1977 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K16_passkey)) && (((call_U1925(parameter_value)) && (((tmp_0 = parameter_value),1))))))) || (((tmp_0 = 0),0)))) {
        if ((((action == ##Inv)) && ((actor == player)))) {
            if (debug_rules) {
                DB_Rule(call_U1977, 820, 0);
            }
            (prior_named_noun = tmp_0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U402));
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1977, 820, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1977, 820, 2);
        }
    }
    rfalse;
];
[ call_U1978;
    ResponseViaActivity(response_id_U402);
];
[ call_U1979 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    print " (which ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    objectloop (tmp_1 ofclass Object && (tmp_1 ofclass Object)) {
        if ((((tmp_1 ofclass K2_thing)) && ((tmp_0 == call_U1938(tmp_1))))) {
            give tmp_1 workflag2;
        } else {
            give tmp_1 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1980;
    if ((((action == ##Examine)) && ((((actor == player)) && ((((noun ofclass K16_passkey)) && (call_U1925(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1980, 821, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U403);
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1980, 821, 2);
        }
    }
    rfalse;
];
[ call_U1981;
    ResponseViaActivity(response_id_U403);
];
[ call_U1982 tmp_0;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((noun == call_U1938(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1983;
    if ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1983, 822, 0);
        }
        if ((second == call_U360(noun))) {
            call_U1939(second, noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1983, 822, 2);
        }
    }
    rfalse;
];
[ call_U1984;
    if ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1984, 823, 0);
        }
        call_U1939(second, noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1984, 823, 2);
        }
    }
    rfalse;
];
[ call_U1985;
    if ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1985, 824, 0);
        }
        if ((second == call_U360(noun))) {
            call_U1939(second, noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1985, 824, 2);
        }
    }
    rfalse;
];
[ call_U1986;
    if ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1986, 825, 0);
        }
        call_U1939(second, noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1986, 825, 2);
        }
    }
    rfalse;
];
[ call_U1987;
    if ((((action == ##PutOn)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((~~((noun ofclass K16_passkey)))))) && ((second ofclass K17_keychain)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1987, 826, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U404);
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1987, 826, 2);
        }
    }
    rfalse;
];
[ call_U1988;
    ResponseViaActivity(response_id_U404);
];
[ call_U1989;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " not a key.";
    rtrue;
];
[ call_U1990;
    if (debug_rules) {
        DB_Rule(call_U1990, 827, 0);
    }
    if ((((((action == ##Lock)) && ((actor == player)))) || ((((action == ##Unlock)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((((second ofclass K2_thing)) && ((((SupporterOf(second) ofclass K17_keychain)) && ((actor == CarrierOf(SupporterOf(second)))))))))))))))) {
        rfalse;
    }
    if (FollowRulebook(CARRYING_REQUIREMENTS_R)) {
        rtrue;
    }
    rfalse;
];
[ call_U1991;
    if ((((parameter_value ofclass K16_passkey)) && ((SupporterOf(parameter_value) ofclass K17_keychain)))) {
        if (debug_rules) {
            DB_Rule(call_U1991, 828, 0);
        }
        if ((~~((second ofclass K17_keychain)))) {
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1991, 828, 2);
        }
    }
    rfalse;
];
[ call_U1992;
    if (debug_rules) {
        DB_Rule(call_U1992, 829, 0);
    }
    if (call_U72(use_option_id_U29)) {
        if ((player == actor)) {
            TryAction(0, player, ##Take, noun, 0);
        } else {
            TryAction(0, actor, ##Take, noun, 0);
        }
    } else {
        CarryOutActivity(V28_implicitly_taking, noun);
    }
    rfalse;
];
[ call_U1993;
    if (debug_rules) {
        DB_Rule(call_U1993, 830, 0);
    }
    if (call_U72(use_option_id_U29)) {
        if ((player == actor)) {
            TryAction(0, player, ##Take, second, 0);
        } else {
            TryAction(0, actor, ##Take, second, 0);
        }
    } else {
        CarryOutActivity(V28_implicitly_taking, second);
    }
    rfalse;
];
[ call_U1994;
    if (debug_rules) {
        DB_Rule(call_U1994, 831, 0);
    }
    if ((~~((actor == OwnerOf(noun))))) {
        FollowRulebook(call_U1992);
    }
    if ((~~((actor == OwnerOf(noun))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U1995;
    if (debug_rules) {
        DB_Rule(call_U1995, 832, 0);
    }
    if ((~~((actor == OwnerOf(second))))) {
        FollowRulebook(call_U1993);
    }
    if ((~~((actor == OwnerOf(second))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U1996 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U1996, 833, 0);
    }
    if ((~~(call_U1924(noun)))) {
        if ((((SupporterOf(noun) ofclass K17_keychain)) && (((tmp_0 = SupporterOf(noun)),1)))) {
            (noun = tmp_0);
        }
        FollowRulebook(call_U1992);
    }
    if ((~~(call_U1924(noun)))) {
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U405));
            print "^";
        }
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U1997;
    ResponseViaActivity(response_id_U405);
];
[ call_U1998 tmp_0;
    (say__p = 1);
    ParaContent();
    print "Without holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ", ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " do nothing.";
    rtrue;
];
[ call_U1999 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1999, 834, 0);
    }
    if ((~~(call_U1924(second)))) {
        (tmp_0 = second);
        if ((((SupporterOf(second) ofclass K17_keychain)) && (((tmp_1 = SupporterOf(second)),1)))) {
            (second = tmp_1);
        }
        FollowRulebook(call_U1993);
        (second = tmp_0);
    }
    if ((~~(call_U1924(second)))) {
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U406)));
            print "^";
        }
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2000;
    ResponseViaActivity(response_id_U406);
];
[ call_U2001 tmp_0 tmp_1;
    (say__p = 1);
    ParaContent();
    print "Without holding ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ", ";
    ParaContent();
    call_U170();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " do nothing.";
    rtrue;
];
[ call_U2002 t_0;
    CarryOutActivity(V35_refusing_keys, t_0);
    rfalse;
];
[ ConjugateVerb59 fn vp t modal_to;
    switch (fn) {
        1:
            print "fit";
            ;
        2:
            print "fitted";
            ;
        3:
            print "fitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "fits";
                    } else {
                        print "fit";
                    }
                    ;
                2:
                    print "fitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has fitted";
                    } else {
                        print "have fitted";
                    }
                    ;
                4:
                    print "had fitted";
                    ;
                5:
                    print "will fit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not fit";
                    } else {
                        print "do not fit";
                    }
                    ;
                2:
                    print "did not fit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not fitted";
                    } else {
                        print "have not fitted";
                    }
                    ;
                4:
                    print "had not fitted";
                    ;
                5:
                    print "will not fit";
                    ;
            }
            ;
    }
];
[ call_U2003 fn vp t modal_to;
    (t = ConjugateVerb59(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb53 fn vp t modal_to;
    switch (fn) {
        1:
            print "open";
            ;
        2:
            print "opened";
            ;
        3:
            print "opening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "opens";
                    } else {
                        print "open";
                    }
                    ;
                2:
                    print "opened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has opened";
                    } else {
                        print "have opened";
                    }
                    ;
                4:
                    print "had opened";
                    ;
                5:
                    print "will open";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not open";
                    } else {
                        print "do not open";
                    }
                    ;
                2:
                    print "did not open";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not opened";
                    } else {
                        print "have not opened";
                    }
                    ;
                4:
                    print "had not opened";
                    ;
                5:
                    print "will not open";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb54 fn vp t modal_to;
    switch (fn) {
        1:
            print "lack";
            ;
        2:
            print "lacked";
            ;
        3:
            print "lacking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "lacks";
                    } else {
                        print "lack";
                    }
                    ;
                2:
                    print "lacked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has lacked";
                    } else {
                        print "have lacked";
                    }
                    ;
                4:
                    print "had lacked";
                    ;
                5:
                    print "will lack";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lack";
                    } else {
                        print "do not lack";
                    }
                    ;
                2:
                    print "did not lack";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not lacked";
                    } else {
                        print "have not lacked";
                    }
                    ;
                4:
                    print "had not lacked";
                    ;
                5:
                    print "will not lack";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb55 fn vp t modal_to;
    switch (fn) {
        1:
            print "lock";
            ;
        2:
            print "locked";
            ;
        3:
            print "locking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "locks";
                    } else {
                        print "lock";
                    }
                    ;
                2:
                    print "locked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has locked";
                    } else {
                        print "have locked";
                    }
                    ;
                4:
                    print "had locked";
                    ;
                5:
                    print "will lock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lock";
                    } else {
                        print "do not lock";
                    }
                    ;
                2:
                    print "did not lock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not locked";
                    } else {
                        print "have not locked";
                    }
                    ;
                4:
                    print "had not locked";
                    ;
                5:
                    print "will not lock";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb56 fn vp t modal_to;
    switch (fn) {
        1:
            print "unlock";
            ;
        2:
            print "unlocked";
            ;
        3:
            print "unlocking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unlocks";
                    } else {
                        print "unlock";
                    }
                    ;
                2:
                    print "unlocked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unlocked";
                    } else {
                        print "have unlocked";
                    }
                    ;
                4:
                    print "had unlocked";
                    ;
                5:
                    print "will unlock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unlock";
                    } else {
                        print "do not unlock";
                    }
                    ;
                2:
                    print "did not unlock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unlocked";
                    } else {
                        print "have not unlocked";
                    }
                    ;
                4:
                    print "had not unlocked";
                    ;
                5:
                    print "will not unlock";
                    ;
            }
            ;
    }
];
[ ConjugateVerb104 fn vp t modal_to;
    switch (fn) {
        1:
            print "unbolt";
            ;
        2:
            print "unbolted";
            ;
        3:
            print "unbolting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record3;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unbolts";
                    } else {
                        print "unbolt";
                    }
                    ;
                2:
                    print "unbolted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unbolted";
                    } else {
                        print "have unbolted";
                    }
                    ;
                4:
                    print "had unbolted";
                    ;
                5:
                    print "will unbolt";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unbolt";
                    } else {
                        print "do not unbolt";
                    }
                    ;
                2:
                    print "did not unbolt";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unbolted";
                    } else {
                        print "have not unbolted";
                    }
                    ;
                4:
                    print "had not unbolted";
                    ;
                5:
                    print "will not unbolt";
                    ;
            }
            ;
    }
];
[ call_U2004 fn vp t modal_to;
    (t = ConjugateVerb104(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record3;
    }
];
[ Noun_Filter1 x;
    (x = noun);
    return (noun ofclass K16_passkey);
];
[ Noun_Filter2 x;
    (x = noun);
    return (noun ofclass K17_keychain);
];
[ Noun_Filter7 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U324(noun)) && (call_U318(noun)))));
];
[ Noun_Filter8 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U318(noun)));
];
[ Noun_Filter9 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U324(noun)) && (call_U318(noun)))));
];
[ Noun_Filter10 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U318(noun)));
];
[ Noun_Filter11 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U321(noun)) && (call_U318(noun)))));
];
[ Noun_Filter12 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U318(noun)));
];
[ Noun_Filter13 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U321(noun)) && (call_U318(noun)))));
];
[ Noun_Filter14 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U318(noun)));
];
[ Noun_Filter16 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U321(noun)) && (call_U318(noun)))));
];
[ Noun_Filter17 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U318(noun)));
];
[ call_U2006 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2008)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2008;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2008;
    if (debug_rules) {
        DB_Rule(call_U2008, 841, 0);
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(as_block_constant_U407);
    print "^";
    SPACEPause();
    VM_ClearScreen(0);
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2009;
    ResponseViaActivity(response_id_U407);
];
[ call_U2010;
    (say__p = 1);
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Please press SPACE to continue.";
    rtrue;
];
[ call_U2011;
    (say__p = 1);
    ParaContent();
    PrintShortName(real_location);
    rtrue;
];
[ call_U2012;
    (say__p = 1);
    ParaContent();
    print (say__n = score);
    ParaContent();
    print "/";
    ParaContent();
    print (say__n = turns);
    rtrue;
];
[ call_U2013;
    CarryOutActivity(V36_pausing_the_game);
    rfalse;
];
[ call_U2014 t_0 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U4(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U4 t_0 tmp_0 tmp_1 ct_0 ct_1 tmp_2 tmp_3;
    (tmp_0 = TableRows(t_0));
    DeepStatus(tmp_0);
    (tmp_1 = 1);
    @push ct_0;
    @push ct_1;
    for (((tmp_2 = t_0),((tmp_3 = 1),((ct_0 = tmp_2),(ct_1 = tmp_3)))):(tmp_3 <= TableRows(tmp_2)):((tmp_3)++,((ct_0 = tmp_2),(ct_1 = tmp_3)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            I7VM_MoveCursorInStatusLine(tmp_1);
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U8, ct_1)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U8, ct_1));
            }
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U9, ct_1)) {
                CenterPrint(BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0, table_column_id_U9, ct_1)), tmp_1);
            }
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U10, ct_1)) {
                RightAlign(tmp_1);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
            }
            (tmp_1 = (tmp_1 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U2016 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2022)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2022;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2018;
    if (debug_rules) {
        DB_Rule(call_U2018, 853, 0);
    }
    ((Global_Vars-->51) = ((Global_Vars-->51) - 1));
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U2019;
    if (debug_rules) {
        DB_Rule(call_U2019, 854, 0);
    }
    if (((Global_Vars-->55) < TableFilledRows((Global_Vars-->54)))) {
        ((Global_Vars-->55) = ((Global_Vars-->55) + 1));
    }
    call_U2028((Global_Vars-->54));
    rfalse;
    rfalse;
];
[ call_U2020;
    if (debug_rules) {
        DB_Rule(call_U2020, 855, 0);
    }
    if (((Global_Vars-->55) > 1)) {
        ((Global_Vars-->55) = ((Global_Vars-->55) - 1));
    }
    call_U2028((Global_Vars-->54));
    rfalse;
    rfalse;
];
[ call_U2021 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U5());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U5 ct_0 ct_1 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2021, 856, 0);
    }
    (ct_0 = (Global_Vars-->54));
    (ct_1 = (Global_Vars-->55));
    if (ExistsTableLookUpEntry(ct_0, table_column_id_U14, ct_1)) {
        FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U14, ct_1));
        call_U2028((Global_Vars-->54));
    } else {
        if (ExistsTableLookUpEntry(ct_0, table_column_id_U12, ct_1)) {
            BlkValueCopy((Global_Vars-->53), TableLookUpEntry(ct_0, table_column_id_U11, ct_1));
            ((Global_Vars-->55) = 1);
            ((Global_Vars-->54) = TableLookUpEntry(ct_0, table_column_id_U12, ct_1));
            call_U2029();
        } else {
            (tmp_0 = I7SFRAME);
            BlkValueCopy(tmp_0, (Global_Vars-->53));
            BlkValueCopy((Global_Vars-->53), TableLookUpEntry(ct_0, table_column_id_U11, ct_1));
            ((Global_Vars-->52) = 1);
            DrawStatusLine();
            ((Global_Vars-->52) = 0);
            VM_ClearScreen(2);
            (say__p = 1);
            ParaContent();
            if (1) { font on; } else { font off; }ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U13, ct_1));
            ParaContent();
            DivideParagraphPoint();
            print "^";
            call_U2013();
            BlkValueCopy((Global_Vars-->53), tmp_0);
            call_U2028((Global_Vars-->54));
        }
    }
    rfalse;
];
[ call_U2022;
    if (debug_rules) {
        DB_Rule(call_U2022, 860, 0);
    }
    ((Global_Vars-->55) = 1);
    call_U2029();
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2023;
    if (TestActivity(V37_displaying)) {
        if (debug_rules) {
            DB_Rule(call_U2023, 861, 0);
        }
        if (((Global_Vars-->52) == 0)) {
            call_U2014(table_data_U7);
        } else {
            call_U2014(table_data_U6);
        }
        RulebookSucceeds();
        rtrue;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2023, 861, 4);
        }
    }
    rfalse;
];
[ call_U2024 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U6());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U6 ct_0 ct_1 tmp_0 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U2024, 864, 0);
    }
    (ct_0 = (Global_Vars-->54));
    (ct_1 = (Global_Vars-->55));
    (tmp_0 = I7SFRAME);
    BlkValueCopy(tmp_0, (Global_Vars-->53));
    BlkValueCopy((Global_Vars-->53), TableLookUpEntry(ct_0, table_column_id_U11, ct_1));
    ((Global_Vars-->52) = 1);
    DrawStatusLine();
    ((Global_Vars-->52) = 0);
    (say__p = 1);
    ParaContent();
    call_U2030(TableLookUpEntry(ct_0, table_column_id_U12, ct_1));
    (tmp_1 = 0);
    while ((tmp_1 < 1)) {
        (tmp_2 = VM_KeyChar());
        if ((((tmp_2 == 13)) || ((((tmp_2 == 31)) || ((tmp_2 == 32)))))) {
            (tmp_1 = 1);
        }
        if ((((tmp_2 == 72)) || ((tmp_2 == 104)))) {
            (say__p = 1);
            ParaContent();
            call_U2031(TableLookUpEntry(ct_0, table_column_id_U12, ct_1));
        }
    }
    BlkValueCopy((Global_Vars-->53), tmp_0);
    rfalse;
];
[ call_U2025;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((Global_Vars-->53));
    rtrue;
];
[ call_U2026;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((Global_Vars-->53));
    rtrue;
];
[ call_U2027;
    (say__p = 1);
    ParaContent();
    print "Q = ";
    if ((~~(((Global_Vars-->51) > 1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Last Menu";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Quit Menu";
    .L_SayX0;
    rtrue;
];
[ call_U2028 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    DrawStatusLine();
    (say__p = 1);
    ParaContent();
    if (0) { font on; } else { font off; }(tmp_0 = 1);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((tmp_0 == (Global_Vars-->55))) {
                (say__p = 1);
                ParaContent();
                print " >";
            } else {
                (say__p = 1);
                ParaContent();
                print "  ";
            }
            (say__p = 1);
            ParaContent();
            print " ";
            ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U11, ct_1));
            ParaContent();
            print "^";
            (tmp_0 = (tmp_0 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    if (1) { font on; } else { font off; }rfalse;
];
[ call_U2029 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U7());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U7 tmp_0 tmp_1 tmp_2 tmp_3 tmp_4 tmp_5 ct_0 ct_1 tmp_6 tmp_7;
    ((Global_Vars-->51) = ((Global_Vars-->51) + 1));
    (tmp_0 = (Global_Vars-->51));
    (tmp_1 = (Global_Vars-->54));
    (tmp_2 = I7SFRAME);
    BlkValueCopy(tmp_2, (Global_Vars-->53));
    (tmp_3 = 0);
    (tmp_4 = 0);
    while ((~~((tmp_4 == 1)))) {
        ((Global_Vars-->54) = tmp_1);
        (tmp_5 = 0);
        @push ct_0;
        @push ct_1;
        for (((tmp_6 = (Global_Vars-->54)),((tmp_7 = 1),((ct_0 = tmp_6),(ct_1 = tmp_7)))):(tmp_7 <= TableRows(tmp_6)):((tmp_7)++,((ct_0 = tmp_6),(ct_1 = tmp_7)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                (tmp_5 = (tmp_5 + 1));
                if (((BlkValueCompare)(TableLookUpEntry(ct_0, table_column_id_U11, ct_1),(Global_Vars-->53)) == 0)) {
                    ((Global_Vars-->55) = tmp_5);
                }
            }
        }
        @pull ct_1;
        @pull ct_0;
        BlkValueCopy((Global_Vars-->53), tmp_2);
        call_U2028((Global_Vars-->54));
        (tmp_3 = VM_KeyChar());
        if (((1) && ((ct_1 = ExistsTableRowCorr((ct_0 = table_data_U5), table_column_id_U15, tmp_3))))) {
            FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U16, ct_1));
            if ((tmp_0 > (Global_Vars-->51))) {
                (tmp_4 = 1);
            }
        }
    }
    rfalse;
];
[ call_U2030 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    (tmp_0 = 0);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            (tmp_0 = (tmp_0 + 1));
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U18, ct_1)) {
                (say__p = 1);
                ParaContent();
                print (say__n = tmp_0);
                ParaContent();
                print "/";
                ParaContent();
                print (say__n = TableRows(t_0));
                ParaContent();
                print ": ";
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
            } else {
                if ((tmp_0 == 1)) {
                    (TableLookUpEntry)(ct_0,table_column_id_U18,ct_1,1,turns);
                    (say__p = 1);
                    ParaContent();
                    print (say__n = tmp_0);
                    ParaContent();
                    print "/";
                    ParaContent();
                    print (say__n = TableRows(t_0));
                    ParaContent();
                    print ": ";
                    ParaContent();
                    TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    print "Press SPACE to return to the menu or H to reveal another hint.";
    print "^";
    rfalse;
];
[ call_U2031 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    (tmp_0 = 0);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            (tmp_0 = (tmp_0 + 1));
            (say__p = 1);
            ParaContent();
            print (say__n = tmp_0);
            ParaContent();
            print "/";
            ParaContent();
            print (say__n = TableRows(t_0));
            ParaContent();
            print ": ";
            ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
            ParaContent();
            DivideParagraphPoint();
            print "^";
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U18, ct_1)) {
            } else {
                (TableLookUpEntry)(ct_0,table_column_id_U18,ct_1,1,turns);
                (say__p = 1);
                ParaContent();
                print "Press SPACE to return to the menu";
                ParaContent();
                if ((~~((tmp_0 < TableRows(t_0))))) {
                    jump L_Say1;
                }
                ParaContent();
                print " or H to reveal another hint";
                .L_Say1;
                ParaContent();
                print ".";
                print "^";
                rfalse;
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    print "Press SPACE to return to the menu";
    ParaContent();
    if ((~~((tmp_0 < TableRows(t_0))))) {
        jump L_Say3;
    }
    ParaContent();
    print " or H to reveal another hint";
    .L_Say3;
    ParaContent();
    print ".";
    print "^";
    rfalse;
];
[ call_U2033 forbid_breaks rv;
    (rv = (call_U2041)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2041;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_asking_for_helpSub;
    return GenericVerbSub(rulebook_id_U378, rulebook_id_U379, rulebook_id_U380);
];
[ A_asking_for_helpDbg n s for_say;
    print "asking for help";
];
[ call_U2035 sk;
    return I_brief_U1;
];
[ E8 value;
    switch (value) {
        I_brief_U1:
            print "brief";
            ;
        I_verbose_U1:
            print "verbose";
            ;
        I_superbrief_U1:
            print "superbrief";
            ;
        default:
            print "<illegal verbosity>";
            ;
    }
];
[ call_U2036 x;
    return ((x%3) + 1);
];
[ call_U2037 x;
    return (((x + 1)%3) + 1);
];
[ call_U2038 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2039;
    if (debug_rules) {
        DB_Rule(call_U2039, 866, 0);
    }
    if (notify_mode) {
        TryAction(0, player, ##NotifyOff, 0, 0);
    } else {
        TryAction(0, player, ##NotifyOn, 0, 0);
    }
    rfalse;
];
[ call_U2040;
    if (debug_rules) {
        DB_Rule(call_U2040, 867, 0);
    }
    if ((call_U2042() == I_verbose_U1)) {
        TryAction(0, player, ##LMode1, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    if ((call_U2042() == I_brief_U1)) {
        TryAction(0, player, ##LMode3, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    if ((call_U2042() == I_superbrief_U1)) {
        TryAction(0, player, ##LMode2, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U2041;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2041, 870, 0);
        }
        ((Global_Vars-->54) = table_data_U9);
        CarryOutActivity(V37_displaying);
        VM_ClearScreen(0);
        TryAction(0, player, ##Look, 0, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2041, 870, 3);
        }
    }
    rfalse;
];
[ call_U2042 tmp_0;
    (tmp_0 = lookmode);
    if ((tmp_0 == 1)) {
        return I_brief_U1;
    }
    if ((tmp_0 == 2)) {
        return I_verbose_U1;
    }
    if ((tmp_0 == 3)) {
        return I_superbrief_U1;
    }
    return I_brief_U1;
];
[ call_U2043;
    (say__p = 1);
    ParaContent();
    print "Introduction to ";
    ParaContent();
    TEXT_TY_Say(bc_U191);
    rtrue;
];
[ call_U2044;
    (say__p = 1);
    ParaContent();
    print "This is a simple demonstration ";
    ParaContent();
    TEXT_TY_Say(bc_U193);
    ParaContent();
    print " game.";
    rtrue;
];
[ call_U2045;
    (say__p = 1);
    ParaContent();
    print "What to do with ";
    ParaContent();
    TEXT_TY_Say((Global_Vars-->22));
    rtrue;
];
[ call_U2046;
    (say__p = 1);
    ParaContent();
    print "The ";
    ParaContent();
    TEXT_TY_Say((Global_Vars-->22));
    ParaContent();
    print " sign is where the game says, ~Okay, what do you want to do now?~  You may respond by typing an instruction -- usually an imperative verb, possibly followed by prepositions and objects.  So, for instance, LOOK, LOOK AT FISH, TAKE FISH.";
    rtrue;
];
[ call_U2047;
    (say__p = 1);
    ParaContent();
    print "The first thing you want to do when starting a game is acquaint yourself with your surroundings and get a sense of your goal. To this end, you should read the introductory text carefully. Sometimes it contains clues. You will also want to look at the room you are in. Notice where the exits from the room are, and what objects are described here. If any of these seem interesting, you may want to EXAMINE them. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "You might also want to examine yourself (EXAMINE ME) to see whether the author has left you any clues about your character. TAKE INVENTORY will tell you what you're carrying, as well.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Once you've gotten your bearings, you may want to explore. Move from room to room, and check out every location available.";
    rtrue;
];
[ call_U2048;
    (say__p = 1);
    ParaContent();
    print "At any given time, you are in a specific location, or room. When you go into a room, the game will print a description of what you can see there. This description will contain two vital kinds of information: things in the room you can interact with or take, and a list of exits, or ways out. If you want to see the description again, you may just type LOOK. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "When you want to leave a location and go to another one, you may communicate this to the game using compass directions: eg, GO NORTH. For simplicity's sake, you are allowed to omit the word GO, and to abbreviate the compass directions. So you may use NORTH, SOUTH, EAST, WEST, NORTHEAST, SOUTHEAST, NORTHWEST, SOUTHWEST, UP, and DOWN, or in short form N, S, E, W, NE, SE, NW, SW, U, and D.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "In some locations, IN and OUT will also be useful.";
    rtrue;
];
[ call_U2049;
    (say__p = 1);
    ParaContent();
    print "Throughout the game there will be assorted objects that you can do things with. Most importantly, you may TAKE or GET items, and (when you are tired of them) DROP them again. INVENTORY (abbreviated I) will list the items you are currently holding. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "There are usually assorted things you may do with these objects. OPEN, CLOSE, WEAR, EAT, LOCK, and UNLOCK are especially common.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Occasionally, you will find that the game does not recognize the name of an object even though it has been described as being in the room with you. If this is the case, the object is just there for scenery, and you may assume that you do not need to interact with it.";
    rtrue;
];
[ call_U2050;
    (say__p = 1);
    ParaContent();
    print "There are a few simple commands for controlling the game itself. These are: ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "SAVE saves a snapshot of the game as it is now. ";
    ParaContent();
    print "^";
    ParaContent();
    print "RESTORE puts the game back to a previous saved state. You may keep as many saved games as you like. ";
    ParaContent();
    print "^";
    ParaContent();
    print "RESTART puts the game back to the way it was at the beginning. ";
    ParaContent();
    print "^";
    ParaContent();
    print "QUIT ends the game.";
    rtrue;
];
[ call_U2051;
    (say__p = 1);
    ParaContent();
    print "Examine every object and look at everything in your inventory. Open all the doors you can find, and go through them. Look inside all closed containers. Make sure you've exhausted all the options in your environment. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Try out all your senses. If the game mentions texture, odor, or sound, try touching, smelling, listening to, or tasting objects.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Be thorough. If you still can't figure out what to do, try opening windows, looking under beds, etc. Sometimes objects are well-hidden.";
    rtrue;
];
[ call_U2052;
    (say__p = 1);
    ParaContent();
    print "Reread. Look back at things you've already looked at. Sometimes this will trigger an idea you hadn't thought of. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Take hints from the prose of the game. Things that are described in great detail are probably more important than things that are given one-liners. Play with those objects. If a machine is described as having component parts, look at the parts, and try manipulating them.  Likewise, notice the verbs that the game itself uses. Try using those yourself. Games often include special verbs -- the names of magic spells, or other special commands. There's no harm in attempting something if the game mentions it.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Check the whole screen. Are there extra windows besides the main window?  What's going on in those?  Check out the status bar, if there is one -- it may contain the name of the room you're in, your score, the time of day, your character's state of health, or some other important information.  If there's something up there, it's worth paying attention to that, too.  When and where does it change?  Why is it significant?  If the bar is describing your character's health, you can bet there is probably a point at which that will be important.";
    rtrue;
];
[ call_U2053;
    (say__p = 1);
    ParaContent();
    print "Rephrase. If there's something you want to do, but the game doesn't seem to understand you, try alternative wordings. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Try variations. Sometimes an action doesn't work, but does produce some kind of unusual result. These are often indications that you're on the right track, even if you haven't figured out quite the right approach yet. Pressing the red button alone may only cause a grinding noise from inside the wall, so perhaps pressing the blue and then the red will open the secret door.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Consider the genre of the game. Mysteries, romances, and thrillers all have their own types of action and motivation. What are you trying to do, and how do conventional characters go about doing that? What's the right sort of behavior for a detective/romance heroine/spy?";
    rtrue;
];
[ call_U2054;
    (say__p = 1);
    if ((~~((call_U2042() == I_verbose_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Verbose room descriptions";
    .L_Say0;
    if ((~~((call_U2042() == I_brief_U1)))) {
        jump L_Say1;
    }
    ParaContent();
    print "Brief room descriptions";
    .L_Say1;
    if ((~~((call_U2042() == I_superbrief_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "Superbrief room descriptions";
    .L_Say2;
    rtrue;
];
[ call_U2055;
    (say__p = 1);
    if ((~~(notify_mode))) {
        jump L_Say0;
    }
    ParaContent();
    print "Score notification on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Score notification off";
    .L_SayX0;
    rtrue;
];
[ call_U2056 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (((t_0 ofclass K14_vehicle)) || ((((t_0 ofclass K18_rideable_animal)) || ((t_0 ofclass K19_rideable_vehicle)))));
    }
    rfalse;
];
[ ADJDEFN39 t_0;
    rfalse;
];
[ call_U2057 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2071)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2071;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2074)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2074;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2077)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2077;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2080)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2080;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2081)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2081;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2058 forbid_breaks rv;
    (rv = (call_U2082)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2082;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2059 forbid_breaks rv;
    (rv = (call_U2083)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2083;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_mountingSub;
    return GenericVerbSub(rulebook_id_U381, rulebook_id_U382, rulebook_id_U383);
];
[ A_mountingDbg n s for_say;
    print "mounting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2060 forbid_breaks rv;
    (rv = (call_U2097)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2097;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2061 forbid_breaks rv;
    (rv = (call_U2102)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2102;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2062 forbid_breaks rv;
    (rv = (call_U2103)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2103;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_dismountingSub;
    return GenericVerbSub(rulebook_id_U384, rulebook_id_U385, rulebook_id_U386);
];
[ A_dismountingDbg n s for_say;
    print "dismounting";
];
[ call_U2063 sk;
    rfalse;
];
[ call_U2064 sk;
    rfalse;
];
[ call_U2065 tmp_0 tmp_1;
    if ((action == ##Go)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2065, 872, 0);
        }
        if ((((CarrierOf(actor) ofclass K18_rideable_animal)) && (((tmp_0 = CarrierOf(actor)),1)))) {
            ((MStack-->(MstVO(var_id_U42, 3))) = tmp_0);
        }
        if ((((SupporterOf(actor) ofclass K19_rideable_vehicle)) && (((tmp_1 = SupporterOf(actor)),1)))) {
            ((MStack-->(MstVO(var_id_U42, 3))) = tmp_1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2065, 872, 2);
        }
    }
    rfalse;
];
[ call_U2066 tmp_0;
    if ((((((action == ##Enter)) && ((((act_requester == 0)) && (((tmp_0 = noun),(((noun ofclass K18_rideable_animal)) && (((tmp_0 = noun),1))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2066, 873, 0);
        }
        TryAction(0, actor, ##A_mounting, tmp_0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2066, 873, 2);
        }
    }
    rfalse;
];
[ call_U2067 tmp_0;
    if ((((((action == ##Enter)) && ((((act_requester == 0)) && (((tmp_0 = noun),(((noun ofclass K19_rideable_vehicle)) && (((tmp_0 = noun),1))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2067, 874, 0);
        }
        TryAction(0, actor, ##A_mounting, tmp_0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2067, 874, 2);
        }
    }
    rfalse;
];
[ call_U2068 tmp_0;
    if ((((((action == ##GetOff)) && ((((act_requester == 0)) && (((tmp_0 = noun),(((noun ofclass K18_rideable_animal)) && (((tmp_0 = noun),1))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2068, 875, 0);
        }
        TryAction(0, actor, ##A_dismounting, 0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2068, 875, 2);
        }
    }
    rfalse;
];
[ call_U2069 tmp_0;
    if ((((((action == ##GetOff)) && ((((act_requester == 0)) && (((tmp_0 = noun),(((noun ofclass K19_rideable_vehicle)) && (((tmp_0 = noun),1))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2069, 876, 0);
        }
        TryAction(0, actor, ##A_dismounting, 0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2069, 876, 2);
        }
    }
    rfalse;
];
[ call_U2070;
    if ((((action == ##Exit)) && ((act_requester == 0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2070, 877, 0);
        }
        if ((CarrierOf(actor) ofclass K18_rideable_animal)) {
            TryAction(0, actor, ##A_dismounting, 0, 0);
            rtrue;
        }
        if ((((CarrierOf(actor) ofclass K19_rideable_vehicle)) && ((CarrierOf(actor) ofclass K8_person)))) {
            TryAction(0, actor, ##A_dismounting, 0, 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2070, 877, 2);
        }
    }
    rfalse;
];
[ call_U2071 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2071, 878, 0);
        }
        if ((((CarrierOf(actor) ofclass K18_rideable_animal)) && (((tmp_0 = CarrierOf(actor)),1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U408));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2071, 878, 2);
        }
    }
    rfalse;
];
[ call_U2072;
    ResponseViaActivity(response_id_U408);
];
[ call_U2073 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already riding ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2074 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2074, 879, 0);
        }
        if ((((SupporterOf(actor) ofclass K19_rideable_vehicle)) && (((tmp_0 = SupporterOf(actor)),1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U409));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2074, 879, 2);
        }
    }
    rfalse;
];
[ call_U2075;
    ResponseViaActivity(response_id_U409);
];
[ call_U2076 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already riding ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2077;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2077, 880, 0);
        }
        if ((((~~((noun ofclass K18_rideable_animal)))) && ((~~((noun ofclass K19_rideable_vehicle)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U410);
                print "^";
                rtrue;
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2077, 880, 2);
        }
    }
    rfalse;
];
[ call_U2078;
    ResponseViaActivity(response_id_U410);
];
[ call_U2079;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be ridden.";
    rtrue;
];
[ call_U2080;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2080, 881, 0);
        }
        if (FollowRulebook(call_U1339)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2080, 881, 2);
        }
    }
    rfalse;
];
[ call_U2081;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2081, 882, 0);
        }
        if (FollowRulebook(call_U1342)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2081, 882, 2);
        }
    }
    rfalse;
];
[ call_U2082;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2082, 883, 0);
        }
        move actor to noun;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2082, 883, 2);
        }
    }
    rfalse;
];
[ call_U2083;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2083, 884, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U411);
            print "^";
            call_U1848(noun);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U412);
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2083, 884, 2);
        }
    }
    rfalse;
];
[ call_U2084;
    ResponseViaActivity(response_id_U411);
];
[ call_U2085;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb60(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2086;
    ResponseViaActivity(response_id_U412);
];
[ call_U2087;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb60(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2088 tmp_0;
    if ((((action == ##A_mounting)) && ((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2088, 885, 0);
        }
        if ((reason_the_action_failed == call_U2071)) {
            (tmp_0 = (call_U2089)());
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U413));
            print "^";
        }
        if ((reason_the_action_failed == call_U2074)) {
            (tmp_0 = (call_U2090)());
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U414));
            print "^";
        }
        if ((reason_the_action_failed == call_U2077)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U415));
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2088, 885, 2);
        }
    }
    rfalse;
];
[ call_U2089 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = 0):0:) {
            if ((x == CarrierOf(actor))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2090 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = 0):0:) {
            if ((x == SupporterOf(actor))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2091;
    ResponseViaActivity(response_id_U413);
];
[ call_U2092 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already riding ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2093;
    ResponseViaActivity(response_id_U414);
];
[ call_U2094 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already riding ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2095;
    ResponseViaActivity(response_id_U415);
];
[ call_U2096 tmp_0;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be ridden.";
    rtrue;
];
[ call_U2097;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2097, 886, 0);
        }
        if (((call_U2098()) && (call_U2099()))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U416);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2097, 886, 2);
        }
    }
    rfalse;
];
[ call_U2098 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = 0):0:) {
        (qcn_0)++;
        if ((x == CarrierOf(actor))) {
            (qcy_0)++;
        }
    }
    if ((qcy_0 == 0)) {
        rtrue;
    }
    rfalse;
];
[ call_U2099 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = 0):0:) {
        (qcn_0)++;
        if ((x == SupporterOf(actor))) {
            (qcy_0)++;
        }
    }
    if ((qcy_0 == 0)) {
        rtrue;
    }
    rfalse;
];
[ call_U2100;
    ResponseViaActivity(response_id_U416);
];
[ call_U2101;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " not riding anything.";
    rtrue;
];
[ call_U2102 tmp_0 tmp_1 tmp_2;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2102, 887, 0);
        }
        if ((((CarrierOf(actor) ofclass K18_rideable_animal)) && (((tmp_0 = CarrierOf(actor)),1)))) {
            (noun = tmp_0);
        }
        if ((((SupporterOf(actor) ofclass K19_rideable_vehicle)) && (((tmp_1 = SupporterOf(actor)),1)))) {
            (noun = tmp_1);
        }
        (tmp_2 = HolderOf(noun));
        move actor to tmp_2;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2102, 887, 2);
        }
    }
    rfalse;
];
[ call_U2103;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2103, 888, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U417);
            LookAfterGoing();
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U418);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2103, 888, 2);
        }
    }
    rfalse;
];
[ call_U2104;
    ResponseViaActivity(response_id_U417);
];
[ call_U2105;
    (say__p = 1);
    ParaContent();
    call_U175();
    ParaContent();
    print " ";
    ConjugateVerb61(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    ParaContent();
    print "^";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U2106;
    ResponseViaActivity(response_id_U418);
];
[ call_U2107;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb61(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2108;
    if ((((action == ##A_dismounting)) && ((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2108, 889, 0);
        }
        if ((reason_the_action_failed == call_U2097)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U419);
            print "^";
        } else {
            rfalse;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2108, 889, 2);
        }
    }
    rfalse;
];
[ call_U2109;
    ResponseViaActivity(response_id_U419);
];
[ call_U2110;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " not riding anything.";
    rtrue;
];
[ call_U2111 tmp_0 tmp_1;
    if ((((((action == ##Go)) && ((((((actor ~= player)) && (((((tmp_0 = actor),(((actor ofclass K18_rideable_animal)) && (((tmp_0 = actor),1))))) && (act_requester))))) && (((tmp_1 = noun),(((noun ofclass K3_direction)) && (((tmp_1 = noun),1))))))))) || ((((tmp_1 = 0),(tmp_0 = 0)),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2111, 890, 0);
        }
        if ((tmp_0 == CarrierOf(player))) {
            TryAction(0, player, ##Go, tmp_1, 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2111, 890, 2);
        }
    }
    rfalse;
];
[ ConjugateVerb60 fn vp t modal_to;
    switch (fn) {
        1:
            print "mount";
            ;
        2:
            print "mounted";
            ;
        3:
            print "mounting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "mounts";
                    } else {
                        print "mount";
                    }
                    ;
                2:
                    print "mounted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has mounted";
                    } else {
                        print "have mounted";
                    }
                    ;
                4:
                    print "had mounted";
                    ;
                5:
                    print "will mount";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mount";
                    } else {
                        print "do not mount";
                    }
                    ;
                2:
                    print "did not mount";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not mounted";
                    } else {
                        print "have not mounted";
                    }
                    ;
                4:
                    print "had not mounted";
                    ;
                5:
                    print "will not mount";
                    ;
            }
            ;
    }
];
[ call_U2112 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb61 fn vp t modal_to;
    switch (fn) {
        1:
            print "dismount";
            ;
        2:
            print "dismounted";
            ;
        3:
            print "dismounting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "dismounts";
                    } else {
                        print "dismount";
                    }
                    ;
                2:
                    print "dismounted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has dismounted";
                    } else {
                        print "have dismounted";
                    }
                    ;
                4:
                    print "had dismounted";
                    ;
                5:
                    print "will dismount";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not dismount";
                    } else {
                        print "do not dismount";
                    }
                    ;
                2:
                    print "did not dismount";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not dismounted";
                    } else {
                        print "have not dismounted";
                    }
                    ;
                4:
                    print "had not dismounted";
                    ;
                5:
                    print "will not dismount";
                    ;
            }
            ;
    }
];
[ call_U2113 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2114 forbid_breaks rv;
    (rv = (call_U2120)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2120;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ StrongSub;
    return GenericVerbSub(rulebook_id_U387, rulebook_id_U388, rulebook_id_U389);
];
[ StrongDbg n s for_say;
    print "swearing obscenely";
];
[ call_U2117 forbid_breaks rv;
    (rv = (call_U2121)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2121;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ MildSub;
    return GenericVerbSub(rulebook_id_U390, rulebook_id_U391, rulebook_id_U392);
];
[ MildDbg n s for_say;
    print "swearing mildly";
];
[ call_U2120;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2120, 891, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Real adventurers do not use such language.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2120, 891, 2);
        }
    }
    rfalse;
];
[ call_U2121;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2121, 892, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Quite.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2121, 892, 2);
        }
    }
    rfalse;
];
[ call_U2122 forbid_breaks rv;
    (rv = (call_U2125)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2125;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SingSub;
    return GenericVerbSub(rulebook_id_U393, rulebook_id_U394, rulebook_id_U395);
];
[ SingDbg n s for_say;
    print "singing";
];
[ call_U2125;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2125, 893, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Your singing is abominable.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2125, 893, 2);
        }
    }
    rfalse;
];
[ call_U2126 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (GProperty(OBJECT_TY, t_0, A_P_price) == 0);
    }
    rfalse;
];
[ call_U2127 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(call_U2126(t_0)));
    }
    rfalse;
];
[ call_U2128 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 1);
    }
    rfalse;
];
[ call_U2129 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 1);
    }
    rfalse;
];
[ call_U2130 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 2);
    }
    rfalse;
];
[ call_U2131 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 2);
    }
    rfalse;
];
[ call_U2132 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 3);
    }
    rfalse;
];
[ call_U2133 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 3);
    }
    rfalse;
];
[ call_U2134 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 4);
    }
    rfalse;
];
[ call_U2135 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 4);
    }
    rfalse;
];
[ call_U2136 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 5);
    }
    rfalse;
];
[ call_U2137 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 5);
    }
    rfalse;
];
[ call_U2138 t_0;
    if (t_0) {
        return (t_0 has P_broken);
    }
    rfalse;
];
[ call_U2139 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_broken, 1);
    }
    rfalse;
];
[ call_U2140 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_broken, 0);
    }
    rfalse;
];
[ call_U2141 t_0;
    if (t_0) {
        return ((t_0 has P_broken) == 0);
    }
    rfalse;
];
[ call_U2142 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_broken, 0);
    }
    rfalse;
];
[ call_U2143 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_broken, 1);
    }
    rfalse;
];
[ call_U2144 t_0;
    if (t_0) {
        return (t_0 has P_seen);
    }
    rfalse;
];
[ call_U2145 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_seen, 1);
    }
    rfalse;
];
[ call_U2146 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_seen, 0);
    }
    rfalse;
];
[ call_U2147 t_0;
    if (t_0) {
        return ((t_0 has P_seen) == 0);
    }
    rfalse;
];
[ call_U2148 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_seen, 0);
    }
    rfalse;
];
[ call_U2149 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_seen, 1);
    }
    rfalse;
];
[ call_U2150 t_0;
    if (t_0) {
        return (t_0 has P_scored);
    }
    rfalse;
];
[ call_U2151 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_scored, 1);
    }
    rfalse;
];
[ call_U2152 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_scored, 0);
    }
    rfalse;
];
[ call_U2153 t_0;
    if (t_0) {
        return ((t_0 has P_scored) == 0);
    }
    rfalse;
];
[ call_U2154 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_scored, 0);
    }
    rfalse;
];
[ call_U2155 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_scored, 1);
    }
    rfalse;
];
[ call_U2156 t_0;
    if (t_0) {
        return (t_0 has P_indoors);
    }
    rfalse;
];
[ call_U2157 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 1);
    }
    rfalse;
];
[ call_U2158 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 0);
    }
    rfalse;
];
[ call_U2159 t_0;
    if (t_0) {
        return ((t_0 has P_indoors) == 0);
    }
    rfalse;
];
[ call_U2160 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 0);
    }
    rfalse;
];
[ call_U2161 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 1);
    }
    rfalse;
];
[ call_U2162 t_0;
    if (t_0) {
        return (t_0 has P_filled);
    }
    rfalse;
];
[ call_U2163 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_filled, 1);
    }
    rfalse;
];
[ call_U2164 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_filled, 0);
    }
    rfalse;
];
[ call_U2165 t_0;
    if (t_0) {
        return ((t_0 has P_filled) == 0);
    }
    rfalse;
];
[ call_U2166 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_filled, 0);
    }
    rfalse;
];
[ call_U2167 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_filled, 1);
    }
    rfalse;
];
[ call_U2168 t_0;
    if (t_0) {
        return (t_0 has P_lost);
    }
    rfalse;
];
[ call_U2169 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_lost, 1);
    }
    rfalse;
];
[ call_U2170 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_lost, 0);
    }
    rfalse;
];
[ call_U2171 t_0;
    if (t_0) {
        return ((t_0 has P_lost) == 0);
    }
    rfalse;
];
[ call_U2172 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_lost, 0);
    }
    rfalse;
];
[ call_U2173 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_lost, 1);
    }
    rfalse;
];
[ call_U2174 t_0;
    if (t_0) {
        return (t_0 has mark_as_room);
    }
    rfalse;
];
[ call_U2175 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 1);
    }
    rfalse;
];
[ call_U2176 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 0);
    }
    rfalse;
];
[ call_U2177 t_0;
    if (t_0) {
        return (t_0 has mark_as_thing);
    }
    rfalse;
];
[ call_U2178 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 1);
    }
    rfalse;
];
[ call_U2179 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 0);
    }
    rfalse;
];
[ call_U2180 t_0;
    if (t_0) {
        return (t_0 has container);
    }
    rfalse;
];
[ call_U2181 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 1);
    }
    rfalse;
];
[ call_U2182 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 0);
    }
    rfalse;
];
[ call_U2183 t_0;
    if (t_0) {
        return (t_0 has supporter);
    }
    rfalse;
];
[ call_U2184 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 1);
    }
    rfalse;
];
[ call_U2185 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 0);
    }
    rfalse;
];
[ call_U2186 t_0;
    if (t_0) {
        return (t_0 has switchable);
    }
    rfalse;
];
[ call_U2187 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 1);
    }
    rfalse;
];
[ call_U2188 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 0);
    }
    rfalse;
];
[ call_U2189 t_0;
    if (t_0) {
        return (t_0 has animate);
    }
    rfalse;
];
[ call_U2190 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 1);
    }
    rfalse;
];
[ call_U2191 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 0);
    }
    rfalse;
];
[ ADJDEFN40 t_0;
    rfalse;
];
[ ADJDEFN41 t_0;
    rfalse;
];
[ ADJDEFN42 t_0;
    rfalse;
];
[ ADJDEFN43 t_0;
    rfalse;
];
[ call_U2192;
    (say__p = 1);
    ParaContent();
    @push self;
    E6(GProperty(OBJECT_TY, (self = I_money_U1), A_P_price));
    @pull self;
    ParaContent();
    print " in cash";
    rtrue;
];
[ call_U2193;
    (say__p = 1);
    ParaContent();
    print "This is a flashlight. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a nice one.";
    rtrue;
];
[ call_U2194;
    (say__p = 1);
    if ((~~(call_U2159(real_location)))) {
        jump L_Say0;
    }
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a beautiful evening. Not a cloud in the sky. The moon is out and there are so many stars to see. A shooting star streaks across the sky.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "re indoors. You can";
    ParaContent();
    print "'";
    ParaContent();
    print "t see the sky here.";
    .L_SayX0;
    rtrue;
];
[ call_U2195;
    (say__p = 1);
    ParaContent();
    print "These are your car keys. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a wonder you could find them, your house is such a mess.";
    rtrue;
];
[ call_U2196;
    (say__p = 1);
    ParaContent();
    print "The carnival parking lot sprawls across an open field, its uneven gravel surface crunching under the tires of arriving cars. The lot is lit by a mix of temporary floodlights mounted on poles and the colorful glow of the carnival itself, which spills across the area in flashes of red, blue, and gold. The distant sounds of laughter, music, and the mechanical whir of rides drift across the lot, creating an air of excitement even before reaching the main grounds.^^Rows of vehicles, from dusty sedans to pickup trucks with weathered paint, are parked haphazardly, guided by makeshift wooden signs and strings of flags fluttering in the breeze. Some families unload children, strollers, and blankets from their cars, their voices mingling with the distant carnival noise. Others sit in their vehicles, adjusting their jackets and preparing for the chilly evening ahead.^^The edges of the lot are lined with trees and bushes, their shadows stretching across the ground, creating pockets of darkness. The occasional glow of a phone screen or flashlight pierces the dim corners as latecomers search for empty spots. Near the entrance, a weathered booth manned by a lone attendant collects parking fees, the cash box jingling with loose change.^^Puddles from a recent rain reflect the flashing carnival lights, creating a surreal, shimmering effect on the ground. The smell of damp earth mixes with the distant aroma of popcorn and funnel cakes wafting from the midway. In some areas, patches of mud threaten to swallow unwary shoes, marked by the faint tread of earlier visitors.^^At the far end of the lot, a handful of RVs and trailers are parked, their occupants relaxing in folding chairs, watching the lights of the Ferris wheel spin lazily against the night sky. Generators hum softly, providing power to the trailers, a subtle background noise beneath the larger symphony of the carnival.^^The parking lot, while utilitarian, is alive with anticipation, serving as the gateway to the magic of the carnival. It's a place of transition, where the mundane gives way to the extraordinary, and the humdrum rhythms of daily life are momentarily forgotten.^^The midway is to the south. There is a blueberry bush here. ";
    if ((~~((I_blueberry_bush_U1 == ContainerOf(I_blueberries_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "There are blueberries on the bush.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "The bush has been picked clean.";
    .L_SayX0;
    ParaContent();
    if ((~~((I_parking_lot_U1 == ContainerOf(I_dime_U1))))) {
        jump L_Say2;
    }
    ParaContent();
    print " You see something shiny on the ground.";
    .L_Say2;
    rtrue;
];
[ call_U2197;
    (say__p = 1);
    ParaContent();
    print "The ticket kiosk stands at the entrance to the carnival, a small but colorful booth designed to catch the eye and set the tone for the excitement ahead. Its exterior is painted in bright red and yellow stripes, with bold, blocky letters above the window that read ~Tickets Here!~ Strings of twinkling lights outline the edges, blinking in rhythmic patterns to draw attention.^^The kiosk is compact, with a single window where a smiling attendant greets visitors. Behind the glass, rows of ticket rolls in vibrant colors - blue, red, and yellow - are neatly arranged in dispensers. A small cash drawer sits open beside them, jingling softly as the attendant counts out change. To the side of the window, a digital payment system is set up for those who prefer modern convenience, its screen glowing faintly in the dim light.^^A colorful signboard is propped up next to the kiosk, listing ticket prices for rides, games, and attractions. At the top, in bold letters, it reads: ~Step Right Up! Your Adventure Awaits!~ Below, the list of options is accompanied by playful illustrations of roller coasters, Ferris wheels, and cotton candy.^^The kiosk roof juts out slightly, providing shelter to visitors during rain or shine. Bright pennant flags are strung from the corners of the roof to nearby poles, fluttering in the breeze and adding to the festive atmosphere. The smell of popcorn and fried dough wafts through the air, carried over from nearby food stalls.^^The ground around the kiosk is well-trodden, with patches of worn grass and compacted dirt revealing the heavy foot traffic of eager carnival-goers. A line of families, couples, and groups of friends forms in front of the kiosk, buzzing with excitement as they wait their turn to purchase tickets.^^The ticket kiosk is more than just a point of entry-it's the first step into the carnival's magic, where anticipation builds and the promise of thrills and wonders begins to take shape.^^The midway continues east and west from here. There is a concession stand to the south west. There is a cashier here. ";
    if ((~~((I_cashier_U1 == OwnerOf(I_hell_ride_ticket_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "The Cashier has a Hell Ride ticket.";
    .L_Say0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2198;
    (say__p = 1);
    ParaContent();
    print "This is a bored teenager just trying to earn enough money to take his sweetie to the movies next week.";
    if ((~~((I_parking_attendant_U1 == CarrierOf(I_parking_ticket_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print " He has a parking ticket. The price of a parking ticket is ";
    ParaContent();
    @push self;
    E6(GProperty(OBJECT_TY, (self = I_parking_ticket_U1), A_P_price));
    @pull self;
    ParaContent();
    print ".";
    .L_Say0;
    rtrue;
];
[ call_U2199;
    (say__p = 1);
    ParaContent();
    print "This is your car. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s seen better days. You can see the seat, the dashboard, and the glove box.";
    rtrue;
];
[ call_U2200;
    (say__p = 1);
    ParaContent();
    print "A nice set of sheepskin gloves. They";
    ParaContent();
    print "'";
    ParaContent();
    print "re very warm.";
    rtrue;
];
[ call_U2201;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny";
    rtrue;
];
[ call_U2202;
    (say__p = 1);
    ParaContent();
    print "You are standing in front of a ticket taker with his hand open waiting for your ticket. The entrance to the ride is south of here. The ride attendant tells you that you";
    ParaContent();
    print "'";
    ParaContent();
    print "re lucky you showed up when you did because this will be the last trip through Hell Ride. You notice that all the other cars are empty.";
    rtrue;
];
[ call_U2203;
    (say__p = 1);
    if ((~~(call_U246(real_location)))) {
        jump L_Say0;
    }
    ParaContent();
    print "You head west through the midway, the bright lights of the carnival fading behind you as you approach a wooden booth. A sign above the entrance reads ~Little Egypt Show - A Journey Into the Mysterious and Exotic!~ A rotund barker, wearing a fez and a dazzling smile, gestures to a small sign beside him that says ~Dime Admission.~";
    .L_Say0;
    ParaContent();
    print "^^You are standing in front of a dark and mysterious tent filled with illusions and exotic performers. Perhaps there's a fortune teller inside, offering cryptic clues about your journey or a hidden artifact that can be collected. There is a stage in front of the tent. The Barker is encouraging you to step up, pay for, and enjoy the Little Egypt Show.";
    if ((~~(call_U246(real_location)))) {
        jump L_Say1;
    }
    ParaContent();
    print "The barker cries:^^Ladies and gentlemen, boys and girls, gather ";
    ParaContent();
    print "'";
    ParaContent();
    print "round! ";
    ParaContent();
    print "^";
    ParaContent();
    print "Step right up and witness the spectacle that";
    ParaContent();
    print "'";
    ParaContent();
    print "s taken the world by storm! ";
    ParaContent();
    print "^";
    ParaContent();
    print "She walks, she talks, she crawls on her belly like a reptile. ";
    ParaContent();
    print "^";
    ParaContent();
    print "Behold the one, the only Little Egypt, performing her legendary Dance of the Pyramids-a dazzling display of mystery, grace, and exotic allure! ";
    ParaContent();
    print "^";
    ParaContent();
    print "For just a dime, a mere one tenth of a dollar, prepare to be transported to the sands of Cairo, where enchantment and wonder await!";
    .L_Say1;
    rtrue;
];
[ call_U2204;
    (say__p = 1);
    ParaContent();
    print "This area features a tall, eye-catching machine adorned with bright, colorful lights, typically red, yellow, and blue. A large sign at the top reads ~Test Your Strength!~ in bold, playful lettering. The machine's base is made of polished wood, with a polished, vintage appearance. At the center is a sturdy metal pole, with a large bell hanging at the top, signaling when a successful attempt has been made. Along the length of the pole are markings indicating how strong you are.  A nearby sign says, ~Buy a mallet, strike the bell, win a prize.~";
    if ((~~((I_strongman_attendant_U1 == ContainerOf(I_mallet_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print " You can see an over-sized mallet here.";
    .L_Say0;
    ParaContent();
    print "^^Spectators gather around, cheering on participants and offering lighthearted jabs and encouragement, creating a lively, competitive atmosphere. The sound of the mallet hitting the target is followed by the resonant clang of the bell (if struck), alongside the buzz of carnival music in the background.";
    rtrue;
];
[ call_U2205;
    (say__p = 1);
    ParaContent();
    print "This Hell Ride ticket will ~Admit One~ to the Hell Ride.";
    ParaContent();
    print "^";
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a real ~E~ ticket, baby!";
    rtrue;
];
[ call_U2206;
    (say__p = 1);
    ParaContent();
    print "This is a bored teenager hired to sell ride tickets all week at this carnival. He";
    ParaContent();
    print "'";
    ParaContent();
    print "s thinking about having a brewski with his bros after work.";
    rtrue;
];
[ call_U2207;
    (say__p = 1);
    ParaContent();
    print "^";
    ParaContent();
    print "$2.00 Cola ";
    ParaContent();
    print "^";
    ParaContent();
    print "$2.50 Popcorn ";
    ParaContent();
    print "^";
    ParaContent();
    print "$1.50 Candy Apple ";
    ParaContent();
    print "^";
    ParaContent();
    print "$1.50 Cotton Candy ";
    ParaContent();
    print "^";
    ParaContent();
    print "$1.50 Soft Pretzel";
    rtrue;
];
[ call_U2208;
    (say__p = 1);
    ParaContent();
    print "An Attendant is standing here ";
    if ((~~((I_strongman_attendant_U1 == CarrierOf(I_mallet_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "holding a mallet";
    .L_Say0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2209;
    (say__p = 1);
    ParaContent();
    print "This is a poster of America";
    ParaContent();
    print "'";
    ParaContent();
    print "s sweetheart, Taylor Swift.";
    rtrue;
];
[ call_U2210;
    (say__p = 1);
    ParaContent();
    print "Here is a man dressed in black pants, a white shirt,a striped vest, a fez, and a dazzling smile. The barker cries:^^Ladies and gentlemen, boys and girls, gather ";
    ParaContent();
    print "'";
    ParaContent();
    print "round! ";
    ParaContent();
    print "^";
    ParaContent();
    print "Step right up and witness the spectacle that";
    ParaContent();
    print "'";
    ParaContent();
    print "s taken the world by storm! ";
    ParaContent();
    print "^";
    ParaContent();
    print "She walks, she talks, she crawls on her belly like a reptile. ";
    ParaContent();
    print "^";
    ParaContent();
    print "Behold the one, the only Little Egypt, performing her legendary Dance of the Pyramids-a dazzling display of mystery, grace, and exotic allure! ";
    ParaContent();
    print "^";
    ParaContent();
    print "For just a dime, a mere one tenth of a dollar, prepare to be transported to the sands of Cairo, where enchantment and wonder await!";
    rtrue;
];
[ call_U2211 ch;
    if (((scene_status-->(1)) == 1)) {
        if ((TableFilledRows(table_data_U14) == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'LittleEgyptAuto' ends]^";
            }
            if (GProperty(SCENE_TY, 2, A_P_recurring)) {
                ((scene_status-->(1)) = 0);
            } else {
                ((scene_status-->(1)) = 2);
            }
            FollowRulebook(rulebook_id_U418);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 2);
            ((scene_ended-->(1)) = the_time);
            ((scene_endings-->(1)) = (((scene_endings-->(1)))|(2)));
            ((scene_latest_ending-->(1)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(1)) == 0)) {
        if ((TestSinglePastState(0, ptc_id_U1, 0, 2) == 2)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'LittleEgyptAuto' begins]^";
            }
            ((scene_status-->(1)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 2);
            FollowRulebook(rulebook_id_U417);
            ((scene_started-->(1)) = the_time);
            ((scene_endings-->(1)) = (((scene_endings-->(1)))|(1)));
            ((scene_latest_ending-->(1)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U2212;
    #ifdef DEBUG;
        if (((scene_status-->(1)) == 1)) {
            print "Scene 'LittleEgyptAuto' playing (for ";
            print (the_time - (scene_started-->(1)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(1)) > 0)) {
                print "Scene 'LittleEgyptAuto' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U2213 ch;
    if (((scene_status-->(2)) == 1)) {
        if ((TableFilledRows(table_data_U15) == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'HellRideAuto' ends]^";
            }
            if (GProperty(SCENE_TY, 3, A_P_recurring)) {
                ((scene_status-->(2)) = 0);
            } else {
                ((scene_status-->(2)) = 2);
            }
            FollowRulebook(rulebook_id_U420);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 3);
            ((scene_ended-->(2)) = the_time);
            ((scene_endings-->(2)) = (((scene_endings-->(2)))|(2)));
            ((scene_latest_ending-->(2)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(2)) == 0)) {
        if ((TestSinglePastState(0, ptc_id_U2, 0, 2) == 3)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'HellRideAuto' begins]^";
            }
            ((scene_status-->(2)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 3);
            FollowRulebook(rulebook_id_U419);
            ((scene_started-->(2)) = the_time);
            ((scene_endings-->(2)) = (((scene_endings-->(2)))|(1)));
            ((scene_latest_ending-->(2)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U2214;
    #ifdef DEBUG;
        if (((scene_status-->(2)) == 1)) {
            print "Scene 'HellRideAuto' playing (for ";
            print (the_time - (scene_started-->(2)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(2)) > 0)) {
                print "Scene 'HellRideAuto' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U2215;
    (say__p = 1);
    ParaContent();
    print "The public square is an open expanse of cobblestones, surrounded by the weathered facades of timber-framed buildings. The air is heavy with the mingling scents of smoke from distant chimneys, damp earth, and the faint metallic tang of the nearby smithy. At the square";
    ParaContent();
    print "'";
    ParaContent();
    print "s center stand a row of crude wooden stocks, their heavy beams stained from years of weather and use. Iron clasps hold the unfortunate captives by their wrists and necks, their bodies forced into unnatural, humiliating postures.^^The punished individuals, heads bowed in shame, are caught in an agonizing tableau of disgrace. Their expressions, a mix of resignation and despair, reflect the full weight of their predicaments. Their clothing hangs in tatters, furthering their exposure to the biting wind and the sharp tongues of the gathered crowd.^^Around the stocks, the townsfolk revel in their collective cruelty. A wiry man leans in close, spitting insults with glee, his laughter cutting through the air. A stout woman clutching a basket of overripe vegetables hurls a squashed tomato, which splatters across one captive's cheek, drawing a chorus of jeers. Nearby, children mimic their elders, pointing and shrieking in mockery, their faces alight with mischief.^^The square is alive with noise: the raucous laughter of the crowd, the occasional sharp crack of a thrown object against the wood, and the soft, pained murmurs of the punished. A passing bell tolls faintly in the distance, but here it is drowned out by the cruel symphony of the jeering mob.^^Above it all, the gray sky looms, heavy with the promise of rain, as if nature itself disapproves of the spectacle. Yet the crowd pays no mind, delighting in their collective judgment, each jeer a reminder that today's entertainment is another";
    ParaContent();
    print "'";
    ParaContent();
    print "s living nightmare.";
    rtrue;
];
[ call_U2216;
    (say__p = 1);
    ParaContent();
    print "At the square";
    ParaContent();
    print "'";
    ParaContent();
    print "s center stand a row of crude wooden stocks, their heavy beams stained from years of weather and use. Iron clasps hold the unfortunate captives by their wrists and necks, their bodies forced into unnatural, humiliating postures.";
    rtrue;
];
[ call_U2217;
    (say__p = 1);
    ParaContent();
    print "The public square lies under a brooding, overcast sky, its cobblestones slick with the morning";
    ParaContent();
    print "'";
    ParaContent();
    print "s drizzle. A grim silence has settled over the gathered crowd, broken only by the occasional murmur or the restless shuffling of feet. At the center of the square, rising like a grim monument to mortality, stands the gallows-a wooden platform, darkened by age and weather, with thick ropes hanging like vipers poised to strike.^^Atop the gallows, a hooded executioner looms, his imposing frame draped in a black cloak that billows faintly in the wind. His face is obscured by the deep cowl, but his presence radiates cold, methodical purpose. In his gloved hands, he adjusts the noose, its coarse fibers frayed from repeated use, ensuring it is ready for the task at hand.^^Standing beside him is the condemned man, his hands bound tightly behind his back. His face is pale, drawn, and haunted, beads of sweat mingling with the light rain. His eyes dart to the crowd, seeking pity, perhaps, but finding only a sea of indifferent faces. His breath comes in shallow bursts, each exhalation visible in the chilly air, a stark reminder of the life still in him-for now.^^The crowd gathers in a semicircle around the platform, a mixture of somber onlookers, opportunistic vendors hawking bread and cider, and children craning their necks for a better view. An old man mutters a prayer under his breath, clutching a rosary, while a group of rough-looking men smirk and exchange bets on how long the drop will take.^^Above it all, the bell tower tolls, its mournful chime echoing through the square, a countdown to the inevitable. The condemned man flinches with each clang, his shoulders tensing as the final moments draw near. A raven perches on the gallows~ beam, its black eyes unblinking, as if waiting for the end with morbid curiosity.^^The executioner steps forward, adjusting the noose around the man's neck with a practiced efficiency. The crowd falls silent, the weight of the moment hanging heavier than the rope itself. Somewhere in the distance, thunder rumbles faintly, as though the heavens themselves are bracing for what is to come.";
    rtrue;
];
[ call_U2218;
    (say__p = 1);
    ParaContent();
    print "The public square is a grim tableau, the usual bustle of commerce and chatter replaced with an oppressive silence broken only by the crackling of the flames. At the center, three wooden stakes rise ominously from a circular pyre of logs and kindling, their rough surfaces darkened by smoke from countless such scenes before. Bound tightly to these stakes are three women, their wrists and ankles secured with coarse, heavy ropes. Their faces tell different stories-one of defiance, another of resignation, and the third of pure terror.^^A crowd encircles the pyre, their expressions a mix of morbid fascination, righteous fury, and hesitant pity. Children cling to their mothers";
    ParaContent();
    print "'";
    ParaContent();
    print " skirts, staring wide-eyed, while town elders nod solemnly as though approving the grim spectacle. Some townsfolk jeer loudly, throwing small stones or rotten vegetables at the condemned. Others murmur prayers or make the sign of the cross, their eyes averted.^^The executioner, clad in a soot-streaked hood and leather apron, steps forward, his torch a blazing beacon in the dreary scene. The flames dance and writhe as he lowers the torch to the base of the pyre, igniting the dry wood with a sudden, hungry roar. A cheer erupts from a faction of the crowd, while others fall into an uneasy silence, watching the fire climb higher.^^Thick, acrid smoke begins to rise, curling around the stakes like a living thing. The women cry out-some in curses, others in prayers-and their voices echo across the square, mingling with the crackle of the flames. The heat radiates outward, and even those in the crowd begin to feel its oppressive warmth.^^Above, the gray clouds hang low, as if nature itself mourns the scene unfolding below. A raven caws from its perch atop the town";
    ParaContent();
    print "'";
    ParaContent();
    print "s bell tower, its black form stark against the ashen sky. The church bells toll in slow, deliberate cadence, each strike a grim punctuation to the scene.^^As the flames consume the pyre, the crowd remains rooted, some transfixed by the spectacle, others quietly slipping away, their faces pale and drawn. The square, once a place of gatherings and life, is now a stage for death, its air heavy with smoke, ash, and the lingering cries of the condemned.";
    rtrue;
];
[ call_U2219;
    (say__p = 1);
    ParaContent();
    print "The dungeon is a dim, oppressive chamber carved deep into the earth, its stone walls slick with moisture and coated in a thin layer of grime. The air is heavy with the stench of sweat, blood, and mildew, punctuated by the faint, acrid tang of burning oil from flickering torches mounted on rusty iron sconces. Shadows dance on the walls, creating grotesque shapes that seem almost alive in the unsteady light.^^Chains hang from the walls and ceilings, their metallic clinking faintly audible as prisoners shift or shudder in their restraints. The room is filled with the soft, pitiful moans of the tormented, their cries occasionally rising to sharp, desperate screams that echo through the corridors beyond. The sound of dripping water from a cracked stone ceiling adds an eerie rhythm to the unsettling cacophony.^^Scattered throughout the dungeon are various instruments of pain and suffering, their designs brutal and unyielding. A rack sits in the center of the room, its wooden frame splintered from years of use. Nearby, a brazier glows a dull red, its coals smoldering beneath a collection of iron tools-branding irons, pincers, and knives, their edges darkened with dried blood. A spiked chair looms in the corner, its cruel design gleaming faintly in the dim light.^^Prisoners are scattered across the room, each trapped in their own nightmare. A man lies stretched on the rack, his face contorted in agony as the torturer methodically turns the wheel, the creaking of wood and rope echoing in the chamber. Another prisoner hangs limply from manacles affixed to the wall, their body bruised and battered, barely able to lift their head. A third, seated in the spiked chair, breathes in shallow gasps, their movements restricted by the cruel embrace of the iron seat.^^The torturer moves about the chamber with practiced efficiency, their face obscured by a hood, their leather apron stained with the evidence of countless victims. They work silently, their movements methodical and devoid of emotion, as if the suffering around them were merely a task to be completed.^^Above it all, the dungeon";
    ParaContent();
    print "'";
    ParaContent();
    print "s ceiling is low and oppressive, the occasional scuttling of rats in the shadows serving as a reminder of the filth and decay that permeates the space. The only exit-a heavy, iron-bound door reinforced with rivets-seems more a barrier to hope than a passage to freedom, its small viewing slit barred and shadowed.^^This is a place of despair and cruelty, where the line between life and death is blurred, and the only certainty is the inevitability of suffering.";
    rtrue;
];
[ call_U2220;
    (say__p = 1);
    ParaContent();
    print "The exit of Hell Ride is as unsettling as the ride itself, designed to leave riders with a lingering sense of unease. The pathway emerges from a dark, narrow corridor, its walls painted in peeling black with streaks of red that resemble dripping blood. Dim, flickering lights cast erratic shadows across the uneven floor, creating an oppressive atmosphere that follows riders even after they've left the ride.^^The air is cooler here, with a faint metallic tang and the unmistakable scent of dampness, as though the exit leads not back to the carnival but somewhere deeper underground. Sound effects of faint whispers and distant screams play softly in the background, barely audible over the creak of the exit door swinging open and the occasional burst of laughter or screams from the ride's next passengers.^^Riders step out into a small courtyard, enclosed by jagged, rusted metal fencing adorned with fake cobwebs and plastic bones. A weathered sign swings overhead, painted in bold, Gothic letters: ~You";
    ParaContent();
    print "'";
    ParaContent();
    print "ve Survived";
    ParaContent();
    (unicode_temp = 8230);
    @streamunichar unicode_temp;
    ParaContent();
    print " For Now.~^^Nearby, a few carnival workers in tattered costumes linger, their expressions disturbingly neutral as they watch riders leave. One might mumble cryptic phrases like, ~Not everyone makes it out";
    ParaContent();
    (unicode_temp = 8230);
    @streamunichar unicode_temp;
    ParaContent();
    print "~ before breaking into a crooked grin.^^The exit path leads past a small merchandise stand selling ride-themed merchandise-~Hell Ride Survivor~ t-shirts, devil horns, and glow-in-the-dark trinkets shaped like skulls. The stand is bathed in red light, adding to the ominous mood.^^Just beyond the fencing, the cheerful sounds and colorful lights of the carnival midway feel jarringly out of place, a sharp contrast to the oppressive darkness of the ride. Riders often pause to gather themselves, exchanging nervous laughter or adjusting their belongings, before stepping back into the lively world of the carnival.^^The Hell Ride exit leaves riders not just thrilled, but marked by the eerie experience, a reminder of the fine line between fun and fear that defines the carnival's darkest attraction.";
    rtrue;
];
[ call_U2221;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a desk. There are coffee stains and cigarette burns from years of abuse. The single drawer is ";
    if ((~~(call_U306(I_drawer_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "shut";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2222;
    (say__p = 1);
    if ((~~(call_U336(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "The radio burbles on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "The radio is off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ TSD_door_dir_value1 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value1 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_stocks_room_U1;
    }
    return I_maintenance_office_U1;
];
[ call_U2223;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s an aqua colored door with the word ~Stocks~ written on it.";
    rtrue;
];
[ TSD_door_dir_value2 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_up_U1;
    }
    return I_down_U1;
];
[ TSD_door_to_value2 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_dark_hallway_U1;
    }
    return I_maintenance_office_U1;
];
[ call_U2224;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a typical 10 foot ladder.";
    rtrue;
];
[ TSD_door_dir_value3 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_crawl_space_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value3 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_crawl_space_U1)) {
        return I_gallows_room_U1;
    }
    return I_crawl_space_U1;
];
[ call_U2225;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a crimson colored door with the word ~Gallows~ written on it.";
    rtrue;
];
[ TSD_door_dir_value4 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_north_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value4 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_north_U1)) {
        return I_stake_room_U1;
    }
    return I_mechanical_room_north_U1;
];
[ call_U2226;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s an emerald colored door with the word ~Stake~ written on it.";
    rtrue;
];
[ TSD_door_dir_value5 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_south_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value5 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_south_U1)) {
        return I_dungeon_U1;
    }
    return I_mechanical_room_south_U1;
];
[ call_U2227;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a gray colored door with the word ~Dungeon~ written on it.";
    rtrue;
];
[ TSD_door_dir_value6 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_generator_room_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value6 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_generator_room_U1)) {
        return I_guillotine_room_U1;
    }
    return I_generator_room_U1;
];
[ call_U2228;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s an indigo colored door with the word ~Guillotine~ written on it.";
    rtrue;
];
[ call_U2229;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_eleven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_eleven_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2230;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_eleven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2231;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_eleven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2232;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_nine_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_nine_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2233 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_socket_nine_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2234;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_nine_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2235;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_nine_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2236;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_seven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_seven_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2237 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_socket_seven_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2238;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_seven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2239;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_seven_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2240;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_five_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_five_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2241 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_socket_five_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2242;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_five_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2243;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_five_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2244;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_three_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_three_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2245 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_socket_three_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2246;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_three_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2247;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_three_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2248;
    (say__p = 1);
    ParaContent();
    print "This is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U306(I_electrical_panel_one_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". ";
    if ((~~(call_U321(I_electrical_panel_one_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    .L_Say2;
    rtrue;
];
[ call_U2249 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_socket_one_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2250;
    (say__p = 1);
    ParaContent();
    print "This is a big switch. You could probably turn it ";
    if ((~~(call_U339(I_switch_one_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2251;
    (say__p = 1);
    ParaContent();
    print "The indicator is currently ";
    if ((~~(call_U336(I_indicator_light_one_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "indicating nothing";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2252;
    (say__p = 1);
    ParaContent();
    print "The carnival storage room is a chaotic yet oddly functional space, tucked away from the flashing lights and lively crowds. Its walls are made of corrugated metal or weathered wood, with patches of rust and peeling paint revealing the room";
    ParaContent();
    print "'";
    ParaContent();
    print "s age. The faint smell of grease, dust, and damp canvas hangs in the air, mingled with a hint of stale popcorn and cotton candy from the midway outside.^^Shelves line the walls, crammed with a mishmash of supplies. Boxes of lightbulbs, spools of electrical wiring, and stacks of replacement parts for rides and games are piled haphazardly, some labeled in fading marker, others left to mystery. A collection of brightly colored pennant flags and strings of carnival lights dangles from hooks, their wires tangled into an unruly knot.^^In one corner, a pile of folded canvas tarps and tent poles leans precariously against the wall, ready to be deployed for setting up new attractions or repairing existing ones. Nearby, over sized crates are labeled with blocky stencils: ~GAME PRIZES~, RIDE PARTS~, and ~SPARE SIGNAGE~. One crate is open, revealing a jumble of stuffed animals, rubber balls, and plastic toys meant to delight lucky winners.^^The center of the room is dominated by larger items-spare seats for rides, unassembled game booths, and the occasional disassembled attraction part, like a faded carousel horse or a section of a Ferris wheel's gondola. These are covered in tarps or wrapped in protective blankets, their surfaces scratched and worn from transport and use.^^A small, battered desk sits near the entrance, cluttered with maintenance logs, mismatched tools, and a few empty coffee cups. Above it, a cork board displays a chaotic array of pinned notes: ride schedules, repair requests, and a map of the carnival grounds with certain areas circled in red. A single fluorescent light flickers overhead, casting uneven shadows across the room and giving it a slightly eerie feel.^^The floor is a patchwork of concrete and dirt, strewn with stray bolts, screws, and scraps of paper. In the darker corners, the scuttling of a rat or the glint of a spider's web serves as a reminder that this space, while essential, is far from pristine.^^The carnival storage room is not glamorous, but it is vital-a hidden world of spare parts, forgotten treasures, and organized chaos that keeps the carnival running smoothly. It's a backstage glimpse into the hard work and improvisation that make the magic possible.";
    rtrue;
];
[ TSD_door_dir_value7 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_storage_room_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value7 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_storage_room_U1)) {
        return I_ride_exit_U1;
    }
    return I_storage_room_U1;
];
[ call_U2253;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a khaki colored door with the word ~Ride Exit~ written on it.";
    rtrue;
];
[ call_U2254;
    (say__p = 1);
    ParaContent();
    print "This is an aqua colored light. The light is ";
    if ((~~(call_U336(I_aqua_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2255;
    (say__p = 1);
    ParaContent();
    print "This is an crimson colored light. The light is ";
    if ((~~(call_U336(I_crimson_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2256;
    (say__p = 1);
    ParaContent();
    print "This is an emerald colored light. The light is ";
    if ((~~(call_U336(I_emerald_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2257;
    (say__p = 1);
    ParaContent();
    print "This is an gray colored light. The light is ";
    if ((~~(call_U336(I_gray_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2258;
    (say__p = 1);
    ParaContent();
    print "This is an indigo colored light. The light is ";
    if ((~~(call_U336(I_indigo_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2259;
    (say__p = 1);
    ParaContent();
    print "This is an khaki colored light. The light is ";
    if ((~~(call_U336(I_khaki_light_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2260;
    (say__p = 1);
    ParaContent();
    print "This is an aqua dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ call_U2261;
    (say__p = 1);
    ParaContent();
    print "This is a crimson dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ call_U2262;
    (say__p = 1);
    ParaContent();
    print "This is an emerald dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ call_U2263;
    (say__p = 1);
    ParaContent();
    print "This is a gray dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ call_U2264;
    (say__p = 1);
    ParaContent();
    print "This is an indigo dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ call_U2265;
    (say__p = 1);
    ParaContent();
    print "This is a khaki dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    rtrue;
];
[ RFI_for_I1;
    if (TestRegionalContainment(location, I_midway_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I2;
    if (TestRegionalContainment(location, I_hellride_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I3;
    if (TestRegionalContainment(location, I_backstage_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I4;
    if (TestRegionalContainment(location, I_second_floor_U1)) {
        rtrue;
    }
    rfalse;
];
[ call_U2266 forbid_breaks rv;
    (rv = (call_U2351)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2351;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2267 forbid_breaks rv;
    (rv = (call_U2352)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2352;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2268 forbid_breaks rv;
    (rv = (call_U2353)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2353;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_pouring_it_intoSub;
    return GenericVerbSub(rulebook_id_U396, rulebook_id_U397, rulebook_id_U398);
];
[ A_pouring_it_intoDbg n s for_say;
    print "pouring";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "into";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U2269 forbid_breaks rv;
    (rv = (call_U2354)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2354;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2270 forbid_breaks rv;
    (rv = (call_U2355)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2355;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2271 forbid_breaks rv;
    (rv = (call_U2356)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2356;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hiding_it_underSub;
    return GenericVerbSub(rulebook_id_U399, rulebook_id_U400, rulebook_id_U401);
];
[ A_hiding_it_underDbg n s for_say;
    print "hiding";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "under";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U2272 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2376)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2376;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2377)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2377;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2374)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2374;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2273 forbid_breaks rv;
    (rv = (call_U2375)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2375;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hi_speakingSub;
    return GenericVerbSub(rulebook_id_U402, rulebook_id_U403, rulebook_id_U404);
];
[ A_hi_speakingDbg n s for_say;
    print "hi-speaking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2276 forbid_breaks rv;
    (rv = (call_U2378)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2378;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_casting_xyzzySub;
    return GenericVerbSub(rulebook_id_U405, rulebook_id_U406, rulebook_id_U407);
];
[ A_casting_xyzzyDbg n s for_say;
    print "casting xyzzy";
];
[ call_U2278 forbid_breaks rv;
    (rv = (call_U2406)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2406;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2279 forbid_breaks rv;
    (rv = (call_U2407)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2407;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hittingSub;
    return GenericVerbSub(rulebook_id_U408, rulebook_id_U409, rulebook_id_U410);
];
[ A_hittingDbg n s for_say;
    print "hitting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2281 forbid_breaks rv;
    (rv = (call_U2552)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2552;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2283 forbid_breaks rv;
    (rv = (call_U2553)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2553;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_spinning_it_toSub;
    return GenericVerbSub(rulebook_id_U411, rulebook_id_U412, rulebook_id_U413);
];
[ A_spinning_it_toDbg n s for_say;
    print "spinning";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Number)(parsed_number);
    }
];
[ call_U2284 X;
    if ((X ofclass K2_thing)) {
        return (X.P_underlying_relation_storag);
    }
    rfalse;
];
[ call_U2285 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        ((L.P_underlying_relation_storag) = R);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record4);
];
[ call_U2286 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(L, A_P_underlying_relation_storag, R);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record4);
];
[ call_U2287 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((Y == call_U2284(X))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2287)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2287)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2287)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2287)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2287)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2287)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U2285(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U2286(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_ShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (VtoORelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((VtoORelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U2288 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == Y)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record5);
            ;
    }
    rfalse;
];
[ call_U2289 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((BlkValueCompare((X)(CV_MEANING), Y) == 0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record6);
            ;
    }
    rfalse;
];
[ call_U2290 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == OwnerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2291 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((RlnGetF(X, RR_HANDLER))(X,RELS_TEST,Y,0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record8);
            ;
    }
    rfalse;
];
[ call_U2292 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record9);
            ;
    }
    rfalse;
];
[ call_U2293 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == ContainerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2293)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2293)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2293)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2293)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U2293)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U2293)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2294 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == SupporterOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                    if ((call_U2294)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2294)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                if ((call_U2294)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2294)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2294)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2294)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2295 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == PartOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2295)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2295)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2295)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2295)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2295)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2295)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MakePart(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2296 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (IndirectlyContains(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2296)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2296)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2296)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2296)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U2296)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U2296)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2297 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == CarrierOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2297)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2297)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2297)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2297)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2297)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2297)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2298 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == HolderOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2298)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2298)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2298)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2298)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2298)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2298)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2299 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == WearerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2299)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2299)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2299)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2299)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2299)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2299)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            WearObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2300 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestVisibility(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2300)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2300)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2300)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2300)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2300)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2300)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2301 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestTouchability(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2301)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2301)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2301)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2301)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2301)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2301)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2302 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestConcealment(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2302)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2302)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2302)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2302)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2302)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2302)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2303 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2305 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2364)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2364;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2453)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2453;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2360)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2360;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2357)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2357;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2308 forbid_breaks rv;
    (rv = (call_U2420)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2420;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2309 forbid_breaks rv;
    (rv = (call_U2426)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2426;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2310 forbid_breaks rv;
    (rv = (call_U2429)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2429;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ E6 value which;
    if ((value == 0)) {
        call_U2554(value);
        rtrue;
    }
    if ((NUMBER_TY_Abs(value) >= 1)) {
        call_U2554(value);
        rtrue;
    }
    call_U2554(value);
    rtrue;
    rtrue;
];
[ call_U2311 sk;
    rfalse;
];
[ call_U2312 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(MAX_POSITIVE_NUMBER);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2313 sk;
    rfalse;
];
[ E9 value which;
    if ((value == 0)) {
        call_U2556(value);
        rtrue;
    }
    if ((NUMBER_TY_Abs(value) >= 1)) {
        call_U2556(value);
        rtrue;
    }
    call_U2556(value);
    rtrue;
    rtrue;
];
[ call_U2314 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(MAX_POSITIVE_NUMBER);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2315 sk;
    rfalse;
];
[ call_U2316 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K20_fluid_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "fluid capacity: ";
                (E9)(GProperty(OBJECT_TY, t_0, A_P_fluid_capacity));
                print "^";
                print "current volume: ";
                (E9)(GProperty(OBJECT_TY, t_0, A_P_current_volume));
                print "^";
                print "liquid: ";
                (E10)(GProperty(OBJECT_TY, t_0, A_P_liquid));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ E10 value;
    switch (value) {
        I_water_U1:
            print "water";
            ;
        I_cola_U1:
            print "Cola";
            ;
        I_milk_U1:
            print "milk";
            ;
        I_lemonade_U1:
            print "lemonade";
            ;
        I_iced_tea_U1:
            print "iced tea";
            ;
        default:
            print "<illegal liquid>";
            ;
    }
];
[ call_U2317 sk;
    return I_water_U1;
];
[ call_U2318 x;
    return ((x%5) + 1);
];
[ call_U2319 x;
    return (((x + 3)%5) + 1);
];
[ call_U2320 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2321 original_wn group_wn v w rv;
    (original_wn = wn);
    if ((NextWordStopped() ~= 'soda')) {
        jump Fail_1;
    }
    (parsed_number = I_cola_U1);
    return GPR_NUMBER;
    .Fail_1;
    (wn = original_wn);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'iced')) {
        jump Failed_1;
    }
    if ((NextWordStopped() ~= 'tea')) {
        jump Failed_1;
    }
    (parsed_number = I_iced_tea_U1);
    return GPR_NUMBER;
    .Failed_1;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'water')) {
        jump Failed_2;
    }
    (parsed_number = I_water_U1);
    return GPR_NUMBER;
    .Failed_2;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'cola')) {
        jump Failed_3;
    }
    (parsed_number = I_cola_U1);
    return GPR_NUMBER;
    .Failed_3;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'milk')) {
        jump Failed_4;
    }
    (parsed_number = I_milk_U1);
    return GPR_NUMBER;
    .Failed_4;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'lemonade')) {
        jump Failed_5;
    }
    (parsed_number = I_lemonade_U1);
    return GPR_NUMBER;
    .Failed_5;
    (wn = original_wn);
    return GPR_FAIL;
];
[ call_U2322 instance original_wn group_wn v w rv;
    (original_wn = wn);
    if ((instance == I_cola_U1)) {
        if ((NextWordStopped() ~= 'soda')) {
            jump Fail_1;
        }
        (parsed_number = I_cola_U1);
        return GPR_NUMBER;
        .Fail_1;
        (wn = original_wn);
    }
    (wn = original_wn);
    if ((instance == I_iced_tea_U1)) {
        if ((NextWordStopped() ~= 'iced')) {
            jump Failed_1;
        }
        if ((NextWordStopped() ~= 'tea')) {
            jump Failed_1;
        }
        (parsed_number = I_iced_tea_U1);
        return GPR_NUMBER;
        .Failed_1;
        return GPR_FAIL;
    }
    if ((instance == I_water_U1)) {
        if ((NextWordStopped() ~= 'water')) {
            jump Failed_2;
        }
        (parsed_number = I_water_U1);
        return GPR_NUMBER;
        .Failed_2;
        return GPR_FAIL;
    }
    if ((instance == I_cola_U1)) {
        if ((NextWordStopped() ~= 'cola')) {
            jump Failed_3;
        }
        (parsed_number = I_cola_U1);
        return GPR_NUMBER;
        .Failed_3;
        return GPR_FAIL;
    }
    if ((instance == I_milk_U1)) {
        if ((NextWordStopped() ~= 'milk')) {
            jump Failed_4;
        }
        (parsed_number = I_milk_U1);
        return GPR_NUMBER;
        .Failed_4;
        return GPR_FAIL;
    }
    if ((instance == I_lemonade_U1)) {
        if ((NextWordStopped() ~= 'lemonade')) {
            jump Failed_5;
        }
        (parsed_number = I_lemonade_U1);
        return GPR_NUMBER;
        .Failed_5;
        return GPR_FAIL;
    }
    return GPR_FAIL;
];
[ call_U2323 sk;
    rfalse;
];
[ call_U2324 sk;
    rfalse;
];
[ call_U2325 sk;
    rfalse;
];
[ call_U2326 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 ofclass K23_socket)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_filled)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "filled";
                }
                if (((0) && ((~~((t_0 has P_filled)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unfilled";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2327 sk;
    rfalse;
];
[ call_U2328 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 ofclass K24_colored_fuse)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((0) && ((t_0 has P_lost)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lost";
                }
                if (((0) && ((~~((t_0 has P_lost)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "found";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2329 sk;
    return I_weakling_U1;
];
[ E11 value;
    switch (value) {
        I_weakling_U1:
            print "Weakling";
            ;
        I_getting_stronger_U1:
            print "Getting Stronger";
            ;
        I_average_U1:
            print "Average";
            ;
        I_almost_there_U1:
            print "Almost There";
            ;
        I_muscle_man_U1:
            print "Muscle Man";
            ;
        default:
            print "<illegal strength pattern>";
            ;
    }
];
[ call_U2330 x;
    return ((x%5) + 1);
];
[ call_U2331 x;
    return (((x + 3)%5) + 1);
];
[ call_U2332 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2333 sk;
    rfalse;
];
[ call_U2334 sk;
    rfalse;
];
[ call_U2335 sk;
    rfalse;
];
[ call_U2336 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K27_colored_dial)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "dial setting: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_dial_setting));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2337;
    if ((((action == ##Examine)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2127(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2337, 894, 0);
        }
        (say__p = 1);
        ParaContent();
        print "It can be yours for ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = noun), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2337, 894, 2);
        }
    }
    rfalse;
];
[ call_U2338;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2127(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2338, 897, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "ll have to pay for that.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2338, 897, 2);
        }
    }
    rfalse;
];
[ call_U2339;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2127(noun)))) && (((((self = actor),1)) && ((~~((I_wallet_U1 == ContainerOf(I_money_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2339, 898, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "re broke.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2339, 898, 2);
        }
    }
    rfalse;
];
[ call_U2340;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2127(noun)))) && (((((self = actor),1)) && (call_U2126(I_money_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2340, 899, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "re broke.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2340, 899, 2);
        }
    }
    rfalse;
];
[ call_U2341;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2127(noun)))) && (((((self = actor),1)) && ((GProperty(OBJECT_TY, I_money_U1, A_P_price) < GProperty(OBJECT_TY, noun, A_P_price))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2341, 900, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You don";
        ParaContent();
        print "'";
        ParaContent();
        print "t have enough money to cover the price of ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ".";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2341, 900, 2);
        }
    }
    rfalse;
];
[ call_U2342;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2342, 901, 0);
        }
        WriteGProperty(OBJECT_TY, I_money_U1, A_P_price, (GProperty(OBJECT_TY, I_money_U1, A_P_price) - GProperty(OBJECT_TY, noun, A_P_price)));
        (say__p = 1);
        ParaContent();
        print "You fork over ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = noun), A_P_price));
        @pull self;
        ParaContent();
        print " for ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ", leaving yourself with ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = I_money_U1), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        if (call_U2126(I_money_U1)) {
            RemoveFromPlay(I_money_U1);
        }
        WriteGProperty(OBJECT_TY, noun, A_P_price, 0);
        MoveObject(noun, player);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2342, 901, 2);
        }
    }
    rfalse;
];
[ call_U2343;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_money_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2343, 902, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Best to leave it alone until you need to buy something.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2343, 902, 2);
        }
    }
    rfalse;
];
[ call_U2344;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2126(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2344, 903, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " is yours already.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2344, 903, 2);
        }
    }
    rfalse;
];
[ call_U2345;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun == I_money_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2345, 904, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The money belongs to you; you buy things with it.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2345, 904, 2);
        }
    }
    rfalse;
];
[ call_U2346;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun ofclass K20_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2346, 905, 0);
        }
        if (call_U55(noun)) {
            (say__p = 1);
            ParaContent();
            print "You catch just a hint of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " at the bottom.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(noun);
            ParaContent();
            print " contains ";
            ParaContent();
            @push self;
            call_U2558(GProperty(OBJECT_TY, (self = noun), A_P_current_volume));
            @pull self;
            ParaContent();
            print " of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2346, 905, 2);
        }
    }
    rfalse;
];
[ call_U2347 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K20_fluid_container)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if ((~~((((action == ##Drink)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U2347, 907, 0);
            }
            if (call_U55(tmp_0)) {
                (say__p = 1);
                ParaContent();
                print "empty ";
            } else {
            }
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2347, 907, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2347, 907, 2);
        }
    }
    rfalse;
];
[ call_U2348 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K20_fluid_container)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if ((~~((((action == ##Examine)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U2348, 908, 0);
            }
            if ((~~(call_U55(tmp_0)))) {
                (say__p = 1);
                ParaContent();
                print " of ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = tmp_0), A_P_liquid));
                @pull self;
                (c_style = ((c_style)&((~(((RECURSE_BIT + FULLINV_BIT) + PARTINV_BIT))))));
            }
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2348, 908, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2348, 908, 2);
        }
    }
    rfalse;
];
[ call_U2349;
    if ((((action == ##Insert)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K20_fluid_container)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2349, 909, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(second);
        ParaContent();
        print " has too narrow a mouth to accept anything but liquids.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2349, 909, 2);
        }
    }
    rfalse;
];
[ call_U2350;
    if ((((action == ##Drink)) && ((((actor == player)) && ((noun ofclass K20_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2350, 912, 0);
        }
        if (call_U55(noun)) {
            (say__p = 1);
            ParaContent();
            print "There is no more ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " within.";
            print "^";
            rtrue;
        } else {
            WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - 2));
            if ((GProperty(OBJECT_TY, noun, A_P_current_volume) < 0)) {
                WriteGProperty(OBJECT_TY, noun, A_P_current_volume, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You take a sip of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            if ((~~(call_U55(noun)))) {
                jump L_Say1;
            }
            ParaContent();
            print ", leaving ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " empty";
            .L_Say1;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2350, 912, 2);
        }
    }
    rfalse;
];
[ call_U2351;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2351, 913, 0);
        }
        if ((~~((noun ofclass K20_fluid_container)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t pour ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if ((~~((second ofclass K20_fluid_container)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t pour liquids into ";
            ParaContent();
            DefArt(second);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if ((noun == second)) {
            (say__p = 1);
            ParaContent();
            print "You can hardly pour ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " into itself.";
            print "^";
            rtrue;
        }
        if ((~~((GProperty(OBJECT_TY, noun, A_P_liquid) == GProperty(OBJECT_TY, second, A_P_liquid))))) {
            if (call_U55(second)) {
                WriteGProperty(OBJECT_TY, second, A_P_liquid, GProperty(OBJECT_TY, noun, A_P_liquid));
            } else {
                (say__p = 1);
                ParaContent();
                print "Mixing ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
                @pull self;
                ParaContent();
                print " with ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = second), A_P_liquid));
                @pull self;
                ParaContent();
                print " would give unsavory results.";
                print "^";
                rtrue;
            }
        }
        if (call_U55(noun)) {
            (say__p = 1);
            ParaContent();
            print "No more ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " remains in ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if (call_U69(second)) {
            (say__p = 1);
            ParaContent();
            CDefArt(second);
            ParaContent();
            print " cannot contain any more than it already holds.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2351, 913, 3);
        }
    }
    rfalse;
];
[ call_U2352 tmp_0;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2352, 914, 0);
        }
        (tmp_0 = (GProperty(OBJECT_TY, second, A_P_fluid_capacity) - GProperty(OBJECT_TY, second, A_P_current_volume)));
        if ((tmp_0 > GProperty(OBJECT_TY, noun, A_P_current_volume))) {
            (tmp_0 = GProperty(OBJECT_TY, noun, A_P_current_volume));
        }
        WriteGProperty(OBJECT_TY, second, A_P_current_volume, (GProperty(OBJECT_TY, second, A_P_current_volume) + tmp_0));
        WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - tmp_0));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2352, 914, 3);
        }
    }
    rfalse;
];
[ call_U2353;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2353, 915, 0);
        }
        (say__p = 1);
        if ((~~(call_U55(noun)))) {
            jump L_Say0;
        }
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " is now empty;";
        jump L_SayX0;
        .L_Say0;
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " now contains ";
        ParaContent();
        @push self;
        call_U2558(GProperty(OBJECT_TY, (self = noun), A_P_current_volume));
        @pull self;
        ParaContent();
        print " of ";
        ParaContent();
        @push self;
        E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
        @pull self;
        ParaContent();
        print "; ";
        .L_SayX0;
        (say__p = 1);
        ParaContent();
        DefArt(second);
        ParaContent();
        print " contains ";
        ParaContent();
        @push self;
        call_U2558(GProperty(OBJECT_TY, (self = second), A_P_current_volume));
        @pull self;
        ParaContent();
        print " of ";
        ParaContent();
        @push self;
        E10(GProperty(OBJECT_TY, (self = second), A_P_liquid));
        @pull self;
        if ((~~(call_U69(second)))) {
            jump L_Say3;
        }
        ParaContent();
        print ", and is now full";
        .L_Say3;
        ParaContent();
        print ".";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2353, 915, 3);
        }
    }
    rfalse;
];
[ call_U2354;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2354, 916, 0);
        }
        if ((~~(call_U261(second)))) {
            (say__p = 1);
            ParaContent();
            CDefArt(second);
            ParaContent();
            print " wouldn";
            ParaContent();
            print "'";
            ParaContent();
            print "t be a very effective place of concealment.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2354, 916, 3);
        }
    }
    rfalse;
];
[ call_U2355;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2355, 917, 0);
        }
        RemoveFromPlay(noun);
        call_U2285(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2355, 917, 3);
        }
    }
    rfalse;
];
[ call_U2356;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2356, 918, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You shove ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " out of sight beneath ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2356, 918, 3);
        }
    }
    rfalse;
];
[ call_U2357 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U2357, 919, 0);
        }
        if (call_U336(tmp_0)) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is switched on.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is switched off.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2357, 919, 2);
        }
    }
    rfalse;
];
[ call_U2358;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2358, 920, 0);
        }
        if ((noun ofclass K13_device)) {
            CarryOutActivity(V38_showing_action, noun);
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2358, 920, 3);
        }
    }
    rfalse;
];
[ call_U2359;
    if ((((actor == player)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2359, 921, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You flip a switch. ";
        CarryOutActivity(V38_showing_action, noun);
        rtrue;
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2359, 921, 2);
        }
    }
    rfalse;
];
[ call_U2360 tmp_0 tmp_1;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K21_electric_lamp)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U2360, 922, 0);
        }
        if (call_U336(tmp_0)) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is lit";
            if ((~~(((call_U2361)() > 1)))) {
                jump L_Say0;
            }
            ParaContent();
            print ", competing with ";
            ParaContent();
            objectloop (tmp_1 ofclass Object && (tmp_1 ofclass Object)) {
                if ((((tmp_1 ofclass K2_thing)) && (((call_U215(tmp_1)) && (((call_U249(tmp_1)) && ((~~((tmp_1 == tmp_0)))))))))) {
                    give tmp_1 workflag2;
                } else {
                    give tmp_1 ~workflag2;
                }
            }
            WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
            .L_Say0;
            ParaContent();
            print ".";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is dark.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2360, 922, 2);
        }
    }
    rfalse;
];
[ call_U2361 x x_ix counter;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (((call_U215(x)) && (call_U249(x)))) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U2362;
    if ((((actor == player)) && ((noun ofclass K21_electric_lamp)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2362, 923, 0);
        }
        call_U250(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2362, 923, 2);
        }
    }
    rfalse;
];
[ call_U2363;
    if ((((actor == player)) && ((noun ofclass K21_electric_lamp)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2363, 924, 0);
        }
        call_U253(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2363, 924, 2);
        }
    }
    rfalse;
];
[ call_U2364;
    if ((parameter_value == I_flashlight_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2364, 925, 0);
        }
        if (call_U336(I_flashlight_U1)) {
            (say__p = 1);
            ParaContent();
            print "A strong, narrow beam of light shines from the flashlight.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            print "It is currently switched off.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2364, 925, 2);
        }
    }
    rfalse;
];
[ call_U2365;
    if ((((parameter_value ofclass K21_electric_lamp)) && (call_U249(parameter_value)))) {
        if (debug_rules) {
            DB_Rule(call_U2365, 926, 0);
        }
        (say__p = 1);
        ParaContent();
        print "lit ";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2365, 926, 2);
        }
    }
    rfalse;
];
[ call_U2366;
    if ((((parameter_value ofclass K21_electric_lamp)) && (((call_U252(parameter_value)) && (call_U249(parameter_value)))))) {
        if (debug_rules) {
            DB_Rule(call_U2366, 927, 0);
        }
        (say__p = 1);
        ParaContent();
        print "extinguished ";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2366, 927, 2);
        }
    }
    rfalse;
];
[ call_U2367;
    if (debug_rules) {
        DB_Rule(call_U2367, 928, 0);
    }
    (say__p = 1);
    ParaContent();
    print "It is pitch black.  You are likely to be eaten by a grue.";
    print "^";
    rtrue;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2368;
    if (debug_rules) {
        DB_Rule(call_U2368, 929, 0);
    }
    (say__p = 1);
    ParaContent();
    print "It is too dark in here to see.";
    print "^";
    rtrue;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2369;
    if ((action == ##Go)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2369, 930, 0);
        }
        ((MStack-->(MstVO(var_id_U42, 5))) = 0);
        if ((location == thedark)) {
            ((MStack-->(MstVO(var_id_U42, 5))) = ((MStack-->(MstVO(var_id_U42, 5))) + 1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2369, 930, 2);
        }
    }
    rfalse;
];
[ call_U2370;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2370, 931, 0);
        }
        if ((location == thedark)) {
            ((MStack-->(MstVO(var_id_U42, 5))) = ((MStack-->(MstVO(var_id_U42, 5))) + 1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2370, 931, 3);
        }
    }
    rfalse;
];
[ call_U2371;
    if ((((action == ##Go)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2371, 932, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 5))) == 2)) {
            (say__p = 1);
            ParaContent();
            print "Oh no! You walked directly into the slavering fangs of a lurking grue!";
            print "^";
            (deadflag = bc_U1179);
            BlkValueIncRefCountPrimitive(deadflag);
            (story_complete = 1);
        }
        if ((~~(((MStack-->(MstVO(var_id_U42, 5))) == 2)))) {
            rfalse;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2371, 932, 2);
        }
    }
    rfalse;
];
[ call_U2372;
    if ((((actor == player)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2372, 933, 0);
        }
        call_U2145(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2372, 933, 2);
        }
    }
    rfalse;
];
[ call_U2373;
    if ((((actor == player)) && (((((MStack-->(MstVON(var_id_U42, 1))) ofclass K1_room)) && (((call_U246((MStack-->(MstVON(var_id_U42, 1))))) && (call_U2150((MStack-->(MstVON(var_id_U42, 1))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2373, 934, 0);
        }
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2373, 934, 2);
        }
    }
    rfalse;
];
[ call_U2374;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2374, 935, 0);
        }
        if ((noun == I_sailor_U1)) {
            (say__p = 1);
            ParaContent();
            print "Nothing happens here.";
            print "^";
            rtrue;
        }
        if ((~~((noun ofclass K8_person)))) {
            (say__p = 1);
            ParaContent();
            print "I think that only schizophrenics say ~Hello~ to ";
            ParaContent();
            IndefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2374, 935, 3);
        }
    }
    rfalse;
];
[ call_U2375;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2375, 936, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " bows his head to you in greeting.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2375, 936, 3);
        }
    }
    rfalse;
];
[ call_U2376;
    if ((((PAPR1)()) && (((((TimesActionHasHappened-->(ahc_id_U1)) == 10)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U1))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2376, 937, 0);
        }
        (say__p = 1);
        ParaContent();
        print "I think that phrase is getting a bit worn out.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2376, 937, 2);
        }
    }
    rfalse;
];
[ call_U2377;
    if ((((PAPR2)()) && (((((TimesActionHasHappened-->(ahc_id_U2)) == 20)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U2))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2377, 938, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You seem to be repeating yourself.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2377, 938, 2);
        }
    }
    rfalse;
];
[ call_U2378;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2378, 939, 0);
        }
        (say__p = 1);
        ParaContent();
        print "A voice nearby says ~Plugh~.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2378, 939, 3);
        }
    }
    rfalse;
];
[ call_U2379;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == player)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2379, 940, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Oh, stop fussing. You look fine.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2379, 940, 2);
        }
    }
    rfalse;
];
[ call_U2380;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_coupon_U1)))))) {
        if (debug_rules) {
            DB_Rule(call_U2380, 941, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_coupon_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2380, 941, 4);
        }
    }
    rfalse;
];
[ call_U2381;
    if (debug_rules) {
        DB_Rule(call_U2381, 942, 0);
    }
    if ((matched_text = SnippetIncludes(Consult_Grammar9, players_command))) {
        (say__p = 1);
        ParaContent();
        print "Please do not say please.";
        print "^";
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2382;
    if (debug_rules) {
        DB_Rule(call_U2382, 943, 0);
    }
    if ((turns == 100)) {
        (say__p = 1);
        ParaContent();
        print "Over the loud speaker, an announcment blares: Attention please. There is a vehicle being towed from the parking lot for parking illegally. The license plate of the car is ~862901~.";
        ParaContent();
        RunParagraphOn();
        if ((I_dashboard_U1 == SupporterOf(I_parking_stub_U1))) {
            (say__p = 1);
            ParaContent();
            print " You breathe a sigh of relief as you realize that";
            ParaContent();
            print "'";
            ParaContent();
            print "s not your plate. I guess it";
            ParaContent();
            print "'";
            ParaContent();
            print "s a good thing you remembered to place the parking stub on the dashboard.";
            print "^";
        }
        if ((~~((I_dashboard_U1 == SupporterOf(I_parking_stub_U1))))) {
            (say__p = 1);
            ParaContent();
            print " Your heart sinks as you realize that is your plate. You race to the parking lot in time to see the tow truck pull away with your car in tow";
            (deadflag = bc_U1180);
            BlkValueIncRefCountPrimitive(deadflag);
            (story_complete = 1);
        }
    }
    rfalse;
];
[ call_U2383 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U8());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U8 ct_0 ct_1;
    if (debug_rules) {
        DB_Rule(call_U2383, 944, 0);
    }
    (ct_0 = table_data_U9);
    (ct_1 = 1);
    BlkValueCopy((TableLookUpEntry)(ct_0,table_column_id_U13,ct_1,5), (((LocalParking-->(0)) = ct_0),(((LocalParking-->(1)) = ct_1),TEXT_TY_ExpandIfPerishable(I7SFRAME, ts_array_U503))));
    rfalse;
];
[ call_U2384 ct_0 ct_1;
    (say__p = 1);
    ParaContent();
    print "Hell Ride - A Ride to remember...^^In the early 1980~s, I had an Apple II Plus computer with 64K of RAM, dual 5.25";
    ParaContent();
    print "~";
    ParaContent();
    print " floppy disks, and a color monitor as big as a television. And the very first game I ever bought was Infocom's Zork I: The Great Underground Empire. This was cool. It was all text-based. The game described your surroundings and you interacted with commands that say what you wanted to do. This ~Interactive Fiction~ really evoked in a game what I appreciated most about reading: rich descriptions, colorful characters, and the like. After Zork I, there was Zork II and III. Enchanter, Moonmist, Suspect, and so many more. I played them all with my best friend Andy.^^Andy and I were software developers at the time and we thought, ~We can do this!~ So we set out to do this. We developed a game engine with a natural language parser And it was pretty good. We could support most of the kinds of things they did, certainly less graceful but pretty good. In fact, our parser was better than theirs in a case where the sentence was ambiguous. e.g. ~Walk into the room with the lamp.~ Is the player carrying the lamp? Or is the lamp in the room?^^For fun, we reverse engineered parts of Infocom's game format. We found the dictionary, certain text tokens use for text substitution, the game text. We also discovered the first example of compression I had ever seen and it just about made my head explode. They stored all ASCII characters in five bits! Pow! Mind blown. I had never considered anything like that. Just another hook.^^We developed two prototypes: Diner and Hell Ride. Diner was about bank robbers coming into the diner where you are a short order cook and have to save the day. Hell Ride was pretty close to what you find here. I decided to implement it using modern tools. It's pretty good.^^I hope you enjoy it,^^d.";
    rtrue;
];
[ call_U2385;
    if (debug_rules) {
        DB_Rule(call_U2385, 945, 0);
    }
    VM_Seed_RNG(0);
    rfalse;
];
[ call_U2386;
    if ((((action == ##Go)) && ((((actor == player)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_electrical_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2386, 946, 0);
        }
        MoveObject(player, (call_U2387)(), 0, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2386, 946, 2);
        }
    }
    rfalse;
];
[ call_U2387 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K1_room_First):x:(x = (x.K1_room_Next))) {
            if (call_U229(x)) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2388;
    if (debug_rules) {
        DB_Rule(call_U2388, 947, 0);
    }
    DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hell_ride_U1)), 0);
    (say__p = 1);
    ParaContent();
    print "The carnival is in town and you and your sweetie had a date to visit it. After dinner and just as you arrive at the carnival, you and your date have a terrible fight. They storm off leaving you alone at the carnival. You decide to stay at the carnival anyway.";
    print "^";
    rfalse;
];
[ call_U2389 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((call_U2284(I_dime_U1) == noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2389, 948, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2390();
        call_U2391();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2389, 948, 2);
        }
    }
    rfalse;
];
[ call_U2390 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2391 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2392;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_blueberries_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2392, 949, 0);
        }
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        (say__p = 1);
        ParaContent();
        print "Good Job!";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2392, 949, 2);
        }
    }
    rfalse;
];
[ call_U2393;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_coupon_U1)) && ((second == I_parking_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2393, 950, 0);
        }
        if ((I_parking_attendant_U1 == CarrierOf(I_parking_ticket_U1))) {
            WriteGProperty(OBJECT_TY, I_parking_ticket_U1, A_P_price, 300);
            MoveObject(I_coupon_U1, I_parking_attendant_U1);
            (say__p = 1);
            ParaContent();
            print "Given. The price of a parking ticket is now ";
            ParaContent();
            @push self;
            E6(GProperty(OBJECT_TY, (self = I_parking_ticket_U1), A_P_price));
            @pull self;
            ParaContent();
            print ".";
            print "^";
        } else {
            if ((player == CarrierOf(I_parking_ticket_U1))) {
                (say__p = 1);
                ParaContent();
                print "Given. But you already bought a parking ticket.";
                print "^";
                MoveObject(I_coupon_U1, I_parking_attendant_U1);
            } else {
                (say__p = 1);
                ParaContent();
                print "Danger Will Robinson, this is a bug!";
                print "^";
            }
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2393, 950, 2);
        }
    }
    rfalse;
];
[ call_U2394;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun == I_parking_ticket_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2394, 951, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The attendant says, ~Don";
        ParaContent();
        print "'";
        ParaContent();
        print "t forget to leave the parking stub on your dashboard~.";
        print "^";
        MoveObject(I_parking_ticket_U1, player);
        MoveObject(I_parking_stub_U1, player);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2394, 951, 2);
        }
    }
    rfalse;
];
[ call_U2395;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_parking_lot_U1)) && ((~~((player == CarrierOf(I_parking_ticket_U1))))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2395, 952, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You have to pay to park.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2395, 952, 2);
        }
    }
    rfalse;
];
[ call_U2396;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_parking_lot_U1)) && ((I_beater_car_U1 == ContainerOf(player))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2396, 953, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You have to exit your car first.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2396, 953, 2);
        }
    }
    rfalse;
];
[ call_U2397;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_parking_lot_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (((call_U246(I_kiosk_U1)) && ((player == CarrierOf(I_parking_ticket_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2397, 954, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ticketbooth_U1)), 0);
        (say__p = 1);
        ParaContent();
        @push self;
        TEXT_TY_Say(GProperty(OBJECT_TY, (self = I_kiosk_U1), A_description));
        @pull self;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2397, 954, 2);
        }
    }
    rfalse;
];
[ call_U2398;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_kiosk_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2398, 955, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ticketbooth_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2398, 955, 2);
        }
    }
    rfalse;
];
[ call_U2399;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun == I_hell_ride_ticket_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2399, 956, 0);
        }
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        (say__p = 1);
        ParaContent();
        print "Well done!";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2399, 956, 2);
        }
    }
    rfalse;
];
[ call_U2400;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_southwest_U1)) && (((((self = actor),1)) && ((((real_location == I_kiosk_U1)) && (call_U246(I_concession_stand_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2400, 957, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_concessionstand_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2400, 957, 2);
        }
    }
    rfalse;
];
[ call_U2401;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_concession_stand_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2401, 958, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_concessionstand_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2401, 958, 2);
        }
    }
    rfalse;
];
[ call_U2402;
    if ((((action == ##Drink)) && ((((actor == player)) && ((noun ofclass K20_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2402, 959, 0);
        }
        if (call_U55(I_can_U1)) {
            (say__p = 1);
            ParaContent();
            CDefArt(actor);
            ParaContent();
            print " tip the can again only to find it empty.";
            print "^";
        } else {
            WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - 20));
            if ((GProperty(OBJECT_TY, noun, A_P_current_volume) < 0)) {
                WriteGProperty(OBJECT_TY, noun, A_P_current_volume, 0);
            }
            (say__p = 1);
            ParaContent();
            CDefArt(actor);
            ParaContent();
            print " gulp down some ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2402, 959, 2);
        }
    }
    rfalse;
];
[ call_U2403;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_east_U1)) && (((((self = actor),1)) && ((((real_location == I_kiosk_U1)) && (call_U246(I_high_striker_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2403, 960, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_highstriker_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2403, 960, 2);
        }
    }
    rfalse;
];
[ call_U2404;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_high_striker_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2404, 961, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_highstriker_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2404, 961, 2);
        }
    }
    rfalse;
];
[ call_U2405;
    if ((((action == ##Take)) && ((((actor == player)) && (((((self = actor),1)) && ((I_swiss_army_knife_U1 == ContainerOf(noun))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2405, 962, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That";
        ParaContent();
        print "'";
        ParaContent();
        print "s part of the Swiss Army knife. You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t take that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2405, 962, 2);
        }
    }
    rfalse;
];
[ call_U2406;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2406, 963, 0);
        }
        if ((~~((noun == I_lever_U1)))) {
            (say__p = 1);
            ParaContent();
            print "Nothing happens.";
            print "^";
            rtrue;
        }
        if ((~~((second == I_mallet_U1)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t hit ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " with that!";
            print "^";
            rtrue;
        }
        if ((~~((player == CarrierOf(I_mallet_U1))))) {
            (say__p = 1);
            ParaContent();
            print "You";
            ParaContent();
            print "'";
            ParaContent();
            print "re not holding the mallet.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2406, 963, 3);
        }
    }
    rfalse;
];
[ call_U2407;
    if ((actor == player)) {
        if ((player == CarrierOf(I_mallet_U1))) {
            if (debug_rules) {
                DB_Rule(call_U2407, 964, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You lift the mallet high and bring it down on the lever with all your might! The striker rises towards the bell stopping at ~";
            ParaContent();
            E11((call_U2332)(I_weakling_U1,I_almost_there_U1));
            ParaContent();
            print "~.  C";
            ParaContent();
            print "'";
            ParaContent();
            print "mon! You can do better than that!";
            print "^";
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2407, 964, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2407, 964, 3);
        }
    }
    rfalse;
];
[ call_U2408;
    if ((((PAPR3)()) && (((((TimesActionHasHappened-->(ahc_id_U3)) == 5)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U3))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2408, 965, 0);
        }
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (say__p = 1);
        ParaContent();
        print "You swing the mallet one more time. The bell rings as the striker reaches the top of the pole. The attendant says, ~You";
        ParaContent();
        print "'";
        ParaContent();
        print "re a Muscle Man. Here";
        ParaContent();
        print "'";
        ParaContent();
        print "s a prize for you.~";
        print "^";
        (say__p = 1);
        ParaContent();
        print "Which prize would you like? 1) a teddy bear, 2) a Swiss Army knife, 3) a poster of Taylor Swift, or 4) a magenta fuse?";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2408, 965, 2);
        }
    }
    rfalse;
];
[ call_U2409;
    if (debug_rules) {
        DB_Rule(call_U2409, 966, 0);
    }
    if (((SnippetMatches(players_command, Consult_Grammar10)) && ((((real_location == I_high_striker_U1)) && ((((~~((player == CarrierOf(I_teddy_bear_U1))))) && ((((~~((player == CarrierOf(I_swiss_army_knife_U1))))) && ((((~~((player == CarrierOf(I_poster_of_taylor_swift_U1))))) && ((~~((player == CarrierOf(I_magenta_fuse_U1))))))))))))))) {
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        (say__p = 1);
        ParaContent();
        print "You are now holding a cute little teddy bear.";
        print "^";
        MoveObject(I_teddy_bear_U1, player);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2410;
    if (debug_rules) {
        DB_Rule(call_U2410, 967, 0);
    }
    if (((SnippetMatches(players_command, Consult_Grammar11)) && ((((real_location == I_high_striker_U1)) && ((((~~((player == CarrierOf(I_teddy_bear_U1))))) && ((((~~((player == CarrierOf(I_swiss_army_knife_U1))))) && ((((~~((player == CarrierOf(I_poster_of_taylor_swift_U1))))) && ((~~((player == CarrierOf(I_magenta_fuse_U1))))))))))))))) {
        (say__p = 1);
        ParaContent();
        print "You are now holding a Swiss Army knife.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        MoveObject(I_swiss_army_knife_U1, player);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2411;
    if (debug_rules) {
        DB_Rule(call_U2411, 968, 0);
    }
    if (((SnippetMatches(players_command, Consult_Grammar12)) && ((((real_location == I_high_striker_U1)) && ((((~~((player == CarrierOf(I_teddy_bear_U1))))) && ((((~~((player == CarrierOf(I_swiss_army_knife_U1))))) && ((((~~((player == CarrierOf(I_poster_of_taylor_swift_U1))))) && ((~~((player == CarrierOf(I_magenta_fuse_U1))))))))))))))) {
        (say__p = 1);
        ParaContent();
        print "You are now holding a poster of Taylor Swift.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        MoveObject(I_poster_of_taylor_swift_U1, player);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2412;
    if (debug_rules) {
        DB_Rule(call_U2412, 969, 0);
    }
    if (((SnippetMatches(players_command, Consult_Grammar13)) && ((((real_location == I_high_striker_U1)) && ((((~~((player == CarrierOf(I_teddy_bear_U1))))) && ((((~~((player == CarrierOf(I_swiss_army_knife_U1))))) && ((((~~((player == CarrierOf(I_poster_of_taylor_swift_U1))))) && ((~~((player == CarrierOf(I_magenta_fuse_U1))))))))))))))) {
        (say__p = 1);
        ParaContent();
        print "You are now holding a magenta colored fuse.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        MoveObject(I_magenta_fuse_U1, player);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2413;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_kiosk_U1)) && (call_U246(I_show_facade_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2413, 970, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptfacad_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2413, 970, 2);
        }
    }
    rfalse;
];
[ call_U2414;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_show_facade_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2414, 971, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptfacad_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2414, 971, 2);
        }
    }
    rfalse;
];
[ call_U2415;
    if ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && ((~~((I_barker_U1 == CarrierOf(I_dime_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2415, 972, 0);
        }
        (say__p = 1);
        ParaContent();
        print "It";
        ParaContent();
        print "'";
        ParaContent();
        print "ll cost you a dime to go that way.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2415, 972, 2);
        }
    }
    rfalse;
];
[ call_U2416;
    if ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && ((I_barker_U1 == CarrierOf(I_dime_U1))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2416, 973, 0);
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2416, 973, 2);
        }
    }
    rfalse;
];
[ call_U2417;
    if ((((action == ##Give)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_dime_U1)) && ((second == I_barker_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2417, 974, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hand over a dime, and the barker nods, waving you through. As you step past the entrance, the air feels thicker, almost humid, and the sounds of the carnival fade away. You've entered an entirely different world now-one filled with the scents of incense and exotic spices, and the low, hypnotic music of a faraway land. Before you, a series of dimly lit tents stretch out, their flaps slightly swaying in the breeze. Intrigued, you take your first step into the Little Egypt Show. You can now head west into the show.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2417, 974, 2);
        }
    }
    rfalse;
];
[ call_U2418;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && (((call_U246(I_show_tent_U1)) && ((I_barker_U1 == CarrierOf(I_dime_U1))))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2418, 975, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptshow_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2418, 975, 2);
        }
    }
    rfalse;
];
[ call_U2419;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_show_tent_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2419, 976, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptshow_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2419, 976, 2);
        }
    }
    rfalse;
];
[ call_U2420;
    if (debug_rules) {
        DB_Rule(call_U2420, 977, 0);
    }
    (say__p = 1);
    ParaContent();
    print "You applaud until your hands are sore. Did she just wink at me?";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "As she leaves the stage, Little Egypt tosses one of her veils to you!";
    print "^";
    PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
    (score = (score + 5));
    MoveObject(I_sheer_veil_U1, player);
    rfalse;
];
[ call_U2421 ct_0 ct_1 tmp_0 tmp_1;
    if (((scene_status-->(1)) == 1)) {
        if (debug_rules) {
            DB_Rule(call_U2421, 978, 0);
        }
        @push ct_0;
        @push ct_1;
        for (((tmp_0 = table_data_U14),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U19, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
                TableBlankOutRow(ct_0, ct_1);
                RulebookSucceeds();
                rtrue;
            }
        }
        @pull ct_1;
        @pull ct_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2421, 978, 1);
        }
    }
    rfalse;
];
[ call_U2422;
    if (((scene_status-->(1)) == 1)) {
        if ((((actor == player)) && ((~~((((action == ##Examine)) || ((((action == ##Listen)) || ((((action == ##Look)) || ((action == ##Wait)))))))))))) {
            (self = noun);
            if (debug_rules) {
                DB_Rule(call_U2422, 979, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You";
            ParaContent();
            print "'";
            ParaContent();
            print "re much too entranced to do anything other than watch the show. You are riveted";
            ParaContent();
            if ((~~((I_folding_chair_U1 == ContainerOf(player))))) {
                jump L_Say0;
            }
            ParaContent();
            print " to your seat";
            .L_Say0;
            ParaContent();
            print "!";
            print "^";
            RulebookFails(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2422, 979, 2);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2422, 979, 1);
        }
    }
    rfalse;
];
[ call_U2423;
    if ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_head_of_the_line_U1)) && ((~~((I_ride_attendant_U1 == OwnerOf(I_hell_ride_ticket_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2423, 980, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "ll need a ticket to go that way.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2423, 980, 2);
        }
    }
    rfalse;
];
[ call_U2424;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_kiosk_U1)) && (call_U246(I_head_of_the_line_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2424, 981, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hellrideentrance_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2424, 981, 2);
        }
    }
    rfalse;
];
[ call_U2425;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_head_of_the_line_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2425, 982, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hellrideentrance_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2425, 982, 2);
        }
    }
    rfalse;
];
[ call_U2426;
    if (debug_rules) {
        DB_Rule(call_U2426, 983, 0);
    }
    (say__p = 1);
    ParaContent();
    print "The car moves forward and the safety bar begins to lower.";
    print "^";
    rfalse;
];
[ call_U2427 ct_0 ct_1 tmp_0 tmp_1;
    if (((scene_status-->(2)) == 1)) {
        if (debug_rules) {
            DB_Rule(call_U2427, 984, 0);
        }
        @push ct_0;
        @push ct_1;
        for (((tmp_0 = table_data_U15),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U19, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
                TableBlankOutRow(ct_0, ct_1);
                RulebookSucceeds();
                rtrue;
            }
        }
        @pull ct_1;
        @pull ct_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2427, 984, 1);
        }
    }
    rfalse;
];
[ call_U2428;
    if (((scene_status-->(2)) == 1)) {
        if ((((actor == player)) && ((~~((((action == ##Examine)) || ((((action == ##Listen)) || ((((action == ##Look)) || ((action == ##Wait)))))))))))) {
            (self = noun);
            if (debug_rules) {
                DB_Rule(call_U2428, 985, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You are having such a good time that you don";
            ParaContent();
            print "'";
            ParaContent();
            print " want to do anything but wait and enjoy the ride.";
            print "^";
            RulebookFails(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2428, 985, 2);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2428, 985, 1);
        }
    }
    rfalse;
];
[ call_U2429;
    if (debug_rules) {
        DB_Rule(call_U2429, 986, 0);
    }
    (deadflag = bc_U1181);
    BlkValueIncRefCountPrimitive(deadflag);
    (story_complete = 1);
    rfalse;
];
[ call_U2430;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((I_ride_entrance_U1 == ContainerOf(player))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2430, 987, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can't go that way.";
        print "^";
        rtrue;
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2430, 987, 2);
        }
    }
    rfalse;
];
[ call_U2431 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((call_U2284(I_aqua_fuse_U1) == noun)))) && (((((self = actor),1)) && (call_U2168(I_aqua_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2431, 988, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2432();
        call_U2433();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_aqua_fuse_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2431, 988, 2);
        }
    }
    rfalse;
];
[ call_U2432 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2433 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2434 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((call_U2284(I_crimson_fuse_U1) == noun)))) && (((((self = actor),1)) && (call_U2168(I_crimson_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2434, 989, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2435();
        call_U2436();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_crimson_fuse_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2434, 989, 2);
        }
    }
    rfalse;
];
[ call_U2435 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2436 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2437 tmp_0;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun == I_emerald_fuse_U1)) && (((((self = actor),1)) && (call_U2168(I_emerald_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2437, 990, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((tmp_0 == ContainerOf(noun))))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2438();
        call_U2439();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_emerald_fuse_U1);
        MoveObject(I_emerald_fuse_U1, player);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2437, 990, 2);
        }
    }
    rfalse;
];
[ call_U2438 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2439 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2440 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((call_U2284(I_gray_fuse_U1) == noun)))) && (((((self = actor),1)) && (call_U2168(I_gray_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2440, 991, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2441();
        call_U2442();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_gray_fuse_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2440, 991, 2);
        }
    }
    rfalse;
];
[ call_U2441 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2442 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2443 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((call_U2284(I_indigo_fuse_U1) == noun)))) && (((((self = actor),1)) && (call_U2168(I_indigo_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2443, 992, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2444();
        call_U2445();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_indigo_fuse_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2443, 992, 2);
        }
    }
    rfalse;
];
[ call_U2444 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2445 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2446 tmp_0;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun == I_khaki_fuse_U1)) && (((((self = actor),1)) && (call_U2168(I_khaki_fuse_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2446, 993, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2284(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2447();
        call_U2448();
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        call_U2172(I_khaki_fuse_U1);
        MoveObject(I_khaki_fuse_U1, player);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2446, 993, 2);
        }
    }
    rfalse;
];
[ call_U2447 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, player);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2448 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2284(x) == noun)) {
            (qcn_0)++;
            call_U2286(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2449;
    if ((((action == ##LookUnder)) && ((((actor == player)) && (((((self = actor),1)) && ((noun == I_pile_of_junk_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2449, 994, 0);
        }
        TryAction(0, player, ##Examine, I_pile_of_junk_U1, 0);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2449, 994, 2);
        }
    }
    rfalse;
];
[ call_U2450;
    if ((((action == ##Examine)) && ((((actor == player)) && (((((self = actor),1)) && ((noun == I_pile_of_junk_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2450, 995, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find a flashlight here.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2450, 995, 2);
        }
    }
    rfalse;
];
[ call_U2451;
    if ((((PAPR4)()) && (((((TimesActionHasHappened-->(ahc_id_U4)) == 1)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U4))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2451, 996, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
        (score = (score + 5));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2451, 996, 2);
        }
    }
    rfalse;
];
[ call_U2452;
    if (((call_U336(I_radio_U1)) && ((real_location == I_maintenance_office_U1)))) {
        if (debug_rules) {
            DB_Rule(call_U2452, 997, 0);
        }
        (say__p = 1);
        ParaContent();
        if (((label_associated_storage_U1668-->(0)) == 0)) {
            ((label_associated_storage_U1667-->(0)) = (I7_SOO_CYC)((label_associated_storage_U1667-->(0)),5));
            ((label_associated_storage_U1668-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1668-->(0)) = 0);
        }
        switch ((((label_associated_storage_U1667-->(0))%(5 + 1)) - 1)) {
            0:
                ParaContent();
                print "~The radio plays ~Stairway to Heaven~ by Led Zeppelin.";
                print "^";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "~The DJ just cued up Pink Floyd";
                ParaContent();
                print "'";
                ParaContent();
                print "s ~Comfortably Numb~.";
                print "^";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "Pharell";
                ParaContent();
                print "'";
                ParaContent();
                print "s ~Happy~ is playing now.";
                print "^";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "~Folsom Prison Blues~ by Johnny Cash is on the air.";
                print "^";
                ParaContent();
                @nop;
                ;
            4:
                ParaContent();
                print "~Peace Train~ by Cat Stevens can be heard playing on the radio.";
                print "^";
                ParaContent();
                ;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2452, 997, 4);
        }
    }
    rfalse;
];
[ call_U2453;
    if ((parameter_value == I_radio_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2453, 998, 0);
        }
        if (call_U336(I_radio_U1)) {
            (say__p = 1);
            ParaContent();
            print "Through the static, you pick up hear bits of the latest Taylor Swift song.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            print "The radio is silent. You";
            ParaContent();
            print "'";
            ParaContent();
            print "re saving the batteries.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2453, 998, 2);
        }
    }
    rfalse;
];
[ call_U2454;
    if ((((action == ##Listen)) && ((((actor == player)) && ((((((I_radio_U1 == I_radio_U1)) && (call_U336(I_radio_U1)))) && (TestScope(I_radio_U1, actor)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2454, 999, 0);
        }
        CarryOutActivity(V38_showing_action, I_radio_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2454, 999, 2);
        }
    }
    rfalse;
];
[ call_U2455;
    if ((((action == ##Climb)) && ((((actor == player)) && ((noun == I_ladder_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2455, 1000, 0);
        }
        TryAction(0, player, ##Enter, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2455, 1000, 2);
        }
    }
    rfalse;
];
[ call_U2456;
    if ((real_location == I_electrical_room_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2456, 1001, 0);
        }
        (say__p = 1);
        ParaContent();
        print "This room is oozing with electromagnetic energy. You can feel your hair stand on end and all your nerves twitching. This feels dangerous! There are exits in all directions.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2456, 1001, 4);
        }
    }
    rfalse;
];
[ call_U2457;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_eleven_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2457, 1002, 0);
        }
        if (((call_U339(I_switch_eleven_U1)) && ((~~((I_socket_eleven_U1 == ContainerOf(I_khaki_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_eleven_U1)) && ((((I_socket_eleven_U1 == ContainerOf(I_khaki_fuse_U1))) && (((Global_Vars-->57) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_eleven_U1);
            call_U337(I_indicator_light_eleven_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->57) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_eleven_U1)) && ((((I_socket_eleven_U1 == ContainerOf(I_khaki_fuse_U1))) && (((Global_Vars-->57) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_eleven_U1);
            call_U337(I_indicator_light_eleven_U1);
            rtrue;
        }
        if (((call_U339(I_switch_eleven_U1)) && ((I_socket_nine_U1 == ContainerOf(I_khaki_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_eleven_U1);
            call_U337(I_indicator_light_eleven_U1);
            rtrue;
        }
        if (call_U336(I_switch_eleven_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_eleven_U1);
            call_U340(I_indicator_light_eleven_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2457, 1002, 2);
        }
    }
    rfalse;
];
[ call_U2458;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_eleven_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2458, 1003, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2458, 1003, 2);
        }
    }
    rfalse;
];
[ call_U2459;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2459, 1004, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2459, 1004, 2);
        }
    }
    rfalse;
];
[ call_U2460;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_eleven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2460, 1005, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2460, 1005, 2);
        }
    }
    rfalse;
];
[ call_U2461;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2461, 1006, 0);
        }
        if (((call_U2162(I_socket_eleven_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_eleven_U1);
            call_U340(I_switch_eleven_U1);
            call_U2166(I_socket_eleven_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2461, 1006, 2);
        }
    }
    rfalse;
];
[ call_U2462;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_khaki_fuse_U1)) && ((((second == I_socket_eleven_U1)) && (((call_U2165(I_socket_eleven_U1)) && (call_U306(I_electrical_panel_eleven_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2462, 1007, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_eleven_U1);
        MoveObject(I_khaki_fuse_U1, I_socket_eleven_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2462, 1007, 2);
        }
    }
    rfalse;
];
[ call_U2463;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_eleven_U1)) && (call_U2165(I_socket_eleven_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2463, 1008, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_eleven_U1);
        call_U2163(I_socket_eleven_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2463, 1008, 2);
        }
    }
    rfalse;
];
[ call_U2464;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_eleven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2464, 1009, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_eleven_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2464, 1009, 2);
        }
    }
    rfalse;
];
[ call_U2465;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_eleven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2465, 1010, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2465, 1010, 2);
        }
    }
    rfalse;
];
[ call_U2466;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_nine_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2466, 1011, 0);
        }
        if (((call_U339(I_switch_nine_U1)) && ((~~((I_socket_nine_U1 == ContainerOf(I_indigo_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_nine_U1)) && ((((I_socket_nine_U1 == ContainerOf(I_indigo_fuse_U1))) && (((Global_Vars-->58) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_nine_U1);
            call_U337(I_indicator_light_nine_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->58) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_nine_U1)) && ((((I_socket_nine_U1 == ContainerOf(I_indigo_fuse_U1))) && (((Global_Vars-->58) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_nine_U1);
            call_U337(I_indicator_light_nine_U1);
            rtrue;
        }
        if (((call_U339(I_switch_nine_U1)) && ((I_socket_nine_U1 == ContainerOf(I_indigo_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_nine_U1);
            call_U337(I_indicator_light_nine_U1);
            rtrue;
        }
        if (call_U336(I_switch_nine_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_nine_U1);
            call_U340(I_indicator_light_nine_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2466, 1011, 2);
        }
    }
    rfalse;
];
[ call_U2467;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_nine_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2467, 1012, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2467, 1012, 2);
        }
    }
    rfalse;
];
[ call_U2468;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2468, 1013, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2468, 1013, 2);
        }
    }
    rfalse;
];
[ call_U2469;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_nine_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2469, 1014, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2469, 1014, 2);
        }
    }
    rfalse;
];
[ call_U2470;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2470, 1015, 0);
        }
        if (((call_U2162(I_socket_nine_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_nine_U1);
            call_U340(I_switch_nine_U1);
            call_U2166(I_socket_nine_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2470, 1015, 2);
        }
    }
    rfalse;
];
[ call_U2471;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_indigo_fuse_U1)) && ((((second == I_socket_nine_U1)) && (((call_U2165(I_socket_nine_U1)) && (call_U306(I_electrical_panel_nine_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2471, 1016, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_nine_U1);
        MoveObject(I_indigo_fuse_U1, I_socket_nine_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2471, 1016, 2);
        }
    }
    rfalse;
];
[ call_U2472;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_nine_U1)) && (call_U2165(I_socket_nine_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2472, 1017, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_nine_U1);
        call_U2163(I_socket_nine_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2472, 1017, 2);
        }
    }
    rfalse;
];
[ call_U2473;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_nine_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2473, 1018, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_nine_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2473, 1018, 2);
        }
    }
    rfalse;
];
[ call_U2474;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_nine_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2474, 1019, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2474, 1019, 2);
        }
    }
    rfalse;
];
[ call_U2475;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_seven_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2475, 1020, 0);
        }
        if (((call_U339(I_switch_seven_U1)) && ((~~((I_socket_seven_U1 == ContainerOf(I_gray_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_seven_U1)) && ((((I_socket_seven_U1 == ContainerOf(I_gray_fuse_U1))) && (((Global_Vars-->59) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_seven_U1);
            call_U337(I_indicator_light_seven_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->59) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_seven_U1)) && ((((I_socket_seven_U1 == ContainerOf(I_gray_fuse_U1))) && (((Global_Vars-->59) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_seven_U1);
            call_U337(I_indicator_light_seven_U1);
            rtrue;
        }
        if (((call_U339(I_switch_seven_U1)) && ((I_socket_nine_U1 == ContainerOf(I_gray_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_seven_U1);
            call_U337(I_indicator_light_seven_U1);
            rtrue;
        }
        if (call_U336(I_switch_seven_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_seven_U1);
            call_U340(I_indicator_light_seven_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2475, 1020, 2);
        }
    }
    rfalse;
];
[ call_U2476;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_seven_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2476, 1021, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2476, 1021, 2);
        }
    }
    rfalse;
];
[ call_U2477;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2477, 1022, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2477, 1022, 2);
        }
    }
    rfalse;
];
[ call_U2478;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_seven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2478, 1023, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2478, 1023, 2);
        }
    }
    rfalse;
];
[ call_U2479;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2479, 1024, 0);
        }
        if (((call_U2162(I_socket_seven_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_seven_U1);
            call_U340(I_switch_seven_U1);
            call_U2166(I_socket_seven_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2479, 1024, 2);
        }
    }
    rfalse;
];
[ call_U2480;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_gray_fuse_U1)) && ((((second == I_socket_seven_U1)) && (((call_U2165(I_socket_seven_U1)) && (call_U306(I_electrical_panel_seven_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2480, 1025, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_seven_U1);
        MoveObject(I_gray_fuse_U1, I_socket_seven_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2480, 1025, 2);
        }
    }
    rfalse;
];
[ call_U2481;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_seven_U1)) && (call_U2165(I_socket_seven_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2481, 1026, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_seven_U1);
        call_U2163(I_socket_seven_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2481, 1026, 2);
        }
    }
    rfalse;
];
[ call_U2482;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_seven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2482, 1027, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_seven_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2482, 1027, 2);
        }
    }
    rfalse;
];
[ call_U2483;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_seven_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2483, 1028, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2483, 1028, 2);
        }
    }
    rfalse;
];
[ call_U2484;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_five_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2484, 1029, 0);
        }
        if (((call_U339(I_switch_five_U1)) && ((~~((I_socket_five_U1 == ContainerOf(I_emerald_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_five_U1)) && ((((I_socket_five_U1 == ContainerOf(I_emerald_fuse_U1))) && (((Global_Vars-->60) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_five_U1);
            call_U337(I_indicator_light_five_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->60) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_five_U1)) && ((((I_socket_five_U1 == ContainerOf(I_emerald_fuse_U1))) && (((Global_Vars-->60) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_five_U1);
            call_U337(I_indicator_light_five_U1);
            rtrue;
        }
        if (((call_U339(I_switch_five_U1)) && ((I_socket_nine_U1 == ContainerOf(I_emerald_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_five_U1);
            call_U337(I_indicator_light_five_U1);
            rtrue;
        }
        if (call_U336(I_switch_five_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_five_U1);
            call_U340(I_indicator_light_five_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2484, 1029, 2);
        }
    }
    rfalse;
];
[ call_U2485;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_five_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2485, 1030, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2485, 1030, 2);
        }
    }
    rfalse;
];
[ call_U2486;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2486, 1031, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2486, 1031, 2);
        }
    }
    rfalse;
];
[ call_U2487;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_five_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2487, 1032, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2487, 1032, 2);
        }
    }
    rfalse;
];
[ call_U2488;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2488, 1033, 0);
        }
        if (((call_U2162(I_socket_five_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_five_U1);
            call_U340(I_switch_five_U1);
            call_U2166(I_socket_five_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2488, 1033, 2);
        }
    }
    rfalse;
];
[ call_U2489;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_emerald_fuse_U1)) && ((((second == I_socket_five_U1)) && (((call_U2165(I_socket_five_U1)) && (call_U306(I_electrical_panel_five_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2489, 1034, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_five_U1);
        MoveObject(I_emerald_fuse_U1, I_socket_five_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2489, 1034, 2);
        }
    }
    rfalse;
];
[ call_U2490;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_five_U1)) && (call_U2165(I_socket_five_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2490, 1035, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_five_U1);
        call_U2163(I_socket_five_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2490, 1035, 2);
        }
    }
    rfalse;
];
[ call_U2491;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_five_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2491, 1036, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_five_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2491, 1036, 2);
        }
    }
    rfalse;
];
[ call_U2492;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_five_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2492, 1037, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2492, 1037, 2);
        }
    }
    rfalse;
];
[ call_U2493;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_three_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2493, 1038, 0);
        }
        if (((call_U339(I_switch_three_U1)) && ((~~((I_socket_three_U1 == ContainerOf(I_crimson_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_three_U1)) && ((((I_socket_three_U1 == ContainerOf(I_crimson_fuse_U1))) && (((Global_Vars-->61) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_three_U1);
            call_U337(I_indicator_light_three_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->61) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_three_U1)) && ((((I_socket_three_U1 == ContainerOf(I_crimson_fuse_U1))) && (((Global_Vars-->61) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_three_U1);
            call_U337(I_indicator_light_three_U1);
            rtrue;
        }
        if (((call_U339(I_switch_three_U1)) && ((I_socket_nine_U1 == ContainerOf(I_crimson_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_three_U1);
            call_U337(I_indicator_light_three_U1);
            rtrue;
        }
        if (call_U336(I_switch_three_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_three_U1);
            call_U340(I_indicator_light_three_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2493, 1038, 2);
        }
    }
    rfalse;
];
[ call_U2494;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_three_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2494, 1039, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2494, 1039, 2);
        }
    }
    rfalse;
];
[ call_U2495;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2495, 1040, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2495, 1040, 2);
        }
    }
    rfalse;
];
[ call_U2496;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_three_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2496, 1041, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2496, 1041, 2);
        }
    }
    rfalse;
];
[ call_U2497;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2497, 1042, 0);
        }
        if (((call_U2162(I_socket_three_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_three_U1);
            call_U340(I_switch_three_U1);
            call_U2166(I_socket_three_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2497, 1042, 2);
        }
    }
    rfalse;
];
[ call_U2498;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_crimson_fuse_U1)) && ((((second == I_socket_three_U1)) && (((call_U2165(I_socket_three_U1)) && (call_U306(I_electrical_panel_three_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2498, 1043, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_three_U1);
        MoveObject(I_crimson_fuse_U1, I_socket_three_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2498, 1043, 2);
        }
    }
    rfalse;
];
[ call_U2499;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_three_U1)) && (call_U2165(I_socket_three_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2499, 1044, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_three_U1);
        call_U2163(I_socket_three_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2499, 1044, 2);
        }
    }
    rfalse;
];
[ call_U2500;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_three_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2500, 1045, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_three_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2500, 1045, 2);
        }
    }
    rfalse;
];
[ call_U2501;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_three_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2501, 1046, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2501, 1046, 2);
        }
    }
    rfalse;
];
[ call_U2502;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_switch_one_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2502, 1047, 0);
        }
        if (((call_U339(I_switch_one_U1)) && ((~~((I_socket_one_U1 == ContainerOf(I_aqua_fuse_U1))))))) {
            (say__p = 1);
            ParaContent();
            print "You push the switch.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
        if (((call_U339(I_switch_one_U1)) && ((((I_socket_one_U1 == ContainerOf(I_aqua_fuse_U1))) && (((Global_Vars-->62) == 0)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_one_U1);
            call_U337(I_indicator_light_one_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            ((Global_Vars-->62) = 1);
            rtrue;
        }
        if (((call_U339(I_switch_one_U1)) && ((((I_socket_one_U1 == ContainerOf(I_aqua_fuse_U1))) && (((Global_Vars-->62) == 1)))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_one_U1);
            call_U337(I_indicator_light_one_U1);
            rtrue;
        }
        if (((call_U339(I_switch_one_U1)) && ((I_socket_nine_U1 == ContainerOf(I_aqua_fuse_U1))))) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes on.";
            print "^";
            call_U337(I_switch_one_U1);
            call_U337(I_indicator_light_one_U1);
            rtrue;
        }
        if (call_U336(I_switch_one_U1)) {
            (say__p = 1);
            ParaContent();
            print "The indicator light goes off.";
            print "^";
            call_U340(I_switch_one_U1);
            call_U340(I_indicator_light_one_U1);
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2502, 1047, 2);
        }
    }
    rfalse;
];
[ call_U2503;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun == I_indicator_light_one_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2503, 1048, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t turn that on.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2503, 1048, 2);
        }
    }
    rfalse;
];
[ call_U2504;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((~~((noun ofclass K24_colored_fuse)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2504, 1049, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That won";
        ParaContent();
        print "'";
        ParaContent();
        print "t fit in the socket.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2504, 1049, 2);
        }
    }
    rfalse;
];
[ call_U2505;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && (call_U2162(I_socket_one_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2505, 1050, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The socket is already filled.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2505, 1050, 2);
        }
    }
    rfalse;
];
[ call_U2506;
    if ((((action == ##Take)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2506, 1051, 0);
        }
        if (((call_U2162(I_socket_one_U1)) && ((noun ofclass K24_colored_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "Taken.";
            print "^";
            MoveObject(noun, player);
            call_U340(I_indicator_light_one_U1);
            call_U340(I_switch_one_U1);
            call_U2166(I_socket_one_U1);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2506, 1051, 2);
        }
    }
    rfalse;
];
[ call_U2507;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_aqua_fuse_U1)) && ((((second == I_socket_one_U1)) && (((call_U2165(I_socket_one_U1)) && (call_U306(I_electrical_panel_one_U1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2507, 1052, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the fuse slides into place.";
        print "^";
        call_U2163(I_socket_one_U1);
        MoveObject(I_aqua_fuse_U1, I_socket_one_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2507, 1052, 2);
        }
    }
    rfalse;
];
[ call_U2508;
    if ((((action == ##Insert)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K24_colored_fuse)) && ((((second == I_socket_one_U1)) && (call_U2165(I_socket_one_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2508, 1053, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You put the fuse in the socket.";
        print "^";
        MoveObject(noun, I_socket_one_U1);
        call_U2163(I_socket_one_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2508, 1053, 2);
        }
    }
    rfalse;
];
[ call_U2509;
    if ((((action == ##Unlock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_one_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2509, 1054, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the cover to the electrical panel.";
        print "^";
        call_U325(I_electrical_panel_one_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2509, 1054, 2);
        }
    }
    rfalse;
];
[ call_U2510;
    if ((((action == ##Lock)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_electrical_closet_one_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2510, 1055, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t lock that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2510, 1055, 2);
        }
    }
    rfalse;
];
[ call_U2511;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_control_panel_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2511, 1056, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The control panel is populated with a row of colored lights. From left to right, the colors are aqua, crimson, emerald, gray, indigo, and khaki. Below the lights is a row of similarly colored dials and below that is a row of buttons. (The poorly generated AI & human image is meant for comparison purposes only. LOL) The control panel is ";
        if ((~~(((Global_Vars-->63) == 6)))) {
            jump L_Say0;
        }
        ParaContent();
        print "lit up like a Christmas tree";
        jump L_SayX0;
        .L_Say0;
        ParaContent();
        print "dark";
        .L_SayX0;
        ParaContent();
        print ".";
        ParaContent();
        print "^";
        if (((((Global_Vars-->63) == 6)) && (call_U2512()))) {
            DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanel_U1)), 0);
        } else {
            if ((((I_socket_one_U1 == ContainerOf(I_aqua_fuse_U1))) && (call_U336(I_aqua_button_U1)))) {
                DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelstoc_U1)), 0);
            } else {
                if ((((I_socket_three_U1 == ContainerOf(I_crimson_fuse_U1))) && (call_U336(I_crimson_button_U1)))) {
                    DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelgall_U1)), 0);
                } else {
                    if ((((I_socket_five_U1 == ContainerOf(I_emerald_fuse_U1))) && (call_U336(I_emerald_button_U1)))) {
                        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelstak_U1)), 0);
                    } else {
                        if ((((I_socket_seven_U1 == ContainerOf(I_gray_fuse_U1))) && (call_U336(I_gray_button_U1)))) {
                            DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpaneldung_U1)), 0);
                        } else {
                            if ((((I_socket_nine_U1 == ContainerOf(I_indigo_fuse_U1))) && (call_U336(I_indigo_button_U1)))) {
                                DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelguil_U1)), 0);
                            } else {
                                if ((((I_socket_eleven_U1 == ContainerOf(I_khaki_fuse_U1))) && (call_U336(I_khaki_button_U1)))) {
                                    DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelexit_U1)), 0);
                                }
                            }
                        }
                    }
                }
            }
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2511, 1056, 2);
        }
    }
    rfalse;
];
[ call_U2512 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        if (call_U339(x)) {
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
        rtrue;
    }
    rfalse;
];
[ call_U2513;
    if ((real_location == I_control_room_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2513, 1058, 0);
        }
        if ((~~(((Global_Vars-->63) == 6)))) {
            call_U2514();
            call_U2515();
            WriteGProperty(OBJECT_TY, I_aqua_dial_U1, A_P_dial_setting, 0);
            WriteGProperty(OBJECT_TY, I_crimson_dial_U1, A_P_dial_setting, 0);
            WriteGProperty(OBJECT_TY, I_emerald_dial_U1, A_P_dial_setting, 0);
            WriteGProperty(OBJECT_TY, I_gray_dial_U1, A_P_dial_setting, 0);
            WriteGProperty(OBJECT_TY, I_indigo_dial_U1, A_P_dial_setting, 0);
            WriteGProperty(OBJECT_TY, I_khaki_dial_U1, A_P_dial_setting, 0);
            call_U2516();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2513, 1058, 4);
        }
    }
    rfalse;
];
[ call_U2514 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2515 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K27_colored_dial_First):x:(x = (x.K27_colored_dial_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2516 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2517;
    if ((real_location == I_control_room_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2517, 1059, 0);
        }
        call_U2559();
        call_U2560();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2517, 1059, 4);
        }
    }
    rfalse;
];
[ call_U2518;
    if ((((action == ##SwitchOn)) && ((((actor == player)) && ((noun ofclass K25_colored_light)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2518, 1060, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t do that!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2518, 1060, 2);
        }
    }
    rfalse;
];
[ call_U2519;
    if ((((action == ##SwitchOff)) && ((((actor == player)) && ((noun ofclass K25_colored_light)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2519, 1061, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t do that!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2519, 1061, 2);
        }
    }
    rfalse;
];
[ call_U2520;
    if (debug_rules) {
        DB_Rule(call_U2520, 1062, 0);
    }
    if ((I_holding_room_U1 == ContainerOf(player))) {
        (say__p = 1);
        ParaContent();
        print "This can never happen!";
        print "^";
    }
    rfalse;
];
[ call_U2521;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_indigo_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2521, 1063, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_indigo_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a tableau of a guillotine. It has stopped rising and falling over the ride exit. The ride is safe again!";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The indigo indicator is now on.";
            print "^";
            DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanelguil_U1)), 0);
            call_U2522();
            call_U2523();
            call_U337(I_indigo_button_U1);
            call_U337(I_indigo_light_U1);
            PlaySound((ResourceIDsOfSounds-->(I_sound_of_strongman_bell_U1)), 0);
            (score = (score + 5));
            (deadflag = bc_U1182);
            BlkValueIncRefCountPrimitive(deadflag);
            (story_complete = 1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The indigo indicator is now off.";
            print "^";
            call_U2524();
            call_U2525();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2521, 1063, 2);
        }
    }
    rfalse;
];
[ call_U2522 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2523 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2524 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2525 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2526;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_aqua_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2526, 1064, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_aqua_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a tableau of poor unfortunate townsfolk locked in stocks.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The aqua indicator is now on.";
            print "^";
            call_U2527();
            call_U2528();
            call_U337(I_aqua_button_U1);
            call_U337(I_aqua_light_U1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The aqua indicator is now off.";
            print "^";
            call_U2529();
            call_U2530();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2526, 1064, 2);
        }
    }
    rfalse;
];
[ call_U2527 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2528 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2529 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2530 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2531;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_crimson_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2531, 1065, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_crimson_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a scene of someone waiting to be hanged.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The crimson indicator is now on.";
            print "^";
            call_U2532();
            call_U2533();
            call_U337(I_crimson_button_U1);
            call_U337(I_crimson_light_U1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The crimson indicator is now off.";
            print "^";
            call_U2534();
            call_U2535();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2531, 1065, 2);
        }
    }
    rfalse;
];
[ call_U2532 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2533 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2534 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2535 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2536;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_emerald_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2536, 1066, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_emerald_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor now displays a scene of witches being burned at the stake.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The emerald indicator is now on.";
            print "^";
            call_U2537();
            call_U2538();
            call_U337(I_emerald_button_U1);
            call_U337(I_emerald_light_U1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The emerald indicator is now off.";
            print "^";
            call_U2539();
            call_U2540();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2536, 1066, 2);
        }
    }
    rfalse;
];
[ call_U2537 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2538 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2539 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2540 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2541;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_gray_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2541, 1067, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_gray_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor now shows the implements of torture in the dungeon.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The gray indicator is now on.";
            print "^";
            call_U2542();
            call_U2543();
            call_U337(I_gray_button_U1);
            call_U337(I_gray_light_U1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The gray indicator is now off.";
            print "^";
            call_U2544();
            call_U2545();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2541, 1067, 2);
        }
    }
    rfalse;
];
[ call_U2542 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2543 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2544 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2545 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2546;
    if ((((((action == ##Push)) || ((action == ##SwitchOn)))) && ((((actor == player)) && ((noun == I_khaki_button_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2546, 1068, 0);
        }
        if (((((Global_Vars-->63) == 6)) && (((((Global_Vars-->64) == 6)) && (call_U339(I_khaki_button_U1)))))) {
            (say__p = 1);
            ParaContent();
            print "The monitor flickers for a second and the scene it displays changes to something different.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The monitor shows a the gift shop located at the Hell Ride exit.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The khaki indicator is now on.";
            print "^";
            call_U2547();
            call_U2548();
            call_U337(I_khaki_button_U1);
            call_U337(I_khaki_light_U1);
        } else {
            (say__p = 1);
            ParaContent();
            print "The monitor turns off and the screen goes black.";
            print "^";
            (say__p = 1);
            ParaContent();
            print "The khaki indicator is now off.";
            print "^";
            call_U2549();
            call_U2550();
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2546, 1068, 2);
        }
    }
    rfalse;
];
[ call_U2547 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2548 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2549 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K25_colored_light_First):x:(x = (x.K25_colored_light_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2550 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K26_colored_button_First):x:(x = (x.K26_colored_button_Next))) {
        (qcn_0)++;
        call_U340(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2551;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_monitor_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2551, 1069, 0);
        }
        if (call_U336(I_aqua_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a tableau of poor unfortunate townsfolk locked in stocks.";
            print "^";
        }
        if (call_U336(I_crimson_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a scene of someone waiting to be hanged.";
            print "^";
        }
        if (call_U336(I_emerald_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor now displays a scene of witches being burned at the stake.";
            print "^";
        }
        if (call_U336(I_gray_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor now shows the implements of torture in the dungeon.";
            print "^";
        }
        if (call_U336(I_indigo_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor now shows a tableau of a guillotine rising and falling over the ride exit.";
            print "^";
        }
        if (call_U336(I_khaki_button_U1)) {
            (say__p = 1);
            ParaContent();
            print "The monitor shows a the gift shop located at the Hell Ride exit.";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2551, 1069, 2);
        }
    }
    rfalse;
];
[ call_U2552;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2552, 1070, 0);
        }
        if ((~~((noun ofclass K27_colored_dial)))) {
            (say__p = 1);
            ParaContent();
            CDefArt(noun);
            ParaContent();
            print " does not spin.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2552, 1070, 3);
        }
    }
    rfalse;
];
[ call_U2553;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2553, 1071, 0);
        }
        if ((((parsed_number < 0)) || ((parsed_number > 11)))) {
            (say__p = 1);
            ParaContent();
            print "The dial can only be set from 0 to 11.";
            print "^";
            rtrue;
        } else {
            (say__p = 1);
            ParaContent();
            print "The dial is now set to ";
            ParaContent();
            print (say__n = parsed_number);
            ParaContent();
            print ".";
            print "^";
            call_U337(noun);
            WriteGProperty(OBJECT_TY, noun, A_P_dial_setting, parsed_number);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2553, 1071, 3);
        }
    }
    rfalse;
];
[ call_U2554 value rem S;
    print "$";
    print (value/100);
    print ".";
    if (((value%100) < 10)) {
        print "0";
    }
    print (value%100);
    rtrue;
];
[ call_U2555 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (wpos = 0);
    (mid_word = 0);
    (matched_number = 0);
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 36)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    (sgn = 1);
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((sgn == 1)) {
        if ((((tot > 21474836)) || ((((tot == 21474836)) && ((matched_number > 21474836)))))) {
            jump Failed;
        }
    } else {
        if ((((tot > 21474836)) || ((((tot == 21474836)) && ((matched_number > 21474836)))))) {
            jump Failed;
        }
    }
    (tot = ((100*tot) + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 46)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((tot >= 100)) {
        jump Failed;
    }
    (tot = (tot + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if (mid_word) {
        jump Failed;
    }
    if ((sgn < 0)) {
        (matched_number = (-1*matched_number));
    }
    (parsed_number = matched_number);
    (parsed_number = (parsed_number + x));
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "  [parsed value ";
            print parsed_number;
            print " by: $10.99]^";
        }
    #endif;
    return GPR_NUMBER;
    .Failed;
    return GPR_FAIL;
];
[ call_U2556 value rem S;
    print (value/10);
    if (((value%10) == 0)) {
        rtrue;
    }
    print ".";
    print (value%10);
    print " ";
    print "fl";
    print " ";
    print "oz";
    rtrue;
];
[ call_U2557 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (wpos = 0);
    (mid_word = 0);
    (matched_number = 0);
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    (sgn = 1);
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((sgn == 1)) {
        if ((((tot > 214748364)) || ((((tot == 214748364)) && ((matched_number > 214748364)))))) {
            jump Failed;
        }
    } else {
        if ((((tot > 214748364)) || ((((tot == 214748364)) && ((matched_number > 214748364)))))) {
            jump Failed;
        }
    }
    (tot = ((10*tot) + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Succeeded;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 46)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((tot >= 10)) {
        jump Failed;
    }
    (tot = (tot + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if (mid_word) {
        jump Failed;
    }
    if ((cur_word ~= 'fl')) {
        jump Failed;
    }
    (wn)++;
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if (mid_word) {
        jump Failed;
    }
    if ((cur_word ~= 'oz')) {
        jump Failed;
    }
    (wn)++;
    .Succeeded;
    if (mid_word) {
        jump Failed;
    }
    if ((sgn < 0)) {
        (matched_number = (-1*matched_number));
    }
    (parsed_number = matched_number);
    (parsed_number = (parsed_number + x));
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "  [parsed value ";
            print parsed_number;
            print " by: 15.9 fl oz]^";
        }
    #endif;
    return GPR_NUMBER;
    .Failed;
    return GPR_FAIL;
];
[ call_U2558 t_0 tmp_0;
    if ((t_0 < 5)) {
        (say__p = 1);
        ParaContent();
        print "a swallow or two";
    } else {
        if (((((t_0%10) > 3)) && (((t_0%10) < 7)))) {
            (tmp_0 = (t_0/10));
            (say__p = 1);
            ParaContent();
            LanguageNumber((say__n = tmp_0));
            ParaContent();
            print " or ";
            ParaContent();
            LanguageNumber((say__n = (tmp_0 + 1)));
            ParaContent();
            print " fluid ounces";
        } else {
            if (((t_0%10) > 6)) {
                (t_0 = (t_0 + 10));
            }
            (say__p = 1);
            ParaContent();
            print "about ";
            ParaContent();
            LanguageNumber((say__n = (t_0/10)));
            ParaContent();
            print " fluid ounce";
            ParaContent();
            STextSubstitution();
        }
    }
    rfalse;
];
[ call_U2559;
    ((Global_Vars-->63) = 0);
    if (call_U336(I_switch_one_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    if (call_U336(I_switch_three_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    if (call_U336(I_switch_five_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    if (call_U336(I_switch_seven_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    if (call_U336(I_switch_nine_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    if (call_U336(I_switch_eleven_U1)) {
        ((Global_Vars-->63) = ((Global_Vars-->63) + 1));
    }
    rfalse;
];
[ call_U2560;
    ((Global_Vars-->64) = 0);
    if ((GProperty(OBJECT_TY, I_aqua_dial_U1, A_P_dial_setting) == 1)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if ((GProperty(OBJECT_TY, I_crimson_dial_U1, A_P_dial_setting) == 3)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if ((GProperty(OBJECT_TY, I_emerald_dial_U1, A_P_dial_setting) == 5)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if ((GProperty(OBJECT_TY, I_gray_dial_U1, A_P_dial_setting) == 7)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if ((GProperty(OBJECT_TY, I_indigo_dial_U1, A_P_dial_setting) == 9)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if ((GProperty(OBJECT_TY, I_khaki_dial_U1, A_P_dial_setting) == 11)) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    rfalse;
];
[ ConjugateVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record5;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U2561 fn vp t modal_to;
    (t = ConjugateVerb1(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record5;
    }
];
[ ConjugateModalVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "auxiliary-have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has not";
                    } else {
                        print "have not";
                    }
                    ;
                2:
                    print "had not";
                    ;
            }
            ;
    }
];
[ ConjugateVerb62 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record6;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ call_U2562 fn vp t modal_to;
    (t = ConjugateVerb62(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb63 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ call_U2563 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2564 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2565 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2566 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb105 fn vp t modal_to;
    switch (fn) {
        1:
            print "underlie";
            ;
        2:
            print "underlaid";
            ;
        3:
            print "underlying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record4;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "underlies";
                    } else {
                        print "underlie";
                    }
                    ;
                2:
                    print "underlaid";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has underlaid";
                    } else {
                        print "have underlaid";
                    }
                    ;
                4:
                    print "had underlaid";
                    ;
                5:
                    print "will underlie";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not underlie";
                    } else {
                        print "do not underlie";
                    }
                    ;
                2:
                    print "did not underlie";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not underlaid";
                    } else {
                        print "have not underlaid";
                    }
                    ;
                4:
                    print "had not underlaid";
                    ;
                5:
                    print "will not underlie";
                    ;
            }
            ;
    }
];
[ call_U2567 fn vp t modal_to;
    (t = ConjugateVerb105(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record4;
    }
];
[ ConjugateModalVerb57 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb58 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U2568;
    (say__p = 1);
    ParaContent();
    print "The music alternates between hauntingly slow melodies and rapid, energetic drum beats, creating an emotional arc that keeps the you entranced. Little Egypt relies on the music";
    ParaContent();
    print "'";
    ParaContent();
    print "s dynamic changes to tell a story with movements reflecting joy, sorrow, seduction, and celebration.";
    rtrue;
];
[ call_U2569;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "Entrance";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The car has begun to move toward the entrance of the ride and the safety bar has been lowered. The entrance to Hell Ride is a chilling spectacle designed to draw both thrill-seekers and the morbidly curious. The facade looms before you, a grotesque masterpiece of twisted metal and carved wood, illuminated by flickering, blood-red lights that cast eerie shadows across the ground. The air smells faintly of sulfur, mingling with the sweet scent of carnival popcorn from nearby stalls.^^A towering archway frames the entrance, its design a chaotic blend of flames, jagged spikes, and sinister, grinning skulls. The words ~HELL RIDE~ are emblazoned above in glowing, flickering letters that seem to pulse like a heartbeat. Beneath the sign, two sculpted demons crouch, their clawed hands extending outward as though inviting-or daring-you to enter.^^Dark curtains, frayed and stained, hang over the entrance, swaying faintly in a breeze that seems to carry whispers and low, menacing chuckles. As you approach, the faint sound of distorted organ music grows louder, interspersed with sudden shrieks and the grinding of unseen machinery. A crooked sign at the side reads: ~One Ticket Admission: Enter If You Dare!~^^Nearby, a carnival barker with a waxen smile stands under a sputtering gaslight, his voice raspy and theatrical: ~Step right up, brave souls! Take the ride of your life-or your afterlife! The gates of hell are open, and the darkness beckons!~^^Through the entrance, the interior is shrouded in near-total darkness, save for flashes of sickly green light that illuminate the suggestion of twisting paths and grotesque shapes. The only certainty is that once you step inside, there's no turning back from the horrors that await.";
    rtrue;
];
[ call_U2570;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "Hallway";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The doors open and your car passes through into the darkness.^^Mist fills the area as you move to the next room.";
    rtrue;
];
[ call_U2571;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "The Stocks";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The public square is an open expanse of cobblestones, surrounded by the weathered facades of timber-framed buildings. The air is heavy with the mingling scents of smoke from distant chimneys, damp earth, and the faint metallic tang of the nearby smithy. At the square";
    ParaContent();
    print "'";
    ParaContent();
    print "s center stand a row of crude wooden stocks, their heavy beams stained from years of weather and use. Iron clasps hold the unfortunate captives by their wrists and necks, their bodies forced into unnatural, humiliating postures.^^The punished individuals, heads bowed in shame, are caught in an agonizing tableau of disgrace. Their expressions, a mix of resignation and despair, reflect the full weight of their predicaments. Their clothing hangs in tatters, furthering their exposure to the biting wind and the sharp tongues of the gathered crowd.^^Around the stocks, the townsfolk revel in their collective cruelty. A wiry man leans in close, spitting insults with glee, his laughter cutting through the air. A stout woman clutching a basket of overripe vegetables hurls a squashed tomato, which splatters across one captive's cheek, drawing a chorus of jeers. Nearby, children mimic their elders, pointing and shrieking in mockery, their faces alight with mischief.^^The square is alive with noise: the raucous laughter of the crowd, the occasional sharp crack of a thrown object against the wood, and the soft, pained murmurs of the punished. A passing bell tolls faintly in the distance, but here it is drowned out by the cruel symphony of the jeering mob.^^Above it all, the gray sky looms, heavy with the promise of rain, as if nature itself disapproves of the spectacle. Yet the crowd pays no mind, delighting in their collective judgment, each jeer a reminder that today's entertainment is another";
    ParaContent();
    print "'";
    ParaContent();
    print "s living nightmare.^^Mist fills the area as you move to the next room.";
    rtrue;
];
[ call_U2572;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "The Gallows";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The public square lies under a brooding, overcast sky, its cobblestones slick with the morning";
    ParaContent();
    print "'";
    ParaContent();
    print "s drizzle. A grim silence has settled over the gathered crowd, broken only by the occasional murmur or the restless shuffling of feet. At the center of the square, rising like a grim monument to mortality, stands the gallows-a wooden platform, darkened by age and weather, with thick ropes hanging like vipers poised to strike.^^Atop the gallows, a hooded executioner looms, his imposing frame draped in a black cloak that billows faintly in the wind. His face is obscured by the deep cowl, but his presence radiates cold, methodical purpose. In his gloved hands, he adjusts the noose, its coarse fibers frayed from repeated use, ensuring it is ready for the task at hand.^^Standing beside him is the condemned man, his hands bound tightly behind his back. His face is pale, drawn, and haunted, beads of sweat mingling with the light rain. His eyes dart to the crowd, seeking pity, perhaps, but finding only a sea of indifferent faces. His breath comes in shallow bursts, each exhalation visible in the chilly air, a stark reminder of the life still in him-for now.^^The crowd gathers in a semicircle around the platform, a mixture of somber onlookers, opportunistic vendors hawking bread and cider, and children craning their necks for a better view. An old man mutters a prayer under his breath, clutching a rosary, while a group of rough-looking men smirk and exchange bets on how long the drop will take.^^Above it all, the bell tower tolls, its mournful chime echoing through the square, a countdown to the inevitable. The condemned man flinches with each clang, his shoulders tensing as the final moments draw near. A raven perches on the gallows~ beam, its black eyes unblinking, as if waiting for the end with morbid curiosity.^^The executioner steps forward, adjusting the noose around the man's neck with a practiced efficiency. The crowd falls silent, the weight of the moment hanging heavier than the rope itself. Somewhere in the distance, thunder rumbles faintly, as though the heavens themselves are bracing for what is to come.^^Mist fills the area as you move to the next room.";
    rtrue;
];
[ call_U2573;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "The Stake";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The public square is a grim tableau, the usual bustle of commerce and chatter replaced with an oppressive silence broken only by the crackling of the flames. At the center, three wooden stakes rise ominously from a circular pyre of logs and kindling, their rough surfaces darkened by smoke from countless such scenes before. Bound tightly to these stakes are three women, their wrists and ankles secured with coarse, heavy ropes. Their faces tell different stories-one of defiance, another of resignation, and the third of pure terror.^^A crowd encircles the pyre, their expressions a mix of morbid fascination, righteous fury, and hesitant pity. Children cling to their mothers";
    ParaContent();
    print "'";
    ParaContent();
    print " skirts, staring wide-eyed, while town elders nod solemnly as though approving the grim spectacle. Some townsfolk jeer loudly, throwing small stones or rotten vegetables at the condemned. Others murmur prayers or make the sign of the cross, their eyes averted.^^The executioner, clad in a soot-streaked hood and leather apron, steps forward, his torch a blazing beacon in the dreary scene. The flames dance and writhe as he lowers the torch to the base of the pyre, igniting the dry wood with a sudden, hungry roar. A cheer erupts from a faction of the crowd, while others fall into an uneasy silence, watching the fire climb higher.^^Thick, acrid smoke begins to rise, curling around the stakes like a living thing. The women cry out-some in curses, others in prayers-and their voices echo across the square, mingling with the crackle of the flames. The heat radiates outward, and even those in the crowd begin to feel its oppressive warmth.^^Above, the gray clouds hang low, as if nature itself mourns the scene unfolding below. A raven caws from its perch atop the town";
    ParaContent();
    print "'";
    ParaContent();
    print "s bell tower, its black form stark against the ashen sky. The church bells toll in slow, deliberate cadence, each strike a grim punctuation to the scene.^^As the flames consume the pyre, the crowd remains rooted, some transfixed by the spectacle, others quietly slipping away, their faces pale and drawn. The square, once a place of gatherings and life, is now a stage for death, its air heavy with smoke, ash, and the lingering cries of the condemned.^^Mist fills the area as you move to the next room.";
    rtrue;
];
[ call_U2574;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "The Dungeon";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The dungeon is a dim, oppressive chamber carved deep into the earth, its stone walls slick with moisture and coated in a thin layer of grime. The air is heavy with the stench of sweat, blood, and mildew, punctuated by the faint, acrid tang of burning oil from flickering torches mounted on rusty iron sconces. Shadows dance on the walls, creating grotesque shapes that seem almost alive in the unsteady light.^^Chains hang from the walls and ceilings, their metallic clinking faintly audible as prisoners shift or shudder in their restraints. The room is filled with the soft, pitiful moans of the tormented, their cries occasionally rising to sharp, desperate screams that echo through the corridors beyond. The sound of dripping water from a cracked stone ceiling adds an eerie rhythm to the unsettling cacophony.^^Scattered throughout the dungeon are various instruments of pain and suffering, their designs brutal and unyielding. A rack sits in the center of the room, its wooden frame splintered from years of use. Nearby, a brazier glows a dull red, its coals smoldering beneath a collection of iron tools-branding irons, pincers, and knives, their edges darkened with dried blood. A spiked chair looms in the corner, its cruel design gleaming faintly in the dim light.^^Prisoners are scattered across the room, each trapped in their own nightmare. A man lies stretched on the rack, his face contorted in agony as the torturer methodically turns the wheel, the creaking of wood and rope echoing in the chamber. Another prisoner hangs limply from manacles affixed to the wall, their body bruised and battered, barely able to lift their head. A third, seated in the spiked chair, breathes in shallow gasps, their movements restricted by the cruel embrace of the iron seat.^^The torturer moves about the chamber with practiced efficiency, their face obscured by a hood, their leather apron stained with the evidence of countless victims. They work silently, their movements methodical and devoid of emotion, as if the suffering around them were merely a task to be completed.^^Above it all, the dungeon";
    ParaContent();
    print "'";
    ParaContent();
    print "s ceiling is low and oppressive, the occasional scuttling of rats in the shadows serving as a reminder of the filth and decay that permeates the space. The only exit-a heavy, iron-bound door reinforced with rivets-seems more a barrier to hope than a passage to freedom, its small viewing slit barred and shadowed.^^This is a place of despair and cruelty, where the line between life and death is blurred, and the only certainty is the inevitability of suffering.^^Mist fills the area as you move to the next room.";
    rtrue;
];
[ call_U2575;
    (say__p = 1);
    ParaContent();
    style bold;
    ParaContent();
    print "The Guillotine";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    ParaContent();
    print "The public square is a charged space, bustling with a crowd eager to witness the grim spectacle. The sky overhead is a patchwork of gray clouds, casting the cobblestone ground in a somber light. At the center of the square stands a raised wooden platform, stark and imposing, where the grim sentence is to be carried out.^^A lone figure stands on the scaffold, their posture slumped under the weight of their fate. Their hands are bound tightly behind their back with coarse ropes, and their head hangs low, avoiding the stares of the gathered crowd. Their clothing, once fine, is now tattered and muddied, a visible testament to the fall from grace that has led to this moment.^^The crowd presses closer, encircling the platform with a mix of emotions etched onto their faces. Some jeer, shouting curses and insults, their voices rising in a cacophony of condemnation. Others watch in heavy silence, their expressions grim and reflective. A few hold children on their shoulders, their young faces filled with curious fascination, unaware of the gravity of what they are about to witness.^^At the edge of the platform, a town crier stands with a long scroll in hand, his voice carrying over the murmurs of the crowd: ~This man has been found guilty of high treason against the crown. Let his punishment serve as a warning to all who would seek to defy the will of the realm!~^^The condemned flinches at the words but remains silent, their face pale and eyes darting nervously. The executioner, a large figure clad in a hooded black robe, stands nearby with arms crossed, their demeanor cold and methodical. A few feet away, the guillotine looms, its blade gleaming dully in the filtered light, ready to deliver the final judgment.^^The tension in the square is palpable as the crier steps aside and the executioner signals for the crowd to quiet. The murmurs fade, replaced by an oppressive silence that hangs over the scene like a shroud. The only sounds now are the rustle of the wind and the faint creak of the wooden scaffold.^^As the condemned is led toward the guillotine, a crow caws from a nearby rooftop, its harsh cry echoing through the square like a dark omen. The crowd leans forward, holding its collective breath, as the weight of justice and mortality descends upon the scene.^^There is just one problem: the guillotine is being raised and lowered by some mechanism. It appears that the timing of the guillotine is off and it is being lowered onto the cars instead of between them. If a person were to be in a car as it passed under the guillotine, they would be decapitated.^^Looks like your goose is cooked. Say ~Goodnight, Gracie!^^You are stupefied as you sit watching guillotine rising and falling, dropping like a stone on the cars in front of you. Thank goodness they are empty. As your turn comes, you raise your hands in a feeble attempt to stop the inevitable.";
    rtrue;
];
[ PCONR1;
    return (I_show_tent_U1 == ContainerOf(player));
];
[ PCONR2;
    return (I_hell_ride_car_U1 == ContainerOf(player));
];
[ PAPR1;
    if ((((action == ##A_hi_speaking)) && ((((actor == player)) && ((noun == I_sailor_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR2;
    if ((((action == ##A_hi_speaking)) && ((((actor == player)) && ((noun == I_sailor_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR3;
    if ((((action == ##A_hitting)) && ((((actor == player)) && ((((noun == I_lever_U1)) && (((((self = actor),1)) && ((second == I_mallet_U1)))))))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR4;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_flashlight_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ Noun_Filter15 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter18 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter19 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter20 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter21 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter22 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ Noun_Filter23 x;
    (x = noun);
    return (noun ofclass K20_fluid_container);
];
[ parse_name1 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name2 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name3 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name4 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name5 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name6 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name7 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name8 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name9 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name10 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name11 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name12 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name13 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((Cond_Token1() == GPR_FAIL)) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'your')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((Cond_Token2() == GPR_FAIL)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'my')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            if ((Cond_Token3() == GPR_FAIL)) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_3;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_3;
            (wn = try_from_wn);
            if ((Cond_Token4() == GPR_FAIL)) {
                jump Fail_4;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_4;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_4;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name15 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name16 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name19 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name21 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'key')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'keys')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name26 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name29 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name31 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'glove')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'compartment')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name34 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name35 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name42 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name44 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2322((self.P_liquid)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name49 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name50 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name55 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name61 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name69 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name75 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name78 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name81 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'spiked')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'chair')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name84 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name87 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name90 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name91 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name92 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name118 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name168 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name199 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                if ((parser_action == ##TheSame)) {
                    #ifdef DEBUG;
                        if ((parser_trace >= 4)) {
                            print "p1, p2 = ";
                            print parser_one;
                            print ", ";
                            print parser_two;
                            print "^";
                        }
                    #endif;
                    (ss = self);
                    if (((parser_one.P_liquid) ~= (parser_two.P_liquid))) {
                        return -2;
                    }
                    (self = ss);
                    rfalse;
                }
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2322((self.P_liquid)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name204 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ Cond_Token1;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token2;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token3;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token4;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Consult_Grammar1 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restart')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar2 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restore')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar3 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'amusing')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar4 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'quit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar5 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'undo')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar6 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'stand')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar7 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'sit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar8 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'lie')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar9 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'please')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar10 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= '1//')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar11 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= '2//')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar12 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= '3//')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar13 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= '4//')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ MistakeActionSub;
    switch (understand_as_mistake_number) {
        default:
            print "I didn't understand that sentence.^";
            rtrue;
            ;
    }
    (say__p = 1);
];
[ Prop_Falsity reason obj;
    rfalse;
];
[ FINAL_CODE_STARTUP_R addr res;
    #ifdef TARGET_GLULX;
    @gestalt 9 0 res;
    if (res == 0) rfalse;
    addr = #classes_table;
    @accelparam 0 addr;
    @accelparam 1 INDIV_PROP_START;
    @accelparam 2 Class;
    @accelparam 3 Object;
    @accelparam 4 Routine;
    @accelparam 5 String;
    addr = #globals_array + WORDSIZE * #g$self;
    @accelparam 6 addr;
    @accelparam 7 NUM_ATTR_BYTES;
    addr = #cpv__start;
    @accelparam 8 addr;
    @accelfunc 1 Z__Region;
    @accelfunc 2 CP__Tab;
    @accelfunc 3 RA__Pr;
    @accelfunc 4 RL__Pr;
    @accelfunc 5 OC__Cl;
    @accelfunc 6 RV__Pr;
    @accelfunc 7 OP__Pr;
    #endif;
    rfalse;
];
[ DebugAction a anames str;
    #ifdef TARGET_GLULX;
    if (a < 4096) {
        if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
        else {
            str = #identifiers_table-->6;
            str = str-->a;
            if (str) print (string) str; else print "<unnamed action ", a, ">";
            return;
        }
    }
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 4096) {
        anames = #identifiers_table;
        anames = anames + 2*(anames-->0) + 2*48;
        print (string) anames-->a;
        return;
    }
    #endif;
    if ((a >= 4096)) {
        print "<fake action ";
        print (a - 4096);
        print ">";
    } else {
        print "<action ";
        print a;
        print ">";
    }
];
[ DebugAttribute a anames str;
    #ifdef TARGET_GLULX;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
    return;
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
    return;
    #endif;
    print "<attribute ";
    print a;
    print ">";
];
[ DebugProperty p pnames str;
    print (property) p;
    return;
    print "<property ";
    print p;
    print ">";
];
[ DecimalNumber num;
    print num;
];
[ PrintI6Text x;
    if ((x ofclass String)) {
        print (string) x;
    }
    if ((x ofclass Routine)) {
        return (x)();
    }
    if ((x == EMPTY_TEXT_PACKED)) {
        rfalse;
    }
    rtrue;
];
[ I7_String x;
    TEXT_TY_Say(x);
];
[ PrintOrRun obj prop no_break pv st routine_return_value;
    @push self;
    (self = obj);
    if ((prop == 0)) {
        PrintShortName(prop);
        (routine_return_value = 1);
    } else {
        (routine_return_value = TEXT_TY_Say(_final_propertyvalue(OBJECT_TY, obj, prop)));
    }
    @pull self;
    if (routine_return_value) {
        (say__p = 1);
        if ((no_break == 0)) {
            print "^";
            DivideParagraphPoint();
        }
    }
    return routine_return_value;
];
[ DA_Number n;
    print n;
];
[ DA_TruthState n;
    if ((n == 0)) {
        print "false";
    } else {
        print "true";
    }
];
[ SayPhraseName closure;
    if ((closure == 0)) {
        print "nothing";
    } else {
        print (string) (closure-->(2));
    }
];
[ KindAtomic kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return kind;
    }
    return (kind-->(0));
];
[ KindBaseArity kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        rfalse;
    }
    return (kind-->(1));
];
[ KindBaseTerm kind n;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return UNKNOWN_TY;
    }
    return (kind-->((2 + n)));
];
[ GenerateRandomNumber n m s;
    if ((n == m)) {
        return n;
    }
    if ((n > m)) {
        (s = n);
        (n = m);
        (m = s);
    }
    (n)--;
    return (random((m - n)) + n);
];
[ PrintSpaces n;
    while ((n > 0)) {
        print " ";
        (n = (n - 1));
    }
];
[ SwapWorkflags obj lst;
    objectloop (obj ofclass Object && (obj ofclass Object)) {
        (lst = 0);
        if ((obj has workflag2)) {
            (lst = 1);
        }
        give obj ~workflag2;
        if ((obj has workflag)) {
            give obj workflag2;
        }
        give obj ~workflag;
        if (lst) {
            give obj workflag;
        }
    }
];
[ ZRegion addr;
    switch (metaclass(addr)) {
        0:
            rfalse;
            ;
        Object, Class:
            rtrue;
            ;
        Routine:
            return 2;
            ;
        String:
            return 3;
            ;
    }
];
[ Memcpy to_addr from_addr size n;
    @mcopy size from_addr to_addr;
];
[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries n val;
    if ((to_entry_size == from_entry_size)) {
        Memcpy(to_array, from_array, (to_entry_size*no_entries));
    } else {
        if ((((to_entry_size == 2)) && ((from_entry_size == 4)))) {
            for ((n = 0):(n < no_entries):(n)++) {
                (val = (from_array-->(n)));
                ((to_array->(0)) = ((val/256)%256));
                ((to_array->(1)) = (val%256));
                (to_array = (to_array + 2));
            }
        } else {
            print "*** Arrcpy doesn't support this ***";
            new_line;
            rtrue;
        }
    }
];
[ PrintVerbAsValue vb;
    if ((vb == 0)) {
        print "(no verb)";
    } else {
        print "verb ";
        (vb)(1);
    }
];
[ VerbIsMeaningful vb;
    if (((vb) && ((BlkValueCompare((vb)(CV_MEANING), MEANINGLESS_RR) ~= 0)))) {
        rtrue;
    }
    rfalse;
];
[ VerbIsModal vb;
    if (((vb) && ((vb)(CV_MODAL)))) {
        rtrue;
    }
    rfalse;
];
[ SEED_RANDOM_NUMBER_GENERATOR_R i;
    if (RNG_SEED_AT_START_OF_PLAY) {
        VM_Seed_RNG(RNG_SEED_AT_START_OF_PLAY);
    }
    for ((i = 1):(i <= 100):(i)++) {
        random(i);
    }
    rfalse;
];
[ DictionaryWordToVerbNum dword verbnum i;
    (dword = ((dword + #dict_par2) - 1));
    @aloads dword 0 verbnum;
    (verbnum = (65535 - verbnum));
    return verbnum;
];
[ RegardingSingleObject obj;
    (prior_named_list = 1);
    (prior_named_list_gender = -1);
    (prior_named_noun = obj);
];
[ RegardingNumber n;
    (prior_named_list = n);
    (prior_named_list_gender = -1);
    (prior_named_noun = 0);
];
[ I7_SOO_PAR oldval count;
    if ((count <= 1)) {
        return count;
    }
    return random(count);
];
[ I7_SOO_RAN oldval count v;
    if ((count <= 1)) {
        return count;
    }
    (v = oldval);
    while ((v == oldval)) {
        (v = random(count));
    }
    return v;
];
[ I7_SOO_STI oldval count v;
    if (oldval) {
        return oldval;
    }
    return I7_SOO_PAR(oldval, count);
];
[ I7_SOO_CYC oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = 1);
    }
    return oldval;
];
[ I7_SOO_STOP oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = count);
    }
    return oldval;
];
[ I7_SOO_TAP oldval count tn rn c;
    if ((count <= 1)) {
        return count;
    }
    (tn = ((count*(count + 1))/2));
    (rn = random(tn));
    for ((c = 1):(c <= count):(c)++) {
        (rn = (rn - c));
        if ((rn <= 0)) {
            return ((count - c) + 1);
        }
    }
];
[ I7_SOO_TRAN oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_RAN((oldval%(count + 1)), count));
];
[ I7_SOO_TPAR oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_PAR((oldval%(count + 1)), count));
];
[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
    (base = (count + 1));
    (v = (oldval%base));
    (oldval = (oldval/base));
    (ct = (oldval%base));
    (sd = (oldval/base));
    if ((count > 32)) {
        return I7_SOO_PAR(oldval, count);
    }
    if ((count <= 1)) {
        (v = count);
    } else {
        (cc = (base*base));
        (scope = ((MAX_POSITIVE_NUMBER - 1)/cc));
        if ((sd == 0)) {
            (sd = random(scope));
            (ct = 0);
        }
        for ((i = 0):(i < count):(i)++) {
            ((I7_SOO_SHUF->(i)) = i);
        }
        (ssd = sd);
        for ((i = 0):(i < (count - 1)):(i)++) {
            (j = ((sd%(count - i)) + i));
            (sd = ((sd*31973) + 17));
            if ((sd < 0)) {
                (sd = (-(sd)));
            }
            (s = (I7_SOO_SHUF->(j)));
            ((I7_SOO_SHUF->(j)) = (I7_SOO_SHUF->(i)));
            ((I7_SOO_SHUF->(i)) = s);
        }
        (v = ((I7_SOO_SHUF->(ct)) + 1));
        (ct)++;
        if ((ct >= count)) {
            (ct = 0);
            (ssd = 0);
        }
    }
    return ((v + (ct*base)) + ((ssd*base)*base));
];
[ RoundOffValue t1 t2;
    if ((t1 >= 0)) {
        return (((t1 + (t2/2))/t2)*t2);
    }
    return (-(((((-(t1)) + (t2/2))/t2)*t2)));
];
[ glk_exit _vararg_count;
    @glk 1 _vararg_count 0;
    rfalse;
];
[ glk_tick _vararg_count;
    @glk 3 _vararg_count 0;
    rfalse;
];
[ glk_gestalt _vararg_count ret;
    @glk 4 _vararg_count ret;
    return ret;
];
[ glk_gestalt_ext _vararg_count ret;
    @glk 5 _vararg_count ret;
    return ret;
];
[ glk_window_iterate _vararg_count ret;
    @glk 32 _vararg_count ret;
    return ret;
];
[ glk_window_get_rock _vararg_count ret;
    @glk 33 _vararg_count ret;
    return ret;
];
[ glk_window_get_root _vararg_count ret;
    @glk 34 _vararg_count ret;
    return ret;
];
[ glk_window_open _vararg_count ret;
    @glk 35 _vararg_count ret;
    return ret;
];
[ glk_window_close _vararg_count;
    @glk 36 _vararg_count 0;
    rfalse;
];
[ glk_window_get_size _vararg_count;
    @glk 37 _vararg_count 0;
    rfalse;
];
[ glk_window_set_arrangement _vararg_count;
    @glk 38 _vararg_count 0;
    rfalse;
];
[ glk_window_get_arrangement _vararg_count;
    @glk 39 _vararg_count 0;
    rfalse;
];
[ glk_window_get_type _vararg_count ret;
    @glk 40 _vararg_count ret;
    return ret;
];
[ glk_window_get_parent _vararg_count ret;
    @glk 41 _vararg_count ret;
    return ret;
];
[ glk_window_clear _vararg_count;
    @glk 42 _vararg_count 0;
    rfalse;
];
[ glk_window_move_cursor _vararg_count;
    @glk 43 _vararg_count 0;
    rfalse;
];
[ glk_window_get_stream _vararg_count ret;
    @glk 44 _vararg_count ret;
    return ret;
];
[ glk_window_set_echo_stream _vararg_count;
    @glk 45 _vararg_count 0;
    rfalse;
];
[ glk_window_get_echo_stream _vararg_count ret;
    @glk 46 _vararg_count ret;
    return ret;
];
[ glk_set_window _vararg_count;
    @glk 47 _vararg_count 0;
    rfalse;
];
[ glk_window_get_sibling _vararg_count ret;
    @glk 48 _vararg_count ret;
    return ret;
];
[ glk_stream_iterate _vararg_count ret;
    @glk 64 _vararg_count ret;
    return ret;
];
[ glk_stream_get_rock _vararg_count ret;
    @glk 65 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file _vararg_count ret;
    @glk 66 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory _vararg_count ret;
    @glk 67 _vararg_count ret;
    return ret;
];
[ glk_stream_close _vararg_count;
    @glk 68 _vararg_count 0;
    rfalse;
];
[ glk_stream_set_position _vararg_count;
    @glk 69 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_position _vararg_count ret;
    @glk 70 _vararg_count ret;
    return ret;
];
[ glk_stream_set_current _vararg_count;
    @glk 71 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_current _vararg_count ret;
    @glk 72 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource _vararg_count ret;
    @glk 73 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_temp _vararg_count ret;
    @glk 96 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_name _vararg_count ret;
    @glk 97 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_prompt _vararg_count ret;
    @glk 98 _vararg_count ret;
    return ret;
];
[ glk_fileref_destroy _vararg_count;
    @glk 99 _vararg_count 0;
    rfalse;
];
[ glk_fileref_iterate _vararg_count ret;
    @glk 100 _vararg_count ret;
    return ret;
];
[ glk_fileref_get_rock _vararg_count ret;
    @glk 101 _vararg_count ret;
    return ret;
];
[ glk_fileref_delete_file _vararg_count;
    @glk 102 _vararg_count 0;
    rfalse;
];
[ glk_fileref_does_file_exist _vararg_count ret;
    @glk 103 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_from_fileref _vararg_count ret;
    @glk 104 _vararg_count ret;
    return ret;
];
[ glk_put_char _vararg_count;
    @glk 128 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream _vararg_count;
    @glk 129 _vararg_count 0;
    rfalse;
];
[ glk_put_string _vararg_count;
    @glk 130 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream _vararg_count;
    @glk 131 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer _vararg_count;
    @glk 132 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream _vararg_count;
    @glk 133 _vararg_count 0;
    rfalse;
];
[ glk_set_style _vararg_count;
    @glk 134 _vararg_count 0;
    rfalse;
];
[ glk_set_style_stream _vararg_count;
    @glk 135 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream _vararg_count ret;
    @glk 144 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream _vararg_count ret;
    @glk 145 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream _vararg_count ret;
    @glk 146 _vararg_count ret;
    return ret;
];
[ glk_char_to_lower _vararg_count ret;
    @glk 160 _vararg_count ret;
    return ret;
];
[ glk_char_to_upper _vararg_count ret;
    @glk 161 _vararg_count ret;
    return ret;
];
[ glk_stylehint_set _vararg_count;
    @glk 176 _vararg_count 0;
    rfalse;
];
[ glk_stylehint_clear _vararg_count;
    @glk 177 _vararg_count 0;
    rfalse;
];
[ glk_style_distinguish _vararg_count ret;
    @glk 178 _vararg_count ret;
    return ret;
];
[ glk_style_measure _vararg_count ret;
    @glk 179 _vararg_count ret;
    return ret;
];
[ glk_select _vararg_count;
    @glk 192 _vararg_count 0;
    rfalse;
];
[ glk_select_poll _vararg_count;
    @glk 193 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event _vararg_count;
    @glk 208 _vararg_count 0;
    rfalse;
];
[ glk_cancel_line_event _vararg_count;
    @glk 209 _vararg_count 0;
    rfalse;
];
[ glk_request_char_event _vararg_count;
    @glk 210 _vararg_count 0;
    rfalse;
];
[ glk_cancel_char_event _vararg_count;
    @glk 211 _vararg_count 0;
    rfalse;
];
[ glk_request_mouse_event _vararg_count;
    @glk 212 _vararg_count 0;
    rfalse;
];
[ glk_cancel_mouse_event _vararg_count;
    @glk 213 _vararg_count 0;
    rfalse;
];
[ glk_request_timer_events _vararg_count;
    @glk 214 _vararg_count 0;
    rfalse;
];
[ glk_image_get_info _vararg_count ret;
    @glk 224 _vararg_count ret;
    return ret;
];
[ glk_image_draw _vararg_count ret;
    @glk 225 _vararg_count ret;
    return ret;
];
[ glk_image_draw_scaled _vararg_count ret;
    @glk 226 _vararg_count ret;
    return ret;
];
[ glk_window_flow_break _vararg_count;
    @glk 232 _vararg_count 0;
    rfalse;
];
[ glk_window_erase_rect _vararg_count;
    @glk 233 _vararg_count 0;
    rfalse;
];
[ glk_window_fill_rect _vararg_count;
    @glk 234 _vararg_count 0;
    rfalse;
];
[ glk_window_set_background_color _vararg_count;
    @glk 235 _vararg_count 0;
    rfalse;
];
[ glk_schannel_iterate _vararg_count ret;
    @glk 240 _vararg_count ret;
    return ret;
];
[ glk_schannel_get_rock _vararg_count ret;
    @glk 241 _vararg_count ret;
    return ret;
];
[ glk_schannel_create _vararg_count ret;
    @glk 242 _vararg_count ret;
    return ret;
];
[ glk_schannel_destroy _vararg_count;
    @glk 243 _vararg_count 0;
    rfalse;
];
[ glk_schannel_create_ext _vararg_count ret;
    @glk 244 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_multi _vararg_count ret;
    @glk 247 _vararg_count ret;
    return ret;
];
[ glk_schannel_play _vararg_count ret;
    @glk 248 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_ext _vararg_count ret;
    @glk 249 _vararg_count ret;
    return ret;
];
[ glk_schannel_stop _vararg_count;
    @glk 250 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume _vararg_count;
    @glk 251 _vararg_count 0;
    rfalse;
];
[ glk_sound_load_hint _vararg_count;
    @glk 252 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume_ext _vararg_count;
    @glk 253 _vararg_count 0;
    rfalse;
];
[ glk_schannel_pause _vararg_count;
    @glk 254 _vararg_count 0;
    rfalse;
];
[ glk_schannel_unpause _vararg_count;
    @glk 255 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink _vararg_count;
    @glk 256 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink_stream _vararg_count;
    @glk 257 _vararg_count 0;
    rfalse;
];
[ glk_request_hyperlink_event _vararg_count;
    @glk 258 _vararg_count 0;
    rfalse;
];
[ glk_cancel_hyperlink_event _vararg_count;
    @glk 259 _vararg_count 0;
    rfalse;
];
[ glk_buffer_to_lower_case_uni _vararg_count ret;
    @glk 288 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_upper_case_uni _vararg_count ret;
    @glk 289 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_title_case_uni _vararg_count ret;
    @glk 290 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_decompose_uni _vararg_count ret;
    @glk 291 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_normalize_uni _vararg_count ret;
    @glk 292 _vararg_count ret;
    return ret;
];
[ glk_put_char_uni _vararg_count;
    @glk 296 _vararg_count 0;
    rfalse;
];
[ glk_put_string_uni _vararg_count;
    @glk 297 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_uni _vararg_count;
    @glk 298 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream_uni _vararg_count;
    @glk 299 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream_uni _vararg_count;
    @glk 300 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream_uni _vararg_count;
    @glk 301 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream_uni _vararg_count ret;
    @glk 304 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream_uni _vararg_count ret;
    @glk 305 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream_uni _vararg_count ret;
    @glk 306 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file_uni _vararg_count ret;
    @glk 312 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory_uni _vararg_count ret;
    @glk 313 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource_uni _vararg_count ret;
    @glk 314 _vararg_count ret;
    return ret;
];
[ glk_request_char_event_uni _vararg_count;
    @glk 320 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event_uni _vararg_count;
    @glk 321 _vararg_count 0;
    rfalse;
];
[ glk_set_echo_line_event _vararg_count;
    @glk 336 _vararg_count 0;
    rfalse;
];
[ glk_set_terminators_line_event _vararg_count;
    @glk 337 _vararg_count 0;
    rfalse;
];
[ glk_current_time _vararg_count;
    @glk 352 _vararg_count 0;
    rfalse;
];
[ glk_current_simple_time _vararg_count ret;
    @glk 353 _vararg_count ret;
    return ret;
];
[ glk_time_to_date_utc _vararg_count;
    @glk 360 _vararg_count 0;
    rfalse;
];
[ glk_time_to_date_local _vararg_count;
    @glk 361 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_utc _vararg_count;
    @glk 362 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_local _vararg_count;
    @glk 363 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_utc _vararg_count;
    @glk 364 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_local _vararg_count;
    @glk 365 _vararg_count 0;
    rfalse;
];
[ glk_date_to_simple_time_utc _vararg_count ret;
    @glk 366 _vararg_count ret;
    return ret;
];
[ glk_date_to_simple_time_local _vararg_count ret;
    @glk 367 _vararg_count ret;
    return ret;
];
[ HandleGlkEvent x1 x2 x3;
    rfalse;
];
[ IdentifyGlkObject x1 x2 x3 x4;
    rfalse;
];
[ InitGlkWindow x1;
    rfalse;
];
[ VM_PreInitialise res;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    (unicode_gestalt_ok = 0);
    if (glk_gestalt(gestalt_Unicode, 0)) {
        (unicode_gestalt_ok = 1);
    }
    @setiosys 2 0;
];
[ VM_Initialise res sty i;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    GGRecoverObjects();
    if (glk_gestalt(gestalt_Sound, 0)) {
        if ((gg_foregroundchan == 0)) {
            (gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK));
        }
        if ((gg_backgroundchan == 0)) {
            (gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK));
        }
    }
    if (((KIT_CONFIGURATION_BITMAP)&(FIX_RNG_TCBIT))) {
        @random 10000 i;
        (i = ((-(i)) - 2000));
        @setrandom i;
    }
    (res = InitGlkWindow(0));
    if ((res ~= 0)) {
        rtrue;
    }
    if ((gg_mainwin == 0)) {
        (res = InitGlkWindow(GG_MAINWIN_ROCK));
        if ((res == 0)) {
            glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
        }
        if ((gg_mainwin == 0)) {
            quit;
        }
    } else {
        glk_window_clear(gg_mainwin);
    }
    if ((gg_statuswin == 0)) {
        (res = InitGlkWindow(GG_STATUSWIN_ROCK));
        if ((res == 0)) {
            (statuswin_cursize = statuswin_size);
            for ((sty = 0):(sty < style_NUMSTYLES):(sty)++) {
                glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            }
            (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        }
    }
    glk_set_window(gg_mainwin);
    InitGlkWindow(1);
    ((buffer3-->(0)) = 0);
];
[ GGRecoverObjects id;
    (gg_mainwin = 0);
    (gg_statuswin = 0);
    (gg_quotewin = 0);
    (gg_scriptfref = 0);
    (gg_scriptstr = 0);
    (gg_savestr = 0);
    (statuswin_cursize = 0);
    (gg_foregroundchan = 0);
    (gg_backgroundchan = 0);
    (gg_commandstr = 0);
    (gg_command_reading = 0);
    IdentifyGlkObject(0);
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SAVESTR_ROCK:
                (gg_savestr = id);
                ;
            GG_SCRIPTSTR_ROCK:
                (gg_scriptstr = id);
                ;
            GG_COMMANDWSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 0);
                ;
            GG_COMMANDRSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 1);
                ;
            default:
                IdentifyGlkObject(1, 1, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_MAINWIN_ROCK:
                (gg_mainwin = id);
                ;
            GG_STATUSWIN_ROCK:
                (gg_statuswin = id);
                ;
            GG_QUOTEWIN_ROCK:
                (gg_quotewin = id);
                ;
            default:
                IdentifyGlkObject(1, 0, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SCRIPTFREF_ROCK:
                (gg_scriptfref = id);
                ;
            default:
                IdentifyGlkObject(1, 2, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            switch ((gg_arguments-->(0))) {
                GG_FOREGROUNDCHAN_ROCK:
                    (gg_foregroundchan = id);
                    ;
                GG_BACKGROUNDCHAN_ROCK:
                    (gg_backgroundchan = id);
                    ;
                default:
                    IdentifyGlkObject(1, 3, id, (gg_arguments-->(0)));
                    ;
            }
            (id = glk_schannel_iterate(id, gg_arguments));
        }
        if ((gg_foregroundchan ~= 0)) {
            glk_schannel_stop(gg_foregroundchan);
        }
        if ((gg_backgroundchan ~= 0)) {
            glk_schannel_stop(gg_backgroundchan);
        }
    }
    IdentifyGlkObject(2);
];
[ VM_Describe_Release i;
    print "Release ";
    @aloads ROM_GAMERELEASE 0 i;
    print i;
    print " / Serial number ";
    for ((i = 0):(i < 6):(i)++) {
        print (char) (ROM_GAMESERIAL->(i));
    }
];
[ VM_KeyChar win nostat done res ix jx ch;
    (jx = ch);
    if ((win == 0)) {
        (win = gg_mainwin);
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, gg_arguments, 31));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if (((gg_arguments->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            (res = (gg_arguments->(0)));
            if ((res == 92)) {
                (res = 0);
                for ((ix = 1):(ix < done):(ix)++) {
                    (ch = (gg_arguments->(ix)));
                    if ((((ch >= 48)) && ((ch <= 57)))) {
                        @shiftl res 4 res;
                        (res = (res + (ch - 48)));
                    } else {
                        if ((((ch >= 97)) && ((ch <= 102)))) {
                            @shiftl res 4 res;
                            (res = (res + ((ch + 10) - 97)));
                        } else {
                            if ((((ch >= 65)) && ((ch <= 70)))) {
                                @shiftl res 4 res;
                                (res = (res + ((ch + 10) - 65)));
                            }
                        }
                    }
                }
            }
            jump KCPContinue;
        }
    }
    (done = 0);
    glk_request_char_event(win);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                if (nostat) {
                    glk_cancel_char_event(win);
                    (res = -2147483648);
                    (done = 1);
                    break;
                }
                DrawStatusLine();
                ;
            2:
                if (((gg_event-->(1)) == win)) {
                    (res = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (res = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        if ((((((res < 32)) || ((res >= 256)))) || ((res == 92 or 32)))) {
            glk_put_char_stream(gg_commandstr, 92);
            (done = 0);
            (jx = res);
            for ((ix = 0):(ix < 8):(ix)++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                (ch = ((ch)&(15)));
                if ((((ch ~= 0)) || ((ix == 7)))) {
                    (done = 1);
                }
                if (done) {
                    if ((((ch >= 0)) && ((ch <= 9)))) {
                        (ch = (ch + 48));
                    } else {
                        (ch = ((ch - 10) + 65));
                    }
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KCPContinue;
    return res;
];
[ VM_KeyDelay tenths key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events((tenths*100));
    while ((~~(done))) {
        glk_select(gg_event);
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (key = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((((ix >= 0)) && (((gg_event-->(0)) == 1 or 2)))) {
                (key = (gg_event-->(2)));
                (done = 1);
            }
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];
[ VM_ReadKeyboard a_buffer a_table done ix;
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, (a_buffer + WORDSIZE), ((INPUT_BUFFER_LEN - WORDSIZE) - 1)));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if ((((a_buffer + WORDSIZE)->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            ((a_buffer-->(0)) = done);
            VM_Style(INPUT_VMSTY);
            glk_put_buffer((a_buffer + WORDSIZE), done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    (done = 0);
    glk_request_line_event(gg_mainwin, (a_buffer + WORDSIZE), (INPUT_BUFFER_LEN - WORDSIZE), 0);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                DrawStatusLine();
                ;
            3:
                if (((gg_event-->(1)) == gg_mainwin)) {
                    ((a_buffer-->(0)) = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 0, a_buffer));
        if ((ix == 2)) {
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        glk_put_buffer_stream(gg_commandstr, (a_buffer + WORDSIZE), (a_buffer-->(0)));
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KPContinue;
    VM_Tokenise(a_buffer, a_table);
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        (gg_quotewin = 0);
    }
    if (((KIT_CONFIGURATION_BITMAP)&(ECHO_COMMANDS_TCBIT))) {
        print "** ";
        for ((ix = WORDSIZE):(ix < ((a_buffer-->(0)) + WORDSIZE)):(ix)++) {
            print (char) (a_buffer->(ix));
        }
        print "^";
    }
];
[ VM_CopyBuffer bto bfrom i;
    for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
        ((bto->(i)) = (bfrom->(i)));
    }
];
[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if ((((((metaclass(a) == Object)) && (((_final_propertylength(OBJECT_TY, a, b)) == WORDSIZE)))) && ((metaclass(_final_propertyvalue(OBJECT_TY, a, b)) == String)))) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, _final_propertyvalue(OBJECT_TY, a, b)));
        } else {
            if ((metaclass(a) == Routine)) {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
            } else {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b));
            }
        }
    } else {
        if ((metaclass(a) == Routine)) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
        } else {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a));
        }
    }
    if (((buf-->(0)) > len)) {
        ((buf-->(0)) = len);
    }
    return (buf-->(0));
];
[ VM_Tokenise buf tab cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    (len = (buf-->(0)));
    (buf = (buf + WORDSIZE));
    (cx = 0);
    (numwords = 0);
    while ((cx < len)) {
        while ((((cx < len)) && (((buf->(cx)) == 32)))) {
            (cx)++;
        }
        if ((cx >= len)) {
            break;
        }
        (bx = cx);
        if (((buf->(cx)) == 46 or 44 or 34)) {
            (cx)++;
        } else {
            while ((((cx < len)) && (((buf->(cx)) ~= 32 or 46 or 44 or 34)))) {
                (cx)++;
            }
        }
        ((tab-->(((numwords*3) + 2))) = (cx - bx));
        ((tab-->(((numwords*3) + 3))) = (WORDSIZE + bx));
        (numwords)++;
        if ((numwords >= MAX_BUFFER_WORDS)) {
            break;
        }
    }
    ((tab-->(0)) = numwords);
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((wx = 0):(wx < numwords):(wx)++) {
        (wlen = (tab-->(((wx*3) + 2))));
        (wpos = (tab-->(((wx*3) + 3))));
        if ((wlen > DICT_WORD_SIZE)) {
            (wlen = DICT_WORD_SIZE);
        }
        (cx = (wpos - WORDSIZE));
        for ((ix = 0):(ix < wlen):(ix)++) {
            ((gg_tokenbuf->(ix)) = VM_UpperToLowerCase((buf->((cx + ix)))));
        }
        for (:(ix < DICT_WORD_SIZE):(ix)++) {
            ((gg_tokenbuf->(ix)) = 0);
        }
        (val = (#dictionary_table + WORDSIZE));
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        ((tab-->(((wx*3) + 1))) = res);
    }
];
[ LTI_Insert i ch b y;
    (b = buffer);
    (y = (b-->(0)));
    if ((y > INPUT_BUFFER_LEN)) {
        (y = INPUT_BUFFER_LEN);
    }
    for ((y = (y + WORDSIZE)):(y > i):(y)--) {
        ((b->(y)) = (b->((y - 1))));
    }
    ((b->(i)) = ch);
    if (((b-->(0)) < INPUT_BUFFER_LEN)) {
        ((b-->(0)))++;
    }
];
[ VM_InvalidDictionaryAddress addr;
    if ((addr < 0)) {
        rtrue;
    }
    rfalse;
];
[ VM_DictionaryAddressToNumber w;
    return w;
];
[ VM_NumberToDictionaryAddress n;
    return n;
];
[ GGWordCompare str1 str2 ix jx;
    for ((ix = 0):(ix < DICT_WORD_SIZE):(ix)++) {
        (jx = ((str1->(ix)) - (str2->(ix))));
        if ((jx ~= 0)) {
            return jx;
        }
    }
    rfalse;
];
[ VM_CommandTableAddress i;
    return (#grammar_table-->((i + 1)));
];
[ VM_PrintCommandWords i wd j dictlen entrylen;
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((j = 0):(j < dictlen):(j)++) {
        (wd = ((#dictionary_table + WORDSIZE) + (entrylen*j)));
        if ((DictionaryWordToVerbNum(wd) == i)) {
            print "'";
            print (address) wd;
            print "' ";
        }
    }
];
[ VM_Seed_RNG n;
    @setrandom n;
];
[ VM_AllocateMemory amount i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        return i;
    }
    @malloc amount i;
    return i;
];
[ VM_FreeMemory address i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        rtrue;
    }
    @mfree address;
];
[ VM_Picture resource_ID;
    if (glk_gestalt(gestalt_Graphics, 0)) {
        glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
    } else {
        print "[Picture number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_SoundEffect resource_ID;
    if (glk_gestalt(gestalt_Sound, 0)) {
        glk_schannel_play(gg_foregroundchan, resource_ID);
    } else {
        print "[Sound effect number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_Style sty;
    switch (sty) {
        NORMAL_VMSTY:
            glk_set_style(style_Normal);
            ;
        HEADER_VMSTY:
            glk_set_style(style_Header);
            ;
        SUBHEADER_VMSTY:
            glk_set_style(style_Subheader);
            ;
        NOTE_VMSTY:
            glk_set_style(style_Note);
            ;
        ALERT_VMSTY:
            glk_set_style(style_Alert);
            ;
        BLOCKQUOTE_VMSTY:
            glk_set_style(style_BlockQuote);
            ;
        INPUT_VMSTY:
            glk_set_style(style_Input);
            ;
    }
];
[ VM_UpperToLowerCase c;
    return glk_char_to_lower(c);
];
[ VM_LowerToUpperCase c;
    return glk_char_to_upper(c);
];
[ Glulx_PrintAnything _vararg_count obj mclass;
    if ((_vararg_count == 0)) {
        rtrue;
    }
    @copy sp obj;
    (_vararg_count)--;
    if ((obj == 0)) {
        rtrue;
    }
    if (((obj->(0)) == 96)) {
        print (address) obj;
        rtrue;
    }
    (mclass = metaclass(obj));
    switch (mclass) {
        0:
            rtrue;
            ;
        String:
            print (string) obj;
            rtrue;
            ;
        Routine:
            @call obj _vararg_count 0;
            rtrue;
            ;
        Object:
            if ((_vararg_count == 0)) {
                PrintShortName(obj);
            } else {
                @copy obj sp;
                (_vararg_count)++;
                @call PrintOrRun _vararg_count 0;
            }
            rtrue;
            ;
    }
];
[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    (_vararg_count = (_vararg_count - 2));
    (oldstr = glk_stream_get_current());
    (str = glk_stream_open_memory(arr, arrlen, 1, 0));
    if ((str == 0)) {
        rfalse;
    }
    glk_stream_set_current(str);
    @call Glulx_PrintAnything _vararg_count 0;
    glk_stream_set_current(oldstr);
    @copy -1 sp;
    @copy str sp;
    @glk 68 2 0;
    @copy sp len;
    @copy sp 0;
    return len;
];
[ Glulx_ChangeAnyToCString _vararg_count ix len;
    (ix = (GG_ANYTOSTRING_LEN - 2));
    @copy ix sp;
    (ix = (AnyToStrArr + 1));
    @copy ix sp;
    (ix = (_vararg_count + 2));
    @call Glulx_PrintAnyToArray ix len;
    ((AnyToStrArr->(0)) = 224);
    if ((len >= GG_ANYTOSTRING_LEN)) {
        (len = (GG_ANYTOSTRING_LEN - 1));
    }
    ((AnyToStrArr->((len + 1))) = 0);
    return AnyToStrArr;
];
[ VM_ClearScreen window;
    if ((window == WIN_ALL or WIN_MAIN)) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            (gg_quotewin = 0);
        }
    }
    if (((gg_statuswin) && ((window == WIN_ALL or WIN_STATUS)))) {
        glk_window_clear(gg_statuswin);
    }
];
[ VM_ScreenWidth id;
    (id = gg_mainwin);
    if (((gg_statuswin) && (statuswin_current))) {
        (id = gg_statuswin);
    }
    glk_window_get_size(id, gg_arguments, 0);
    return (gg_arguments-->(0));
];
[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return (gg_arguments-->(0));
];
[ VM_SetWindowColours f b window doclear i fwd bwd swin;
    if (((((clr_on) && (f))) && (b))) {
        if (window) {
            (swin = (5 - window));
        }
        (fwd = MakeColourWord(f));
        (bwd = MakeColourWord(b));
        for ((i = 0):(i < style_NUMSTYLES):(i)++) {
            if ((((f == CLR_DEFAULT)) || ((b == CLR_DEFAULT)))) {
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }
        if (gg_statuswin) {
            glk_window_close(gg_statuswin, 0);
        }
        (gg_statuswin = 0);
        if (((doclear) || ((((window ~= 1)) && ((((clr_fg ~= f)) || ((clr_bg ~= b)))))))) {
            glk_window_close(gg_mainwin, 0);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
            if ((gg_scriptstr ~= 0)) {
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
            }
        }
        (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        if (((statuswin_current) && (gg_statuswin))) {
            VM_MoveCursorInStatusLine();
        } else {
            VM_MainWindow();
        }
        if ((window ~= 2)) {
            (clr_fgstatus = f);
            (clr_bgstatus = b);
        }
        if ((window ~= 1)) {
            (clr_fg = f);
            (clr_bg = b);
        }
    }
];
[ VM_RestoreWindowColours;
    if (clr_on) {
        VM_SetWindowColours(clr_fg, clr_bg, 2);
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, 1);
        VM_ClearScreen();
    }
];
[ MakeColourWord c;
    if ((c > 9)) {
        return c;
    }
    (c = (c - 2));
    return (((16711680*((c)&(1))) + (65280*(((c)&(2)) ~= 0))) + (255*(((c)&(4)) ~= 0)));
];
[ VM_MainWindow;
    glk_set_window(gg_mainwin);
    (statuswin_current = 0);
];
[ VM_StatusLineHeight hgt;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    if ((hgt == statuswin_cursize)) {
        rtrue;
    }
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), 18, hgt, 0);
    (statuswin_cursize = hgt);
];
[ VM_MoveCursorInStatusLine line column;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    glk_set_window(gg_statuswin);
    if ((line == 0)) {
        (line = 1);
        (column = 1);
    }
    glk_window_move_cursor(gg_statuswin, (column - 1), (line - 1));
    (statuswin_current = 1);
];
[ Box__Routine maxwid arr ix lines lastnl parwin;
    (maxwid = 0);
    (lines = (arr-->(0)));
    if ((gg_quotewin == 0)) {
        ((gg_arguments-->(0)) = lines);
        (ix = InitGlkWindow(GG_QUOTEWIN_ROCK));
        if ((ix == 0)) {
            (gg_quotewin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK));
        }
    } else {
        (parwin = glk_window_get_parent(gg_quotewin));
        glk_window_set_arrangement(parwin, 18, lines, 0);
    }
    (lastnl = 1);
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        (lastnl = 0);
    }
    VM_Style(BLOCKQUOTE_VMSTY);
    for ((ix = 0):(ix < lines):(ix)++) {
        print (string) (arr-->((ix + 1)));
        if ((((ix < (lines - 1))) || (lastnl))) {
            print "^";
        }
    }
    VM_Style(NORMAL_VMSTY);
    if (gg_quotewin) {
        glk_set_window(gg_mainwin);
    }
];
[ Unsigned__Compare x y;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ RT__ChLDW x y;
    @aload x y sp;
    @return sp;
];
[ RT__ChLDB x y;
    @aloadb x y sp;
    @return sp;
];
[ ClearParagraphing r;
    (say__p = 0);
    (say__pc = 0);
];
[ DivideParagraphPoint;
    if (say__p) {
        print "^";
        (say__p = 0);
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
        (say__pc_save = 1);
        if (((say__pc)&(PARA_PROMPTSKIP))) {
            (say__pc = (say__pc - PARA_PROMPTSKIP));
        }
        if (((say__pc)&(PARA_SUPPRESSPROMPTSKIP))) {
            (say__pc = (say__pc - PARA_SUPPRESSPROMPTSKIP));
        }
    }
    (say__pc = ((say__pc)|(PARA_CONTENTEXPECTED)));
    (say__pc_save = ((say__pc)&(PARA_COMPLETED)));
];
[ AdjustParagraphPoint;
    if (say__pc_save) {
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
    }
];
[ ParaContent;
    if (((say__pc)&(PARA_CONTENTEXPECTED))) {
        (say__pc = (say__pc - PARA_CONTENTEXPECTED));
        (say__p = 1);
    }
];
[ GoingLookBreak;
    if ((((say__pc)&(PARA_COMPLETED)) == 0)) {
        print "^";
    }
    ClearParagraphing(10);
];
[ CommandClarificationBreak;
    print "^";
    ClearParagraphing(11);
];
[ RunParagraphOn;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
    (say__pc = ((say__pc)|(PARA_SUPPRESSPROMPTSKIP)));
];
[ SpecialLookSpacingBreak;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
];
[ EnsureBreakBeforePrompt;
    if (((say__p) || (((((say__pc)&(PARA_PROMPTSKIP))) && ((((say__pc)&(PARA_SUPPRESSPROMPTSKIP)) == 0)))))) {
        print "^";
    }
    ClearParagraphing(12);
];
[ PrintSingleParagraph matter;
    (say__p = 1);
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    TEXT_TY_Say(matter);
    DivideParagraphPoint();
    (say__pc = 0);
];
[ STextSubstitution;
    if ((say__n ~= 1)) {
        print "s";
    }
];
[ EnglishNumber n;
    LanguageNumber(n);
];
[ LanguageNumber n f;
    if ((n == 0)) {
        print "zero";
        rfalse;
    }
    if ((n == MIN_NEGATIVE_NUMBER)) {
        print "minus two billion";
        (n = 147483648);
        (f = 1);
    }
    if ((n < 0)) {
        print "minus ";
        (n = (-(n)));
    }
    if ((n >= 1000000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000000));
        print " billion";
        (n = (n%1000000000));
        (f = 1);
    }
    if ((n >= 1000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000));
        print " million";
        (n = (n%1000000));
        (f = 1);
    }
    if ((n >= 1000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000));
        print " thousand";
        (n = (n%1000));
        (f = 1);
    }
    if ((n >= 100)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/100));
        print " hundred";
        (n = (n%100));
        (f = 1);
    }
    if ((n == 0)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(DIALECT_US_TCBIT))) {
        if ((f == 1)) {
            print " ";
        }
    } else {
        if ((f == 1)) {
            print " and ";
        }
    }
    if ((((n >= 20)) && ((n < 100)))) {
        switch ((n/10)) {
            2:
                print "twenty";
                ;
            3:
                print "thirty";
                ;
            4:
                print "forty";
                ;
            5:
                print "fifty";
                ;
            6:
                print "sixty";
                ;
            7:
                print "seventy";
                ;
            8:
                print "eighty";
                ;
            9:
                print "ninety";
                ;
        }
        if (((n%10) ~= 0)) {
            print "-";
            LanguageNumber((n%10));
        }
    } else {
        switch (n) {
            1:
                print "one";
                ;
            2:
                print "two";
                ;
            3:
                print "three";
                ;
            4:
                print "four";
                ;
            5:
                print "five";
                ;
            6:
                print "six";
                ;
            7:
                print "seven";
                ;
            8:
                print "eight";
                ;
            9:
                print "nine";
                ;
            10:
                print "ten";
                ;
            11:
                print "eleven";
                ;
            12:
                print "twelve";
                ;
            13:
                print "thirteen";
                ;
            14:
                print "fourteen";
                ;
            15:
                print "fifteen";
                ;
            16:
                print "sixteen";
                ;
            17:
                print "seventeen";
                ;
            18:
                print "eighteen";
                ;
            19:
                print "nineteen";
                ;
        }
    }
];
[ SquareRoot num op res one n x;
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
    (op = num);
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    for ((one = WORD_NEXTTOHIGHBIT):(one > op):(one = (one/4))) {
    }
    while ((one ~= 0)) {
        if ((op >= (res + one))) {
            (op = ((op - res) - one));
            (res = ((res/2) + one));
        } else {
            (res = (res/2));
        }
        (one = (one/4));
    }
    return res;
];
[ CubeRoot num neg x y n;
    @gestalt 11 0 n;
    if (n) {
        if ((num < 0)) {
            (neg = 1);
            (num = (-(num)));
        }
        @numtof num x;
        @pow x 1051372203 x;
        @ftonumz x num;
        if (neg) {
            return (-(num));
        } else {
            return num;
        }
    }
    if ((num < 0)) {
        (x = (-(SquareRoot((-(num))))));
    } else {
        (x = SquareRoot(num));
    }
    for ((n = 0):(((y ~= x)) && (((n)++ < 100))):((y = x),(x = (((2*x) + ((num/x)/x))/3)))) {
    }
    return x;
];
[ NUMBER_TY_Abs x;
    if ((x < 0)) {
        return (-(x));
    }
    return x;
];
[ IntegerDivide A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A/B);
];
[ IntegerRemainder A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A%B);
];
[ UnsignedCompare x y u v;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ SignedCompare x y;
    if ((x > y)) {
        rtrue;
    }
    if ((x == y)) {
        rfalse;
    }
    return (-(1));
];
[ REAL_NUMBER_TY_Say fp;
    Float(fp);
];
[ REAL_NUMBER_TY_Compare r1 r2;
    @jflt r1 r2 ?less;
    @jfeq r1 r2 0 ?same;
    rtrue;
    .same;
    rfalse;
    .less;
    return (-(1));
];
[ NUMBER_TY_to_REAL_NUMBER_TY int real;
    @numtof int real;
    return real;
];
[ REAL_NUMBER_TY_to_NUMBER_TY real int;
    @ftonumn real int;
    return int;
];
[ REAL_NUMBER_TY_Sin in out;
    @sin in out;
    return out;
];
[ REAL_NUMBER_TY_Cos in out;
    @cos in out;
    return out;
];
[ REAL_NUMBER_TY_Tan in out;
    @tan in out;
    return out;
];
[ REAL_NUMBER_TY_Arcsin in out;
    @asin in out;
    return out;
];
[ REAL_NUMBER_TY_Arccos in out;
    @acos in out;
    return out;
];
[ REAL_NUMBER_TY_Arctan in out;
    @atan in out;
    return out;
];
[ REAL_NUMBER_TY_Sinh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fadd tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Cosh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fsub tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Tanh in s c t;
    (s = REAL_NUMBER_TY_Sinh(in));
    (c = REAL_NUMBER_TY_Cosh(in));
    @fdiv s c t;
    return t;
];
[ REAL_NUMBER_TY_Reciprocal in out;
    @fdiv M_1 in out;
    return out;
];
[ REAL_NUMBER_TY_Negate in out;
    @fsub M_0 in out;
    return out;
];
[ REAL_NUMBER_TY_Plus x y out;
    @fadd x y out;
    return out;
];
[ REAL_NUMBER_TY_Minus x y out;
    @fsub x y out;
    return out;
];
[ REAL_NUMBER_TY_Times x y out;
    @fmul x y out;
    return out;
];
[ REAL_NUMBER_TY_Divide x y out;
    @fdiv x y out;
    return out;
];
[ REAL_NUMBER_TY_Remainder x y r q;
    @fmod x y r q;
    return r;
];
[ REAL_NUMBER_TY_Approximate x y quotient out;
    @fdiv x y quotient;
    @fadd quotient M_HALF quotient;
    @floor quotient quotient;
    @fmul quotient y out;
    return out;
];
[ REAL_NUMBER_TY_Root x out;
    @sqrt x out;
    return out;
];
[ REAL_NUMBER_TY_Cube_Root x out;
    @pow x M_THIRD out;
    return out;
];
[ REAL_NUMBER_TY_Pow x y out;
    @pow x y out;
    return out;
];
[ REAL_NUMBER_TY_Exp x out;
    @exp x out;
    return out;
];
[ REAL_NUMBER_TY_Log x out;
    @log x out;
    return out;
];
[ REAL_NUMBER_TY_BLog x n d out;
    @log x out;
    if ((n == 10)) {
        (d = M_LOG10);
    } else {
        @numtof n d;
        @log d d;
    }
    @fdiv out d out;
    return out;
];
[ REAL_NUMBER_TY_Floor x out;
    @floor x out;
    return out;
];
[ REAL_NUMBER_TY_Ceiling x out;
    @ceil x out;
    return out;
];
[ REAL_NUMBER_TY_Abs x;
    return ((x)&(2147483647));
];
[ REAL_NUMBER_TY_Nan x;
    @jisnan x ?Nan;
    rfalse;
    .Nan;
    rtrue;
];
[ FloatParse buf len useall res ix val ch ten negative intpart fracpart fracdiv expon expnegative count;
    if ((len == 0)) {
        return FLOAT_NAN;
    }
    (ix = 0);
    (negative = 0);
    (intpart = 0);
    (fracpart = 0);
    @numtof 10 ten;
    (ch = (buf->(ix)));
    if ((ch == 45)) {
        (negative = 1);
        (ix)++;
    } else {
        if ((ch == 43)) {
            (ix)++;
        }
    }
    for ((count = 0):(ix < len):((ix)++,(count)++)) {
        (ch = (buf->(ix)));
        if ((((ch < 48)) || ((ch > 57)))) {
            break;
        }
        (val = (ch - 48));
        @numtof val val;
        @fmul intpart ten intpart;
        @fadd intpart val intpart;
    }
    if ((((ix < len)) && (((buf->(ix)) == 46)))) {
        (ix)++;
        @numtof 1 fracdiv;
        for (:(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (val = (ch - 48));
            @numtof val val;
            @fmul fracpart ten fracpart;
            @fadd fracpart val fracpart;
            @fmul fracdiv ten fracdiv;
        }
        @fdiv fracpart fracdiv fracpart;
    }
    if ((count == 0)) {
        return FLOAT_NAN;
    }
    @fadd intpart fracpart res;
    if ((((ix < len)) && (((buf->(ix)) == 101 or 69 or 32 or 42 or 120 or 88 or 215)))) {
        if (((buf->(ix)) == 101 or 69)) {
            (ix)++;
            if ((ix == len)) {
                return FLOAT_NAN;
            }
        } else {
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 42 or 120 or 88 or 215)) {
                return FLOAT_NAN;
            }
            (ix)++;
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 49)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 48)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 94)) {
                return FLOAT_NAN;
            }
            (ix)++;
        }
        (expnegative = 0);
        (ch = (buf->(ix)));
        if ((ch == 45)) {
            (expnegative = 1);
            (ix)++;
        } else {
            if ((ch == 43)) {
                (ix)++;
            }
        }
        (expon = 0);
        for ((count = 0):(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (expon = ((10*expon) + (ch - 48)));
        }
        if ((count == 0)) {
            return FLOAT_NAN;
        }
        if (expnegative) {
            (expon = (-(expon)));
        }
        if (expon) {
            @numtof expon expon;
            @pow ten expon val;
            @fmul res val res;
        }
    }
    if (negative) {
        (res = ((-2147483648)|(res)));
    }
    if (((useall) && ((ix ~= len)))) {
        return FLOAT_NAN;
    }
    return res;
];
[ Float val prec pval;
    (pval = ((val)&(2147483647)));
    @jz pval ?UseFloatDec;
    @jfge pval 1232348160 ?UseFloatExp;
    @jflt pval 953267991 ?UseFloatExp;
    .UseFloatDec;
    return FloatDec(val, prec);
    .UseFloatExp;
    return FloatExp(val, prec);
];
[ FloatExp val prec log10val expo fexpo idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    if ((val == 0)) {
        (expo = 0);
        (idig = 0);
        jump DoPrint;
    }
    @log val sp;
    @fdiv sp 1075010958 log10val;
    @floor log10val fexpo;
    @ftonumn fexpo expo;
    @fsub log10val fexpo sp;
    @numtof prec sp;
    @fadd sp sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    .DoPrint;
    if ((idig >= (10*pow10))) {
        (expo)++;
        @div idig 10 idig;
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    for ((ix = 0):(ix <= prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        if ((ix == 0)) {
            @streamchar 46;
        }
        @div pow10 10 pow10;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(PROGRAMMING_EXPONENTS_TCBIT)) == 0)) {
        PrintMultiplicationSign();
        @streamchar 49;
        @streamchar 48;
        @streamchar 94;
        @streamnum expo;
    } else {
        @streamchar 101;
        if ((expo < 0)) {
            @streamchar 45;
            @neg expo expo;
        } else {
            @streamchar 43;
        }
        if ((expo < 10)) {
            @streamchar 48;
        }
        @streamnum expo;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ FloatDec val prec log10val int fint extra0 frac idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    (extra0 = 0);
    @fmod val 1065353216 frac fint;
    @ftonumz fint int;
    if ((int == 2147483647)) {
        @log fint sp;
        @fdiv sp 1075010958 log10val;
        @ftonumz log10val extra0;
        @sub extra0 8 extra0;
        @numtof extra0 sp;
        @fsub log10val sp sp;
        @fmul sp 1075010958 sp;
        @exp sp sp;
        @ftonumz sp int;
    }
    @streamnum int;
    for ((ix = 0):(ix < extra0):(ix)++) {
        @streamchar 48;
    }
    @streamchar 46;
    @log frac sp;
    @fdiv sp 1075010958 log10val;
    @numtof prec sp;
    @fadd log10val sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    if ((idig >= pow10)) {
        (idig = (pow10 - 1));
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    @div pow10 10 pow10;
    for ((ix = 0):(ix < prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        @div pow10 10 pow10;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ PrintInfinity;
    @streamunichar 8734;
];
[ PrintNan;
    @streamunichar 9888;
];
[ PrintMultiplicationSign;
    print " ";
    @streamunichar 215;
    print " ";
];
[ FileIO_Error extf err_text struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        print "^*** Error on unknown file: ";
        print (string) err_text;
        print " ***^";
    } else {
        (struc = (TableOfExternalFiles-->(extf)));
        print "^*** Error on file '";
        print (string) (struc-->(AUXF_FILENAME));
        print "': ";
        print (string) err_text;
        print " ***^";
    }
    RunTimeProblem(RTP_FILEIOERROR);
    rfalse;
];
[ FileIO_Exists extf fref struc rv usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    (rv = glk_fileref_does_file_exist(fref));
    glk_fileref_destroy(fref);
    return rv;
];
[ FileIO_Ready extf struc fref usage str ch;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        rfalse;
    }
    (str = glk_stream_open_file(fref, filemode_Read, 0));
    (ch = glk_get_char_stream(str));
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
    if ((ch ~= 42)) {
        rfalse;
    }
    rtrue;
];
[ FileIO_MarkReady extf readiness struc fref str ch usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only existing files can be marked");
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only closed files can be marked");
    }
    (str = glk_stream_open_file(fref, filemode_ReadWrite, 0));
    glk_stream_set_position(str, 0, 0);
    if (readiness) {
        (ch = 42);
    } else {
        (ch = 45);
    }
    glk_put_char_stream(str, ch);
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
];
[ FileIO_Open extf write_flag append_flag struc fref str mode ix ch not_this_ifid owner force_header usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        return FileIO_Error(extf, "tried to open a file already open");
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if (write_flag) {
        if (append_flag) {
            (mode = filemode_WriteAppend);
            if ((glk_fileref_does_file_exist(fref) == 0)) {
                (force_header = 1);
            }
        } else {
            (mode = filemode_Write);
        }
    } else {
        (mode = filemode_Read);
        if ((glk_fileref_does_file_exist(fref) == 0)) {
            glk_fileref_destroy(fref);
            return FileIO_Error(extf, "tried to open a file which does not exist");
        }
    }
    (str = glk_stream_open_file(fref, mode, 0));
    glk_fileref_destroy(fref);
    if ((str == 0)) {
        return FileIO_Error(extf, "tried to open a file but failed");
    }
    ((struc-->(AUXF_STREAM)) = str);
    if (write_flag) {
        if (append_flag) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_APPEND);
        } else {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_WRITE);
        }
        glk_stream_set_current(str);
        if ((((append_flag == 0)) || (force_header))) {
            print "- ";
            for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
                print (char) (UUID_ARRAY->(ix));
            }
            print " ";
            print (string) (struc-->(AUXF_FILENAME));
            print "^";
        }
    } else {
        ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_READ);
        (ch = FileIO_GetC(extf));
        if ((ch ~= 45 or 42)) {
            jump BadFile;
        }
        if ((ch == 45)) {
            return FileIO_Error(extf, "tried to open a file which was incomplete");
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 32)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (owner = (struc-->(AUXF_IFID_OF_OWNER)));
        (ix = 3);
        if ((owner == UUID_ARRAY)) {
            (ix = 8);
        }
        if ((owner ~= NULL)) {
            for (:(ix <= (owner->(0))):(ix)++) {
                (ch = FileIO_GetC(extf));
                if ((ch == -1)) {
                    jump BadFile;
                }
                if ((ch ~= (owner->(ix)))) {
                    (not_this_ifid = 1);
                }
                if ((ch == 32)) {
                    break;
                }
            }
            if ((not_this_ifid == 0)) {
                (ch = FileIO_GetC(extf));
                if ((ch ~= 32)) {
                    jump BadFile;
                }
            }
        }
        while ((ch ~= -1)) {
            (ch = FileIO_GetC(extf));
            if ((ch == 10 or 13)) {
                break;
            }
        }
        if (not_this_ifid) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
            glk_stream_close(str, 0);
            return FileIO_Error(extf, "tried to open a file owned by another project");
        }
    }
    return (struc-->(AUXF_STREAM));
    .BadFile;
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
    glk_stream_close(str, 0);
    return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];
[ FileIO_Close extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ or AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to close a file which is not open");
    }
    if (((struc-->(AUXF_STATUS)) == AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        glk_stream_set_position((struc-->(AUXF_STREAM)), 0, 0);
        glk_put_char_stream((struc-->(AUXF_STREAM)), 42);
    }
    glk_stream_close((struc-->(AUXF_STREAM)), 0);
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
];
[ FileIO_GetC extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return (-(1));
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ)) {
        return (-(1));
    }
    return glk_get_char_stream((struc-->(AUXF_STREAM)));
];
[ FileIO_PutC extf char struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to write to a file which is not open for writing");
    }
    return glk_put_char_stream((struc-->(AUXF_STREAM)), char);
];
[ FileIO_PrintLine extf ch struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    for (:1:) {
        (ch = FileIO_GetC(extf));
        if ((ch == -1)) {
            rfalse;
        }
        if ((ch == 10 or 13)) {
            print "^";
            rtrue;
        }
        print (char) ch;
    }
];
[ FileIO_PrintContents extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "printing text will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    while (FileIO_PrintLine(extf)) {
    }
    FileIO_Close(extf);
    rtrue;
];
[ FileIO_PutContents extf text append_flag struc str ch oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing text will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    (str = FileIO_Open(extf, 1, append_flag));
    if ((str == 0)) {
        rfalse;
    }
    @push say__p;
    @push say__pc;
    ClearParagraphing(19);
    TEXT_TY_Say(text);
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    @pull say__pc;
    @pull say__p;
    rfalse;
];
[ FileIO_PutTable extf tab rv struc oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write table to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing a table will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    if ((FileIO_Open(extf, 1) == 0)) {
        rfalse;
    }
    (rv = TablePrint(tab));
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    if (rv) {
        return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
    }
    rtrue;
];
[ FileIO_GetTable extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to read table from a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "reading a table will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    TableRead(tab, extf);
    FileIO_Close(extf);
    rtrue;
];
[ SetSortDomain swapf compf;
    (I7S_Swap = swapf);
    (I7S_Comp = compf);
];
[ SortArray tab col dir size algorithm;
    (I7S_Tab = tab);
    (I7S_Col = col);
    (I7S_Dir = dir);
    SortRange(0, size, algorithm);
];
[ SortRange x y algorithm;
    if (((y - x) < 2)) {
        rtrue;
    }
    if (algorithm) {
        (algorithm)(x,y);
    } else {
        InPlaceMergeSortAlgorithm(x, y);
    }
];
[ CompareFields x y;
    return (I7S_Dir*(I7S_Comp)(I7S_Tab,I7S_Col,(x + 1),(y + 1),I7S_Dir));
];
[ ExchangeFields x y r;
    (r = (I7S_Swap)(I7S_Tab,(x + 1),(y + 1)));
    return r;
];
[ OldSortAlgorithm x y f i j;
    if (((y - x) < 2)) {
        rtrue;
    }
    (f = 1);
    while (f) {
        (f = 0);
        for ((i = x):(i < y):(i)++) {
            for ((j = (i + 1)):(j < y):(j)++) {
                if ((CompareFields(i, j) > 0)) {
                    ExchangeFields(i, j);
                    (f = 1);
                    break;
                }
            }
        }
    }
];
[ InsertionSortAlgorithm from to i j;
    if ((to > (from + 1))) {
        for ((i = (from + 1)):(i < to):(i)++) {
            for ((j = i):(j > from):(j)--) {
                if ((CompareFields(j, (j - 1)) < 0)) {
                    ExchangeFields(j, (j - 1));
                } else {
                    break;
                }
            }
        }
    }
];
[ InPlaceMergeSortAlgorithm from to middle;
    if (((to - from) < 12)) {
        if (((to - from) < 2)) {
            rtrue;
        }
        InsertionSortAlgorithm(from, to);
        rtrue;
    }
    (middle = ((from + to)/2));
    InPlaceMergeSortAlgorithm(from, middle);
    InPlaceMergeSortAlgorithm(middle, to);
    IPMS_Merge(from, middle, to, (middle - from), (to - middle));
];
[ IPMS_Lower from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(mid, val) < 0)) {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        } else {
            (len = half);
        }
    }
    return from;
];
[ IPMS_Upper from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(val, mid) < 0)) {
            (len = half);
        } else {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        }
    }
    return from;
];
[ IPMS_Reverse from to;
    while ((from < to)) {
        ExchangeFields((from)++, (to)--);
    }
];
[ IPMS_Rotate from mid to n val shift p1 p2;
    if ((((from == mid)) || ((mid == to)))) {
        rtrue;
    }
    IPMS_Reverse(from, (mid - 1));
    IPMS_Reverse(mid, (to - 1));
    IPMS_Reverse(from, (to - 1));
];
[ IPMS_Merge from pivot to len1 len2 first_cut second_cut len11 len22 new_mid;
    if ((((len1 == 0)) || ((len2 == 0)))) {
        rtrue;
    }
    if (((len1 + len2) == 2)) {
        if ((CompareFields(pivot, from) < 0)) {
            ExchangeFields(pivot, from);
        }
        rtrue;
    }
    if ((len1 > len2)) {
        (len11 = (len1/2));
        (first_cut = (from + len11));
        (second_cut = IPMS_Lower(pivot, to, first_cut));
        (len22 = (second_cut - pivot));
    } else {
        (len22 = (len2/2));
        (second_cut = (pivot + len22));
        (first_cut = IPMS_Upper(from, pivot, second_cut));
        (len11 = (first_cut - from));
    }
    IPMS_Rotate(first_cut, pivot, second_cut);
    (new_mid = (first_cut + len22));
    IPMS_Merge(from, first_cut, new_mid, len11, len22);
    IPMS_Merge(new_mid, second_cut, to, (len1 - len11), (len2 - len22));
];
[ TableFindCol tab col f i no_cols n;
    (no_cols = (tab-->(0)));
    for ((i = 1):(i <= no_cols):(i)++) {
        if ((col == ((((tab-->(i))-->(1)))&(TB_COLUMN_NUMBER)))) {
            return i;
        }
    }
    if (f) {
        RunTimeProblem(RTP_TABLE_NOCOL, tab);
        rfalse;
    }
    rfalse;
];
[ TableRows tab first_col;
    (first_col = (tab-->(1)));
    if ((first_col == 0)) {
        rfalse;
    }
    return ((first_col-->(0)) - COL_HSIZE);
];
[ CheckTableEntryIsBlank tab col row i at;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if ((((tab-->(col))-->((row + COL_HSIZE))) ~= TABLE_NOVALUE)) {
        print "*** CTEIB on nonblank value ";
        print tab;
        print " ";
        print col;
        print " ";
        print row;
        print " ***^";
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    if ((((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row%8)))))) {
        rtrue;
    }
    rfalse;
];
[ ForceTableEntryBlank tab col row i at oldv flags;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv ~= 0 or TABLE_NOVALUE)))) {
        BlkValueFree(oldv);
    }
    (((tab-->(col))-->((row + COL_HSIZE))) = TABLE_NOVALUE);
    if (((flags)&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row%8))))));
];
[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv == 0 or TABLE_NOVALUE)))) {
        (kov = UNKNOWN_TY);
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        if ((kov ~= UNKNOWN_TY)) {
            (((tab-->(col))-->((row + COL_HSIZE))) = BlkValueCreate(kov));
        }
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row%8))))));
];
[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (at1 = (((tab-->(col))-->(2)) + (row1/8)));
    (row2)--;
    (at2 = (((tab-->(col))-->(2)) + (row2/8)));
    (bit1 = (((TB_Blanks->(at1)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    (bit2 = (((TB_Blanks->(at2)))&((CheckTableEntryIsBlank_LU->((row2%8))))));
    if (bit1) {
        (bit1 = 1);
    }
    if (bit2) {
        (bit2 = 1);
    }
    if ((bit1 == bit2)) {
        rtrue;
    }
    if (bit1) {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))&((CheckTableEntryIsNonBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))|((CheckTableEntryIsBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (row2)--;
    (at = (((tab-->(col))-->(2)) + (row1/8)));
    (bit = (((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    if (bit) {
        (bit = 1);
    }
    for ((rx = row1):(rx < row2):(rx)++) {
        (atp1 = (((tab-->(col))-->(2)) + ((rx + 1)/8)));
        (at = (((tab-->(col))-->(2)) + (rx/8)));
        if ((((TB_Blanks->(atp1)))&((CheckTableEntryIsBlank_LU->(((rx + 1)%8)))))) {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((rx%8))))));
        } else {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((rx%8))))));
        }
    }
    (at = (((tab-->(col))-->(2)) + (row2/8)));
    if (bit) {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableRowCorr tab col lookup_value lookup_col i j f v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    (lookup_col = (tab-->(col)));
    (j = ((lookup_col-->(0)) - COL_HSIZE));
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (f) {
        for ((i = 1):(i <= j):(i)++) {
            (v = (lookup_col-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if ((BlkValueCompare(v, lookup_value) == 0)) {
                return i;
            }
        }
    } else {
        for ((i = 1):(i <= j):(i)++) {
            if ((((lookup_value == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (((lookup_col-->((i + COL_HSIZE))) == lookup_value)) {
                return i;
            }
        }
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableRowCorr tab col entry i k v f kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    (f = 0);
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 1);
    } else {
        if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
            (f = 2);
        }
    }
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            continue;
        }
        switch (f) {
            1:
                if (((v)((entry/100),(entry%100)) ~= GPR_FAIL)) {
                    return i;
                }
                ;
            2:
                if ((BlkValueCompare(v, entry) == 0)) {
                    return i;
                }
                ;
            default:
                if ((v == entry)) {
                    return i;
                }
                ;
        }
    }
    rfalse;
];
[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 1));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 1));
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        (v = (cola2-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col2, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare(v, lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if (((v)((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if ((v ~= lookup_value)) {
                    continue;
                }
            }
        }
        if (write_flag) {
            if ((write_flag == 4)) {
                ForceTableEntryBlank(tab, col1, (i - COL_HSIZE));
            } else {
                ForceTableEntryNonBlank(tab, col1, (i - COL_HSIZE));
            }
            switch (write_flag) {
                1:
                    ((cola1-->(i)) = write_value);
                    ;
                2:
                    ((cola1-->(i)) = ((cola1-->(i)) + write_value));
                    ;
                3:
                    ((cola1-->(i)) = ((cola1-->(i)) - write_value));
                    ;
                5:
                    return (cola1-->(i));
                    ;
            }
            rfalse;
        }
        (v = (cola1-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        return v;
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 0));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 0));
    }
    if (((col1*col2) == 0)) {
        rfalse;
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        if (((((cola1-->(i)) == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare((cola2-->(i)), lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if ((((cola2-->(i)))((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if (((cola2-->(i)) ~= lookup_value)) {
                    continue;
                }
            }
        }
        rtrue;
    }
    rfalse;
];
[ TableLookUpEntry tab col index write_flag write_value v;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE2);
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        RunTimeProblem(RTP_TABLE_NOROW, tab, index);
        (index = 1);
    }
    if (write_flag) {
        switch (write_flag) {
            1:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = write_value);
                ;
            2:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) + write_value));
                ;
            3:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) - write_value));
                ;
            4:
                ForceTableEntryBlank(tab, col, index);
                ;
            5:
                ForceTableEntryNonBlank(tab, col, index);
                return ((tab-->(col))-->((index + COL_HSIZE)));
                ;
        }
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
        rfalse;
    }
    return v;
];
[ ExistsTableLookUpEntry tab col index v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        rfalse;
    }
    rtrue;
];
[ TableRowIsBlank tab j k;
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        if ((((tab-->(k))-->((j + COL_HSIZE))) ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((CheckTableEntryIsBlank(tab, k, j) == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ TableBlankOutRow tab row k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        ForceTableEntryBlank(tab, k, row);
    }
];
[ TableBlankOutColumn tab col n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        ForceTableEntryBlank(tab, col, k);
    }
];
[ TableBlankOutAll tab n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        TableBlankOutRow(tab, k);
    }
];
[ TableBlankRows tab i j c;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            (c)++;
        }
    }
    return c;
];
[ TableFilledRows tab;
    return (TableRows(tab) - TableBlankRows(tab));
];
[ TableBlankRow tab i j;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            return j;
        }
    }
    RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
    return i;
];
[ TableRandomRow tab i j k;
    (i = TableRows(tab));
    (j = TableFilledRows(tab));
    if ((j == 0)) {
        return RunTimeProblem(RTP_TABLE_NOROWS, tab);
    }
    if ((j > 1)) {
        (j = random(j));
    }
    for ((k = 1):(k <= i):(k)++) {
        if ((TableRowIsBlank(tab, k) == 0)) {
            (j)--;
        }
        if ((j == 0)) {
            return k;
        }
    }
];
[ TableSwapRows tab i j k l v1 v2;
    if ((i == j)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (v1 = ((tab-->(k))-->((i + COL_HSIZE))));
        (v2 = ((tab-->(k))-->((j + COL_HSIZE))));
        (((tab-->(k))-->((i + COL_HSIZE))) = v2);
        (((tab-->(k))-->((j + COL_HSIZE))) = v1);
        if ((((v1 == TABLE_NOVALUE)) || ((v2 == TABLE_NOVALUE)))) {
            TableSwapBlankBits(tab, i, j, k);
        }
    }
];
[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (val1 = ((tab-->(col))-->((row1 + COL_HSIZE))));
    (val2 = ((tab-->(col))-->((row2 + COL_HSIZE))));
    if ((val1 == TABLE_NOVALUE)) {
        (bl1 = CheckTableEntryIsBlank(tab, col, row1));
    }
    if ((val2 == TABLE_NOVALUE)) {
        (bl2 = CheckTableEntryIsBlank(tab, col, row2));
    }
    if ((((val1 == val2)) && ((bl1 == bl2)))) {
        if ((val1 ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((bl1 == 0)) {
            rfalse;
        }
        if (TableRowIsBlank(tab, row1)) {
            if (TableRowIsBlank(tab, row2)) {
                rfalse;
            }
            return (-(dir));
        }
        if (TableRowIsBlank(tab, row2)) {
            return dir;
        }
        rfalse;
    }
    if (bl1) {
        return dir;
    }
    if (bl2) {
        return (-(dir));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        if ((BlkValueCompare(val2, val1) < 0)) {
            rtrue;
        }
        return (-(1));
    } else {
        if (((f)&(TB_COLUMN_REAL))) {
            if ((REAL_NUMBER_TY_Compare(val1, val2) > 0)) {
                rtrue;
            }
            return (-(1));
        } else {
            if (((f)&(TB_COLUMN_SIGNED))) {
                if ((val1 > val2)) {
                    rtrue;
                }
                return (-(1));
            } else {
                if ((UnsignedCompare(val1, val2) > 0)) {
                    rtrue;
                }
                return (-(1));
            }
        }
    }
];
[ TableMoveRowDown tab r1 r2 rx k l m v f;
    if ((r1 == r2)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (f = 0);
        (m = ((tab-->(k))-->((r1 + COL_HSIZE))));
        if ((m == TABLE_NOVALUE)) {
            (f = 1);
        }
        for ((rx = r1):(rx < r2):(rx)++) {
            (v = ((tab-->(k))-->(((rx + COL_HSIZE) + 1))));
            (((tab-->(k))-->((rx + COL_HSIZE))) = v);
            if ((v == TABLE_NOVALUE)) {
                (f = 1);
            }
        }
        (((tab-->(k))-->((r2 + COL_HSIZE))) = m);
        if (f) {
            TableMoveBlankBitsDown(tab, r1, r2, k);
        }
    }
];
[ TableShuffle tab i to;
    TableMoveBlanksToBack(tab, 1, TableRows(tab));
    (to = TableFilledRows(tab));
    for ((i = 2):(i <= to):(i)++) {
        TableSwapRows(tab, i, random(i));
    }
];
[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        (blk = 1);
    }
    (signed_arithmetic = ((f)&(TB_COLUMN_SIGNED)));
    if ((row == 0)) {
        if (signed_arithmetic) {
            if ((dir == 1)) {
                (val = -2147483648);
            } else {
                (val = 2147483647);
            }
        } else {
            if ((dir == 1)) {
                (val = 0);
            } else {
                (val = -1);
            }
        }
    } else {
        (val = ((tab-->(col))-->((row + COL_HSIZE))));
    }
    if (signed_arithmetic) {
        (min_dv = 2147483647);
    } else {
        (min_dv = -1);
    }
    (k = TableRows(tab));
    if ((dir == 1)) {
        for ((i = 1):(i <= k):(i)++) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = 1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z > 0)) || ((((z == 0)) && ((i > row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) < 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i > row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i > row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    } else {
        for ((i = k):(i >= 1):(i)--) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = -1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z < 0)) || ((((z == 0)) && ((i < row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) > 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i < row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i < row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    }
    return min_at;
];
[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
    if ((torow < fromrow)) {
        rtrue;
    }
    (fbl = 0);
    (lnbl = 0);
    for ((i = fromrow):(i <= torow):(i)++) {
        if (TableRowIsBlank(tab, i)) {
            if ((fbl == 0)) {
                (fbl = i);
            }
            (blc)++;
        } else {
            (lnbl = i);
        }
    }
    if ((((((fbl > 0)) && ((lnbl > 0)))) && ((fbl < lnbl)))) {
        TableMoveRowDown(tab, fbl, lnbl);
        TableMoveBlanksToBack(tab, fbl, (lnbl - 1));
    }
    return (torow - blc);
];
[ TableSort tab col dir algorithm i j k f;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if ((((j-->(1)))&(TB_COLUMN_DONTSORTME))) {
            return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
        }
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    SetSortDomain(TableSwapRows, TableCompareRows);
    SortArray(tab, col, dir, k, algorithm);
];
[ TablePrint tab i j k row col v tc kov;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            rtrue;
        }
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    print "! ";
    PrintTableName(tab);
    print " (";
    print k;
    print ")^";
    for ((row = 1):(row <= k):(row)++) {
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (v = ((tab-->(col))-->((row + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, row)))) {
                print "-- ";
            } else {
                if ((BlkValueWriteToFile(v, kov) == 0)) {
                    print v;
                }
                print " ";
            }
        }
        print "^";
    }
    rfalse;
];
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        (j = (tab-->(col)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
        }
    }
    (maxrow = TableRows(tab));
    for ((row = 1):(row <= maxrow):(row)++) {
        TableBlankOutRow(tab, row);
    }
    for ((row = 1):(row <= maxrow):(row)++) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 33)) {
            while ((ch ~= -1 or 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
            while ((ch == 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            if ((ch == -1)) {
                (row)++;
                jump NoMore;
            }
            if ((ch == 10 or 13)) {
                break;
            }
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (sgn = 1);
            if ((ch == 45)) {
                (ch = FileIO_GetC(auxf));
                if ((ch == -1)) {
                    jump NotTable;
                }
                if ((ch == 45)) {
                    (ch = FileIO_GetC(auxf));
                    jump EntryDone;
                }
                (sgn = -1);
            }
            if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                ForceTableEntryNonBlank(tab, col, row);
            }
            (v = BlkValueReadFromFile(0, 0, (-(1)), kov));
            if (v) {
                if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                    (v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row), auxf, ch, kov));
                } else {
                    (v = BlkValueReadFromFile(0, auxf, ch, kov));
                }
                (ch = 32);
            } else {
                (dg = (ch - 48));
                if ((((dg < 0)) || ((dg > 9)))) {
                    jump NotTable;
                }
                (v = dg);
                for (:1:) {
                    (ch = FileIO_GetC(auxf));
                    (dg = (ch - 48));
                    if ((((dg < 0)) || ((dg > 9)))) {
                        break;
                    }
                    (v = ((10*v) + dg));
                }
                (v = (v*sgn));
            }
            if ((((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED)) == 0)) {
                TableLookUpEntry(tab, col, row, 1, v);
            }
            .EntryDone;
            while ((ch == 9 or 32)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        while ((ch ~= -1 or 10 or 13)) {
            if ((((ch ~= 45)) && (((((ch - 48) < 0)) || (((ch - 48) > 9)))))) {
                jump NotTable;
            }
            if ((ch ~= 9 or 32)) {
                jump WontFit;
            }
            (ch = FileIO_GetC(auxf));
        }
    }
    .NoMore;
    while ((ch == 9 or 32 or 10 or 13)) {
        (ch = FileIO_GetC(auxf));
    }
    if ((ch == -1)) {
        rtrue;
    }
    .WontFit;
    return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
    .NotTable;
    return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
[ TableColumnDebug tab col k i v tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
    (kov = TC_KOV(tc));
    for ((i = 1):(i <= k):(i)++) {
        if ((i > 1)) {
            print ", ";
        }
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "--";
        } else {
            PrintKindValuePair(kov, v);
        }
    }
    (say__p = 1);
];
[ TableRowDebug tab i col k v tc kov;
    (k = TableRows(tab));
    if ((((i < 1)) || ((i > k)))) {
        print "No such row";
        new_line;
        rtrue;
    }
    print "(row ";
    print i;
    print ")  |";
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        print " ";
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "-- ";
        } else {
            PrintKindValuePair(kov, v);
            print " |";
        }
    }
    (say__p = 1);
];
[ TableDebug tab i k;
    PrintTableName(tab);
    print "^";
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        TableRowDebug(tab, i);
        print "^";
    }
];
[ Mstack_Create_Frame creator id extent;
    if ((creator == 0)) {
        rfalse;
    }
    (extent = (creator)((MStack_Top + 2),1));
    if ((extent == 0)) {
        rfalse;
    }
    if (((MStack_Top + MAX_MSTACK_FRAME) >= (MSTACK_SIZE + 2))) {
        RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
        Mstack_Backtrace();
        rfalse;
    }
    (MStack_Top)++;
    ((MStack-->(MStack_Top)) = id);
    (MStack_Top)++;
    (MStack_Top = (MStack_Top + extent));
    ((MStack-->(MStack_Top)) = (-((extent + 2))));
    rtrue;
];
[ Mstack_Destroy_Frame creator id pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    (MStack_Top = (pos - 2));
    if (creator) {
        (creator)(pos,(-(1)));
    }
    rtrue;
];
[ Mstack_Seek_Frame id pos;
    (pos = MStack_Top);
    while ((((pos > 0)) && (((MStack-->(pos)) ~= 0)))) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        if (((MStack-->((pos + 1))) == id)) {
            return (pos + 2);
        }
    }
    (MStack_Frame_Extent = 0);
    rfalse;
];
[ Mstack_Backtrace pos k;
    print "Mstack backtrace: size ";
    print (MStack_Top + 1);
    print " words^";
    (pos = MStack_Top);
    while (((MStack-->(pos)) ~= 0)) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        print "Block at ";
        print (pos + 2);
        print " owner ID ";
        print (MStack-->((pos + 1)));
        print " size ";
        print MStack_Frame_Extent;
        print "^";
        for ((k = 0):(k < MStack_Frame_Extent):(k)++) {
            print (MStack-->(((pos + 2) + k)));
            print " ";
        }
        print "^";
    }
];
[ MstVO id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        print "Variable unavailable for this action, activity or rulebook: ";
        print "internal ID number ";
        print id;
        print "/";
        print off;
        print "^";
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MstVON id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MStack_CreateRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Create_Frame(cr, rb);
    }
];
[ MStack_DestroyRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Destroy_Frame(cr, rb);
    }
];
[ MStack_CreateAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Create_Frame(cr, (av + 10000));
];
[ MStack_DestroyAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Destroy_Frame(cr, (av + 10000));
];
[ RecordRuleOutcome usage strong_kind val;
    if (((((latest_rule_result-->(0)) == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue((latest_rule_result-->(1)))))) {
        BlkValueFree((latest_rule_result-->(2)));
    }
    if ((((usage == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue(strong_kind)))) {
        (val = BlkValueCopy(BlkValueCreate(strong_kind), val));
    }
    ((latest_rule_result-->(0)) = usage);
    ((latest_rule_result-->(1)) = strong_kind);
    ((latest_rule_result-->(2)) = val);
];
[ FollowRulebook rulebook parameter no_paragraph_skips rv ss spv;
    (ss = self);
    if (((((Protect_I7_Arrays-->(0)) ~= 16339)) || (((Protect_I7_Arrays-->(1)) ~= 12345)))) {
        print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
        @quit;
    }
    if (parameter) {
        (self = parameter);
        (parameter_object = parameter);
    }
    (spv = parameter_value);
    (parameter_value = parameter);
    (parameter = debugging_rules);
    if (debugging_rules) {
        DebugRulebooks(rulebook, parameter);
        (process_rulebook_count = (process_rulebook_count + debugging_rules));
    }
    if ((((rulebook >= 0)) && ((rulebook < NUMBER_RULEBOOKS_CREATED)))) {
        (rv = (rulebooks_array-->(rulebook)));
        if ((rv ~= EMPTY_RULEBOOK)) {
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_CreateRBVars(rulebook);
            }
            if (say__p) {
                RulebookParBreak(no_paragraph_skips);
            }
            (rv = (rv)(no_paragraph_skips));
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_DestroyRBVars(rulebook);
            }
        } else {
            (rv = 0);
        }
    } else {
        if (say__p) {
            RulebookParBreak(no_paragraph_skips);
        }
        (rv = (rulebook)());
        if ((rv == 2)) {
            (rv = reason_the_action_failed);
        } else {
            if (rv) {
                (rv = rulebook);
            }
        }
    }
    if (rv) {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
            if ((process_rulebook_count < 0)) {
                (process_rulebook_count = 0);
            }
            spaces (2*process_rulebook_count);
            if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
                print "[stopped: success]^";
            }
            if (((latest_rule_result-->(0)) == RS_FAILS)) {
                print "[stopped: fail]^";
            }
        }
    } else {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
        }
        ((latest_rule_result-->(0)) = RS_NEITHER);
    }
    (debugging_rules = parameter);
    (self = ss);
    (parameter_value = spv);
    return rv;
];
[ RulebookParBreak no_paragraph_skips;
    if ((((no_paragraph_skips == 0)) && ((((say__pc)&(PARA_NORULEBOOKBREAKS)) == 0)))) {
        DivideParagraphPoint();
    }
];
[ ActRulebookSucceeds rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookSucceeds();
];
[ ActRulebookFails rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookFails();
];
[ RulebookSucceeds strong_kind value;
    RecordRuleOutcome(RS_SUCCEEDS, strong_kind, value);
];
[ RulebookFails strong_kind value;
    RecordRuleOutcome(RS_FAILS, strong_kind, value);
];
[ RuleHasNoOutcome;
    RecordRuleOutcome(RS_NEITHER, 0, 0);
];
[ SetRulebookOutcome a;
    ((latest_rule_result-->(0)) = a);
];
[ RulebookOutcome a;
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        return a;
    }
    return RS_NEITHER;
];
[ RulebookFailed;
    if (((latest_rule_result-->(0)) == RS_FAILS)) {
        rtrue;
    }
    rfalse;
];
[ RulebookSucceeded;
    if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ResultOfRule RB V F K a;
    if (RB) {
        FollowRulebook(RB, V, F);
    }
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        (a = (latest_rule_result-->(1)));
        if (a) {
            return (latest_rule_result-->(2));
        }
    }
    if (K) {
        return DefaultValueOfKOV(K);
    }
    rfalse;
];
[ RULEBOOK_TY_to_RULE_TY r;
    return r;
];
[ DebugRulebooks subs parameter i;
    spaces (2*process_rulebook_count);
    print "[";
    RulePrintingRule(subs);
    if (parameter) {
        print " / on O";
        print parameter;
    }
    print "]^";
];
[ DB_Rule R N blocked;
    if ((R == 0)) {
        rtrue;
    }
    print "[Rule ~";
    RulePrintingRule(R);
    print "~ ";
    if ((blocked == 0)) {
        print "applies.]";
        new_line;
        rtrue;
    }
    print "does not apply (wrong ";
    if ((blocked == 1)) {
        print "scene";
    }
    if ((blocked == 2)) {
        print "action";
    }
    if ((blocked == 3)) {
        print "actor";
    }
    if ((blocked == 4)) {
        print "context";
    }
    print ").]^";
];
[ LITTLE_USED_DO_NOTHING_R;
    rfalse;
];
[ EMPTY_RULEBOOK forbid_breaks;
    rfalse;
];
[ HeapInitialise n bsize blk2;
    (blk2 = (Flex_Heap + BLK_DATA_MULTI_OFFSET));
    ((Flex_Heap->(BLK_HEADER_N)) = 4);
    ((Flex_Heap-->(BLK_HEADER_KOV)) = 0);
    ((Flex_Heap-->(BLK_HEADER_RCOUNT)) = MAX_POSITIVE_NUMBER);
    ((Flex_Heap->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((Flex_Heap-->(BLK_NEXT)) = blk2);
    ((Flex_Heap-->(BLK_PREV)) = NULL);
    for ((bsize = 1):(bsize < MEMORY_HEAP_SIZE):(bsize = (bsize*2))) {
        (n)++;
    }
    ((blk2->(BLK_HEADER_N)) = n);
    ((blk2-->(BLK_HEADER_KOV)) = 0);
    ((blk2-->(BLK_HEADER_RCOUNT)) = 0);
    ((blk2->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((blk2-->(BLK_NEXT)) = NULL);
    ((blk2-->(BLK_PREV)) = Flex_Heap);
];
[ HeapNetFreeSpace multiple txb asize;
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = (asize + FlexSize(txb)));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
    }
    return asize;
];
[ HeapMakeSpace size multiple newblocksize newblock B n hsize;
    for (:1:) {
        if (multiple) {
            (hsize = BLK_DATA_MULTI_OFFSET);
            if ((HeapNetFreeSpace(multiple) >= size)) {
                rtrue;
            }
        } else {
            (hsize = BLK_DATA_OFFSET);
            if ((HeapLargestFreeBlock(0) >= size)) {
                rtrue;
            }
        }
        (newblocksize = 1);
        for ((n = 0):(((n < SMALLEST_BLK_WORTH_ALLOCATING)) || ((newblocksize < (size + hsize)))):(n)++) {
            (newblocksize = (newblocksize*2));
        }
        (newblock = VM_AllocateMemory(newblocksize));
        if ((newblock == 0)) {
            rfalse;
        }
        ((newblock->(BLK_HEADER_N)) = n);
        ((newblock-->(BLK_HEADER_KOV)) = 0);
        ((newblock-->(BLK_HEADER_RCOUNT)) = 0);
        ((newblock->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((newblock-->(BLK_NEXT)) = NULL);
        ((newblock-->(BLK_PREV)) = NULL);
        for ((B = (Flex_Heap-->(BLK_NEXT))):(B ~= NULL):(B = (B-->(BLK_NEXT)))) {
            if (((B-->(BLK_NEXT)) == NULL)) {
                ((B-->(BLK_NEXT)) = newblock);
                ((newblock-->(BLK_PREV)) = B);
                jump Linked;
            }
        }
        ((Flex_Heap-->(BLK_NEXT)) = newblock);
        ((newblock-->(BLK_PREV)) = Flex_Heap);
        .Linked;
    }
    rtrue;
];
[ HeapLargestFreeBlock multiple txb asize best;
    (best = 0);
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = FlexSize(txb));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
        if ((asize > best)) {
            (best = asize);
        }
    }
    return best;
];
[ HeapDebug full;
    if (full) {
        print "Managing a heap of initially ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes.^";
        print HeapNetFreeSpace(0);
        print " bytes currently free.^";
        print "Free space decomposition: ";
        FlexDebugDecomposition(Flex_Heap);
        print "Free space map: ";
        FlexDebug(Flex_Heap);
    } else {
        print HeapNetFreeSpace(0);
        print " of ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes free.^";
    }
];
[ FlexAllocate size kov flags dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
    if ((HeapMakeSpace(size, ((flags)&(BLK_FLAG_MULTIPLE))) == 0)) {
        FlexError("ran out");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (hsize = BLK_DATA_MULTI_OFFSET);
    } else {
        (hsize = BLK_DATA_OFFSET);
    }
    (n = 0);
    for ((dsize = 1):(((dsize < (hsize + size))) || ((n < (3 + (WORDSIZE/2))))):(dsize = (dsize*2))) {
        (n)++;
    }
    (min_m = 10000);
    (max_m = 0);
    for ((free_block = (Flex_Heap-->(BLK_NEXT))):(free_block ~= NULL):(free_block = (free_block-->(BLK_NEXT)))) {
        (m = (free_block->(BLK_HEADER_N)));
        if ((m == n)) {
            jump CorrectSizeFound;
        }
        if ((m > n)) {
            if ((min_m > m)) {
                (min_m = m);
                (smallest_oversized_block = free_block);
            }
        }
        if ((m < n)) {
            if ((max_m < m)) {
                (max_m = m);
            }
        }
    }
    if ((min_m == 10000)) {
        if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
            FlexError("too fragmented");
        }
        for ((dsize = 1):(max_m > 0):(dsize = (dsize*2))) {
            (max_m)--;
        }
        (head = FlexAllocate((dsize - hsize), kov, flags));
        if ((head == 0)) {
            FlexError("for head block not available");
        }
        (tail = FlexAllocate((size - (dsize - hsize)), kov, flags));
        if ((tail == 0)) {
            FlexError("for tail block not available");
        }
        ((head-->(BLK_NEXT)) = tail);
        ((tail-->(BLK_PREV)) = head);
        return head;
    }
    for (((dsize = 1),(m = 1)):(m <= min_m):(dsize = (dsize*2))) {
        (m)++;
    }
    (free_block = smallest_oversized_block);
    while ((min_m > n)) {
        (dsize = (dsize/2));
        (secondhalf = (free_block + dsize));
        ((secondhalf-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        if (((secondhalf-->(BLK_NEXT)) ~= NULL)) {
            (((secondhalf-->(BLK_NEXT))-->(BLK_PREV)) = secondhalf);
        }
        ((secondhalf-->(BLK_PREV)) = free_block);
        ((free_block-->(BLK_NEXT)) = secondhalf);
        ((free_block->(BLK_HEADER_N)) = ((free_block->(BLK_HEADER_N)) - 1));
        ((secondhalf->(BLK_HEADER_N)) = (free_block->(BLK_HEADER_N)));
        ((secondhalf-->(BLK_HEADER_KOV)) = (free_block-->(BLK_HEADER_KOV)));
        ((secondhalf-->(BLK_HEADER_RCOUNT)) = 0);
        ((secondhalf->(BLK_HEADER_FLAGS)) = (free_block->(BLK_HEADER_FLAGS)));
        (min_m)--;
    }
    .CorrectSizeFound;
    if (((free_block-->(BLK_NEXT)) == NULL)) {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
    } else {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        (((free_block-->(BLK_NEXT))-->(BLK_PREV)) = (free_block-->(BLK_PREV)));
    }
    ((free_block-->(BLK_HEADER_KOV)) = KindAtomic(kov));
    ((free_block-->(BLK_HEADER_RCOUNT)) = 1);
    ((free_block->(BLK_HEADER_FLAGS)) = flags);
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        ((free_block-->(BLK_NEXT)) = NULL);
        ((free_block-->(BLK_PREV)) = NULL);
    }
    for ((i = hsize):(i < dsize):(i)++) {
        ((free_block->(i)) = 0);
    }
    return free_block;
];
[ FlexError reason;
    print "*** Memory ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ FlexMergeInternal block first last pv nx;
    (first = block);
    (last = block);
    while (((last-->(BLK_NEXT)) == (last + FlexSize(last)))) {
        (last = (last-->(BLK_NEXT)));
    }
    while ((((((first-->(BLK_PREV)) + FlexSize((first-->(BLK_PREV)))) == first)) && (((first-->(BLK_PREV)) ~= Flex_Heap)))) {
        (first = (first-->(BLK_PREV)));
    }
    (pv = (first-->(BLK_PREV)));
    (nx = (last-->(BLK_NEXT)));
    if (FlexRecutInternal(first, last)) {
    }
];
[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
    if ((first == last)) {
        rfalse;
    }
    (mfrom = first);
    (mto = (last + FlexSize(last)));
    (bnext = (last-->(BLK_NEXT)));
    (fine_so_far = 1);
    for (:(mto > mfrom):(mto = (mto - backsize))) {
        for (((n = 0),(backsize = 1)):((backsize*2) <= (mto - mfrom)):(n)++) {
            (backsize = (backsize*2));
        }
        if (((fine_so_far) && ((backsize == FlexSize(last))))) {
            (bnext = last);
            (last = (last-->(BLK_PREV)));
            ((bnext-->(BLK_PREV)) = last);
            ((last-->(BLK_NEXT)) = bnext);
            continue;
        }
        (fine_so_far = 0);
        (backend = (mto - backsize));
        ((backend->(BLK_HEADER_N)) = n);
        ((backend-->(BLK_HEADER_KOV)) = 0);
        ((backend-->(BLK_HEADER_RCOUNT)) = 0);
        ((backend->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((backend-->(BLK_NEXT)) = bnext);
        if ((bnext ~= NULL)) {
            ((bnext-->(BLK_PREV)) = backend);
            (bnext = backend);
        }
    }
    if (fine_so_far) {
        rfalse;
    }
    rtrue;
];
[ FlexFree block fromtxb ptxb;
    if ((block == 0)) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_RESIDENT))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_N)))&(128))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE))) {
        if (((block-->(BLK_PREV)) ~= NULL)) {
            (((block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
        }
        (fromtxb = block);
        for (:((block-->(BLK_NEXT)) ~= NULL):(block = (block-->(BLK_NEXT)))) {
        }
        while ((block ~= fromtxb)) {
            (ptxb = (block-->(BLK_PREV)));
            FlexFreeSingleBlockInternal(block);
            (block = ptxb);
        }
    }
    FlexFreeSingleBlockInternal(block);
];
[ FlexFreeSingleBlockInternal block free nx;
    ((block-->(BLK_HEADER_KOV)) = 0);
    ((block-->(BLK_HEADER_RCOUNT)) = 0);
    ((block->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    for ((free = Flex_Heap):(free ~= NULL):(free = (free-->(BLK_NEXT)))) {
        (nx = (free-->(BLK_NEXT)));
        if ((nx == NULL)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = NULL);
            FlexMergeInternal(block);
            rtrue;
        }
        if ((UnsignedCompare(nx, block) == 1)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = nx);
            ((nx-->(BLK_PREV)) = block);
            FlexMergeInternal(block);
            rtrue;
        }
    }
];
[ FlexResize block req newsize dsize newblk kov n i otxb flags;
    if ((block == 0)) {
        FlexError("failed resizing null block");
    }
    (kov = (block-->(BLK_HEADER_KOV)));
    (flags = (block->(BLK_HEADER_FLAGS)));
    if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
        FlexError("failed resizing inextensible block");
    }
    (otxb = block);
    (newsize = req);
    for (:1:(block = (block-->(BLK_NEXT)))) {
        (n = (block->(BLK_HEADER_N)));
        for ((dsize = 1):(n > 0):(n)--) {
            (dsize = (dsize*2));
        }
        (i = (dsize - BLK_DATA_MULTI_OFFSET));
        (newsize = (newsize - i));
        if ((newsize > 0)) {
            if (((block-->(BLK_NEXT)) ~= NULL)) {
                continue;
            }
            (newblk = FlexAllocate(newsize, kov, flags));
            if ((newblk == 0)) {
                rfalse;
            }
            ((block-->(BLK_NEXT)) = newblk);
            ((newblk-->(BLK_PREV)) = block);
            rtrue;
        }
        if (((block-->(BLK_NEXT)) ~= NULL)) {
            FlexFree((block-->(BLK_NEXT)));
            ((block-->(BLK_NEXT)) = NULL);
        }
        rtrue;
    }
];
[ FlexSize txb bsize n m;
    if ((txb == 0)) {
        rfalse;
    }
    (m = (txb->(BLK_HEADER_N)));
    for ((bsize = 1):(n < m):(bsize = (bsize*2))) {
        (n)++;
    }
    return bsize;
];
[ FlexTotalSize txb size_in_bytes;
    if ((txb == 0)) {
        rfalse;
    }
    if (((((txb->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE)) == 0)) {
        return (FlexSize(txb) - BLK_DATA_OFFSET);
    }
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (size_in_bytes = ((size_in_bytes + FlexSize(txb)) - BLK_DATA_MULTI_OFFSET));
    }
    return size_in_bytes;
];
[ FlexDebug txb n k i bsize tot dtot kov;
    if ((txb == 0)) {
        print "Block never created.";
        new_line;
        rtrue;
    }
    (kov = (txb-->(BLK_HEADER_KOV)));
    print "Block ";
    print txb;
    print " (kov ";
    print kov;
    print "): ";
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        if (((k)++ == 100)) {
            print " ... and so on.";
            new_line;
            rtrue;
        }
        if (((txb-->(BLK_HEADER_KOV)) ~= kov)) {
            print "*Wrong kov=";
            print (txb-->(BLK_HEADER_KOV));
            print "* ";
        }
        (n = (txb->(BLK_HEADER_N)));
        for ((bsize = 1):(n > 0):(n)--) {
            (bsize = (bsize*2));
        }
        (i = (bsize - BLK_DATA_OFFSET));
        (dtot = (dtot + i));
        (tot = (tot + bsize));
        print txb;
        print "(";
        print bsize;
        print ") > ";
    }
    print dtot;
    print " data in ";
    print tot;
    print " bytes^";
];
[ FlexDebugDecomposition from to txb pf;
    if ((to == 0)) {
        (to = NULL);
    }
    for ((txb = from):(((txb ~= to)) && ((txb ~= NULL))):(txb = (txb-->(BLK_NEXT)))) {
        if (pf) {
            print "+";
        }
        print FlexSize(txb);
        (pf = 1);
    }
    print "^";
];
[ BlkValueGetLongBlock bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv + WORDSIZE);
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_LONGBLOCK))) {
                return (bv-->(1));
            }
            rfalse;
        }
        return o;
    }
    return bv;
];
[ BlkValueWeakKind bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv-->((BLK_HEADER_KOV + 1)));
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_TEXT))) {
                return TEXT_TY;
            }
            (o = (bv-->(1)));
        }
        return (o-->(BLK_HEADER_KOV));
    }
    return NIL_TY;
];
[ BlkValueGetRefCountPrimitive bv long_block;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        return (long_block-->(BLK_HEADER_RCOUNT));
    }
    return RC_INFINITY;
];
[ BlkValueIncRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            ((long_block-->(BLK_HEADER_RCOUNT)) = (refc + 1));
        }
    }
];
[ BlkValueDecRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            (refc)--;
            if ((refc < 0)) {
                BlkValueError("reference count negative");
            }
            ((long_block-->(BLK_HEADER_RCOUNT)) = refc);
        }
        return refc;
    }
    return RC_INFINITY;
];
[ BlkValueLBCapacity bv long_block array_size_in_bytes entry_size_in_bytes flags;
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (array_size_in_bytes = FlexTotalSize(long_block));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    return (array_size_in_bytes/entry_size_in_bytes);
];
[ BlkValueSetLBCapacity bv new_capacity long_block flags entry_size_in_bytes;
    if ((bv == 0)) {
        rfalse;
    }
    BlkMakeMutable(bv);
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    FlexResize(long_block, (new_capacity*entry_size_in_bytes));
    rtrue;
];
[ BlkValueRead from pos do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((from == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = from);
    } else {
        (long_block = BlkValueGetLongBlock(from));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    return (long_block->(0));
                    ;
                2:
                    return (((long_block->(0))*256) + (long_block->(1)));
                    ;
                4:
                    return (long_block-->(0));
                    ;
            }
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueRead: reading from index out of range: ";
    print pos;
    print " in ";
    print from;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueWrite to pos val do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((to == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = to);
    } else {
        BlkMakeMutable(to);
        (long_block = BlkValueGetLongBlock(to));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    ((long_block->(0)) = val);
                    ;
                2:
                    ((long_block->(0)) = ((val/256)%256));
                    ((long_block->(1)) = (val%256));
                    ;
                4:
                    ((long_block-->(0)) = val);
                    ;
            }
            rtrue;
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueWrite: writing to index out of range: ";
    print pos;
    print " in ";
    print to;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueSeekZeroEntry from long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes byte_position addr from_addr to_addr;
    if ((from == 0)) {
        return (-(1));
    }
    (long_block = BlkValueGetLongBlock(from));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (byte_position = 0);
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        (from_addr = (long_block + header_size_in_bytes));
        (to_addr = (from_addr + chunk_size_in_bytes));
        switch (entry_size_in_bytes) {
            1:
                for ((addr = from_addr):(addr < to_addr):(addr)++) {
                    if (((addr->(0)) == 0)) {
                        return ((byte_position + addr) - from_addr);
                    }
                }
                ;
            2:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 2))) {
                    if (((((addr->(0)) == 0)) && (((addr->(1)) == 0)))) {
                        return (((byte_position + addr) - from_addr)/2);
                    }
                }
                ;
            4:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 4))) {
                    if (((addr-->(0)) == 0)) {
                        return (((byte_position + addr) - from_addr)/4);
                    }
                }
                ;
        }
        (byte_position = (byte_position + chunk_size_in_bytes));
    }
    return (-(1));
];
[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy from_long_block from_addr from_bytes_left from_header_size_in_bytes to_long_block to_addr to_bytes_left to_header_size_in_bytes bytes_to_copy flags entry_size_in_bytes min;
    BlkMakeMutable(to_bv);
    (from_long_block = BlkValueGetLongBlock(from_bv));
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (from_long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (from_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (from_addr = (from_long_block + from_header_size_in_bytes));
    (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
    (to_addr = (to_long_block + to_header_size_in_bytes));
    (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
    (bytes_to_copy = (entry_size_in_bytes*no_entries_to_copy));
    while (1) {
        if ((from_bytes_left == 0)) {
            (from_long_block = (from_long_block-->(BLK_NEXT)));
            if ((from_long_block == 0)) {
                BlkValueError("copy destination exhausted");
            }
            (from_addr = (from_long_block + from_header_size_in_bytes));
            (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
        } else {
            if ((to_bytes_left == 0)) {
                (to_long_block = (to_long_block-->(BLK_NEXT)));
                if ((to_long_block == 0)) {
                    BlkValueError("copy source exhausted");
                }
                (to_addr = (to_long_block + to_header_size_in_bytes));
                (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
            } else {
                (min = from_bytes_left);
                if ((to_bytes_left < min)) {
                    (min = to_bytes_left);
                }
                if ((bytes_to_copy <= min)) {
                    Memcpy(to_addr, from_addr, bytes_to_copy);
                    rtrue;
                }
                Memcpy(to_addr, from_addr, min);
                (bytes_to_copy = (bytes_to_copy - min));
                (from_addr = (from_addr + min));
                (from_bytes_left = (from_bytes_left - min));
                (to_addr = (to_addr + min));
                (to_bytes_left = (to_bytes_left - min));
            }
        }
    }
];
[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy to_long_block to_addr to_entries_left to_header_size to_entry_size flags;
    BlkMakeMutable(to_bv);
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    (to_entry_size = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (to_entry_size = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (to_entry_size = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size = BLK_DATA_OFFSET);
    }
    (to_addr = (to_long_block + to_header_size));
    (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    while ((no_entries_to_copy > to_entries_left)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
        (no_entries_to_copy = (no_entries_to_copy - to_entries_left));
        (from_array = (from_array + (to_entries_left*from_entry_size)));
        (to_long_block = (to_long_block-->(BLK_NEXT)));
        if ((to_long_block == 0)) {
            BlkValueError("copy source exhausted");
        }
        (to_addr = (to_long_block + to_header_size));
        (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    }
    if ((no_entries_to_copy > 0)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
    }
];
[ BlkValueCreate strong_kind short_block kovs;
    (kovs = KOVSupportFunction(strong_kind, "impossible allocation"));
    (short_block = (kovs)(CREATE_KOVS,strong_kind,short_block));
    return short_block;
];
[ BlkValueError reason;
    print "*** Value handling failed: ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ BlkValueCreateSB1 short_block val;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val);
    return short_block;
];
[ BlkValueCreateSB2 short_block val1 val2;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate((2*WORDSIZE), 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val1);
    ((short_block-->(1)) = val2);
    return short_block;
];
[ StackFramingInitialise;
    (I7SFRAME = (blockv_stack + (WORDSIZE*BLOCKV_STACK_SIZE)));
];
[ StackFrameCreate size new;
    (new = (I7SFRAME - (WORDSIZE*size)));
    if ((new < blockv_stack)) {
        RunTimeProblem(RTP_HEAPERROR);
        @quit;
    }
    (I7SFRAME = new);
];
[ BlkValueCreateOnStack offset strong_kind;
    BlkValueCreate(strong_kind, (I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFreeOnStack offset;
    BlkValueFree((I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFree bv kovs d;
    if ((bv == 0)) {
        rtrue;
    }
    (kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation"));
    BlkValueDestroyPrimitive(bv, kovs);
    (d = (bv - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        FlexFree((bv - BLK_DATA_OFFSET));
    }
];
[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
    BlkValueDestroyPrimitive(to_bv, kovs);
    (kovs)(COPYSB_KOVS,to_bv,from_bv);
    BlkValueIncRefCountPrimitive(from_bv);
];
[ BlkValueCopySB1 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    if (((to_bv-->(0)) == 0)) {
        ((to_bv-->(0)) = (from_bv + WORDSIZE));
    }
];
[ BlkValueCopySB2 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    ((to_bv-->(1)) = (from_bv-->(1)));
    if (((to_bv-->(1)) == 0)) {
        ((to_bv-->(1)) = (from_bv + (2*WORDSIZE)));
    }
];
[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling k from_long_block no_entries_to_copy;
    (k = (kovs)(KINDDATA_KOVS,to_bv,from_bv));
    (from_long_block = BlkValueGetLongBlock(from_bv));
    if (from_long_block) {
        if (recycling) {
            BlkValueRecyclePrimitive(to_bv, kovs);
        }
        (no_entries_to_copy = (kovs)(EXTENT_KOVS,from_bv));
        if ((no_entries_to_copy == -1)) {
            (no_entries_to_copy = BlkValueLBCapacity(from_bv));
        }
        BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
    }
    (kovs)(COPY_KOVS,to_bv,from_bv,k);
];
[ BlkValueCopy to_bv from_bv to_kind from_kind kovs;
    if ((to_bv == 0)) {
        BlkValueError("copy to null value");
    }
    if ((from_bv == 0)) {
        BlkValueError("copy from null value");
    }
    if ((to_bv == from_bv)) {
        rtrue;
    }
    (to_kind = BlkValueWeakKind(to_bv));
    (from_kind = BlkValueWeakKind(from_bv));
    if ((to_kind ~= from_kind)) {
        BlkValueError("copy incompatible kinds");
    }
    (kovs = KOVSupportFunction(to_kind, "impossible copy"));
    if ((kovs)(COPYQUICK_KOVS,to_bv,from_bv)) {
        BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
    } else {
        BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, 1);
    }
    return to_bv;
];
[ BlkValueCopyAZ to_bv from_bv;
    if (from_bv) {
        return BlkValueCopy(to_bv, from_bv);
    }
    return to_bv;
];
[ BlkValueDestroyPrimitive bv kovs long_block;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            FlexFree(long_block);
        }
    }
];
[ BlkValueRecyclePrimitive bv kovs;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        BlkValueIncRefCountPrimitive(bv);
    } else {
        BlkValueCreate(BlkValueWeakKind(bv), bv);
    }
];
[ BlkMakeMutable bv block bv_kind kovs sb_size;
    if ((bv == 0)) {
        BlkValueError("tried to make null block mutable");
    }
    if ((BlkValueGetRefCountPrimitive(bv) > 1)) {
        BlkValueDecRefCountPrimitive(bv);
        (bv_kind = BlkValueWeakKind(bv));
        (kovs = KOVSupportFunction(bv_kind, "impossible mutability"));
        (sb_size = (kovs)(MAKEMUTABLE_KOVS,bv));
        if ((sb_size > 0)) {
            @push I7SFRAME;
            StackFrameCreate(sb_size);
            BlkValueCreateOnStack(0, bv_kind);
            (kovs)(COPYKIND_KOVS,I7SFRAME,bv);
            BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, 0);
            (kovs)(COPYSB_KOVS,bv,I7SFRAME);
            @pull I7SFRAME;
        }
    }
];
[ BlkValueCast to_bv original_kind original_value kovs;
    (kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast"));
    (kovs)(CAST_KOVS,to_bv,original_kind,original_value);
    return to_bv;
];
[ BlkValueCompare bv_left bv_right kind_left kind_right kovs;
    if ((((bv_left == 0)) && ((bv_right == 0)))) {
        rfalse;
    }
    if ((bv_left == 0)) {
        rtrue;
    }
    if ((bv_right == 0)) {
        return (-(1));
    }
    (kind_left = BlkValueWeakKind(bv_left));
    (kind_right = BlkValueWeakKind(bv_right));
    if ((kind_left ~= kind_right)) {
        return (kind_left - kind_right);
    }
    (kovs = KOVSupportFunction(kind_left, "impossible comparison"));
    return (kovs)(COMPARE_KOVS,bv_left,bv_right);
];
[ GetHashValue kind value;
    if (KOVIsBlockValue(kind)) {
        return BlkValueHash(value);
    }
    return value;
];
[ BlkValueHash bv bv_kind kovs;
    if ((bv == 0)) {
        rfalse;
    }
    (bv_kind = BlkValueWeakKind(bv));
    (kovs = KOVSupportFunction(bv_kind, "impossible hashing"));
    return (kovs)(HASH_KOVS,bv);
];
[ BlkValueReadFromFile bv auxf ch bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(READ_FILE_KOVS,bv,auxf,ch);
    }
    rfalse;
];
[ BlkValueWriteToFile bv bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(WRITE_FILE_KOVS,bv);
    }
    rfalse;
];
[ BlkValueDebug bv flag refc long_block kovs;
    print "(BV";
    if (bv) {
        BlkDebugAddress(bv, flag);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            if (((bv-->(0)) == 0)) {
                print "...";
            } else {
                print "-->";
            }
            print "L";
            BlkDebugAddress(long_block, flag);
            print " 2**";
            print (long_block->(BLK_HEADER_N));
            (refc = BlkValueGetRefCountPrimitive(bv));
            if ((refc == RC_INFINITY)) {
                print " resident";
            } else {
                print " ";
                print refc;
                print " ref";
                if ((refc ~= 1)) {
                    print "s";
                }
            }
        }
        (kovs = KOVSupportFunction(BlkValueWeakKind(bv)));
        if (kovs) {
            (kovs)(DEBUG_KOVS,bv);
        }
    }
    print ")";
];
[ BlkDebugAddress addr flag d;
    if (flag) {
        print "###";
        rtrue;
    }
    (d = (addr - blockv_stack));
    if ((((d >= 0)) && ((d <= (WORDSIZE*BLOCKV_STACK_SIZE))))) {
        print "s+";
        BlkPrintHexadecimal(d);
        (d = (addr - I7SFRAME));
        print "=f";
        if ((d >= 0)) {
            print "+";
        }
        print d;
        rtrue;
    }
    (d = (addr - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        print "h+";
        BlkPrintHexadecimal(d);
        rtrue;
    }
    BlkPrintHexadecimal(addr);
];
[ BlkPrintHexadecimal v;
    if (((v)&(-65536))) {
        if (((v)&(-16777216))) {
            BlkPrintHexDigit((v/268435456));
            BlkPrintHexDigit((v/16777216));
        }
        BlkPrintHexDigit((v/1048576));
        BlkPrintHexDigit((v/65536));
    }
    BlkPrintHexDigit((v/4096));
    BlkPrintHexDigit((v/256));
    BlkPrintHexDigit((v/16));
    BlkPrintHexDigit(v);
];
[ BlkPrintHexDigit v;
    (v = ((v)&(15)));
    if ((v < 10)) {
        print v;
    } else {
        print (char) ((65 + v) - 10);
    }
];
[ TEXT_TY_Extent arg1 x;
    (x = BlkValueSeekZeroEntry(arg1));
    if ((x < 0)) {
        return (-(1));
    }
    return (x + 1);
];
[ TEXT_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return TEXT_TY_Create(arg2);
            ;
        CAST_KOVS:
            TEXT_TY_Cast(arg1, arg2, arg3);
            ;
        MAKEMUTABLE_KOVS:
            return TEXT_TY_Mutable(arg1);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            TEXT_TY_CopySB(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return TEXT_TY_Extent(arg1);
            ;
        COMPARE_KOVS:
            return TEXT_TY_Compare(arg1, arg2);
            ;
        READ_FILE_KOVS:
            if ((arg3 == -1)) {
                rtrue;
            }
            return TEXT_TY_ReadFile(arg1, arg2, arg3);
            ;
        WRITE_FILE_KOVS:
            return TEXT_TY_WriteFile(arg1);
            ;
        HASH_KOVS:
            return TEXT_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            TEXT_TY_Debug(arg1);
            ;
    }
    rfalse;
];
[ TEXT_TY_Debug txt;
    switch ((txt-->(0))) {
        CONSTANT_PACKED_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        CONSTANT_PERISHABLE_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        PACKED_TEXT_STORAGE:
            print " = p~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        UNPACKED_TEXT_STORAGE:
            print " = ~";
            TEXT_TY_Say(txt);
            print "~";
            ;
        default:
            print " broken?";
            ;
    }
];
[ TEXT_TY_Create short_block x;
    return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];
[ TEXT_TY_CopySB to_bv from_bv;
    BlkValueCopySB2(to_bv, from_bv);
    if ((((to_bv-->(0)))&(BLK_BVBITMAP_CONSTANTMASK))) {
        ((to_bv-->(0)) = PACKED_TEXT_STORAGE);
    }
];
[ TEXT_TY_Transmute txt;
    TEXT_TY_Temporarily_Transmute(txt);
];
[ TEXT_TY_Temporarily_Transmute txt x;
    if (((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) {
        (x = (txt-->(1)));
        ((txt-->(0)) = UNPACKED_TEXT_STORAGE);
        ((txt-->(1)) = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags));
        if ((x ~= EMPTY_TEXT_PACKED)) {
            TEXT_TY_CastPrimitive(txt, 0, x);
        }
        return x;
    }
    rfalse;
];
[ TEXT_TY_Untransmute txt pk cp x;
    if (((pk) && (((txt-->(0)) == UNPACKED_TEXT_STORAGE)))) {
        (x = (txt-->(1)));
        FlexFree(x);
        ((txt-->(0)) = cp);
        ((txt-->(1)) = pk);
    }
    return txt;
];
[ TEXT_TY_Mutable txt;
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        TEXT_TY_Transmute(txt);
        rfalse;
    }
    return 2;
];
[ TEXT_TY_Cast to_txt from_kind from_value;
    if ((from_kind == TEXT_TY)) {
        BlkValueCopy(to_txt, from_value);
    } else {
        if ((from_kind == SNIPPET_TY)) {
            TEXT_TY_Transmute(to_txt);
            TEXT_TY_CastPrimitive(to_txt, 1, from_value);
        } else {
            BlkValueError("impossible cast to text");
        }
    }
];
[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
    return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value len i stream saved_stream news buffer buffer_size memory_to_free results;
    if ((to_txt == 0)) {
        BlkValueError("no destination for cast");
    }
    (buffer_size = ((TEXT_TY_BufferSize + 2)*WORDSIZE));
    (RawBufferSize = TEXT_TY_BufferSize);
    (buffer = (RawBufferAddress + (TEXT_TY_CastPrimitiveNesting*buffer_size)));
    (TEXT_TY_CastPrimitiveNesting)++;
    if ((TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)) {
        (buffer = VM_AllocateMemory(buffer_size));
        (memory_to_free = buffer);
        if ((buffer == 0)) {
            FlexError("ran out with too many simultaneous text conversions");
        }
    }
    if (unicode_gestalt_ok) {
        SuspendRTP();
        .RetryWithLargerBuffer;
        (saved_stream = glk_stream_get_current());
        (stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0));
        glk_stream_set_current(stream);
        @push say__p;
        @push say__pc;
        ClearParagraphing(7);
        if (from_snippet) {
            PrintSnippet(from_value);
        } else {
            PrintI6Text(from_value);
        }
        @pull say__pc;
        @pull say__p;
        (results = ((buffer + buffer_size) - (2*WORDSIZE)));
        glk_stream_close(stream, results);
        if (saved_stream) {
            glk_stream_set_current(saved_stream);
        }
        ResumeRTP();
        (len = (results-->(1)));
        if ((len > (RawBufferSize - 1))) {
            (news = RawBufferSize);
            while ((news < len)) {
                (news = (news*2));
            }
            (i = VM_AllocateMemory((news*WORDSIZE)));
            if ((i ~= 0)) {
                if (memory_to_free) {
                    VM_FreeMemory(memory_to_free);
                }
                (memory_to_free = i);
                (buffer = i);
                (RawBufferSize = news);
                (buffer_size = ((RawBufferSize + 2)*WORDSIZE));
                jump RetryWithLargerBuffer;
            }
            (len = (RawBufferSize - 1));
        }
        ((buffer-->(len)) = 0);
        (TEXT_TY_CastPrimitiveNesting)--;
        BlkValueMassCopyFromArray(to_txt, buffer, 4, (len + 1));
    } else {
        RunTimeProblem(RTP_NOGLULXUNICODE);
    }
    if (memory_to_free) {
        VM_FreeMemory(memory_to_free);
    }
];
[ TEXT_TY_Compare left_txt right_txt rv;
    @push say__comp;
    (say__comp = 1);
    (rv = TEXT_TY_Compare_Inner(left_txt, right_txt));
    @pull say__comp;
    return rv;
];
[ TEXT_TY_Compare_Inner left_txt right_txt pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
    if (((((left_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fl = 1);
    }
    if (((((right_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fr = 1);
    }
    if (((fl) && (fr))) {
        if (((((left_txt-->(1)) ofclass String)) && (((right_txt-->(1)) ofclass String)))) {
            return ((left_txt-->(1)) - (right_txt-->(1)));
        }
        if (((((left_txt-->(1)) ofclass Routine)) && (((right_txt-->(1)) ofclass Routine)))) {
            if (((left_txt-->(1)) == (right_txt-->(1)))) {
                rfalse;
            }
        }
        (cpl = (left_txt-->(0)));
        (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        (cpr = (right_txt-->(0)));
        (cr = TEXT_TY_Temporarily_Transmute(right_txt));
    } else {
        if (fl) {
            (cpl = (left_txt-->(0)));
            (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        } else {
            if (fr) {
                (cpr = (right_txt-->(0)));
                (cr = TEXT_TY_Temporarily_Transmute(right_txt));
            }
        }
    }
    if (((cl) || (cr))) {
        (pos = TEXT_TY_Compare(left_txt, right_txt));
        TEXT_TY_Untransmute(left_txt, cl, cpl);
        TEXT_TY_Untransmute(right_txt, cr, cpr);
        return pos;
    }
    (capacity_left = BlkValueLBCapacity(left_txt));
    (capacity_right = BlkValueLBCapacity(right_txt));
    for ((pos = 0):(((pos < capacity_left)) && ((pos < capacity_right))):(pos)++) {
        (ch1 = BlkValueRead(left_txt, pos));
        (ch2 = BlkValueRead(right_txt, pos));
        if ((ch1 ~= ch2)) {
            return (ch1 - ch2);
        }
        if ((ch1 == 0)) {
            rfalse;
        }
    }
    if ((pos == capacity_left)) {
        return (-(1));
    }
    rtrue;
];
[ TEXT_TY_Distinguish left_txt right_txt;
    if ((TEXT_TY_Compare(left_txt, right_txt) == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Hash txt rv len i p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (rv = 0);
    (len = BlkValueLBCapacity(txt));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + BlkValueRead(txt, i)));
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return rv;
];
[ TEXT_TY_Say txt ch i dsize;
    if ((txt == 0)) {
        rfalse;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        return PrintI6Text((txt-->(1)));
    }
    (dsize = BlkValueLBCapacity(txt));
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        @streamunichar ch;
    }
    if ((i == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Say_Capitalised txt mod rc;
    (mod = BlkValueCreate(TEXT_TY));
    TEXT_TY_SubstitutedForm(mod, txt);
    if ((TEXT_TY_CharacterLength(mod) > 0)) {
        BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
        TEXT_TY_Say(mod);
        (rc = 1);
        (say__p = 1);
    }
    BlkValueFree(mod);
    return rc;
];
[ TEXT_TY_WriteFile txt len pos ch p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = BlkValueLBCapacity(txt));
    print "S";
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 0)) {
            print "0;";
            break;
        } else {
            print ch;
            print ",";
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
];
[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
    TEXT_TY_Transmute(txt);
    (tsize = BlkValueLBCapacity(txt));
    while ((ch ~= 32 or 9 or 10 or 13 or 0 or -1)) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 44 or 59)) {
            if (((pos + 1) >= tsize)) {
                if ((BlkValueSetLBCapacity(txt, (2*pos)) == 0)) {
                    break;
                }
                (tsize = BlkValueLBCapacity(txt));
            }
            BlkValueWrite(txt, (pos)++, v);
            (v = 0);
            if ((ch == 59)) {
                break;
            }
        } else {
            (dg = (ch - 48));
            (v = ((v*10) + dg));
        }
    }
    BlkValueWrite(txt, pos, 0);
    return txt;
];
[ TEXT_TY_SubstitutedForm to txt;
    if (txt) {
        BlkValueCopy(to, txt);
        TEXT_TY_Transmute(to);
    }
    return to;
];
[ TEXT_TY_IsSubstituted txt;
    if (((((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) && (((txt-->(1)) ofclass Routine)))) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_ExpandIfPerishable to from;
    if (((from) && (((from-->(0)) == CONSTANT_PERISHABLE_TEXT_STORAGE)))) {
        return TEXT_TY_SubstitutedForm(to, from);
    }
    return from;
];
[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt p1 p2 cp1 cp2 r;
    if ((txt == 0)) {
        rfalse;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_CharacterLength(txt);
    }
    (cp1 = (txt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(txt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    TEXT_TY_Transmute(ctxt);
    if (ctxt) {
        BlkMakeMutable(ctxt);
    }
    (r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt));
    TEXT_TY_Untransmute(txt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt brm oldbrm ch i dsize blobcount gp cl j;
    (dsize = BlkValueLBCapacity(txt));
    if (((rtxt) && ((ctxt == 0)))) {
        print "*** rtxt without ctxt ***";
        new_line;
        rtrue;
    }
    (brm = WS_BRM);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        (oldbrm = brm);
        if ((ch == 10 or 13 or 32 or 9)) {
            if ((oldbrm ~= WS_BRM)) {
                (gp = 0);
                for ((j = i):(j < dsize):(j)++) {
                    (ch = BlkValueRead(txt, j));
                    if ((ch == 0)) {
                        (brm = WS_BRM);
                        break;
                    }
                    if ((ch == 10 or 13)) {
                        (gp)++;
                        continue;
                    }
                    if ((ch ~= 32 or 9)) {
                        break;
                    }
                }
                (ch = BlkValueRead(txt, i));
                if ((j == dsize)) {
                    (brm = WS_BRM);
                }
                switch (blobtype) {
                    PARA_BLOB:
                        if ((gp >= 2)) {
                            (brm = WS_BRM);
                        }
                        ;
                    LINE_BLOB:
                        if ((gp >= 1)) {
                            (brm = WS_BRM);
                        }
                        ;
                    default:
                        (brm = WS_BRM);
                        ;
                }
            }
        } else {
            (gp = 0);
            if ((((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB)) && ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                (gp = 1);
            }
            switch (oldbrm) {
                WS_BRM:
                    (brm = ACCEPTED_BRM);
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                SKIPPED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        }
                    }
                    ;
                ACCEPTED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDP_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
                ACCEPTEDN_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDPN_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
            }
        }
        if ((brm == ACCEPTED_BRM or ACCEPTEDP_BRM)) {
            if ((oldbrm ~= brm)) {
                (blobcount)++;
            }
            if (((ctxt) && ((blobcount == wanted)))) {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    if ((brm == ACCEPTED_BRM)) {
                        (brm = ACCEPTEDN_BRM);
                    }
                    if ((brm == ACCEPTEDP_BRM)) {
                        (brm = ACCEPTEDPN_BRM);
                    }
                } else {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            } else {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            }
        } else {
            if (((rtxt) && ((brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)))) {
                if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
    }
    if (ctxt) {
        if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
            BlkValueSetLBCapacity(ctxt, (2*cl));
        }
        BlkValueWrite(ctxt, (cl)++, 0);
    }
    return blobcount;
];
[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
    if ((txt == 0)) {
        rtrue;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_GetCharacter(ctxt, txt, wanted);
    }
    TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
    return ctxt;
];
[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
    TEXT_TY_Transmute(txt);
    (cp = (rtxt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(rtxt));
    if ((blobtype == CHR_BLOB)) {
        (ilen = TEXT_TY_CharacterLength(txt));
        (rlen = TEXT_TY_CharacterLength(rtxt));
        (wanted)--;
        if ((((wanted >= 0)) && ((wanted < ilen)))) {
            if ((rlen == 1)) {
                BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
            } else {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                if (BlkValueSetLBCapacity(ctxt, ((ilen + rlen) + 1))) {
                    for ((i = 0):(i < wanted):(i)++) {
                        BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
                    }
                    for ((i = 0):(i < rlen):(i)++) {
                        BlkValueWrite(ctxt, (wanted + i), BlkValueRead(rtxt, i));
                    }
                    for ((i = (wanted + 1)):(i < ilen):(i)++) {
                        BlkValueWrite(ctxt, ((rlen + i) - 1), BlkValueRead(txt, i));
                    }
                    BlkValueWrite(ctxt, (rlen + ilen), 0);
                    BlkValueCopy(txt, ctxt);
                }
                BlkValueFree(ctxt);
            }
        }
    } else {
        (ctxt = BlkValueCreate(TEXT_TY));
        TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
        BlkValueCopy(txt, ctxt);
        BlkValueFree(ctxt);
    }
    TEXT_TY_Untransmute(rtxt, p, cp);
];
[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt r p1 p2 cp1 cp2;
    TEXT_TY_Transmute(txt);
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
    if ((blobtype == REGEXP_BLOB or CHR_BLOB)) {
        return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
    }
    (ilen = TEXT_TY_CharacterLength(txt));
    (flen = TEXT_TY_CharacterLength(ftxt));
    (ctxt = BlkValueCreate(TEXT_TY));
    TEXT_TY_Transmute(ctxt);
    (csize = BlkValueLBCapacity(ctxt));
    (mpos = 0);
    (whitespace = 1);
    (punctuation = 0);
    for ((i = 0):(i <= ilen):(i)++) {
        (ch = BlkValueRead(txt, i));
        (chm = BlkValueRead(ftxt, (mpos)++));
        if ((mpos == 1)) {
            switch (blobtype) {
                WORD_BLOB:
                    if ((((whitespace == 0)) && ((punctuation == 0)))) {
                        (chm = -1);
                    }
                    ;
            }
        }
        (whitespace = 0);
        if ((ch == 10 or 13 or 32 or 9)) {
            (whitespace = 1);
        }
        (punctuation = 0);
        if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
            if ((blobtype == WORD_BLOB)) {
                (chm = -1);
            }
            (punctuation = 1);
        }
        if ((ch == chm)) {
            if ((mpos == flen)) {
                if ((i == ilen)) {
                    (chm = 0);
                } else {
                    (chm = BlkValueRead(txt, (i + 1)));
                }
                if ((((((blobtype == CHR_BLOB)) || ((chm == 0 or 10 or 13 or 32 or 9)))) || ((chm == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (mpos = 0);
                    (cl = (cl - (flen - 1)));
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (csize = BlkValueLBCapacity(ctxt));
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    continue;
                }
            }
        } else {
            (mpos = 0);
        }
        if (((cl + 1) >= csize)) {
            if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                break;
            }
            (csize = BlkValueLBCapacity(ctxt));
        }
        BlkValueWrite(ctxt, (cl)++, ch);
    }
    BlkValueCopy(txt, ctxt);
    BlkValueFree(ctxt);
];
[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (dsize = BlkValueLBCapacity(txt));
    (r = dsize);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            (r = i);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_Empty txt;
    if ((txt == 0)) {
        rtrue;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        if (((txt-->(1)) == EMPTY_TEXT_PACKED)) {
            rtrue;
        }
        rfalse;
    }
    if ((TEXT_TY_CharacterLength(txt) == 0)) {
        rtrue;
    }
    rfalse;
];
[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    if ((((i <= 0)) || ((i > TEXT_TY_CharacterLength(txt))))) {
        (ch = 0);
    } else {
        (ch = BlkValueRead(txt, (i - 1)));
    }
    BlkValueWrite(ctxt, 0, ch);
    BlkValueWrite(ctxt, 1, 0);
    TEXT_TY_Untransmute(txt, p, cp);
    return ctxt;
];
[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = TEXT_TY_CharacterLength(txt));
    (r = 1);
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt, i));
        if (((ch) && ((CharIsOfCase(ch, case) == 0)))) {
            (r = 0);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (pk = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    (len = TEXT_TY_CharacterLength(txt));
    if (BlkValueSetLBCapacity(ctxt, (len + 1))) {
        (bnd = 1);
        for ((i = 0):(i < len):(i)++) {
            (ch = BlkValueRead(txt, i));
            if ((case < 2)) {
                BlkValueWrite(ctxt, i, CharToCase(ch, case));
            } else {
                BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
                if ((case == 2)) {
                    (bnd = 0);
                    if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        (bnd = 1);
                    }
                }
                if ((case == 3)) {
                    if ((ch ~= 0 or 10 or 13 or 32 or 9)) {
                        if ((bnd == 1)) {
                            (bnd = 0);
                        } else {
                            if ((ch == 46 or 33 or 63)) {
                                (bnd = 1);
                            }
                        }
                    }
                }
            }
        }
        BlkValueWrite(ctxt, len, 0);
    }
    TEXT_TY_Untransmute(txt, pk, cp);
    return ctxt;
];
[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt p cp r;
    if ((to_txt == 0)) {
        rfalse;
    }
    if ((from_txt == 0)) {
        return to_txt;
    }
    TEXT_TY_Transmute(to_txt);
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt));
    TEXT_TY_Untransmute(from_txt, p, cp);
    return r;
];
[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt pos len ch i tosize x y case;
    switch (blobtype) {
        CHR_BLOB, 0:
            (pos = TEXT_TY_CharacterLength(to_txt));
            (len = TEXT_TY_CharacterLength(from_txt));
            if ((BlkValueSetLBCapacity(to_txt, ((pos + len) + 1)) == 0)) {
                return to_txt;
            }
            for ((i = 0):(i < len):(i)++) {
                (ch = BlkValueRead(from_txt, i));
                BlkValueWrite(to_txt, (i + pos), ch);
            }
            BlkValueWrite(to_txt, (len + pos), 0);
            return to_txt;
            ;
        REGEXP_BLOB:
            return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
            ;
    }
    print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
    rfalse;
];
[ CharIsOfCase c case i tab min max len par;
    if ((c < 65)) {
        rfalse;
    }
    if ((case == 0)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            rtrue;
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            rtrue;
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        rfalse;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            rfalse;
        }
        if ((c < (min + len))) {
            if (par) {
                if ((((c - min)%2) == 0)) {
                    rtrue;
                }
            } else {
                rtrue;
            }
        }
    }
    rfalse;
];
[ CharToCase c case i tab min max len par del f;
    if ((c < 65)) {
        return c;
    }
    if ((case == 1)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            return (c - 32);
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            return (c + 32);
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        return c;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (del = (tab-->(i)));
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            return c;
        }
        if ((c < (min + len))) {
            (f = 0);
            if (par) {
                if ((((c - min)%2) == 0)) {
                    (f = 1);
                }
            } else {
                (f = 1);
            }
            if (f) {
                if ((del == UNIC_NCT)) {
                    return c;
                }
                return (c + del);
            }
        }
    }
    return c;
];
[ TEXT_TY_RevCase ch;
    if ((ch < 65)) {
        return ch;
    }
    if ((((ch >= 97)) && ((ch <= 122)))) {
        return ((ch - 97) + 65);
    }
    if ((((ch >= 65)) && ((ch <= 90)))) {
        return ((ch - 65) + 97);
    }
    if ((ch < 128)) {
        return ch;
    }
    if (CharIsOfCase(ch, 0)) {
        return CharToCase(ch, 1);
    }
    if (CharIsOfCase(ch, 1)) {
        return CharToCase(ch, 0);
    }
    return ch;
];
[ DigitToValue c n;
    (n = (c - 48));
    if ((((n < 0)) || ((n > 9)))) {
        return (-(1));
    }
    return n;
];
[ CharTestCases case i j;
    for ((i = 32):(i < 224):(i)++) {
        if ((((i >= 127)) && ((i < 155)))) {
            continue;
        }
        print i;
        print " - ";
        print (char) i;
        print " -";
        if (CharIsOfCase(i, 0)) {
            print "  lower";
        }
        if (CharIsOfCase(i, 1)) {
            print "  upper";
        }
        (j = CharToCase(i, 0));
        if ((j ~= i)) {
            print "  tolower: ";
            print (char) j;
        }
        (j = CharToCase(i, 1));
        if ((j ~= i)) {
            print "  toupper: ";
            print (char) j;
        }
        print "^";
    }
];
[ TEXT_TY_RE_SetTrace F;
    (TEXT_TY_RE_Trace = F);
];
[ TEXT_TY_RE_Node n cc par1 par2 par3 offset;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        rfalse;
    }
    (offset = (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES)));
    ((offset-->(RE_CCLASS)) = cc);
    ((offset-->(RE_PAR1)) = par1);
    ((offset-->(RE_PAR2)) = par2);
    ((offset-->(RE_PAR3)) = par3);
    ((offset-->(RE_NEXT)) = NULL);
    ((offset-->(RE_PREVIOUS)) = NULL);
    ((offset-->(RE_DOWN)) = NULL);
    ((offset-->(RE_UP)) = NULL);
    ((offset-->(RE_DATA1)) = -1);
    ((offset-->(RE_DATA2)) = -1);
    ((offset-->(RE_CONSTRAINT)) = -1);
    return offset;
];
[ TEXT_TY_RE_NodeAddress n;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        return (-(1));
    }
    return (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES));
];
[ TEXT_TY_RE_DebugMatchVars txt offset n i;
    print (RE_Subexpressions-->(10));
    print " collecting subexps^";
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        print "Subexp ";
        print (offset-->(RE_PAR1));
        print " = [";
        print (offset-->(RE_DATA1));
        print ",";
        print (offset-->(RE_DATA2));
        print "] = ";
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            print (char) BlkValueRead(txt, i);
        }
        print "^";
    }
];
[ TEXT_TY_RE_CreateMatchVars txt offset n i ch ctxt cl csize;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        if ((Allocated_Match_Vars-->(n))) {
            BlkValueFree((Allocated_Match_Vars-->(n)));
        }
        ((Allocated_Match_Vars-->(n)) = BlkValueCreate(TEXT_TY));
        TEXT_TY_Transmute((Allocated_Match_Vars-->(n)));
        (ctxt = (Allocated_Match_Vars-->(n)));
        (csize = BlkValueLBCapacity(ctxt));
        (cl = 0);
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            (ch = BlkValueRead(txt, i));
            if (((cl + 1) >= csize)) {
                if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                    break;
                }
                (csize = BlkValueLBCapacity(ctxt));
            }
            BlkValueWrite(ctxt, (cl)++, ch);
        }
        BlkValueWrite(ctxt, cl, 0);
    }
];
[ TEXT_TY_RE_EmptyMatchVars txt n;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        if (((Allocated_Match_Vars-->(n)) ~= 0)) {
            BlkValueWrite((Allocated_Match_Vars-->(n)), 0, 0);
        }
    }
];
[ TEXT_TY_RE_GetMatchVar vn offset;
    if ((((((vn < 0)) || ((vn >= 10)))) || ((vn >= (RE_Subexpressions-->(10)))))) {
        return EMPTY_TEXT_VALUE;
    }
    (offset = (RE_Subexpressions-->(vn)));
    if ((offset == 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((offset-->(RE_DATA1)) < 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((Allocated_Match_Vars-->(vn)) == 0)) {
        print "*** ";
        print vn;
        print " unallocated! ***^";
        return EMPTY_TEXT_VALUE;
    }
    return (Allocated_Match_Vars-->(vn));
];
[ TEXT_TY_MV_End n end offset;
    (offset = (RE_Subexpressions-->(n)));
    if ((end == 0)) {
        return (offset-->(RE_DATA1));
    }
    return (offset-->(RE_DATA2));
];
[ TEXT_TY_RE_Clear_Markers token;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_Clear_Markers((token-->(RE_DOWN)));
        }
        ((token-->(RE_DATA1)) = -1);
        ((token-->(RE_DATA2)) = -1);
        ((token-->(RE_CONSTRAINT)) = -1);
    }
];
[ TEXT_TY_RE_DebugTree ftxt detail;
    print "Pattern: ";
    TEXT_TY_Say(ftxt);
    print "^";
    TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];
[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail cup;
    if ((offset ~= NULL)) {
        (cup = (offset-->(RE_UP)));
        if (((offset-->(RE_PREVIOUS)) ~= NULL)) {
            print "*** broken initial previous ***^";
        }
    }
    while ((offset ~= NULL)) {
        if (((offset-->(RE_UP)) ~= cup)) {
            print "*** broken up matching ***^";
        }
        spaces (depth*2);
        TEXT_TY_RE_DebugNode(offset, ftxt, detail);
        if (((offset-->(RE_DOWN)) ~= NULL)) {
            if ((((offset-->(RE_DOWN))-->(RE_UP)) ~= offset)) {
                print "*** broken down/up ***^";
            }
            TEXT_TY_RE_DebugSubtree(ftxt, (depth + 1), (offset-->(RE_DOWN)), detail);
        }
        if (((offset-->(RE_NEXT)) ~= NULL)) {
            if ((((offset-->(RE_NEXT))-->(RE_PREVIOUS)) ~= offset)) {
                print "*** broken next/previous ***^";
            }
        }
        (offset = (offset-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_DebugNode offset ftxt detail i par1 par2 par3;
    if ((offset == NULL)) {
        print "[NULL]";
        new_line;
        rtrue;
    }
    print "[";
    print ((offset - RE_PACKET_space)/RE_PACKET_SIZE_IN_BYTES);
    print "] ";
    (par1 = (offset-->(RE_PAR1)));
    (par2 = (offset-->(RE_PAR2)));
    (par3 = (offset-->(RE_PAR3)));
    switch ((offset-->(RE_CCLASS))) {
        DIGIT_RE_CC:
            print "DIGIT";
            ;
        NONDIGIT_RE_CC:
            print "NONDIGIT";
            ;
        UCASE_RE_CC:
            print "UCASE";
            ;
        NONUCASE_RE_CC:
            print "NONUCASE";
            ;
        LCASE_RE_CC:
            print "LCASE";
            ;
        NONLCASE_RE_CC:
            print "NONLCASE";
            ;
        WHITESPACE_RE_CC:
            print "WHITESPACE";
            ;
        NONWHITESPACE_RE_CC:
            print "NONWHITESPACE";
            ;
        PUNCTUATION_RE_CC:
            print "PUNCTUATION";
            ;
        NONPUNCTUATION_RE_CC:
            print "NONPUNCTUATION";
            ;
        WORD_RE_CC:
            print "WORD";
            ;
        NONWORD_RE_CC:
            print "NONWORD";
            ;
        ALWAYS_RE_CC:
            print "ALWAYS";
            ;
        NEVER_RE_CC:
            print "NEVER";
            ;
        START_RE_CC:
            print "START";
            ;
        END_RE_CC:
            print "END";
            ;
        BOUNDARY_RE_CC:
            print "BOUNDARY";
            ;
        NONBOUNDARY_RE_CC:
            print "NONBOUNDARY";
            ;
        ANYTHING_RE_CC:
            print "ANYTHING";
            ;
        NOTHING_RE_CC:
            print "NOTHING";
            ;
        RANGE_RE_CC:
            print "RANGE";
            if ((par3 == 1)) {
                print " (negated)";
            }
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        VARIABLE_RE_CC:
            print "VARIABLE ";
            print par1;
            ;
        SUBEXP_RE_CC:
            if ((par1 == 0)) {
                print "EXP";
            } else {
                print "SUBEXP ";
            }
            if ((par1 >= 0)) {
                print "= V";
                print par1;
            }
            if ((par2 == 1)) {
                if ((par3 == 0)) {
                    print " (?=...) lookahead";
                } else {
                    print " (?<=...) lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 2)) {
                if ((par3 == 0)) {
                    print " (?!...) negated lookahead";
                } else {
                    print " (?<!...) negated lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 3)) {
                print " uncollecting";
            }
            if ((par2 == 0 or 3)) {
                if ((par3 == 1)) {
                    print " forcing case sensitivity";
                }
                if ((par3 == 2)) {
                    print " forcing case insensitivity";
                }
            }
            if ((par2 == 4)) {
                print " (?>...) possessive";
            }
            ;
        NEWLINE_RE_CC:
            print "NEWLINE";
            ;
        TAB_RE_CC:
            print "TAB";
            ;
        QUANTIFIER_RE_CC:
            print "QUANTIFIER min=";
            print par1;
            print " max=";
            print par2;
            if (par3) {
                print " (lazy)";
            } else {
                print " (greedy)";
            }
            ;
        LITERAL_RE_CC:
            print "LITERAL";
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        DISJUNCTION_RE_CC:
            print "DISJUNCTION of ";
            print par1;
            print " choices";
            ;
        CHOICE_RE_CC:
            print "CHOICE no ";
            print par1;
            ;
        SENSITIVITY_RE_CC:
            print "SENSITIVITY";
            if (par1) {
                print " off";
            } else {
                print " on";
            }
            ;
        IF_RE_CC:
            print "IF";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        CONDITION_RE_CC:
            print "CONDITION";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        THEN_RE_CC:
            print "THEN";
            ;
        ELSE_RE_CC:
            print "ELSE";
            ;
    }
    if (detail) {
        print ": ";
        print (offset-->(RE_DATA1));
        print ", ";
        print (offset-->(RE_DATA2));
        print ", ";
        print (offset-->(RE_CONSTRAINT));
    }
    print "^";
];
[ TEXT_TY_CHR_CompileTree ftxt exactly root literal fto no_packets token attach_to;
    (fto = TEXT_TY_CharacterLength(ftxt));
    (root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0));
    (literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0));
    ((root-->(RE_DOWN)) = literal);
    ((literal-->(RE_UP)) = root);
    if (exactly) {
        (no_packets = 2);
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
];
[ TEXT_TY_RE_CompileTree ftxt exactly no_packets ffrom fto cc par1 par2 par3 quantifiable token attach_to no_subs blevel bits;
    (fto = TEXT_TY_CharacterLength(ftxt));
    if ((fto == 0)) {
        TEXT_TY_RE_Node((no_packets)++, NEVER_RE_CC, 0, 0, 0);
        rtrue;
    }
    (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, 0, 0, 0));
    ((RE_Subexpressions-->(0)) = attach_to);
    ((RE_Subexpressions-->(10)) = 1);
    (no_subs = 1);
    (quantifiable = 0);
    (blevel = 0);
    for ((ffrom = 0):(ffrom < fto):) {
        (cc = BlkValueRead(ftxt, (ffrom)++));
        (par1 = 0);
        (par2 = 0);
        (par3 = 0);
        if ((cc == 92)) {
            if ((ffrom == fto)) {
                return "Search pattern not terminated";
            }
            (cc = BlkValueRead(ftxt, (ffrom)++));
            switch (cc) {
                98:
                    (cc = BOUNDARY_RE_CC);
                    ;
                66:
                    (cc = NONBOUNDARY_RE_CC);
                    ;
                100:
                    (cc = DIGIT_RE_CC);
                    ;
                68:
                    (cc = NONDIGIT_RE_CC);
                    ;
                108:
                    (cc = LCASE_RE_CC);
                    ;
                76:
                    (cc = NONLCASE_RE_CC);
                    ;
                110:
                    (cc = NEWLINE_RE_CC);
                    ;
                112:
                    (cc = PUNCTUATION_RE_CC);
                    ;
                80:
                    (cc = NONPUNCTUATION_RE_CC);
                    ;
                115:
                    (cc = WHITESPACE_RE_CC);
                    ;
                83:
                    (cc = NONWHITESPACE_RE_CC);
                    ;
                116:
                    (cc = TAB_RE_CC);
                    ;
                117:
                    (cc = UCASE_RE_CC);
                    ;
                85:
                    (cc = NONUCASE_RE_CC);
                    ;
                119:
                    (cc = WORD_RE_CC);
                    ;
                87:
                    (cc = NONWORD_RE_CC);
                    ;
                default:
                    if ((((cc >= 49)) && ((cc <= 57)))) {
                        (par1 = (cc - 48));
                        (cc = VARIABLE_RE_CC);
                    } else {
                        if ((((((cc >= 97)) && ((cc <= 122)))) || ((((cc >= 65)) && ((cc <= 90)))))) {
                            return "unknown escape";
                        }
                        (cc = LITERAL_RE_CC);
                        (par1 = (ffrom - 1));
                        (par2 = ffrom);
                    }
                    ;
            }
            (quantifiable = 1);
        } else {
            switch (cc) {
                40:
                    (par2 = 0);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (bits = 1);
                        if ((BlkValueRead(ftxt, ffrom) == 45)) {
                            (ffrom)++;
                            (bits = 0);
                        } else {
                            if ((BlkValueRead(ftxt, ffrom) == 60)) {
                                (ffrom)++;
                                (bits = 0);
                            }
                        }
                        switch ((cc = BlkValueRead(ftxt, (ffrom)++))) {
                            35:
                                while ((BlkValueRead(ftxt, (ffrom)++) ~= 0 or 41)) {
                                }
                                if ((BlkValueRead(ftxt, (ffrom - 1)) == 0)) {
                                    return "comment never ends";
                                }
                                continue;
                                ;
                            40:
                                (cc = BlkValueRead(ftxt, ffrom));
                                if ((((cc == 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) && ((BlkValueRead(ftxt, (ffrom + 1)) == 41)))) {
                                    (ffrom = (ffrom + 2));
                                    (par1 = (cc - 48));
                                } else {
                                    (ffrom)--;
                                }
                                (cc = IF_RE_CC);
                                (quantifiable = 0);
                                if ((blevel == 20)) {
                                    return "subexpressions too deep";
                                }
                                ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                                jump CClassKnown;
                                ;
                            61:
                                (par2 = 1);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            33:
                                (par2 = 2);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            58:
                                (par2 = 3);
                                ;
                            62:
                                (par2 = 4);
                                ;
                            default:
                                if ((BlkValueRead(ftxt, ffrom) == 41)) {
                                    if ((cc == 105)) {
                                        (cc = SENSITIVITY_RE_CC);
                                        (par1 = bits);
                                        (ffrom)++;
                                        jump CClassKnown;
                                    }
                                }
                                if ((BlkValueRead(ftxt, ffrom) == 58)) {
                                    if ((cc == 105)) {
                                        (par1 = bits);
                                        (par2 = 3);
                                        (par3 = (bits + 1));
                                        (ffrom)++;
                                        jump AllowForm;
                                    }
                                }
                                return "unknown (?...) form";
                                ;
                        }
                    }
                    .AllowForm;
                    if ((par2 == 0)) {
                        (par1 = (no_subs)++);
                    } else {
                        (par1 = -1);
                    }
                    (cc = SUBEXP_RE_CC);
                    (quantifiable = 0);
                    if ((blevel == 20)) {
                        return "subexpressions too deep";
                    }
                    ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                    ;
                41:
                    if ((blevel == 0)) {
                        return "subexpression bracket mismatch";
                    }
                    (blevel)--;
                    (attach_to = (Subexp_Posns-->(blevel)));
                    if (((attach_to-->(RE_DOWN)) == NULL)) {
                        if ((no_packets >= RE_MAX_PACKETS)) {
                            return "regexp too complex";
                        }
                        ((attach_to-->(RE_DOWN)) = TEXT_TY_RE_Node((no_packets)++, ALWAYS_RE_CC, 0, 0, 0));
                        (((attach_to-->(RE_DOWN))-->(RE_UP)) = attach_to);
                    }
                    (quantifiable = 1);
                    continue;
                    ;
                46:
                    (cc = ANYTHING_RE_CC);
                    (quantifiable = 1);
                    ;
                124:
                    (cc = CHOICE_RE_CC);
                    (quantifiable = 0);
                    ;
                94:
                    (cc = START_RE_CC);
                    (quantifiable = 0);
                    ;
                36:
                    (cc = END_RE_CC);
                    (quantifiable = 0);
                    ;
                123:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (par1 = 0);
                    (par2 = -1);
                    (bits = 1);
                    while (((cc = BlkValueRead(ftxt, (ffrom)++)) ~= 0 or 125)) {
                        if ((cc == 44)) {
                            (bits)++;
                            if ((bits >= 3)) {
                                return "too many colons in ?{...}";
                            }
                            continue;
                        }
                        if ((((cc >= 48)) || ((cc <= 57)))) {
                            if ((bits == 1)) {
                                if ((par1 < 0)) {
                                    (par1 = 0);
                                }
                                (par1 = ((par1*10) + (cc - 48)));
                            } else {
                                if ((par2 < 0)) {
                                    (par2 = 0);
                                }
                                (par2 = ((par2*10) + (cc - 48)));
                            }
                        } else {
                            return "non-digit in ?{...}";
                        }
                    }
                    if ((cc ~= 125)) {
                        return "{x,y} quantifier never ends";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    if ((par2 == -1)) {
                        if ((bits == 2)) {
                            (par2 = 30000);
                        } else {
                            (par2 = par1);
                        }
                    }
                    if ((par1 > par2)) {
                        return "{x,y} with x greater than y";
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                60, 91:
                    (par3 = 0);
                    if ((cc == 60)) {
                        (bits = 62);
                    } else {
                        (bits = 93);
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 94)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (par1 = ffrom);
                    if ((BlkValueRead(ftxt, ffrom) == bits)) {
                        (ffrom)++;
                    }
                    while ((cc ~= bits or 0)) {
                        (cc = BlkValueRead(ftxt, (ffrom)++));
                        if ((cc == 92)) {
                            (cc = BlkValueRead(ftxt, (ffrom)++));
                            if ((cc ~= 0)) {
                                (cc = BlkValueRead(ftxt, (ffrom)++));
                            }
                        }
                    }
                    if ((cc == 0)) {
                        return "Character range never ends";
                    }
                    (par2 = (ffrom - 1));
                    if ((((((((par2 > (par1 + 1))) && ((BlkValueRead(ftxt, par1) == 58)))) && ((BlkValueRead(ftxt, (par2 - 1)) == 58)))) && ((BlkValueRead(ftxt, (par2 - 2)) ~= 92)))) {
                        return "POSIX named character classes unsupported";
                    }
                    (bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2));
                    if (bits) {
                        return bits;
                    }
                    if ((par1 < par2)) {
                        (cc = RANGE_RE_CC);
                    } else {
                        (cc = NOTHING_RE_CC);
                    }
                    (quantifiable = 1);
                    ;
                42:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                43:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 1);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                63:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 1);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
            }
        }
        .CClassKnown;
        if ((cc >= 0)) {
            (quantifiable = 1);
            if (((((attach_to-->(RE_CCLASS)) == LITERAL_RE_CC)) && ((BlkValueRead(ftxt, ffrom) ~= 42 or 43 or 63 or 123)))) {
                ((attach_to-->(RE_PAR2)))++;
                if ((TEXT_TY_RE_Trace == 2)) {
                    print "Extending literal by ";
                    print cc;
                    print "=";
                    print (char) cc;
                    print "^";
                }
                continue;
            }
            (cc = LITERAL_RE_CC);
            (par1 = (ffrom - 1));
            (par2 = ffrom);
        }
        if ((no_packets >= RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Attaching packet ";
            print (no_packets + 1);
            print " to ";
            TEXT_TY_RE_DebugNode(attach_to, ftxt);
            TEXT_TY_RE_DebugTree(ftxt);
        }
        (token = TEXT_TY_RE_Node((no_packets)++, cc, par1, par2, par3));
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 0)))) {
            ((RE_Subexpressions-->((token-->(RE_PAR1)))) = token);
            ((RE_Subexpressions-->(10)))++;
        }
        if (((((attach_to-->(RE_CCLASS)) == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC)) && (((attach_to-->(RE_DOWN)) == NULL)))) {
            ((attach_to-->(RE_DOWN)) = token);
            ((token-->(RE_UP)) = attach_to);
        } else {
            if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && ((((attach_to-->(RE_UP))-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (no_packets)--;
                (token = (attach_to-->(RE_UP)));
            } else {
                if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                    while (((attach_to-->(RE_PREVIOUS)) ~= NULL)) {
                        (attach_to = (attach_to-->(RE_PREVIOUS)));
                    }
                }
                if (((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC or CHOICE_RE_CC)) {
                    ((token-->(RE_PREVIOUS)) = (attach_to-->(RE_PREVIOUS)));
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                    if (((((attach_to-->(RE_UP)) ~= NULL)) && (((attach_to-->(RE_PREVIOUS)) == NULL)))) {
                        (((attach_to-->(RE_UP))-->(RE_DOWN)) = token);
                    }
                    ((token-->(RE_DOWN)) = attach_to);
                    (bits = attach_to);
                    while ((bits ~= NULL)) {
                        ((bits-->(RE_UP)) = token);
                        (bits = (bits-->(RE_NEXT)));
                    }
                    ((attach_to-->(RE_PREVIOUS)) = NULL);
                    if (((token-->(RE_PREVIOUS)) ~= NULL)) {
                        (((token-->(RE_PREVIOUS))-->(RE_NEXT)) = token);
                    }
                } else {
                    ((attach_to-->(RE_NEXT)) = token);
                    ((token-->(RE_PREVIOUS)) = attach_to);
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                }
            }
        }
        if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            ((token-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, CHOICE_RE_CC, 0, 0, 0));
            (((token-->(RE_NEXT))-->(RE_PREVIOUS)) = token);
            (((token-->(RE_NEXT))-->(RE_UP)) = (token-->(RE_UP)));
            (token = (token-->(RE_NEXT)));
        }
        (attach_to = token);
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Result:^";
            TEXT_TY_RE_DebugTree(ftxt);
        }
    }
    if ((blevel ~= 0)) {
        return "subexpression bracket mismatch";
    }
    if (exactly) {
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
    if (TEXT_TY_RE_Trace) {
        print "Compiled pattern:^";
        TEXT_TY_RE_DebugTree(ftxt);
    }
    (bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs));
    if (bits) {
        return bits;
    }
    return no_packets;
];
[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt i chm;
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            if ((((((chm >= 97)) && ((chm <= 122)))) || ((((chm >= 65)) && ((chm <= 90)))))) {
                if ((chm ~= 115 or 83 or 112 or 80 or 119 or 87 or 100 or 68 or 110 or 116 or 108 or 76 or 117 or 85)) {
                    return "Invalid escape in {} range";
                }
            }
        }
        if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
            if ((chm > BlkValueRead(ftxt, (i + 2)))) {
                return "Invalid {} range";
            }
            (i = (i + 2));
        }
    }
    rfalse;
];
[ TEXT_TY_RE_ExpandChoices token no_packets rv prev nex holder new ct n cond_node then_node else_node;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == IF_RE_CC)) {
            if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                for (((nex = (token-->(RE_DOWN))),(n = 0)):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    (n)++;
                }
                if ((n ~= 2)) {
                    return "conditional has too many clauses";
                }
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                }
                (then_node = (token-->(RE_DOWN)));
                ((then_node-->(RE_CCLASS)) = THEN_RE_CC);
                (else_node = (then_node-->(RE_NEXT)));
                ((else_node-->(RE_CCLASS)) = ELSE_RE_CC);
                if (((cond_node-->(RE_PAR1)) < 1)) {
                    ((cond_node-->(RE_DOWN)) = (then_node-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((then_node-->(RE_DOWN))-->(RE_NEXT)));
                    if (((then_node-->(RE_DOWN)) ~= NULL)) {
                        (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                    }
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
            } else {
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (then_node = TEXT_TY_RE_Node((no_packets)++, THEN_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                    ((then_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                } else {
                    ((cond_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((token-->(RE_DOWN))-->(RE_NEXT)));
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
                ((then_node-->(RE_UP)) = token);
                ((then_node-->(RE_NEXT)) = NULL);
                if (((then_node-->(RE_DOWN)) ~= NULL)) {
                    (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                }
                for ((nex = (then_node-->(RE_DOWN))):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    ((nex-->(RE_UP)) = then_node);
                }
            }
            if (((cond_node-->(RE_DOWN)) ~= NULL)) {
                (nex = (cond_node-->(RE_DOWN)));
                if (((((((nex-->(RE_CCLASS)) ~= SUBEXP_RE_CC)) || (((nex-->(RE_NEXT)) ~= NULL)))) || (((nex-->(RE_PAR2)) ~= 1 or 2)))) {
                    return "condition not lookahead/behind";
                }
            }
        }
        if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && (((token-->(RE_PAR1)) < 1)))) {
            (prev = (token-->(RE_PREVIOUS)));
            (nex = (token-->(RE_NEXT)));
            while ((((nex ~= NULL)) && (((nex-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (nex = (nex-->(RE_NEXT)));
            }
            (holder = (token-->(RE_UP)));
            if ((holder == NULL)) {
                return "bang";
            }
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            (new = TEXT_TY_RE_Node((no_packets)++, DISJUNCTION_RE_CC, 0, 0, 0));
            ((holder-->(RE_DOWN)) = new);
            ((new-->(RE_UP)) = holder);
            if ((prev ~= NULL)) {
                ((prev-->(RE_NEXT)) = new);
                ((new-->(RE_PREVIOUS)) = prev);
            }
            if ((nex ~= NULL)) {
                ((nex-->(RE_PREVIOUS)) = new);
                ((new-->(RE_NEXT)) = nex);
            }
            ((new-->(RE_DOWN)) = token);
            ((token-->(RE_PREVIOUS)) = NULL);
            (ct = 1);
            while ((token ~= NULL)) {
                ((token-->(RE_PAR1)) = (ct)++);
                ((token-->(RE_UP)) = new);
                if (((((token-->(RE_NEXT)) ~= NULL)) && ((((token-->(RE_NEXT))-->(RE_CCLASS)) ~= CHOICE_RE_CC)))) {
                    ((token-->(RE_NEXT)) = NULL);
                }
                (token = (token-->(RE_NEXT)));
            }
            ((new-->(RE_PAR1)) = (ct - 1));
            if ((token ~= NULL)) {
                ((token-->(RE_NEXT)) = NULL);
            }
            (token = new);
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (no_packets = TEXT_TY_RE_ExpandChoices((token-->(RE_DOWN)), no_packets));
            if ((((no_packets < 0)) || ((no_packets >= RE_MAX_PACKETS)))) {
                break;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    return no_packets;
];
[ TEXT_TY_RE_CheckTree token no_subs rv;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == VARIABLE_RE_CC)) {
            if (((token-->(RE_PAR1)) >= no_subs)) {
                return "reference to nonexistent group";
            }
        }
        if (((((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2)))) && (((token-->(RE_PAR3)) == -1)))) {
            ((token-->(RE_PAR3)) = TEXT_TY_RE_Width((token-->(RE_DOWN))));
            if (((token-->(RE_PAR3)) == -1)) {
                return "variable length lookbehind not implemented";
            }
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (rv = TEXT_TY_RE_CheckTree((token-->(RE_DOWN)), no_subs));
            if (rv) {
                return rv;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    rfalse;
];
[ TEXT_TY_RE_Width token downwards w rv aw choice;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC, PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC, ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC, UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
                (w)++;
                ;
            START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
                ;
            LITERAL_RE_CC:
                (w = ((w + (token-->(RE_PAR2))) - (token-->(RE_PAR1))));
                ;
            VARIABLE_RE_CC:
                return (-(1));
                ;
            IF_RE_CC:
                (rv = TEXT_TY_RE_Width(((token-->(RE_DOWN))-->(RE_NEXT))));
                if ((rv == -1)) {
                    return (-(1));
                }
                if ((rv ~= TEXT_TY_RE_Width((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))))) {
                    return (-(1));
                }
                (w = (w + rv));
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (rv = 0);
                } else {
                    (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                }
                (w = (w + rv));
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_PAR1)) ~= (token-->(RE_PAR2)))) {
                    return (-(1));
                }
                (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                if ((rv == -1)) {
                    return (-(1));
                }
                (w = (w + (rv*(token-->(RE_PAR1)))));
                ;
            DISJUNCTION_RE_CC:
                (aw = -1);
                for ((choice = (token-->(RE_DOWN))):(choice ~= NULL):(choice = (choice-->(RE_NEXT)))) {
                    (rv = TEXT_TY_RE_Width((choice-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                    if ((((aw >= 0)) && ((aw ~= rv)))) {
                        return (-(1));
                    }
                    (aw = rv);
                }
                (w = (w + aw));
                ;
            SENSITIVITY_RE_CC:
                ;
        }
        if (downwards) {
            return w;
        }
        if ((token ~= NULL)) {
            (token = (token-->(RE_NEXT)));
        }
    }
    return w;
];
[ TEXT_TY_RE_PrintNoRewinds;
    print TEXT_TY_RE_RewindCount;
];
[ TEXT_TY_RE_Parse ftxt txt ipos insens ilen rv root i initial_mode;
    (ilen = TEXT_TY_CharacterLength(txt));
    if ((((ipos < 0)) || ((ipos > ilen)))) {
        return (-(1));
    }
    (root = RE_PACKET_space);
    (initial_mode = 0);
    if (insens) {
        (initial_mode = CIS_MFLAG);
    }
    TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
    for (:(ipos <= ilen):(ipos)++) {
        if (((((((RE_PACKET_space-->(RE_DOWN)) ~= NULL)) && ((((RE_PACKET_space-->(RE_DOWN))-->(RE_CCLASS)) == START_RE_CC)))) && ((ipos > 0)))) {
            (rv = -1);
            break;
        }
        if ((ipos > 0)) {
            TEXT_TY_RE_EraseConstraints(RE_PACKET_space);
        }
        (TEXT_TY_RE_RewindCount = 0);
        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode));
        if ((rv >= 0)) {
            break;
        }
    }
    if ((rv == -1)) {
        ((root-->(RE_DATA1)) = -1);
        ((root-->(RE_DATA2)) = -1);
    } else {
        ((root-->(RE_DATA1)) = ipos);
        ((root-->(RE_DATA2)) = (ipos + rv));
    }
    return rv;
];
[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags outcome ipos npos rv i ch edge rewind_this;
    if ((ifrom > ito)) {
        return (-(1));
    }
    (ipos = ifrom);
    .Rewind;
    while ((token ~= NULL)) {
        (outcome = 0);
        if (TEXT_TY_RE_Trace) {
            print "Matching at ";
            print ipos;
            print ": ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if ((ipos < ito)) {
            (ch = BlkValueRead(txt, ipos));
        } else {
            (ch = 0);
        }
        ((token-->(RE_MODES)) = mode_flags);
        switch ((token-->(RE_CCLASS))) {
            CHOICE_RE_CC:
                return "internal error";
                ;
            SENSITIVITY_RE_CC:
                if ((token-->(RE_PAR1))) {
                    (mode_flags = ((mode_flags)|(CIS_MFLAG)));
                } else {
                    (mode_flags = ((mode_flags)&((~(CIS_MFLAG)))));
                }
                (outcome = 1);
                ;
            ALWAYS_RE_CC:
                (outcome = 1);
                ;
            NEVER_RE_CC:
                ;
            START_RE_CC:
                if ((ipos == 0)) {
                    (outcome = 1);
                }
                ;
            END_RE_CC:
                if ((BlkValueRead(txt, ipos) == 0)) {
                    (outcome = 1);
                }
                ;
            BOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv == 1)) {
                    (outcome = 1);
                }
                ;
            NONBOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv ~= 1)) {
                    (outcome = 1);
                }
                ;
            IF_RE_CC:
                (i = (token-->(RE_PAR1)));
                (ch = 0);
                if (TEXT_TY_RE_Trace) {
                    print "Trying conditional from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if ((i >= 1)) {
                    if ((((i < (RE_Subexpressions-->(10)))) && ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)))) {
                        (ch = 1);
                    }
                } else {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((token-->(RE_DOWN))-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        (ch = 1);
                    }
                }
                if (TEXT_TY_RE_Trace) {
                    print "Condition found to be ";
                    print ch;
                    print "^";
                }
                if (ch) {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                } else {
                    if (((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT)) == NULL)) {
                        (rv = 0);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                    }
                }
                if ((rv >= 0)) {
                    (outcome = 1);
                    (ipos = (ipos + rv));
                }
                ;
            DISJUNCTION_RE_CC:
                if (TEXT_TY_RE_Trace) {
                    print "Trying disjunction from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                for ((ch = (token-->(RE_DOWN))):(ch ~= NULL):(ch = (ch-->(RE_NEXT)))) {
                    if (((ch-->(RE_PAR1)) <= (token-->(RE_CONSTRAINT)))) {
                        continue;
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Trying choice at ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                    }
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (ch-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        ((token-->(RE_DATA1)) = ipos);
                        ((token-->(RE_DATA2)) = (ch-->(RE_PAR1)));
                        (ipos = (ipos + rv));
                        (outcome = 1);
                        if (TEXT_TY_RE_Trace) {
                            print "Choice worked with width ";
                            print rv;
                            print ": ";
                            TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                        }
                        break;
                    } else {
                        if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                            TEXT_TY_RE_FailSubexpressions((ch-->(RE_DOWN)));
                        }
                    }
                }
                if ((outcome == 0)) {
                    if (TEXT_TY_RE_Trace) {
                        print "Failed disjunction from ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    ((token-->(RE_DATA1)) = ipos);
                    ((token-->(RE_DATA2)) = -1);
                }
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (npos = (ipos - (token-->(RE_PAR3))));
                    if ((npos < 0)) {
                        (rv = -1);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), mode_flags));
                    }
                } else {
                    switch ((token-->(RE_PAR3))) {
                        0:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), mode_flags));
                            ;
                        1:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)&((~(CIS_MFLAG))))));
                            ;
                        2:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)|(CIS_MFLAG))));
                            ;
                    }
                }
                (npos = ipos);
                if ((rv >= 0)) {
                    (npos = (ipos + rv));
                }
                switch ((token-->(RE_PAR2))) {
                    1:
                        if ((rv >= 0)) {
                            (rv = 0);
                        }
                        ;
                    2:
                        if ((rv >= 0)) {
                            (rv = -1);
                        } else {
                            (rv = 0);
                        }
                        ;
                }
                if ((rv >= 0)) {
                    ((token-->(RE_DATA1)) = ipos);
                    (ipos = (ipos + rv));
                    ((token-->(RE_DATA2)) = npos);
                    (outcome = 1);
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        ((token-->(RE_DATA1)) = -1);
                        ((token-->(RE_DATA2)) = -1);
                    }
                }
                if (((token-->(RE_PAR2)) == 2)) {
                    TEXT_TY_RE_FailSubexpressions(token, 1);
                }
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_DATA1)) = ipos);
                if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                    (((token-->(RE_DOWN))-->(RE_CACHE1)) = -1);
                    (((token-->(RE_DOWN))-->(RE_CACHE2)) = -1);
                }
                if (TEXT_TY_RE_Trace) {
                    print "Trying quantifier from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if (((token-->(RE_PAR3)) == 0)) {
                    (edge = (token-->(RE_PAR2)));
                    if (((token-->(RE_CONSTRAINT)) >= 0)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    (rv = -1);
                    for (((i = 0),(npos = ipos)):(i < edge):(i)++) {
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= (token-->(RE_PAR1)))) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                } else {
                    (edge = (token-->(RE_PAR1)));
                    if (((token-->(RE_CONSTRAINT)) > edge)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    for (((i = 0),(npos = ipos)):(((npos < ito)) && ((i < (token-->(RE_PAR2))))):(i)++) {
                        if ((i >= edge)) {
                            break;
                        }
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= edge)) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                }
                if (outcome) {
                    if (((token-->(RE_PAR3)) == 0)) {
                        if ((i > (token-->(RE_PAR1)))) {
                            ((token-->(RE_DATA2)) = (i - 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    } else {
                        if ((i < (token-->(RE_PAR2)))) {
                            ((token-->(RE_DATA2)) = (i + 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    }
                    (ipos = npos);
                    if ((((i == 0)) && ((((mode_flags)&(ACCUM_MFLAG)) == 0)))) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                        (((token-->(RE_DOWN))-->(RE_DATA1)) = ((token-->(RE_DOWN))-->(RE_CACHE1)));
                        (((token-->(RE_DOWN))-->(RE_DATA2)) = ((token-->(RE_DOWN))-->(RE_CACHE2)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Successful quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Failed quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                }
                ;
            NOTHING_RE_CC:
                ;
            ANYTHING_RE_CC:
                if (ch) {
                    (outcome = 1);
                }
                (ipos)++;
                ;
            WHITESPACE_RE_CC:
                if ((ch == 10 or 13 or 32 or 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWHITESPACE_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            PUNCTUATION_RE_CC:
                if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONPUNCTUATION_RE_CC:
                if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            WORD_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWORD_RE_CC:
                if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            DIGIT_RE_CC:
                if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONDIGIT_RE_CC:
                if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LCASE_RE_CC:
                if (CharIsOfCase(ch, 0)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONLCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 0) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            UCASE_RE_CC:
                if (CharIsOfCase(ch, 1)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONUCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 1) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NEWLINE_RE_CC:
                if ((ch == 10)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            TAB_RE_CC:
                if ((ch == 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            RANGE_RE_CC:
                if (TEXT_TY_RE_Range(ch, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), (token-->(RE_PAR3)), ((mode_flags)&(CIS_MFLAG)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LITERAL_RE_CC:
                (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), ((mode_flags)&(CIS_MFLAG))));
                if ((rv >= 0)) {
                    (ipos = (ipos + rv));
                    (outcome = 1);
                }
                ;
            VARIABLE_RE_CC:
                (i = (token-->(RE_PAR1)));
                if ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)) {
                    (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, txt, ((RE_Subexpressions-->(i))-->(RE_DATA1)), ((RE_Subexpressions-->(i))-->(RE_DATA2)), ((mode_flags)&(CIS_MFLAG))));
                    if ((rv >= 0)) {
                        (ipos = (ipos + rv));
                        (outcome = 1);
                    }
                }
                ;
        }
        if ((outcome == 0)) {
            if (((TEXT_TY_RE_RewindCount)++ >= 10000)) {
                if ((TEXT_TY_RE_RewindCount == 10001)) {
                    style bold;
                    print "OVERFLOW^";
                    style roman;
                }
                return (-(1));
            }
            if (TEXT_TY_RE_Trace) {
                print "Rewind sought from failure at pos ";
                print ipos;
                print " with: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            if (((((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC)) && (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, 0)))) {
                jump RewindFound;
            }
            if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                TEXT_TY_RE_FailSubexpressions(token);
            }
            (token = (token-->(RE_PREVIOUS)));
            while ((token ~= NULL)) {
                if (TEXT_TY_RE_SeekBacktrack(token, ftxt, 1, ito, 0)) {
                    .RewindFound;
                    (ipos = (token-->(RE_DATA1)));
                    (mode_flags = (token-->(RE_MODES)));
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions(token, 1);
                    }
                    if ((ipos == -1)) {
                        TEXT_TY_RE_DebugTree(ftxt, 1);
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "^[";
                        print ifrom;
                        print ",";
                        print ito;
                        print "] rewinding to ";
                        print ipos;
                        print " at ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    jump Rewind;
                }
                (token = (token-->(RE_PREVIOUS)));
            }
            if (TEXT_TY_RE_Trace) {
                print "^Rewind impossible^";
            }
            return (-(1));
        }
        (token = (token-->(RE_NEXT)));
    }
    return (ipos - ifrom);
];
[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only untried;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
            print "Scan for rewind: ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2 or 4)))) {
            if (downwards) {
                rfalse;
            }
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                print "Descend^";
            }
            if (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, report_only)) {
                rtrue;
            }
        }
        (untried = 0);
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                if (((((((token-->(RE_DATA2)) >= 1)) && (((token-->(RE_DATA2)) < (token-->(RE_PAR1)))))) && (((token-->(RE_CONSTRAINT)) < (token-->(RE_PAR1)))))) {
                    if (report_only) {
                        rtrue;
                    }
                    if (((token-->(RE_CONSTRAINT)) == -1)) {
                        ((token-->(RE_CONSTRAINT)) = 1);
                    } else {
                        ((token-->(RE_CONSTRAINT)))++;
                    }
                    (untried = 1);
                }
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_CONSTRAINT)) ~= -2)) {
                    if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                        print "Quant with cons not -2: ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    if (((token-->(RE_DATA2)) >= 0)) {
                        if (report_only) {
                            rtrue;
                        }
                        ((token-->(RE_CONSTRAINT)) = (token-->(RE_DATA2)));
                        (untried = 1);
                    }
                }
                ;
        }
        if (untried) {
            if (TEXT_TY_RE_Trace) {
                print "Grounds for rewind at: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            TEXT_TY_RE_EraseConstraints((token-->(RE_NEXT)));
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
            rtrue;
        }
        if (downwards) {
            rfalse;
        }
    }
    rfalse;
];
[ TEXT_TY_RE_FailSubexpressions token downwards;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
        }
        if (((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
            ((token-->(RE_DATA1)) = -1);
            ((token-->(RE_DATA2)) = -1);
        }
        if (downwards) {
            break;
        }
    }
];
[ TEXT_TY_RE_EraseConstraints token;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
        }
        if ((token-->(RE_DOWN))) {
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
        }
        (token = (token-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens i ch;
    if ((mfrom < 0)) {
        rfalse;
    }
    if (insens) {
        for ((i = mfrom):(i < mto):(i)++) {
            (ch = BlkValueRead(mtxt, i));
            if ((BlkValueRead(txt, (ipos)++) ~= ch or TEXT_TY_RevCase(ch))) {
                return (-(1));
            }
        }
    } else {
        for ((i = mfrom):(i < mto):(i)++) {
            if ((BlkValueRead(txt, (ipos)++) ~= BlkValueRead(mtxt, i))) {
                return (-(1));
            }
        }
    }
    return (mto - mfrom);
];
[ TEXT_TY_RE_Range ch ftxt rf rt negate insens i chm upper crev;
    if ((ch == 0)) {
        rfalse;
    }
    if ((negate == 1)) {
        if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, 0, insens)) {
            rfalse;
        }
        rtrue;
    }
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            switch (chm) {
                115:
                    if ((ch == 10 or 13 or 32 or 9)) {
                        rtrue;
                    }
                    ;
                83:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                        rtrue;
                    }
                    ;
                112:
                    if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                80:
                    if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                119:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                87:
                    if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                100:
                    if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                        rtrue;
                    }
                    ;
                68:
                    if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                        rtrue;
                    }
                    ;
                108:
                    if (CharIsOfCase(ch, 0)) {
                        rtrue;
                    }
                    ;
                76:
                    if ((CharIsOfCase(ch, 0) == 0)) {
                        rtrue;
                    }
                    ;
                117:
                    if (CharIsOfCase(ch, 1)) {
                        rtrue;
                    }
                    ;
                85:
                    if ((CharIsOfCase(ch, 1) == 0)) {
                        rtrue;
                    }
                    ;
                110:
                    if ((ch == 10)) {
                        rtrue;
                    }
                    ;
                116:
                    if ((ch == 9)) {
                        rtrue;
                    }
                    ;
            }
        } else {
            if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
                (upper = BlkValueRead(ftxt, (i + 2)));
                if ((((ch >= chm)) && ((ch <= upper)))) {
                    rtrue;
                }
                if (insens) {
                    (crev = TEXT_TY_RevCase(ch));
                    if ((((crev >= chm)) && ((crev <= upper)))) {
                        rtrue;
                    }
                }
                (i = (i + 2));
            } else {
                if ((chm == ch)) {
                    rtrue;
                }
                if (((insens) && ((chm == TEXT_TY_RevCase(ch))))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly r p p1 p2 cp cp1 cp2;
    if ((rtxt == 0 or 1)) {
        (cp = (txt-->(0)));
        (p = TEXT_TY_Temporarily_Transmute(txt));
    } else {
        TEXT_TY_Transmute(txt);
    }
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    if ((rtxt == 0 or 1)) {
        TEXT_TY_Untransmute(txt, p, cp);
    }
    return r;
];
[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly ctxt csize ilen i cl mpos cpos ch chm;
    (ilen = TEXT_TY_CharacterLength(txt));
    (TEXT_TY_RE_Err = 0);
    switch (ftxtype) {
        REGEXP_BLOB:
            (i = TEXT_TY_RE_CompileTree(ftxt, exactly));
            ;
        CHR_BLOB:
            (i = TEXT_TY_CHR_CompileTree(ftxt, exactly));
            ;
        default:
            print "*** bad ftxtype ***";
            new_line;
            rtrue;
            ;
    }
    if ((((i < 0)) || ((i > RE_MAX_PACKETS)))) {
        (TEXT_TY_RE_Err = i);
        print "*** Regular expression error: ";
        print (string) TEXT_TY_RE_Err;
        print " ***^";
        RunTimeProblem(RTP_REGEXPSYNTAXERROR);
        rfalse;
    }
    if (TEXT_TY_RE_Trace) {
        TEXT_TY_RE_DebugTree(ftxt);
        print "(compiled to ";
        print i;
        print " packets)^";
    }
    if ((ftxtype == REGEXP_BLOB)) {
        TEXT_TY_RE_EmptyMatchVars();
    }
    (mpos = 0);
    (chm = 0);
    (cpos = 0);
    while ((TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0)) {
        (chm)++;
        if (TEXT_TY_RE_Trace) {
            print "^*** Match ";
            print chm;
            print " found (";
            print (RE_PACKET_space-->(RE_DATA1));
            print ",";
            print (RE_PACKET_space-->(RE_DATA2));
            print "): ";
            if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
                print "<empty>";
            }
            for ((i = (RE_PACKET_space-->(RE_DATA1))):(i < (RE_PACKET_space-->(RE_DATA2))):(i)++) {
                print (char) BlkValueRead(txt, i);
            }
            print " ***^";
        }
        if ((rtxt == 0)) {
            break;
        }
        if ((rtxt ~= 0 or 1)) {
            if ((chm == 1)) {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                (csize = BlkValueLBCapacity(ctxt));
            }
            for ((i = cpos):(i < (RE_PACKET_space-->(RE_DATA1))):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
            BlkValueWrite(ctxt, cl, 0);
            TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
            (csize = BlkValueLBCapacity(ctxt));
            (cl = TEXT_TY_CharacterLength(ctxt));
        }
        (mpos = (RE_PACKET_space-->(RE_DATA2)));
        (cpos = mpos);
        if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
            (mpos)++;
        }
        if (TEXT_TY_RE_Trace) {
            if ((chm == 100)) {
                print "(Stopping after 100 matches.)^";
                break;
            }
        }
    }
    if ((chm > 0)) {
        if ((rtxt ~= 0 or 1)) {
            for ((i = cpos):(i < ilen):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
        if ((ftxtype == REGEXP_BLOB)) {
            TEXT_TY_RE_CreateMatchVars(txt);
            if (TEXT_TY_RE_Trace) {
                TEXT_TY_RE_DebugMatchVars(txt);
            }
        }
        if ((rtxt ~= 0 or 1)) {
            BlkValueWrite(ctxt, cl, 0);
            BlkValueCopy(txt, ctxt);
            BlkValueFree(ctxt);
        }
    }
    return chm;
];
[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref pos len ch i tosize x y case;
    if ((((txt_to == 0)) || ((BlkValueWeakKind(txt_to) ~= TEXT_TY)))) {
        rfalse;
    }
    if ((((txt_from == 0)) || ((BlkValueWeakKind(txt_from) ~= TEXT_TY)))) {
        return txt_to;
    }
    (pos = TEXT_TY_CharacterLength(txt_to));
    (tosize = BlkValueLBCapacity(txt_to));
    (len = TEXT_TY_CharacterLength(txt_from));
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt_from, i));
        if ((((ch == 92)) && ((i < (len - 1))))) {
            (ch = BlkValueRead(txt_from, ++(i)));
            if ((ch == 110)) {
                (ch = 10);
            }
            if ((ch == 116)) {
                (ch = 9);
            }
            (case = -1);
            if ((ch == 108)) {
                (case = 0);
            }
            if ((ch == 117)) {
                (case = 1);
            }
            if ((case >= 0)) {
                (ch = BlkValueRead(txt_from, ++(i)));
            }
            if ((((ch >= 48)) && ((ch <= 57)))) {
                (ch = (ch - 48));
                if ((ch < (RE_Subexpressions-->(10)))) {
                    (x = ((RE_Subexpressions-->(ch))-->(RE_DATA1)));
                    (y = ((RE_Subexpressions-->(ch))-->(RE_DATA2)));
                    if ((x >= 0)) {
                        for (:(x < y):(x)++) {
                            (ch = BlkValueRead(txt_ref, x));
                            if (((pos + 1) >= tosize)) {
                                if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                                    break;
                                }
                                (tosize = BlkValueLBCapacity(txt_to));
                            }
                            if ((case >= 0)) {
                                BlkValueWrite(txt_to, (pos)++, CharToCase(ch, case));
                            } else {
                                BlkValueWrite(txt_to, (pos)++, ch);
                            }
                        }
                    }
                }
                continue;
            }
        }
        if (((pos + 1) >= tosize)) {
            if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                break;
            }
            (tosize = BlkValueLBCapacity(txt_to));
        }
        BlkValueWrite(txt_to, (pos)++, ch);
    }
    BlkValueWrite(txt_to, pos, 0);
    return txt_to;
];
[ LIST_OF_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return LIST_OF_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            LIST_OF_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return LIST_OF_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            return LIST_OF_TY_QuickCopy(arg1, arg2);
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return LIST_OF_TY_KindData(arg1, arg2);
            ;
        EXTENT_KOVS:
            return (BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE);
            ;
        COPY_KOVS:
            LIST_OF_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return LIST_OF_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return LIST_OF_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = {";
            LIST_OF_TY_Say(arg1);
            print "} of kind ";
            print BlkValueRead(arg1, LIST_ITEM_KOV_F);
            ;
    }
    rfalse;
];
[ LIST_OF_TY_Create skov sb list;
    (skov = KindBaseTerm(skov, 0));
    (list = FlexAllocate((27*WORDSIZE), LIST_OF_TY, (BLK_FLAG_MULTIPLE + BLK_FLAG_WORD)));
    BlkValueWrite(list, LIST_ITEM_KOV_F, skov, 1);
    BlkValueWrite(list, LIST_LENGTH_F, 0, 1);
    (sb = BlkValueCreateSB1(sb, list));
    return sb;
];
[ LIST_OF_TY_Destroy list no_items i k;
    (k = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (KOVIsBlockValue(k)) {
        (no_items = BlkValueRead(list, LIST_LENGTH_F));
        for ((i = 0):(i < no_items):(i)++) {
            BlkValueFree(BlkValueRead(list, (i + LIST_ITEM_BASE)));
        }
    }
];
[ LIST_OF_TY_CopyKind to from;
    BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_QuickCopy to from;
    if ((BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_KindData list dummy;
    return BlkValueRead(list, LIST_ITEM_KOV_F);
];
[ LIST_OF_TY_Copy lto lfrom precopied_list_kov no_items i nv bk val splk;
    (no_items = BlkValueRead(lfrom, LIST_LENGTH_F));
    (bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F));
    if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
    } else {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
    }
    if (KOVIsBlockValue(bk)) {
        for ((i = 0):(i < no_items):(i)++) {
            (val = BlkValueRead(lfrom, (i + LIST_ITEM_BASE)));
            if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
                (nv = BlkValueCreate(precopied_list_kov));
            } else {
                (nv = BlkValueCreate(bk));
            }
            BlkValueCopy(nv, val);
            BlkValueWrite(lto, (i + LIST_ITEM_BASE), nv);
        }
    }
];
[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
    (delta = (BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F)));
    if (delta) {
        return delta;
    }
    (no_items = BlkValueRead(listleft, LIST_LENGTH_F));
    if ((no_items == 0)) {
        rfalse;
    }
    (delta = (BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F)));
    if (delta) {
        return delta;
    }
    (cf = LIST_OF_TY_ComparisonFn(listleft));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (BlkValueRead(listleft, (i + LIST_ITEM_BASE)) - BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (cf)(BlkValueRead(listleft, (i + LIST_ITEM_BASE)),BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_ComparisonFn list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_Distinguish txb1 txb2;
    if ((LIST_OF_TY_Compare(txb1, txb2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_Hash list len kov rv i;
    (rv = 0);
    (len = BlkValueRead(list, LIST_LENGTH_F));
    (kov = BlkValueRead(list, LIST_ITEM_KOV_F));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + GetHashValue(kov, BlkValueRead(list, (i + LIST_ITEM_BASE)))));
    }
    return rv;
];
[ LIST_OF_TY_Say list format no_items v i bk;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rtrue;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F)));
    if ((format == 1)) {
        print "{";
    }
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        switch (format) {
            2:
                DefArt(v);
                ;
            3:
                IndefArt(v);
                ;
            default:
                if ((bk == LIST_OF_TY)) {
                    LIST_OF_TY_Say(v, 1);
                } else {
                    if ((((bk == TEXT_TY)) && ((format == 1)))) {
                        print "~";
                        PrintKindValuePair(bk, v);
                        print "~";
                    } else {
                        PrintKindValuePair(bk, v);
                    }
                }
                ;
        }
        if ((i < (no_items - 2))) {
            print ", ";
        }
        if ((i == (no_items - 2))) {
            if ((format == 1)) {
                print ", ";
            } else {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((no_items ~= 2)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
        }
    }
    if ((format == 1)) {
        print "}";
    }
    (prior_named_list = no_items);
    (prior_named_list_gender = -1);
];
[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    (len = (desc)(-3));
    if (((len + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (len + LIST_ITEM_BASE)) == 0)) {
            rfalse;
        }
    }
    if (kov) {
        BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
    } else {
        BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
    }
    BlkValueWrite(list, LIST_LENGTH_F, len);
    (obj = 0);
    for ((i = 0):(i < len):(i)++) {
        (obj = (desc)(-2,obj,i));
        BlkValueWrite(list, (i + LIST_ITEM_BASE), obj);
    }
    return list;
];
[ LIST_OF_TY_FindItem list v i no_items cf;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            if ((v == BlkValueRead(list, (i + LIST_ITEM_BASE)))) {
                rtrue;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            if (((cf)(v,BlkValueRead(list, (i + LIST_ITEM_BASE))) == 0)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if (((nodups) && (LIST_OF_TY_FindItem(list, v)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    (contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + LIST_ITEM_BASE) + 1) > ex)) {
        if ((BlkValueSetLBCapacity(list, (ex + 16)) == 0)) {
            rfalse;
        }
    }
    if (KOVIsBlockValue(contents_kind)) {
        (nv = BlkValueCreate(contents_kind));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if (posnflag) {
        (posn)--;
        for ((i = no_items):(i > posn):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - 1) + LIST_ITEM_BASE)));
        }
        BlkValueWrite(list, (posn + LIST_ITEM_BASE), v);
    } else {
        BlkValueWrite(list, (no_items + LIST_ITEM_BASE), v);
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + 1));
    return list;
];
[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((((more == 0)) || ((BlkValueWeakKind(more) ~= LIST_OF_TY)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (msize = BlkValueRead(more, LIST_LENGTH_F));
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + msize) + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (((no_items + msize) + LIST_ITEM_BASE) + 8)) == 0)) {
            rfalse;
        }
    }
    if (posnflag) {
        (posn)--;
        for ((i = (no_items + msize)):(i >= (posn + msize)):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - msize) + LIST_ITEM_BASE)));
        }
        for ((j = 0):(j < msize):(j)++) {
            (v = BlkValueRead(more, (j + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            BlkValueWrite(list, ((posn + j) + LIST_ITEM_BASE), v);
        }
    } else {
        for (((i = 0),(j = 0)):(i < msize):(i)++) {
            (v = BlkValueRead(more, (i + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            if ((((nodups == 0)) || ((LIST_OF_TY_FindItem(list, v) == 0)))) {
                BlkValueWrite(list, ((no_items + j) + LIST_ITEM_BASE), v);
                (j)++;
            }
        }
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + j));
    return list;
];
[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    for ((i = 0):(i < no_items):(i)++) {
        (delendum = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        if ((cf == 0 or UnsignedCompare)) {
            (f = (v == delendum));
        } else {
            (f = ((cf)(v,delendum) == 0));
        }
        if (f) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                BlkValueFree(delendum);
            }
            for ((j = (i + 1)):(j < no_items):(j)++) {
                BlkValueWrite(list, ((j - 1) + LIST_ITEM_BASE), BlkValueRead(list, (j + LIST_ITEM_BASE)));
            }
            (no_items)--;
            (i)--;
            BlkValueWrite(list, LIST_LENGTH_F, no_items);
        }
    }
    if ((odsize ~= no_items)) {
        rfalse;
    }
    if (forgive) {
        rfalse;
    }
    print "*** Couldn't remove: the value ";
    PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
    print " was not present in the list ";
    LIST_OF_TY_Say(list, 1);
    print " ***^";
    RunTimeProblem(RTP_LISTRANGEERROR);
];
[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((((from > to)) || ((from <= 0)))) || ((to > no_items)))) {
        if (forgive) {
            if ((from <= 0)) {
                (from = 1);
            }
            if ((to >= no_items)) {
                (to = no_items);
            }
            if ((from > to)) {
                return list;
            }
        } else {
            print "*** Couldn't remove entries ";
            print from;
            print " to ";
            print to;
            print " from the list ";
            LIST_OF_TY_Say(list, 1);
            print ", which has entries in the range 1 to ";
            print no_items;
            print " ***^";
            RunTimeProblem(RTP_LISTRANGEERROR);
            rfalse;
        }
    }
    (to)--;
    (from)--;
    (d = ((to - from) + 1));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        for ((i = 0):(i < d):(i)++) {
            BlkValueFree(BlkValueRead(list, ((from + i) + LIST_ITEM_BASE)));
        }
    }
    for ((i = from):(i < (no_items - d)):(i)++) {
        BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i + d) + LIST_ITEM_BASE)));
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items - d));
    return list;
];
[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    (rsize = BlkValueRead(rlist, LIST_LENGTH_F));
    (cf = LIST_OF_TY_ComparisonFn(list));
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        for ((k = 0):(k < rsize):(k)++) {
            (w = BlkValueRead(rlist, (k + LIST_ITEM_BASE)));
            if ((cf == 0 or UnsignedCompare)) {
                (f = (v == w));
            } else {
                (f = ((cf)(v,w) == 0));
            }
            if (f) {
                if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                    BlkValueFree(v);
                }
                for ((j = (i + 1)):(j < no_items):(j)++) {
                    BlkValueWrite(list, ((j + LIST_ITEM_BASE) - 1), BlkValueRead(list, (j + LIST_ITEM_BASE)));
                }
                (no_items)--;
                (i)--;
                BlkValueWrite(list, LIST_LENGTH_F, no_items);
                break;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_GetLength list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return BlkValueRead(list, LIST_LENGTH_F);
];
[ LIST_OF_TY_Empty list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((BlkValueRead(list, LIST_LENGTH_F) == 0)) {
        rtrue;
    }
    rfalse;
];
[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((newsize < 0)) {
        return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
    }
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < newsize)) {
        if ((this_way_only == -1)) {
            return list;
        }
        (ex = BlkValueLBCapacity(list));
        if (((newsize + LIST_ITEM_BASE) > ex)) {
            if ((BlkValueSetLBCapacity(list, (newsize + LIST_ITEM_BASE)) == 0)) {
                rfalse;
            }
        }
        (dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F)));
        for ((i = no_items):(i < newsize):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), dv);
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    if ((no_items > newsize)) {
        if ((this_way_only == 1)) {
            return list;
        }
        if ((truncation_end == -1)) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = 0):(i < (no_items - newsize)):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
            for ((i = 0):(i < newsize):(i)++) {
                BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - newsize) + i)));
            }
        } else {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = newsize):(i < no_items):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    return list;
];
[ LIST_OF_TY_GetItem list i forgive no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        if (forgive) {
            rfalse;
        }
        print "*** Couldn't read from entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        RunTimeProblem(RTP_LISTRANGEERROR);
        if ((no_items >= 1)) {
            (i = 1);
        } else {
            rfalse;
        }
    }
    return BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1));
];
[ WriteLIST_OF_TY_GetItem list i val no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        print "*** Couldn't write to list entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        return RunTimeProblem(RTP_LISTRANGEERROR);
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), val);
];
[ LIST_OF_TY_PutItem list i v no_items nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if ((((i <= 0)) || ((i > no_items)))) {
        rfalse;
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), v);
];
[ LIST_OF_TY_Reverse list no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    for ((i = 0):((i*2) < no_items):(i)++) {
        (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
        BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - 1) - i)));
        BlkValueWrite(list, (((LIST_ITEM_BASE + no_items) - 1) - i), v);
    }
    return list;
];
[ LIST_OF_TY_Rotate list backwards no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    if (backwards) {
        (v = BlkValueRead(list, LIST_ITEM_BASE));
        for ((i = 0):(i < (no_items - 1)):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) + 1)));
        }
        BlkValueWrite(list, ((no_items - 1) + LIST_ITEM_BASE), v);
    } else {
        (v = BlkValueRead(list, ((no_items - 1) + LIST_ITEM_BASE)));
        for ((i = (no_items - 1)):(i > 0):(i)--) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
        }
        BlkValueWrite(list, LIST_ITEM_BASE, v);
    }
    return list;
];
[ LIST_OF_TY_Sort list dir prop cf i j no_items v;
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((dir == 2)) {
        if ((no_items < 2)) {
            rtrue;
        }
        for ((i = 1):(i < no_items):(i)++) {
            (j = (random((i + 1)) - 1));
            (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (LIST_ITEM_BASE + j)));
            BlkValueWrite(list, (LIST_ITEM_BASE + j), v);
        }
        rtrue;
    }
    SetSortDomain(ListSwapEntries, ListCompareEntries);
    if (cf) {
        (LIST_OF_TY_Sort_cf = BlkValueCompare);
    } else {
        (LIST_OF_TY_Sort_cf = 0);
    }
    SortArray(list, prop, dir, no_items, 0);
];
[ ListSwapEntries list i j v;
    if ((i == j)) {
        rtrue;
    }
    (v = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + j) - 1), v);
];
[ ListCompareEntries list col i j d cf;
    if ((i == j)) {
        rfalse;
    }
    (i = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    (j = BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    if (I7S_Col) {
        if ((_final_propertyexists(OBJECT_TY, i, I7S_Col))) {
            (i = _final_propertyvalue(OBJECT_TY, i, I7S_Col));
        } else {
            (i = 0);
        }
        if ((_final_propertyexists(OBJECT_TY, j, I7S_Col))) {
            (j = _final_propertyvalue(OBJECT_TY, j, I7S_Col));
        } else {
            (j = 0);
        }
        (cf = LIST_OF_TY_Sort_cf);
    } else {
        (cf = LIST_OF_TY_ComparisonFn(list));
    }
    if ((cf == 0)) {
        if ((i > j)) {
            rtrue;
        }
        if ((i < j)) {
            return (-(1));
        }
        rfalse;
    } else {
        return (cf)(i,j);
    }
];
[ COMBINATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return COMBINATION_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            COMBINATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return COMBINATION_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return COMBINATION_TY_KindData(arg1);
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            COMBINATION_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return COMBINATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return COMBINATION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            COMBINATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ COMBINATION_TY_Create kind sb long_block N i bk v;
    (N = KindBaseArity(kind));
    (long_block = FlexAllocate(((COMBINATION_ITEM_BASE + N)*WORDSIZE), COMBINATION_TY, BLK_FLAG_WORD));
    BlkValueWrite(long_block, COMBINATION_KIND_F, kind, 1);
    for ((i = 0):(i < N):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (v = BlkValueCreate(bk));
        } else {
            (v = DefaultValueOfKOV(bk));
        }
        BlkValueWrite(long_block, (COMBINATION_ITEM_BASE + i), v, 1);
    }
    return BlkValueCreateSB1(sb, long_block);
];
[ COMBINATION_TY_Destroy comb kind no_items i bk;
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            BlkValueFree(BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        }
    }
];
[ COMBINATION_TY_CopyKind to from;
    BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];
[ COMBINATION_TY_CopySB to from;
    BlkValueCopySB1(to, from);
];
[ COMBINATION_TY_KindData comb;
    return BlkValueRead(comb, COMBINATION_KIND_F);
];
[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov no_items i nv kind bk;
    (no_items = KindBaseArity(precopied_comb_kov));
    BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (nv = BlkValueCreate(bk));
            BlkValueCopy(nv, BlkValueRead(from_comb, (i + COMBINATION_ITEM_BASE)));
            BlkValueWrite(to_comb, (i + COMBINATION_ITEM_BASE), nv);
        }
    }
];
[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
    (kind = BlkValueRead(left_comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (cf = KOVComparisonFunction(bk));
        if ((cf == 0 or UnsignedCompare)) {
            (delta = (BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)) - BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        } else {
            (delta = (cf)(BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)),BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ COMBINATION_TY_Distinguish left_comb right_comb;
    if ((COMBINATION_TY_Compare(left_comb, right_comb) == 0)) {
        rfalse;
    }
    rtrue;
];
[ COMBINATION_TY_Hash comb kind rv no_items i bk;
    (rv = 0);
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (rv = ((rv*33) + GetHashValue(bk, BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)))));
    }
    return rv;
];
[ COMBINATION_TY_Say comb format no_items v i kind bk;
    if ((((comb == 0)) || ((BlkValueWeakKind(comb) ~= COMBINATION_TY)))) {
        rtrue;
    }
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    print "(";
    for ((i = 0):(i < no_items):(i)++) {
        if ((i > 0)) {
            print ", ";
        }
        (bk = KindBaseTerm(kind, i));
        (v = BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        if ((bk == LIST_OF_TY)) {
            LIST_OF_TY_Say(v, 1);
        } else {
            PrintKindValuePair(bk, v);
        }
    }
    print ")";
];
[ RELATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return RELATION_TY_Create(arg1, 0, arg2);
            ;
        DESTROY_KOVS:
            RELATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            RELATION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return RELATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return arg1;
            ;
        DEBUG_KOVS:
            print " = ";
            RELATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ RelationTest relation task X Y handler;
    (handler = RlnGetF(relation, RR_HANDLER));
    return (handler)(relation,task,X,Y);
];
[ RlnGetF rel fld i;
    (rel = BlkValueGetLongBlock(rel));
    return (rel-->(fld));
];
[ RlnSetF rel fld v;
    (rel = BlkValueGetLongBlock(rel));
    ((rel-->(fld)) = v);
];
[ EmptyRelationHandler relation task X Y;
    if ((task == RELS_EMPTY)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_Create kov from sb rel i skov handler;
    (rel = FlexAllocate(((RRV_DATA_BASE + (3*RRP_MIN_SIZE))*WORDSIZE), RELATION_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
    if ((((from == 0)) && ((kov ~= 0)))) {
        (from = DefaultValueFinder(kov));
    }
    if (from) {
        for ((i = 0):(i < RRV_DATA_BASE):(i)++) {
            BlkValueWrite(rel, i, BlkValueRead(from, i), 1);
        }
        if ((BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler)) {
            (handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, 1)));
            BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
            BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
            BlkValueWrite(rel, RRV_HANDLER, handler, 1);
            BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
            BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
            BlkValueWrite(rel, RRV_USED, 0, 1);
            BlkValueWrite(rel, RRV_FILLED, 0, 1);
        }
    } else {
        (handler = ChooseRelationHandler(kov));
        BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
        BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
        BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
        BlkValueWrite(rel, RRV_KIND, kov, 1);
        BlkValueWrite(rel, RRV_HANDLER, handler, 1);
        BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
        BlkValueWrite(rel, RRV_USED, 0, 1);
        BlkValueWrite(rel, RRV_FILLED, 0, 1);
    }
    return BlkValueCreateSB1(sb, rel);
];
[ RELATION_TY_Destroy rel handler;
    (handler = BlkValueRead(rel, RRV_HANDLER));
    (handler)(rel,RELS_DESTROY);
];
[ RELATION_TY_Copy lto lfrom handler;
    (handler = BlkValueRead(lto, RRV_HANDLER));
    (handler)(lto,RELS_COPY);
];
[ RELATION_TY_Compare rleft rright ind1 ind2;
    (ind1 = BlkValueRead(rleft, RRV_HANDLER));
    (ind2 = BlkValueRead(rright, RRV_HANDLER));
    if ((ind1 ~= ind2)) {
        return (ind1 - ind2);
    }
    if ((IsMutableRelationHandler(ind1) == 0)) {
        rfalse;
    }
    return (rleft - rright);
];
[ RELATION_TY_Distinguish rleft rright;
    if ((RELATION_TY_Compare(rleft, rright) == 0)) {
        rfalse;
    }
    rtrue;
];
[ RELATION_TY_Say rel;
    if ((rel == 0)) {
        print "(null relation)";
    } else {
        print (string) RlnGetF(rel, RR_NAME);
    }
];
[ RELATION_TY_Name rel txt;
    if (rel) {
        BlkValueWrite(rel, RRV_NAME, txt);
        BlkValueWrite(rel, RRV_DESCRIPTION, txt);
    }
];
[ ChooseRelationHandler kov sym;
    if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
        if (sym) {
            return SymHashListRelationHandler;
        }
        return HashListRelationHandler;
    }
    if (sym) {
        return SymDoubleHashSetRelationHandler;
    }
    return DoubleHashSetRelationHandler;
];
[ IsMutableRelationHandler h;
    if ((h == SymHashListRelationHandler or HashListRelationHandler or SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_SetValency rel val kov filled cur handler ext;
    (filled = BlkValueRead(rel, RRV_FILLED));
    if (filled) {
        RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
        rfalse;
    }
    (kov = BlkValueRead(rel, RRV_KIND));
    if ((val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O)) {
        if ((KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1))) {
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
        }
    }
    (cur = BlkValueRead(rel, RRV_HANDLER));
    switch (val) {
        RRVAL_V_TO_V:
            (handler = ChooseRelationHandler(kov, 0));
            ;
        RRVAL_V_TO_O:
            (handler = HashTableRelationHandler);
            ;
        RRVAL_O_TO_V:
            (handler = ReversedHashTableRelationHandler);
            ;
        RRVAL_O_TO_O:
            (handler = TwoInOneHashTableRelationHandler);
            ;
        RRVAL_EQUIV:
            (handler = EquivHashTableRelationHandler);
            ;
        RRVAL_SYM_V_TO_V:
            (handler = ChooseRelationHandler(kov, 1));
            ;
        RRVAL_SYM_O_TO_O:
            (handler = Sym2in1HashTableRelationHandler);
            ;
        default:
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
            ;
    }
    if ((cur == handler)) {
        rtrue;
    }
    if ((cur == TwoInOneHashTableRelationHandler)) {
        (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (3*ext)));
    } else {
        if ((handler == TwoInOneHashTableRelationHandler)) {
            (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
            BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (4*ext)));
        }
    }
    BlkValueWrite(rel, RRV_HANDLER, handler);
];
[ RELATION_TY_GetValency rel handler;
    return ((BlkValueRead(rel, RRV_PERMISSIONS))&(VALENCY_MASK));
];
[ DoubleHashSetRelationHandler rel task X Y sym kov kx ky at tmp v;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((tmp)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (ky) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((tmp)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (Y) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((tmp)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            DoubleHashSetRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                    if ((Y == RLANY_GET_X or RLANY_CAN_GET_X)) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    } else {
                                        (v = BlkValueRead(rel, (tmp + 1)));
                                        if (KOVIsBlockValue(kx)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_Y)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 2));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                            (v = BlkValueRead(rel, (tmp + 1)));
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(v, X) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((v ~= X)) {
                                                    continue;
                                                }
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((((X == 0)) || ((BlkValueWeakKind(X) ~= LIST_OF_TY)))) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X, RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (tmp)++;
                                                        if ((Y == RLIST_ALL_Y)) {
                                                            (tmp)++;
                                                        }
                                                        (v = BlkValueRead(rel, tmp));
                                                        LIST_OF_TY_InsertItem(X, v, 0, 0, 1);
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (Y = BlkValueCreate(kov));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (v = BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
                                                        (v = BlkValueRead(rel, (tmp + 2)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), v);
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
    switch (task) {
        RELS_TEST:
            if ((at >= 0)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at >= 0)) {
                rtrue;
            }
            (at = (~(at)));
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
            if (KOVIsBlockValue(kx)) {
                (X = BlkValueCopy(BlkValueCreate(kx), X));
            }
            if (KOVIsBlockValue(ky)) {
                (Y = BlkValueCopy(BlkValueCreate(ky), Y));
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
            DoubleHashSetCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            if (KOVIsBlockValue(ky)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ DoubleHashSetLookUp rel kx ky X Y hashv i free mask perturb flags;
    (hashv = (GetHashValue(kx, X) + GetHashValue(ky, Y)));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ DoubleHashSetCheckResize rel filled ext newext temp i at kov kx ky F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ DoubleHashSetEntryMatches rel at kx ky X Y cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    (cy = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
    if (KOVIsBlockValue(ky)) {
        if ((BlkValueCompare(cy, Y) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cy ~= Y)) {
            rfalse;
        }
    }
    rtrue;
];
[ HashListRelationHandler rel task X Y sym kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];
[ HashTableRelationHandler rel task X Y kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ ReversedHashTableRelationHandler rel task X Y kov kx ky swap;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    switch (task) {
        RELS_SET_VALENCY:
            return RELATION_TY_SetValency(rel, X);
            ;
        RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
            return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
            ;
        RELS_LOOKUP_ANY:
            switch (Y) {
                RLANY_GET_X:
                    (Y = RLANY_GET_Y);
                    ;
                RLANY_GET_Y:
                    (Y = RLANY_GET_X);
                    ;
                RLANY_CAN_GET_X:
                    (Y = RLANY_CAN_GET_Y);
                    ;
                RLANY_CAN_GET_Y:
                    (Y = RLANY_CAN_GET_X);
                    ;
            }
            ;
        RELS_LOOKUP_ALL_X:
            (task = RELS_LOOKUP_ALL_Y);
            ;
        RELS_LOOKUP_ALL_Y:
            (task = RELS_LOOKUP_ALL_X);
            ;
        RELS_SHOW:
            (swap = X);
            (X = Y);
            (Y = swap);
            (swap = kx);
            (kx = ky);
            (ky = swap);
            ;
        RELS_LIST:
            switch (Y) {
                RLIST_ALL_X:
                    (Y = RLIST_ALL_Y);
                    ;
                RLIST_ALL_Y:
                    (Y = RLIST_ALL_X);
                    ;
            }
            ;
    }
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ SymDoubleHashSetRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        DoubleHashSetRelationHandler(rel, task, Y, X);
    }
    return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];
[ SymHashListRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        HashListRelationHandler(rel, task, Y, X);
    }
    return HashListRelationHandler(rel, task, X, Y);
];
[ Sym2in1HashTableRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        TwoInOneHashTableRelationHandler(rel, task, Y, X);
    }
    return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];
[ HashCoreRelationHandler rel task kx ky X Y mult sym rev at tmp fl;
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((fl)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (((ky) || ((~~(((fl)&(RRF_SINGLE))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (((Y) || ((~~(((fl)&(RRF_SINGLE))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    switch (RELATION_TY_GetValency(rel)) {
                        RRVAL_SYM_V_TO_V:
                            (sym = 1);
                            (tmp = KOVComparisonFunction(kx));
                            if ((~~(tmp))) {
                                (tmp = UnsignedCompare);
                            }
                            ;
                        RRVAL_O_TO_V:
                            (rev = 1);
                            ;
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((fl)&(RRF_SINGLE))) {
                                if (((sym) && (((tmp)(X,Y) > 0)))) {
                                    continue;
                                }
                                print "  ";
                                if (rev) {
                                    PrintKindValuePair(ky, Y);
                                } else {
                                    PrintKindValuePair(kx, X);
                                }
                                if (sym) {
                                    print " <=> ";
                                } else {
                                    print " >=> ";
                                }
                                if (rev) {
                                    PrintKindValuePair(kx, X);
                                } else {
                                    PrintKindValuePair(ky, Y);
                                }
                                print "^";
                            } else {
                                for ((mult = 1):(mult <= LIST_OF_TY_GetLength(Y)):(mult)++) {
                                    (fl = LIST_OF_TY_GetItem(Y, mult));
                                    if (((sym) && (((tmp)(X,fl) > 0)))) {
                                        continue;
                                    }
                                    print "  ";
                                    if (rev) {
                                        PrintKindValuePair(ky, fl);
                                    } else {
                                        PrintKindValuePair(kx, X);
                                    }
                                    if (sym) {
                                        print " <=> ";
                                    } else {
                                        print " >=> ";
                                    }
                                    if (rev) {
                                        PrintKindValuePair(kx, X);
                                    } else {
                                        PrintKindValuePair(ky, fl);
                                    }
                                    print "^";
                                }
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            HashCoreRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_GET_Y or RLANY_CAN_GET_Y)) {
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at >= 0)) {
                                    if ((Y == RLANY_CAN_GET_Y)) {
                                        rtrue;
                                    }
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    (tmp = BlkValueRead(rel, (tmp + 2)));
                                    if (((fl)&(RRF_SINGLE))) {
                                        return tmp;
                                    }
                                    return LIST_OF_TY_GetItem(tmp, 1);
                                }
                            } else {
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(ky)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    (at = HashCoreLookUp(rel, kx, X));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            LIST_OF_TY_InsertItem(Y, tmp);
                                        } else {
                                            LIST_OF_TY_AppendList(Y, tmp);
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((BlkValueWeakKind(X) ~= LIST_OF_TY)) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)));
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            LIST_OF_TY_InsertItem(X, tmp, 0, 0, 1);
                                                        } else {
                                                            LIST_OF_TY_AppendList(X, tmp, 0, 0, 1);
                                                        }
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                if ((RELATION_TY_GetValency(rel) == RRVAL_O_TO_V)) {
                                                    (rev = 1);
                                                }
                                                (Y = BlkValueCreate(COMBINATION_TY, tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + rev), BlkValueRead(rel, (tmp + 1)));
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), tmp);
                                                            LIST_OF_TY_InsertItem(X, Y);
                                                        } else {
                                                            for ((mult = LIST_OF_TY_GetLength(tmp)):(mult > 0):(mult)--) {
                                                                BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), LIST_OF_TY_GetItem(tmp, mult));
                                                                LIST_OF_TY_InsertItem(X, Y);
                                                            }
                                                        }
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            } else {
                return LIST_OF_TY_FindItem(tmp, Y);
            }
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                if (KOVIsBlockValue(ky)) {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                HashCoreCheckResize(rel);
                break;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                if (mult) {
                    (fl = BlkValueCreate(LIST_OF_TY));
                    BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
                    LIST_OF_TY_SetLength(fl, 2);
                    BlkValueWrite(fl, LIST_ITEM_BASE, tmp);
                    LIST_OF_TY_PutItem(fl, 2, Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), fl);
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_USED);
                } else {
                    if (KOVIsBlockValue(ky)) {
                        BlkValueFree(tmp);
                        (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                    }
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                }
            } else {
                LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
            }
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) ~= 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp ~= Y)) {
                        rtrue;
                    }
                }
                if (KOVIsBlockValue(ky)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                }
                .DeleteEntryIgnoringY;
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
                if (KOVIsBlockValue(kx)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            } else {
                LIST_OF_TY_RemoveValue(tmp, Y, 1);
                if ((LIST_OF_TY_GetLength(tmp) == 0)) {
                    BlkValueFree(tmp);
                    jump DeleteEntryIgnoringY;
                }
            }
            rtrue;
            ;
    }
    rtrue;
];
[ HashCoreLookUp rel kx X hashv i free mask perturb flags;
    (hashv = GetHashValue(kx, X));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (HashCoreEntryMatches(rel, i, kx, X)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (HashCoreEntryMatches(rel, i, kx, X)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ HashCoreCheckResize rel filled ext newext temp i at kov kx F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = HashCoreLookUp(rel, kx, X));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ HashCoreEntryMatches rel at kx X cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    rtrue;
];
[ EquivHashTableRelationHandler rel task X Y kx at at2 tmp fl i ext;
    (kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            if (KOVIsBlockValue(kx)) {
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    (at)--;
                }
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                if (KOVIsBlockValue(kx)) {
                    (at = BlkValueRead(rel, RRV_STORAGE));
                    while ((at >= 0)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1));
                        }
                        (at)--;
                    }
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for (((at = 0),(X = RRV_DATA_BASE)):(at <= ext):((at)++,(X = (X + 3)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            BlkValueWrite(rel, (X + 2), (-(BlkValueRead(rel, (X + 2)))));
                        }
                    }
                    for (((at = 0),((X = RRV_DATA_BASE),(fl = 0))):(at <= ext):((at)++,((X = (X + 3)),(fl = 0)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            (fl = BlkValueRead(rel, (X + 2)));
                            if ((fl > 0)) {
                                continue;
                            }
                            BlkValueWrite(rel, (X + 2), (-(fl)));
                            (tmp = BlkValueRead(rel, (X + 1)));
                            (i = 0);
                            for (((at2 = (at + 1)),(Y = (RRV_DATA_BASE + (3*at2)))):(at2 <= ext):((at2)++,(Y = (Y + 3)))) {
                                if (((BlkValueRead(rel, Y))&(RRF_USED))) {
                                    if ((BlkValueRead(rel, (Y + 2)) ~= fl)) {
                                        continue;
                                    }
                                    BlkValueWrite(rel, (Y + 2), (-(fl)));
                                    if ((~~(i))) {
                                        print "  { ";
                                        PrintKindValuePair(kx, tmp);
                                        (i = 1);
                                    }
                                    print ", ";
                                    PrintKindValuePair(kx, BlkValueRead(rel, (Y + 1)));
                                }
                            }
                            if (i) {
                                print " }^";
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y)) {
                                rtrue;
                            }
                            return X;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at < 0)) {
                                    LIST_OF_TY_InsertItem(Y, X);
                                } else {
                                    (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        if (((fl)&(RRF_USED))) {
                                            if ((BlkValueRead(rel, (tmp + 2)) ~= X)) {
                                                continue;
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                        }
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LIST)) {
                                    print "*** Domains of equivalence relations cannot be listed ***^";
                                    return X;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    (at2 = HashCoreLookUp(rel, kx, Y));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                if (KOVIsBlockValue(kx)) {
                    if ((BlkValueCompare(X, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((X == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            }
            if ((at2 < 0)) {
                rfalse;
            }
            if ((at == at2)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) == tmp)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if (KOVIsBlockValue(kx)) {
                if ((BlkValueCompare(X, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((X == Y)) {
                    rtrue;
                }
            }
            if ((at < 0)) {
                if ((at2 < 0)) {
                    (tmp = 0);
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for ((i = 0):(i <= ext):(i)++) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
                        if (((fl)&(RRF_USED))) {
                            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*i)) + 2)));
                            if ((fl > tmp)) {
                                (tmp = fl);
                            }
                        }
                    }
                    (tmp)++;
                    BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 2));
                    (at = (~(at)));
                    if (KOVIsBlockValue(kx)) {
                        (X = BlkValueCopy(BlkValueCreate(kx), X));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                    (at2 = (~(HashCoreLookUp(rel, kx, Y))));
                    if (KOVIsBlockValue(kx)) {
                        (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                    jump CheckResize;
                }
                (at = (~(at)));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                jump CheckResize;
            }
            if ((at2 < 0)) {
                (at2 = (~(at2)));
                if (KOVIsBlockValue(kx)) {
                    (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                jump CheckResize;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
            if ((tmp < fl)) {
                (i = tmp);
                (tmp = fl);
                (fl = i);
            }
            (ext = BlkValueRead(rel, RRV_STORAGE));
            for ((at = 0):(at <= ext):(at)++) {
                (i = ((RRV_DATA_BASE + (3*at)) + 2));
                if ((BlkValueRead(rel, i) == tmp)) {
                    BlkValueWrite(rel, i, fl);
                }
            }
            .CheckResize;
            HashCoreCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((((at < 0)) || ((at2 < 0)))) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) ~= tmp)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ TwoInOneHashTableRelationHandler rel task X Y sym kov kx ky at at2 tmp fl;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_USED))) {
                    if (((((kx) && (((fl)&(RRF_ENTKEYX))))) || (((ky) && (((fl)&(RRF_ENTKEYY))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    if (((fl)&(RRF_USED))) {
                        if (((((X) && (((fl)&(RRF_ENTKEYX))))) || (((Y) && (((fl)&(RRF_ENTKEYY))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            if (((fl)&(RRF_ENTKEYX))) {
                                (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            } else {
                                (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            }
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), tmp);
                            if (((fl)&(RRF_HASX))) {
                                (at2 = TwoInOneLookUp(rel, kx, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 2)), RRF_ENTKEYX));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 3), tmp);
                                }
                            }
                            if (((fl)&(RRF_HASY))) {
                                (at2 = TwoInOneLookUp(rel, ky, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)), RRF_ENTKEYY));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), tmp);
                                }
                            }
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                        if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (4*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                                BlkValueWrite(rel, (tmp + 3), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            switch (Y) {
                                RLANY_GET_X, RLANY_CAN_GET_X:
                                    (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                            if ((Y == RLANY_CAN_GET_X)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 2));
                                        }
                                    }
                                    ;
                                RLANY_GET_Y, RLANY_CAN_GET_Y:
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            if ((Y == RLANY_CAN_GET_Y)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 3));
                                        }
                                    }
                                    ;
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                if ((at >= 0)) {
                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 3)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                (fl = ((RRF_USED + RRF_ENTKEYX) + RRF_HASY));
                                                jump ListEntryKeys;
                                                ;
                                            RLIST_ALL_Y:
                                                (fl = ((RRF_USED + RRF_ENTKEYY) + RRF_HASX));
                                                .ListEntryKeys;
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    if ((((BlkValueRead(rel, tmp))&(fl)) == fl)) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)), 0, 0, 1);
                                                    }
                                                }
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (tmp = BlkValueRead(X, LIST_ITEM_KOV_F));
                                                if ((KindAtomic(tmp) ~= COMBINATION_TY)) {
                                                    rfalse;
                                                }
                                                (Y = BlkValueCreate(tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), BlkValueRead(rel, (tmp + 3)));
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        return X;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((~~(((fl)&(RRF_HASY))))) {
                rfalse;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((tmp == Y)) {
                    rtrue;
                }
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                (fl = ((RRF_USED + RRF_HASY) + RRF_ENTKEYX));
                if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                    (fl = (fl + RRF_ENTKEYY));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
            } else {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_HASY))) {
                    (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                    if (KOVIsBlockValue(ky)) {
                        if ((BlkValueCompare(tmp, Y) == 0)) {
                            rtrue;
                        }
                    } else {
                        if ((tmp == Y)) {
                            rtrue;
                        }
                    }
                    (at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY));
                    if ((at2 >= 0)) {
                        TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                    }
                } else {
                    BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), (fl + RRF_HASY));
                }
                (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
            }
            (at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY));
            if (KOVIsBlockValue(ky)) {
                if ((at2 >= 0)) {
                    (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at2)) + 1)));
                } else {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
            if ((at2 >= 0)) {
                TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
            } else {
                (at2 = (~(at2)));
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at2))));
            if ((fl == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            (fl = ((fl)|(((RRF_USED + RRF_HASX) + RRF_ENTKEYY))));
            if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                (fl = ((fl)|(RRF_ENTKEYX)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at2)), fl);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 1), Y);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), X);
            TwoInOneCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((((fl)&(RRF_HASY)) == 0)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) ~= 0)) {
                    rtrue;
                }
            } else {
                if ((tmp ~= Y)) {
                    rtrue;
                }
            }
            TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
            rtrue;
            ;
    }
];
[ TwoInOneDelete rel at kx ky ekflag both fl at2 E i;
    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
    if ((ekflag == RRF_ENTKEYX)) {
        if (((fl)&(RRF_HASY))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 3));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                }
                if ((at2 == at)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                }
            }
            (fl = ((fl)&((~(RRF_HASY)))));
        }
    } else {
        if (((fl)&(RRF_HASX))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 2));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
                    if ((at2 == at)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    }
                }
            }
            (fl = ((fl)&((~(RRF_HASX)))));
        }
    }
    if ((((fl)&((RRF_HASX + RRF_HASY))) == 0)) {
        if (((((((fl)&(RRF_ENTKEYX))) && (KOVIsBlockValue(kx)))) || ((((((ky ~= kx)) && (((fl)&(RRF_ENTKEYY))))) && (KOVIsBlockValue(ky)))))) {
            BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
        }
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), RRF_DELETED);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), 0);
        BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
    } else {
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
    }
];
[ TwoInOneLookUp rel ke E ekflag hashv i free mask perturb flags;
    (hashv = GetHashValue(ke, E));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ TwoInOneCheckResize rel filled ext newext temp i at kov kx ky F E X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(4*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*4)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*4)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*4)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (4*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (E = BlkValueRead(temp, ((4*i) + 1), 1));
            (X = BlkValueRead(temp, ((4*i) + 2), 1));
            (Y = BlkValueRead(temp, ((4*i) + 3), 1));
            if (((F)&(RRF_ENTKEYX))) {
                (at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
            } else {
                (at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
            }
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), E);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
        }
        FlexFree(temp);
    }
];
[ TwoInOneEntryMatches rel at ke E ce;
    (ce = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
    if (KOVIsBlockValue(ke)) {
        if ((BlkValueCompare(ce, E) ~= 0)) {
            rfalse;
        }
    } else {
        if ((ce ~= E)) {
            rfalse;
        }
    }
    rtrue;
];
[ RELATION_TY_Empty rel set handler;
    (handler = RlnGetF(rel, RR_HANDLER));
    return (handler)(rel,RELS_EMPTY,set);
];
[ RELATION_TY_EquivalenceAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_EQUIVALENCE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_EQUIVALENCE));
        if ((((perms)&(RELS_SYMMETRIC)) == 0)) {
            (perms = (perms + RELS_SYMMETRIC));
        }
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_EQUIVALENCE));
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to an equivalence relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_SymmetricAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_SYMMETRIC))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_SYMMETRIC));
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_SYMMETRIC));
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a symmetric relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToOAdjective rel set perms state handler i;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == (RELS_X_UNIQUE + RELS_Y_UNIQUE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_X_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToOAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_Y_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == 0)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    if ((((set == 0)) && (state))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ Relation_Now1to1 obj1 relation_property obj2 ol;
    if (obj2) {
        objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, ol, relation_property) == obj2)) {
                (_final_store_property(OBJECT_TY,ol,relation_property, 0));
            }
        }
    }
    if (obj1) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
    }
];
[ Relation_NowN1toV obj1 relation_property obj2;
    if (((obj1) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
    }
];
[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N;
    if (obj2) {
        (N = KOVDomainSize(KOV));
        for ((ol = 1):(ol <= N):(ol)++) {
            if ((GProperty(KOV, ol, relation_property) == obj2)) {
                WriteGProperty(KOV, ol, relation_property, 0);
            }
        }
    }
    if (obj1) {
        WriteGProperty(KOV, obj1, relation_property, obj2);
    }
];
[ Relation_NowN1toVV obj1 obj2 KOV relation_property;
    if (((obj1) && ((GProperty(KOV, obj1, relation_property) == obj2)))) {
        WriteGProperty(KOV, obj1, relation_property, 0);
    }
];
[ Relation_NowS1to1 obj1 relation_property obj2;
    if ((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) {
        if (_final_propertyvalue(OBJECT_TY, obj1, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj1, relation_property),relation_property, 0));
        }
        if (_final_propertyvalue(OBJECT_TY, obj2, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj2, relation_property),relation_property, 0));
        }
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
        (_final_store_property(OBJECT_TY,obj2,relation_property, obj1));
    }
];
[ Relation_NowSN1to1 obj1 relation_property obj2;
    if ((((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
        (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
    }
];
[ Relation_NowS1to1V obj1 obj2 KOV relation_property;
    if (GProperty(KOV, obj1, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
    }
    if (GProperty(KOV, obj2, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
    }
    WriteGProperty(KOV, obj1, relation_property, obj2);
    WriteGProperty(KOV, obj2, relation_property, obj1);
];
[ Relation_NowSN1to1V obj1 obj2 KOV relation_property;
    if ((GProperty(KOV, obj1, relation_property) == obj2)) {
        WriteGProperty(KOV, obj1, relation_property, 0);
        WriteGProperty(KOV, obj2, relation_property, 0);
    }
];
[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    ((vtov_structure-->(pr)) = (((vtov_structure-->(pr)))|(i1)));
];
[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowNVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        ((vtov_structure-->(pr)) = ((vtov_structure-->(pr)) - i1));
    }
];
[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    if (((sym) && ((obj2 > obj1)))) {
        (sym = obj1);
        (obj1 = obj2);
        (obj2 = sym);
    }
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            RunTimeProblem(RTP_IMPREL, obj1, relation);
            rfalse;
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            RunTimeProblem(RTP_IMPREL, obj2, relation);
            rfalse;
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        rtrue;
    }
    rfalse;
];
[ Relation_NowEquiv obj1 relation_property obj2 big little;
    (big = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (little = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
        (big = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    }
    objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == big)) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, little));
        }
    }
];
[ Relation_NowNEquiv obj1 relation_property obj2 old new;
    (old = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) > new)) {
            (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
        }
    }
    (new)++;
    (_final_store_property(OBJECT_TY,obj1,relation_property, new));
];
[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
    (big = GProperty(KOV, obj1, relation_property));
    (little = GProperty(KOV, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = GProperty(KOV, obj1, relation_property));
        (big = GProperty(KOV, obj2, relation_property));
    }
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) == big)) {
            WriteGProperty(KOV, i, relation_property, little);
        }
    }
];
[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
    (old = GProperty(KOV, obj1, relation_property));
    (new = GProperty(KOV, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) > new)) {
            (new = GProperty(KOV, i, relation_property));
        }
    }
    (new)++;
    WriteGProperty(KOV, obj1, relation_property, new);
];
[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    if (sym) {
                        print "  <=>  ";
                    } else {
                        print "  >=>  ";
                    }
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    (proutine2)(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    (proutine1)(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if ((x == 0)) {
                    print (string) RlnGetF(relation, RR_DESCRIPTION);
                    print ":^";
                    (x = 1);
                }
                print "  ";
                (proutine1)(obj1);
                print "  >=>  ";
                (proutine2)(obj2);
                print "^";
            }
        }
    }
];
[ Relation_ShowOtoO relation sym x relation_property t tr N obj1 obj2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (tr = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            CDefArt(obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    } else {
        (N = KOVDomainSize(t));
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            (obj2 = GProperty(t, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            PrintKindValuePair(t, obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    }
];
[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
    } else {
        (N2 = KOVDomainSize(t2));
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        }
    }
];
[ RSE_Flip KOV v relation_property x;
    (x = GProperty(KOV, v, relation_property));
    (x = (-(x)));
    WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
    if ((GProperty(KOV, v, relation_property) < 0)) {
        rtrue;
    }
    rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
    print (string) RlnGetF(relation, RR_DESCRIPTION);
    print ":^";
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
        }
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (v = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                (c = 0);
                objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
                    give obj2 ~workflag2;
                }
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) == v)) {
                        give obj2 workflag2;
                        (_final_store_property(OBJECT_TY,obj2,relation_property, (-(v))));
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  { ";
                    WriteListOfMarkedObjects(ENGLISH_BIT);
                    print " }^";
                } else {
                    (_final_store_property(OBJECT_TY,obj1,relation_property, v));
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (c)++;
                give obj1 workflag2;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c < 4)) {
            WriteListOfMarkedObjects(ENGLISH_BIT);
            print " in";
        } else {
            print c;
        }
        if ((c == 1)) {
            print " a";
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            RSE_Flip(t, obj1, relation_property);
        }
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (v = GProperty(t, obj1, relation_property));
                (c = 0);
                for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                    if ((GProperty(t, obj2, relation_property) == v)) {
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  {";
                    (d = 0);
                    for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                        if ((GProperty(t, obj2, relation_property) == v)) {
                            print " ";
                            PrintKindValuePair(t, obj2);
                            if ((d < (c - 1))) {
                                print ",";
                            }
                            print " ";
                            RSE_Flip(t, obj2, relation_property);
                            (d)++;
                        }
                    }
                    print "}^";
                } else {
                    WriteGProperty(t, obj1, relation_property, v);
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (c)++;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c == 1)) {
            print "a";
        } else {
            print c;
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                RSE_Flip(t, obj1, relation_property);
            }
        }
    }
];
[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
            (obj1 = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
                } else {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
            (obj1 = GProperty(t2, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    WriteGProperty(t2, obj2, relation_property, 0);
                } else {
                    rfalse;
                }
            }
        }
    }
    if ((t1 ~= t2)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
                    } else {
                        rfalse;
                    }
                }
            }
        } else {
            for ((obj1 = 1):(obj1 <= N2):(obj1)++) {
                (obj2 = GProperty(t1, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        WriteGProperty(t1, obj1, relation_property, 0);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyEquiv relation sym clear relation_property obj1 obj2 t N v;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if (clear) {
        (v = 1);
        if ((t == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (v)++));
            }
        } else {
            for ((obj1 = 1):(obj1 <= N):(obj1)++) {
                WriteGProperty(t, obj1, relation_property, (v)++);
            }
        }
        rtrue;
    }
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                if ((((obj1 < obj2)) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == _final_propertyvalue(OBJECT_TY, obj2, relation_property))))) {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            for ((obj2 = (obj1 + 1)):(obj1 <= N):(obj1)++) {
                if ((GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))) {
                    rfalse;
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ RelationRouteTo relation from to count handler;
    if (count) {
        if ((from == 0)) {
            return (-(1));
        }
        if ((to == 0)) {
            return (-(1));
        }
        if ((relation == 0)) {
            return (-(1));
        }
    } else {
        if ((from == 0)) {
            rfalse;
        }
        if ((to == 0)) {
            rfalse;
        }
        if ((relation == 0)) {
            rfalse;
        }
    }
    if ((from == to)) {
        rfalse;
    }
    if ((((RlnGetF(relation, RR_PERMISSIONS))&(RELS_ROUTE_FIND)) == 0)) {
        RunTimeProblem(RTP_ROUTELESS);
        rfalse;
    }
    if ((RlnGetF(relation, RR_STORAGE) == 0)) {
        rfalse;
    }
    (handler = RlnGetF(relation, RR_HANDLER));
    if (count) {
        return (handler)(relation,RELS_ROUTE_FIND_COUNT,from,to);
    }
    return (handler)(relation,RELS_ROUTE_FIND,from,to);
];
[ RelFollowVector rv from to obj i;
    if ((rv == 0)) {
        return (-(1));
    }
    (i = 0);
    (obj = from);
    while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
        (i)++;
        (obj = (obj.vector));
    }
    return i;
];
[ OtoVRelRouteTo relation_property from to previous;
    while (((((to) && ((_final_propertyexists(OBJECT_TY, to, relation_property))))) && (_final_propertyvalue(OBJECT_TY, to, relation_property)))) {
        (previous = _final_propertyvalue(OBJECT_TY, to, relation_property));
        ((previous.vector) = to);
        if ((previous == from)) {
            return to;
        }
        (to = previous);
    }
    rfalse;
];
[ VtoORelRouteTo relation_property from to next start;
    (start = from);
    while (((((from) && ((_final_propertyexists(OBJECT_TY, from, relation_property))))) && (_final_propertyvalue(OBJECT_TY, from, relation_property)))) {
        (next = _final_propertyvalue(OBJECT_TY, from, relation_property));
        ((from.vector) = next);
        if ((next == to)) {
            return (start.vector);
        }
        (from = next);
    }
    rfalse;
];
[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    if ((vtov_structure-->(VTOVS_CACHE))) {
        return FastVtoVRelRouteTo(relation, from, to, count);
    }
    (left_ix = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_vector))))) {
        ((obj.vector) = 0);
    }
    ((to.vector) = 1);
    while (1) {
        (progressed = 0);
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            if (((obj.vector) == 0)) {
                objectloop (obj2 ofclass Object && (((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) && (((obj2.vector) > 0)))) {
                    if (Relation_TestVtoV(obj, relation, obj2)) {
                        ((obj.vector) = ((obj2)|(WORD_HIGHBIT)));
                        (progressed = 1);
                        continue;
                    }
                }
            }
        }
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            ((obj.vector) = (((obj.vector))&((~(WORD_HIGHBIT)))));
        }
        if ((from.vector)) {
            break;
        }
        if ((progressed == 0)) {
            break;
        }
    }
    if (count) {
        if (((from.vector) == 0)) {
            return (-(1));
        }
        (i = 0);
        (obj = from);
        while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
            (i)++;
            (obj = (obj.vector));
        }
        return i;
    }
    return (from.vector);
];
[ FastVtoVRelRouteTo relation from to count domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
    (domainsize = (RlnGetF(relation, RR_STORAGE)-->(2)));
    (left_ix = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_LEFT_INDEX_PROP)));
    if ((((_final_propertyexists(OBJECT_TY, from, left_ix))) && ((_final_propertyexists(OBJECT_TY, to, left_ix))))) {
        if ((domainsize < 256)) {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + (domainsize*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 1);
                            ((cache2->(offset)) = _final_propertyvalue(OBJECT_TY, ox, left_ix));
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 0);
                            ((cache2->(offset)) = 255);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache->(offset)) = (axy + ayj));
                                        ((cache2->(offset)) = (cache2->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            (oy = (cache2->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
            if ((oy < 255)) {
                objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                    if ((_final_propertyvalue(OBJECT_TY, ox, left_ix) == oy)) {
                        return ox;
                    }
                }
            }
            rfalse;
        } else {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + ((WORDSIZE*domainsize)*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 1);
                            ((cache2-->(offset)) = ox);
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 0);
                            ((cache2-->(offset)) = 0);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache-->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache-->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache-->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache-->(offset)) = (axy + ayj));
                                        ((cache2-->(offset)) = (cache2-->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            return (cache2-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix))));
        }
    }
    if (count) {
        return (-(1));
    }
    rfalse;
];
[ RunTimeProblem n par1 par2 par3 ln file;
    if (((RTP_Buffer-->(0)) == -1)) {
        ((RTP_Buffer-->(0)) = n);
        ((RTP_Buffer-->(1)) = par1);
        ((RTP_Buffer-->(2)) = par2);
        ((RTP_Buffer-->(3)) = par3);
        ((RTP_Buffer-->(4)) = ln);
        ((RTP_Buffer-->(5)) = file);
    }
    RunTimeProblemShow();
];
[ ClearRTP;
    ((RTP_Buffer-->(0)) = -1);
    ((RTP_Buffer-->(6)) = 0);
];
[ SuspendRTP;
    ((RTP_Buffer-->(6)) = 1);
];
[ ResumeRTP;
    ((RTP_Buffer-->(6)) = 0);
];
[ RunTimeProblemShow n par1 par2 par3 ln file i c;
    if (((RTP_Buffer-->(0)) == -1 or -2)) {
        rtrue;
    }
    if ((RTP_Buffer-->(6))) {
        rtrue;
    }
    (n = (RTP_Buffer-->(0)));
    (par1 = (RTP_Buffer-->(1)));
    (par2 = (RTP_Buffer-->(2)));
    (par3 = (RTP_Buffer-->(3)));
    (ln = (RTP_Buffer-->(4)));
    (file = (RTP_Buffer-->(5)));
    ((RTP_Buffer-->(0)) = -2);
    print "^";
    print "*** Run-time problem P";
    print n;
    if (ln) {
        print " (at paragraph ";
        print ln;
        print " in ";
        if ((file == 0)) {
            print "the source text";
        } else {
            ShowOneExtension(file);
        }
        print ")";
    }
    print ": ";
    switch (n) {
        RTP_IMPREL:
            print "Tried to access an inappropriate relation for ";
            DefArt(par1);
            print ", violating '";
            print (string) RlnGetF(par2, RR_DESCRIPTION);
            print "'.^";
            ;
        RTP_TOOMANYRULEBOOKS:
            print "Too many rulebooks in simultaneous use.^";
            ;
        RTP_BADPROPERTY:
            print "Tried to access non-existent property for ";
            DefArt(par1);
            print ".^";
            ;
        RTP_UNPROVIDED:
            print "Since ";
            DefArt(par1);
            print " is not allowed the property ~";
            PrintPropertyName(par2);
            print "~, it is against the rules to try to use it.^";
            ;
        RTP_UNSET:
            print "Although ";
            DefArt(par1);
            print " is allowed to have the property ~";
            PrintPropertyName(par2);
            print "~, no value was ever given, so it can't now be used.^";
            ;
        RTP_TOOMANYACTS:
            print "Too many activities are going on at once.^";
            ;
        RTP_CANTABANDON:
            print "Tried to abandon an activity which wasn't going on.^";
            ;
        RTP_CANTEND:
            print "Tried to end an activity which wasn't going on.^";
            ;
        RTP_DIVZERO:
            print "You can't divide by zero.^";
            ;
        RTP_BADVALUEPROPERTY:
            print "Tried to access property for a value which didn't fit: ";
            print "if this were a number it would be ";
            print par1;
            print ".^";
            ;
        RTP_TABLE_NOCOL:
            print "Attempt to look up a non-existent column in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOCORR:
            print "Attempt to look up a non-existent correspondence in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROW:
            print "Attempt to look up a non-existent row in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOENTRY:
            print "Attempt to look up a non-existent entry at column ";
            print par2;
            print ", row ";
            print par3;
            print " of the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOTABLE:
            print "Attempt to blank out a row from a non-existent table (value ";
            print par1;
            print ").^";
            ;
        RTP_TABLE_NOTABLE2:
            print "Attempt to access an entry from a non-existent table.^";
            ;
        RTP_TABLE_NOMOREBLANKS:
            print "Attempt to choose a blank row in a table with none left: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROWS:
            print "Attempt to choose a random row in an entirely blank table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTRUNTHROUGH:
            print "Attempt to repeat through a table in a tricky column order: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSORT:
            print "Attempt to sort a table whose ordering must remain fixed: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSAVE:
            print "Attempt to save a table to a file whose data is unstable: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_WONTFIT:
            print "File being read has too many rows or columns to fit into table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_BADFILE:
            print "File being read is not a previously saved table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_ROUTELESS:
            print "Attempt to find route or count steps through an implicit relation.^";
            ;
        RTP_PROPOFNOTHING:
            print "Attempt to use a property of the 'nothing' non-object: property ";
            PrintPropertyName(par2);
            print "^";
            ;
        RTP_DECIDEONWRONGKIND:
            print "Attempt to 'decide on V' where V is the wrong kind of object.^";
            ;
        RTP_DECIDEONNOTHING:
            print "Attempt to 'decide on nothing'.^";
            ;
        RTP_LOWLEVELERROR:
            print "Low level error.^";
            ;
        RTP_LISTWRITERMEMORY:
            print "The list-writer has run out of memory.^";
            ;
        RTP_MSTACKMEMORY:
            print "The memory stack is exhausted.^";
            ;
        RTP_TYPECHECK:
            print "Phrase applied to an incompatible kind of value.^";
            ;
        RTP_FILEIOERROR:
            print "Error handling external file.^";
            ;
        RTP_HEAPERROR:
            print "Memory allocation proved impossible.^";
            ;
        RTP_LISTRANGEERROR:
            print "Attempt to use list item which does not exist.^";
            ;
        RTP_LISTSIZENEGATIVE:
            print "Attempt to resize list to ";
            print par1;
            print " entries - there must ";
            print "always be 0 or more.^";
            ;
        RTP_REGEXPSYNTAXERROR:
            print "Syntax error in regular expression.^";
            ;
        RTP_NOGLULXUNICODE:
            print "This interpreter does not support Unicode.^";
            ;
        RTP_NEGATIVEROOT:
            print "You can't take the square root of a negative number.^";
            ;
        RTP_CANTITERATE:
            print "You can't implicitly repeat through the values of this kind: ";
            print "a problem arising from a description which started out here - ~";
            print (string) par1;
            print "~.^";
            ;
        RTP_WRONGASSIGNEDKIND:
            print "Attempt to set a variable to the wrong kind of object: ";
            print "you wrote '";
            print (string) par2;
            print "', which sets the value to ";
            DefArt(par1);
            print " - but that doesn't have the kind '";
            print (string) par3;
            print "'.^";
            ;
        RTP_RELKINDVIOLATION:
            print "Tried to change a relation for objects with the wrong kinds: ";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print ", but you tried to ";
            print "relate (or unrelate) ";
            DefArt(par1);
            print " to ";
            DefArt(par2);
            print ".^";
            ;
        RTP_TEXTTOKENTOOHARD:
            print "This use of '[text]' is too complicated.^";
            ;
        RTP_RELATIONCHANGEIMPOSSIBLE:
            print "This change of the relation's nature is impossible in play.^";
            ;
        RTP_RELMINIMAL:
            print "This operation can't be done with the relation '";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print "'.^";
            ;
    }
    RunTimeProblemShowWM(n, par1, par2, par3);
    print "^";
];
[ RunTimeError n p1 p2;
    print "** Library error ";
    print n;
    print " (";
    print p1;
    print ",";
    print p2;
    print ") **^";
    RunTimeProblem(RTP_LOWLEVELERROR);
];
[ ArgumentTypeFailed line file;
    RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];
[ CheckKindReturned V K;
    if ((V ofclass K)) {
        return V;
    }
    if ((V == 0)) {
        RunTimeProblem(RTP_DECIDEONNOTHING);
    } else {
        RunTimeProblem(RTP_DECIDEONWRONGKIND);
    }
    return V;
];
[ ProvidesProperty K obj q issue_rtp a l holder;
    if ((K == OBJECT_TY)) {
        if (ScanPropertyMetadata(obj, q, 4)) {
            jump PermissionFound;
        }
        if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
            (l = (obj.KD_Count));
            while ((l > 0)) {
                (a = (l*2));
                if (ScanPropertyMetadata((KindHierarchy-->(a)), q, 4)) {
                    jump PermissionFound;
                }
                (l = (KindHierarchy-->((a + 1))));
            }
        }
        if (ScanPropertyMetadata(K0_kind, q, 4)) {
            jump PermissionFound;
        }
        if (issue_rtp) {
            RunTimeProblem(RTP_UNPROVIDED, obj, q);
        }
        rfalse;
    }
    .PermissionFound;
    if ((_final_propertyexists(K, obj, q))) {
        rtrue;
    }
    if (issue_rtp) {
        RunTimeProblem(RTP_UNSET, obj, q);
    }
    rfalse;
];
[ PrintPropertyName p textual;
    if ((p < 0)) {
        (p = (~(p)));
    }
    (textual = (p-->(3)));
    print (string) textual;
];
[ ScanPropertyMetadata obj property_metadata off i;
    for ((i = off):((property_metadata-->(i)) >= 0):(i)++) {
        if ((obj == (property_metadata-->(i)))) {
            rtrue;
        }
    }
    rfalse;
];
[ GProperty K V pr err holder val;
    if (ProvidesProperty(K, V, pr, (1 - err))) {
        return _final_propertyvalue(K, V, pr);
    }
    rfalse;
];
[ WriteGProperty K V pr val holder;
    if (ProvidesProperty(K, V, pr, 1)) {
        (_final_store_property(K,V,pr, val));
    }
];
[ PROPERTY_TY_Say v;
    print "property ";
    print v;
];
[ LanguageTimeOfDay hours mins i;
    (i = (hours%12));
    if ((i == 0)) {
        (i = 12);
    }
    if ((i < 10)) {
        print " ";
    }
    print i;
    print ":";
    print (mins/10);
    print (mins%10);
    if (((hours/12) > 0)) {
        print " pm";
    } else {
        print " am";
    }
];
[ LanguageDirection d;
    PrintShortName(d);
];
[ LanguageToInformese;
];
[ LanguageContraction text;
    if (((text->(0)) == 97 or 101 or 105 or 111 or 117 or 65 or 69 or 73 or 79 or 85)) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerb i;
    switch (i) {
        'i//', 'inv', 'inventory':
            print "take inventory";
            ;
        'l//':
            print "look";
            ;
        'x//':
            print "examine";
            ;
        'z//':
            print "wait";
            ;
        default:
            rfalse;
            ;
    }
    rtrue;
];
[ LanguageVerbLikesAdverb w;
    if ((w == 'look' or 'go' or 'push' or 'walk')) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerbMayBeName w;
    if ((w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')) {
        rtrue;
    }
    rfalse;
];
[ LanguageIsVerb buffer parse verb_wordnum;
    rfalse;
];
[ ParserError error_type;
    if (error_type) {
        PrintSingleParagraph(error_type);
    }
    rfalse;
];
[ UnknownVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        (verb_wordnum = 0);
        return 'no.verb';
    }
    rfalse;
];
[ PrintVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        if ((v == 'no.verb')) {
            print "do something to";
            rtrue;
        }
    }
    rfalse;
];
[ VM_Undo result_code;
    @restoreundo result_code;
    return (~~(result_code));
];
[ VM_Save_Undo result_code;
    @saveundo result_code;
    if ((result_code == -1)) {
        GGRecoverObjects();
        return 2;
    }
    return (~~(result_code));
];
[ QUIT_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    QUIT_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        quit;
    }
];
[ RESTART_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    RESTART_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        @restart;
        RESTART_THE_GAME_RM(66);
        print "^";
    }
];
[ RESTORE_THE_GAME_R res fref;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(1, 2, 0));
    if ((fref == 0)) {
        jump RFailed;
    }
    (gg_savestr = glk_stream_open_file(fref, 2, GG_SAVESTR_ROCK));
    glk_fileref_destroy(fref);
    if ((gg_savestr == 0)) {
        jump RFailed;
    }
    @restore gg_savestr res;
    glk_stream_close(gg_savestr, 0);
    (gg_savestr = 0);
    .RFailed;
    RESTORE_THE_GAME_RM(65);
    print "^";
];
[ SAVE_THE_GAME_R fref len res;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(fileusage_SavedGame, filemode_Write, 0));
    if (fref) {
        (gg_savestr = glk_stream_open_file(fref, filemode_Write, GG_SAVESTR_ROCK));
        if (gg_savestr) {
            @save gg_savestr res;
            if ((res == -1)) {
                GGRecoverObjects();
                glk_stream_close(gg_savestr, GLK_NULL);
                (gg_savestr = 0);
                RESTORE_THE_GAME_RM(66);
                print "^";
                rtrue;
            }
            glk_stream_close(gg_savestr, GLK_NULL);
            (gg_savestr = 0);
            if ((res == 0)) {
                if (glk_fileref_does_file_exist(fref)) {
                    (gg_savestr = glk_stream_open_file(fref, filemode_Read, GG_SAVESTR_ROCK));
                    if (gg_savestr) {
                        glk_stream_set_position(gg_savestr, 0, seekmode_End);
                        (len = glk_stream_get_position(gg_savestr));
                        glk_stream_close(gg_savestr, GLK_NULL);
                        (gg_savestr = 0);
                        if (len) {
                            SAVE_THE_GAME_RM(66);
                            print "^";
                            glk_fileref_destroy(fref);
                            rtrue;
                        }
                        glk_fileref_delete_file(fref);
                    }
                }
            }
        }
        glk_fileref_destroy(fref);
    }
    SAVE_THE_GAME_RM(65);
    print "^";
];
[ VERIFY_THE_STORY_FILE_R res;
    if ((actor ~= player)) {
        rfalse;
    }
    @verify res;
    if ((res == 0)) {
        VERIFY_THE_STORY_FILE_RM(65);
        print "^";
        rtrue;
    }
    VERIFY_THE_STORY_FILE_RM(66);
    print "^";
];
[ SWITCH_TRANSCRIPT_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr ~= 0)) {
        SWITCH_TRANSCRIPT_ON_RM(65);
        print "^";
        rtrue;
    }
    .S2Failed;
    if ((gg_scriptfref == 0)) {
        (gg_scriptfref = glk_fileref_create_by_prompt(258, 5, GG_SCRIPTFREF_ROCK));
        if ((gg_scriptfref == 0)) {
            jump S1Failed;
        }
    }
    (gg_scriptstr = glk_stream_open_file(gg_scriptfref, 5, GG_SCRIPTSTR_ROCK));
    if ((gg_scriptstr == 0)) {
        glk_fileref_destroy(gg_scriptfref);
        (gg_scriptfref = 0);
        jump S2Failed;
    }
    glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
    SWITCH_TRANSCRIPT_ON_RM(66);
    print "^";
    VersionSub();
    rtrue;
    .S1Failed;
    SWITCH_TRANSCRIPT_ON_RM(67);
    print "^";
];
[ SWITCH_TRANSCRIPT_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr == 0)) {
        SWITCH_TRANSCRIPT_OFF_RM(65);
        print "^";
        rtrue;
    }
    SWITCH_TRANSCRIPT_OFF_RM(66);
    print "^";
    glk_stream_close(gg_scriptstr, 0);
    (gg_scriptstr = 0);
];
[ ANNOUNCE_STORY_FILE_VERSION_R ix;
    if ((actor ~= player)) {
        rfalse;
    }
    Banner();
    print "Inform 7 v";
    PrintI6Text(I7_FULL_VERSION_NUMBER);
    print "^";
    if (((UUID_ARRAY->(0)) >= 6)) {
        print "Identification number: ";
        for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
            print (char) (UUID_ARRAY->(ix));
        }
        print "^";
    }
    @gestalt 1 0 ix;
    print "Interpreter version ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print " / ";
    @gestalt 0 0 ix;
    print "VM ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print "^";
    ShowExtensionVersions();
    (say__p = 1);
];
[ DESCEND_TO_SPECIFIC_ACTION_R;
    ((#actions_table-->((action + 1))))();
    rtrue;
];
[ OffersLight obj j;
    while (obj) {
        if ((obj has light)) {
            rtrue;
        }
        objectloop (j in obj) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
        if ((((((obj has container)) && ((~~((obj has open)))))) && ((~~((obj has transparent)))))) {
            rfalse;
        }
        if ((((_final_propertyexists(OBJECT_TY, obj, A_component_parent))) && ((obj.component_parent)))) {
            (obj = (obj.component_parent));
        } else {
            (obj = parent(obj));
        }
    }
    rfalse;
];
[ HasLightSource i j ad sr po;
    if ((i == 0)) {
        rfalse;
    }
    if ((i has light)) {
        rtrue;
    }
    if (((IsSeeThrough(i)) && ((~~(HidesLightSource(i)))))) {
        objectloop (j in i) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, i, A_add_to_scope)));
    if ((((parent(i) ~= 0)) && ((ad ~= 0)))) {
        if ((metaclass((ad-->(0))) == Routine)) {
            (ats_hls = 0);
            (ats_flag = 1);
            (sr = scope_reason);
            (po = parser_one);
            (scope_reason = LOOPOVERSCOPE_REASON);
            (parser_one = 0);
            RunRoutines(i, A_add_to_scope);
            (scope_reason = sr);
            (parser_one = po);
            (ats_flag = 0);
            if ((ats_hls == 1)) {
                rtrue;
            }
        } else {
            for ((j = 0):((WORDSIZE*j) < (_final_propertylength(OBJECT_TY, i, A_add_to_scope))):(j)++) {
                if ((((ad-->(j))) && ((HasLightSource((ad-->(j))) == 1)))) {
                    rtrue;
                }
            }
        }
    }
    if (ComponentHasLight(i)) {
        rtrue;
    }
    rfalse;
];
[ ComponentHasLight o obj next_obj;
    if ((_final_propertyexists(OBJECT_TY, o, A_component_child))) {
        (obj = (o.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((obj has light)) {
                rtrue;
            }
            if (HasLightSource(obj)) {
                rtrue;
            }
            if ((((_final_propertyexists(OBJECT_TY, obj, A_component_child))) && (ComponentHasLight(obj)))) {
                rtrue;
            }
            (obj = next_obj);
        }
    }
    rfalse;
];
[ HidesLightSource obj;
    if ((obj == player)) {
        rfalse;
    }
    if (((or_tmp_var = obj) && (((or_tmp_var has transparent)) || ((or_tmp_var has supporter))))) {
        rfalse;
    }
    if ((obj has animate)) {
        rfalse;
    }
    if ((obj has container)) {
        return (~~((obj has open)));
    }
    return (~~((obj has enterable)));
];
[ ADJUST_LIGHT_R previous_light_condition;
    (previous_light_condition = lightflag);
    (lightflag = OffersLight(parent(player)));
    if ((((previous_light_condition == 0)) && ((lightflag == 0)))) {
        (location = thedark);
        rfalse;
    }
    if ((((previous_light_condition == 0)) && ((lightflag == 1)))) {
        (location = real_location);
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 0)))) {
        (location = thedark);
        DivideParagraphPoint();
        BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        if ((ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == 0)) {
            ADJUST_LIGHT_RM(65);
            print "^";
        }
        EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 1)))) {
        (location = real_location);
        rfalse;
    }
    rfalse;
];
[ SilentlyConsiderLight;
    (lightflag = OffersLight(parent(player)));
    if (lightflag) {
        (location = real_location);
    } else {
        (location = thedark);
    }
    rfalse;
];
[ IsSeeThrough obj;
    if ((((((((obj has supporter)) || ((obj has transparent)))) || ((obj has animate)))) || ((((obj has container)) && ((obj has open)))))) {
        rtrue;
    }
    rfalse;
];
[ VisibilityParent o;
    if (((((((o) && ((o has container)))) && ((~~((o has open)))))) && ((~~((o has transparent)))))) {
        rfalse;
    }
    if (o) {
        (o = CoreOfParentOfCoreOf(o));
    }
    return o;
];
[ FindVisibilityLevels lc up;
    if ((location == thedark)) {
        (visibility_ceiling = thedark);
        (visibility_levels = 0);
    } else {
        (visibility_ceiling = player);
        while (1) {
            (up = VisibilityParent(visibility_ceiling));
            if ((up == 0)) {
                break;
            }
            (visibility_ceiling = up);
            (lc)++;
        }
        (visibility_levels = lc);
    }
];
[ TouchabilityCeiling original o p;
    (o = original);
    while (o) {
        (p = CoreOfParentOfCoreOf(o));
        if ((p ofclass K1_room)) {
            return p;
        }
        if ((p == 0)) {
            return o;
        }
        if (((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))) {
            return p;
        }
        (o = p);
    }
    return o;
];
[ ScopeCeiling pos c;
    if ((((pos == player)) && ((location == thedark)))) {
        return thedark;
    }
    (c = parent(pos));
    if ((c == 0)) {
        return pos;
    }
    while (VisibilityParent(c)) {
        (c = VisibilityParent(c));
    }
    return c;
];
[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
    if ((LocationOf(p) ~= real_location)) {
        for ((x = CoreOf(item)):x:(x = CoreOfParentOfCoreOf(x))) {
            if ((x ofclass K4_door or K7_backdrop)) {
                (moving = 1);
                MoveFloatingObjects(LocationOf(p));
                break;
            }
        }
    }
    (untouchable_object = item);
    (untouchable_silence = silent_flag);
    (touch_persona = p);
    if ((p == actor)) {
        (touch_persona = 0);
    }
    (save_sp = say__p);
    (say__p = 0);
    @push actor;
    (actor = p);
    if (FollowRulebook(ACCESSIBILITY_RB, 0, 1)) {
        if (RulebookSucceeded()) {
            (decision = 0);
        } else {
            (decision = 1);
        }
    } else {
        (decision = 0);
    }
    @pull actor;
    if ((say__p == 0)) {
        (say__p = save_sp);
    }
    if (moving) {
        MoveFloatingObjects();
    }
    (untouchable_silence = 0);
    return decision;
];
[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
    (p = touch_persona);
    if ((p == 0)) {
        (p = actor);
    }
    (ancestor = CommonAncestor(p, untouchable_object));
    if ((((((ancestor == 0)) && ((LocationOf(untouchable_object) == 0)))) && (((untouchable_object ofclass K4_door or K7_backdrop) == 0)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                ACCESS_THROUGH_BARRIERS_RM(65, untouchable_object);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    if ((CoreOf(p) ~= ancestor)) {
        (i = parent(CoreOf(p)));
        (j = CoreOf(i));
        (external = 0);
        if ((j ~= i)) {
            (i = j);
            (external = 1);
        }
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_OUTSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = parent(CoreOf(i)));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    if ((CoreOf(untouchable_object) ~= ancestor)) {
        (i = CoreOf(untouchable_object));
        (i = parent(i));
        (external = 0);
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_INSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = CoreOf(i));
            if ((i == ancestor)) {
                break;
            }
            (i = parent(i));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    RulebookSucceeds();
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_OUTSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_OUTSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_INSIDE_ROOMS_R;
    if (((parameter_value) && ((parameter_value ofclass K1_room)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_ROOMS_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ RequisitionStack len top addr;
    (top = (requisition_stack_pointer + len));
    if ((top > REQUISITION_STACK_SIZE)) {
        rfalse;
    }
    (addr = (requisition_stack + (requisition_stack_pointer*WORDSIZE)));
    (requisition_stack_pointer = top);
    return addr;
];
[ FreeStack addr;
    if ((addr == 0)) {
        rtrue;
    }
    (requisition_stack_pointer = ((addr - requisition_stack)/WORDSIZE));
];
[ WriteListOfMarkedObjects in_style obj common_parent first mixed_parentage length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        if ((first == 0)) {
            (first = obj);
            (common_parent = parent(obj));
        } else {
            if ((parent(obj) ~= common_parent)) {
                (mixed_parentage = 1);
            }
        }
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    if (mixed_parentage) {
        (common_parent = 0);
    }
    if ((length == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            if ((((in_style)&(CFIRSTART_BIT)) ~= 0)) {
                LIST_WRITER_INTERNAL_RM(88);
            } else {
                LIST_WRITER_INTERNAL_RM(89);
            }
        }
    } else {
        @push MarkedObjectArray;
        @push MarkedObjectLength;
        (MarkedObjectArray = RequisitionStack(length));
        (MarkedObjectLength = length);
        if ((MarkedObjectArray == 0)) {
            return RunTimeProblem(RTP_LISTWRITERMEMORY);
        }
        if (common_parent) {
            ObjectTreeCoalesce(child(common_parent));
            (length = 0);
            objectloop (obj in common_parent) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        } else {
            (length = 0);
            objectloop (obj ofclass Object && (obj ofclass Object)) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        }
        WriteListFrom(first, in_style, 0, 0, MarkedListIterator);
        FreeStack(MarkedObjectArray);
        @pull MarkedObjectLength;
        @pull MarkedObjectArray;
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    rtrue;
];
[ RegardingMarkedObjects obj length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
            (prior_named_noun = obj);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    if ((length == 0)) {
        (prior_named_noun = 0);
        (prior_named_list_gender = -1);
    }
    rtrue;
];
[ PNToVP gna;
    if ((prior_named_noun == player)) {
        return story_viewpoint;
    }
    if (prior_named_noun) {
        (gna = GetGNAOfObject(prior_named_noun));
    }
    if ((((((gna%6)/3) == 1)) || ((prior_named_list >= 2)))) {
        return 6;
    }
    return 3;
];
[ SetLWI a b c;
    ((LWI_Storage-->(0)) = a);
    ((LWI_Storage-->(1)) = b);
    ((LWI_Storage-->(2)) = c);
];
[ RegardingLWI;
    (prior_named_list = (LWI_Storage-->(0)));
    (prior_named_list_gender = (LWI_Storage-->(1)));
    (prior_named_noun = (LWI_Storage-->(2)));
];
[ ResponseViaActivity R;
    @push prior_named_noun;
    @push prior_named_list;
    @push prior_named_list_gender;
    RegardingSingleObject(0);
    CarryOutActivity(PRINTING_RESPONSE_ACT, R);
    @pull prior_named_list_gender;
    @pull prior_named_list;
    @pull prior_named_noun;
];
[ MarkedListIterator obj depth required_lt function i;
    if ((obj == 0)) {
        rfalse;
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    switch (function) {
        START_ITF:
            return (MarkedObjectArray-->(0));
            ;
        COALESCE_ITF:
            return MarkedListCoalesce();
            ;
        SEEK_ITF, ADVANCE_ITF:
            for ((i = 0):(i < MarkedObjectLength):(i)++) {
                if (((MarkedObjectArray-->(i)) == obj)) {
                    if ((function == ADVANCE_ITF)) {
                        (i)++;
                    }
                    for (:(i < MarkedObjectLength):(i)++) {
                        (obj = (MarkedObjectArray-->(i)));
                        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
                            continue;
                        }
                        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
                            continue;
                        }
                        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
                            continue;
                        }
                        return obj;
                    }
                    rfalse;
                }
            }
            ;
    }
    rfalse;
];
[ ConcealedFromLists obj c;
    if ((((obj has concealed)) || ((obj has scenery)))) {
        rtrue;
    }
    (c = parent(obj));
    if (((((c) && ((c ofclass K5_container or K6_supporter)))) && (TestConcealment(c, obj)))) {
        rtrue;
    }
    rfalse;
];
[ MarkedListCoalesce o i lt l swap m;
    for ((i = 0):(i < MarkedObjectLength):(i)++) {
        (lt = ((MarkedObjectArray-->(i)).list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)) {
            for ((i)++:(((i < MarkedObjectLength)) && ((LT_Compare(((MarkedObjectArray-->(i)).list_together), lt) == 0))):(i)++) {
            }
            if ((i == MarkedObjectLength)) {
                return (MarkedObjectArray-->(0));
            }
            for ((l = (i + 1)):(l < MarkedObjectLength):(l)++) {
                if ((LT_Compare(((MarkedObjectArray-->(l)).list_together), lt) == 0)) {
                    (swap = (MarkedObjectArray-->(l)));
                    for ((m = l):(m > i):(m)--) {
                        ((MarkedObjectArray-->(m)) = (MarkedObjectArray-->((m - 1))));
                    }
                    ((MarkedObjectArray-->(i)) = swap);
                    (i)++;
                    if ((i == MarkedObjectLength)) {
                        return (MarkedObjectArray-->(0));
                    }
                }
            }
            (i)--;
        }
    }
    return (MarkedObjectArray-->(0));
];
[ ObjectTreeIterator obj depth required_lt function;
    if ((((obj == 0)) || ((parent(obj) == 0)))) {
        rfalse;
    }
    if ((function == START_ITF)) {
        (obj = child(parent(obj)));
    }
    if ((function == COALESCE_ITF)) {
        return ObjectTreeCoalesce(obj);
    }
    if ((function == ADVANCE_ITF)) {
        (obj = sibling(obj));
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    for (:1:(obj = sibling(obj))) {
        if ((obj == 0)) {
            rfalse;
        }
        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
            continue;
        }
        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
            continue;
        }
        if ((~~(_final_propertyvalue(OBJECT_TY, obj, list_filter_permits)))) {
            continue;
        }
        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
            continue;
        }
        return obj;
    }
];
[ ObjectTreeCoalesce obj memb lt later;
    .StartAgain;
    (memb = obj);
    while ((memb ~= 0)) {
        (lt = (memb.list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) == 0)) {
            (memb = sibling(memb));
            continue;
        }
        for ((memb = sibling(memb)):((memb) && ((LT_Compare((memb.list_together), lt) == 0))):(memb = sibling(memb))) {
        }
        if ((memb == 0)) {
            return obj;
        }
        for ((later = sibling(memb)):later:(later = sibling(later))) {
            if ((LT_Compare((later.list_together), lt) == 0)) {
                (obj = GroupChildren(parent(obj), lt));
                jump StartAgain;
            }
        }
    }
    return obj;
];
[ GroupChildren par value;
    while ((child(par) ~= 0)) {
        if ((LT_Compare((child(par).list_together), value) ~= 0)) {
            move child(par) to out_obj;
        } else {
            move child(par) to in_obj;
        }
    }
    while ((child(in_obj) ~= 0)) {
        move child(in_obj) to par;
    }
    while ((child(out_obj) ~= 0)) {
        move child(out_obj) to par;
    }
    return child(par);
];
[ WriteListFrom first in_style depth noactivity iter a ol;
    @push c_iterator;
    @push c_style;
    @push c_depth;
    @push c_margin;
    if (iter) {
        (c_iterator = iter);
    } else {
        (c_iterator = ObjectTreeIterator);
    }
    (c_style = in_style);
    (c_depth = depth);
    (c_margin = 0);
    if (((in_style)&(EXTRAINDENT_BIT))) {
        (c_margin = 1);
    }
    objectloop (a ofclass Object && (a ofclass Object)) {
        (_final_store_property(OBJECT_TY,a,list_filter_permits, 1));
        if (((list_filter_routine) && (((list_filter_routine)(a) == 0)))) {
            (_final_store_property(OBJECT_TY,a,list_filter_permits, 0));
        }
    }
    (first = (c_iterator)(first,depth,0,START_ITF));
    if ((first == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            LIST_WRITER_INTERNAL_RM(89);
        }
        if ((((in_style)&(NEWLINE_BIT)) ~= 0)) {
            print "^";
        }
    } else {
        if (((noactivity) || (iter))) {
            WriteListR(first, c_depth, 1);
            (say__p = 1);
        } else {
            objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, A_list_together))) {
                BlkValueCopy((ol.list_together), EMPTY_TEXT_VALUE);
            }
            CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
        }
    }
    @pull c_margin;
    @pull c_depth;
    @pull c_style;
    @pull c_iterator;
];
[ STANDARD_CONTENTS_LISTING_R;
    WriteListFrom(child(parameter_value), c_style, c_depth, 1);
];
[ PartitionList first no_objs depth partition_classes partition_class_sizes i k l n m;
    for ((i = 0):(i < no_objs):(i)++) {
        ((partition_classes->(i)) = 0);
    }
    (n = 1);
    for (((i = first),(k = 0)):(k < no_objs):((i = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(k)++)) {
        if (((partition_classes->(k)) == 0)) {
            ((partition_classes->(k)) = n);
            ((partition_class_sizes->(n)) = 1);
            for (((l = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(m = (k + 1))):(((l ~= 0)) && ((m < no_objs))):((l = (c_iterator)(l,depth,lt_value,ADVANCE_ITF)),(m)++)) {
                if (((((partition_classes->(m)) == 0)) && (ListEqual(i, l)))) {
                    if (((partition_class_sizes->(n)) < 255)) {
                        ((partition_class_sizes->(n)))++;
                    }
                    ((partition_classes->(m)) = n);
                }
            }
            if ((n < 255)) {
                (n)++;
            }
        }
    }
    (n)--;
    return n;
];
[ ListEqual o1 o2;
    if (((((o1.plural) == 0)) || (((o2.plural) == 0)))) {
        rfalse;
    }
    if ((((child(o1) ~= 0)) && ((WillRecurs(o1) ~= 0)))) {
        rfalse;
    }
    if ((((child(o2) ~= 0)) && ((WillRecurs(o2) ~= 0)))) {
        rfalse;
    }
    if ((((c_style)&((FULLINV_BIT + PARTINV_BIT))) ~= 0)) {
        if ((((((~~((o1 has worn)))) && ((o2 has worn)))) || ((((~~((o2 has worn)))) && ((o1 has worn)))))) {
            rfalse;
        }
        if ((((((~~((o1 has light)))) && ((o2 has light)))) || ((((~~((o2 has light)))) && ((o1 has light)))))) {
            rfalse;
        }
        if ((o1 has container)) {
            if ((~~((o2 has container)))) {
                rfalse;
            }
            if ((((((o1 has open)) && ((~~((o2 has open)))))) || ((((o2 has open)) && ((~~((o1 has open)))))))) {
                rfalse;
            }
        } else {
            if ((o2 has container)) {
                rfalse;
            }
        }
    }
    return Identical(o1, o2);
];
[ WillRecurs o;
    if ((((c_style)&(ALWAYS_BIT)) ~= 0)) {
        rtrue;
    }
    if ((((c_style)&(RECURSE_BIT)) == 0)) {
        rfalse;
    }
    if ((((o has supporter)) || ((((o has container)) && (((or_tmp_var = o) && (((or_tmp_var has open)) || ((or_tmp_var has transparent))))))))) {
        rtrue;
    }
    rfalse;
];
[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes no_groups cl memb k current_lt lt;
    (current_lt = EMPTY_TEXT_VALUE);
    (lt = EMPTY_TEXT_VALUE);
    (no_groups = no_classes);
    for (((cl = 1),((memb = o),(k = 0))):(cl <= no_classes):(cl)++) {
        while (((partition_classes->(k)) ~= cl)) {
            (k)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
        }
        if (memb) {
            (lt = (memb.list_together));
            if ((((((LT_Compare(lt, lt_value) ~= 0)) && ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)))) && ((LT_Compare(lt, current_lt) == 0)))) {
                (no_groups)--;
            }
            (current_lt = lt);
        }
    }
    return no_groups;
];
[ LT_Compare lt1 lt2;
    if ((lt1 == lt2)) {
        rfalse;
    }
    if ((lt1 == 0)) {
        (lt1 = EMPTY_TEXT_VALUE);
    }
    if ((lt2 == 0)) {
        (lt2 = EMPTY_TEXT_VALUE);
    }
    if ((TEXT_TY_IsSubstituted(lt1) == 0)) {
        if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
            return ((lt1-->(1)) - (lt2-->(1)));
        }
        return (-(1));
    }
    if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
        return (-(1));
    }
    return BlkValueCompare(lt1, lt2);
];
[ WriteListR o depth from_start partition_classes partition_class_sizes cl memb index k2 l m no_classes q groups_to_do current_lt;
    if ((o == 0)) {
        rtrue;
    }
    if (from_start) {
        (o = (c_iterator)(o,depth,0,COALESCE_ITF));
    }
    (o = (c_iterator)(o,depth,0,SEEK_ITF));
    if ((o == 0)) {
        rtrue;
    }
    for (((memb = o),(index = 0)):memb:(memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF))) {
        (index)++;
    }
    if ((((c_style)&(ISARE_BIT)) ~= 0)) {
        SetLWI(index, (-(1)), o);
        LIST_WRITER_INTERNAL_RM(86, o);
        if ((((c_style)&(NEWLINE_BIT)) ~= 0)) {
            print ":^";
        } else {
            print (char) 32;
        }
        (c_style = (c_style - ISARE_BIT));
    }
    (partition_classes = RequisitionStack(((index/WORDSIZE) + 2)));
    (partition_class_sizes = RequisitionStack(((index/WORDSIZE) + 2)));
    if ((((partition_classes == 0)) || ((partition_class_sizes == 0)))) {
        return RunTimeProblem(RTP_LISTWRITERMEMORY);
    }
    (no_classes = PartitionList(o, index, depth, partition_classes, partition_class_sizes));
    (groups_to_do = NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes));
    for (((cl = 1),((memb = o),((index = 0),(current_lt = EMPTY_TEXT_VALUE)))):(groups_to_do > 0):(cl)++) {
        while (((partition_classes->(index)) ~= cl)) {
            (index)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
            if ((memb == 0)) {
                print "*** Error in list-writer ***^";
                rtrue;
            }
        }
        if ((((LT_Compare((memb.list_together), lt_value) == 0)) || ((LT_Compare((memb.list_together), EMPTY_TEXT_VALUE) == 0)))) {
            (current_lt = EMPTY_TEXT_VALUE);
        } else {
            if ((LT_Compare((memb.list_together), current_lt) == 0)) {
                continue;
            }
            @push listing_size;
            (q = memb);
            (listing_size = 1);
            (l = index);
            (m = cl);
            while ((((m < no_classes)) && ((LT_Compare((q.list_together), (memb.list_together)) == 0)))) {
                (m)++;
                while (((partition_classes->(l)) ~= m)) {
                    (l)++;
                    (q = (c_iterator)(q,depth,lt_value,ADVANCE_ITF));
                }
                if ((LT_Compare((q.list_together), (memb.list_together)) == 0)) {
                    (listing_size)++;
                }
            }
            if ((listing_size > 1)) {
                WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
                (current_lt = (memb.list_together));
                jump GroupComplete;
            }
            (current_lt = EMPTY_TEXT_VALUE);
            @pull listing_size;
        }
        WriteSingleClassGroup(cl, memb, depth, (partition_class_sizes->(cl)));
        .GroupComplete;
        (groups_to_do)--;
        if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
            if ((groups_to_do == 1)) {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((cl > 1)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
            if ((groups_to_do > 1)) {
                print ", ";
            }
        }
    }
    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
];
[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
    (q = c_style);
    if ((((c_style)&(INDENT_BIT)) ~= 0)) {
        PrintSpaces((2*(depth + c_margin)));
    }
    BeginActivity(GROUPING_TOGETHER_ACT, memb);
    if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
        (c_style = ((c_style)&((~(NEWLINE_BIT)))));
    } else {
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 1);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            if ((((pv-->(1)))() == 1)) {
                jump Omit__Sublist2;
            }
        } else {
            if (pv) {
                (k2 = 0);
                for ((l = 0):(l < listing_size):(l)++) {
                    (k2 = (k2 + (partition_class_sizes->((l + cl)))));
                }
                EnglishNumber(k2);
                print " ";
                TEXT_TY_Say(pv);
                if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
                    print " (";
                }
                if ((((c_style)&(INDENT_BIT)) ~= 0)) {
                    print ":^";
                }
            }
        }
        (c_margin)++;
        @push lt_value;
        @push listing_together;
        @push listing_size;
        (lt_value = (memb.list_together));
        (listing_together = memb);
        WriteListR(memb, depth, 0);
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        (c_margin)--;
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 2);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            ((pv-->(1)))();
        } else {
            if ((LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0)) {
                if ((((q)&(ENGLISH_BIT)) ~= 0)) {
                    print ")";
                }
            }
        }
        .Omit__Sublist2;
    }
    EndActivity(GROUPING_TOGETHER_ACT, memb);
    if ((((((q)&(NEWLINE_BIT)) ~= 0)) && ((((c_style)&(NEWLINE_BIT)) == 0)))) {
        print "^";
    }
    (c_style = q);
];
[ WriteSingleClassGroup cl memb depth size q;
    (q = c_style);
    if (((c_style)&(INDENT_BIT))) {
        PrintSpaces((2*(depth + c_margin)));
    }
    if ((size == 1)) {
        if ((((c_style)&(NOARTICLE_BIT)) ~= 0)) {
            PrintShortName(memb);
        } else {
            if (((c_style)&(DEFART_BIT))) {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CDefArt(memb);
                } else {
                    DefArt(memb);
                }
            } else {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CIndefArt(memb);
                } else {
                    IndefArt(memb);
                }
            }
        }
    } else {
        if (((c_style)&(DEFART_BIT))) {
            if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                PrefaceByArticle(memb, 0, size);
            } else {
                PrefaceByArticle(memb, 1, size);
            }
        }
        @push listing_size;
        (listing_size = size);
        CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
        @pull listing_size;
    }
    if ((((size > 1)) && ((~~((memb has pluralname)))))) {
        give memb pluralname;
        WriteAfterEntry(memb, depth);
        give memb ~pluralname;
    } else {
        WriteAfterEntry(memb, depth);
    }
    (c_style = q);
];
[ WriteAfterEntry o depth p recurse_flag parenth_flag eldest_child child_count combo;
    (inventory_stage = 2);
    if (((c_style)&(PARTINV_BIT))) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == 0)) {
            (combo = 0);
            if ((((o has light)) && ((~~((location has light)))))) {
                (combo = (combo + 1));
            }
            if ((((o has container)) && ((~~((o has open)))))) {
                (combo = (combo + 2));
            }
            if ((((((o has container)) && ((((o has open)) || ((o has transparent)))))) && ((child(o) == 0)))) {
                (combo = (combo + 4));
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(65);
            }
            switch (combo) {
                1:
                    LIST_WRITER_INTERNAL_RM(68, o);
                    ;
                2:
                    LIST_WRITER_INTERNAL_RM(69, o);
                    ;
                3:
                    LIST_WRITER_INTERNAL_RM(72, o);
                    ;
                4:
                    LIST_WRITER_INTERNAL_RM(70, o);
                    ;
                5:
                    LIST_WRITER_INTERNAL_RM(73, o);
                    ;
                6:
                    LIST_WRITER_INTERNAL_RM(71, o);
                    ;
                7:
                    LIST_WRITER_INTERNAL_RM(74, o);
                    ;
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }
    if (((c_style)&(FULLINV_BIT))) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == 0)) {
            if ((((o has light)) && ((o has worn)))) {
                LIST_WRITER_INTERNAL_RM(65);
                LIST_WRITER_INTERNAL_RM(75, o);
                (parenth_flag = 1);
            } else {
                if ((o has light)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(68, o);
                    (parenth_flag = 1);
                }
                if ((o has worn)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(76, o);
                    (parenth_flag = 1);
                }
            }
            if ((o has container)) {
                if ((o has openable)) {
                    if (parenth_flag) {
                        if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                            print ",";
                        }
                        LIST_WRITER_INTERNAL_RM(67);
                    } else {
                        LIST_WRITER_INTERNAL_RM(65, o);
                    }
                    if ((o has open)) {
                        if (child(o)) {
                            LIST_WRITER_INTERNAL_RM(77, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(78, o);
                        }
                    } else {
                        if ((((o has lockable)) && ((o has locked)))) {
                            LIST_WRITER_INTERNAL_RM(80, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(79, o);
                        }
                    }
                    (parenth_flag = 1);
                } else {
                    if ((((child(o) == 0)) && ((o has transparent)))) {
                        if (parenth_flag) {
                            LIST_WRITER_INTERNAL_RM(67);
                            LIST_WRITER_INTERNAL_RM(70);
                        } else {
                            LIST_WRITER_INTERNAL_RM(65);
                            LIST_WRITER_INTERNAL_RM(70);
                            LIST_WRITER_INTERNAL_RM(66);
                        }
                    }
                }
            }
            if (parenth_flag) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }
    (child_count = 0);
    (eldest_child = 0);
    objectloop (p in o) {
        if ((((((c_style)&(CONCEAL_BIT)) == 0)) || ((ConcealedFromLists(p) == 0)))) {
            if (_final_propertyvalue(OBJECT_TY, p, list_filter_permits)) {
                (child_count)++;
                if ((eldest_child == 0)) {
                    (eldest_child = p);
                }
            }
        }
    }
    if (((child_count) && (((c_style)&(ALWAYS_BIT))))) {
        if (((c_style)&(ENGLISH_BIT))) {
            print " ";
            LIST_WRITER_INTERNAL_RM(81, o);
            print " ";
        }
        (recurse_flag = 1);
    }
    if (((child_count) && (((c_style)&(RECURSE_BIT))))) {
        if ((o has supporter)) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(82, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(83, o);
                }
            }
            (recurse_flag = 1);
        }
        if ((((o has container)) && ((((o has open)) || ((o has transparent)))))) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(84, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(85, o);
                }
            }
            (recurse_flag = 1);
        }
    }
    if (((recurse_flag) && (((c_style)&(ENGLISH_BIT))))) {
        SetLWI(child_count, (-(1)), eldest_child);
        LIST_WRITER_INTERNAL_RM(86, o);
        print " ";
    }
    if (((c_style)&(NEWLINE_BIT))) {
        print "^";
    }
    if (recurse_flag) {
        (o = child(o));
        @push lt_value;
        @push listing_together;
        @push listing_size;
        @push c_iterator;
        (c_iterator = ObjectTreeIterator);
        (lt_value = EMPTY_TEXT_VALUE);
        (listing_together = 0);
        (listing_size = 0);
        WriteListR(o, (depth + 1), 1);
        @pull c_iterator;
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        if (((c_style)&(TERSE_BIT))) {
            LIST_WRITER_INTERNAL_RM(66);
        }
    }
];
[ LIST_WRITER_INTERNAL_R;
];
[ Main;
    #ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    FollowRulebook(STARTUP_RB);
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    while (1) {
        while ((deadflag == 0)) {
            (EarlyInTurnSequence = 1);
            (action = ##Wait);
            (meta = 0);
            (noun = 0);
            (second = 0);
            (actor = player);
            FollowRulebook(TURN_SEQUENCE_RB);
            (IterationsOfTurnSequence)++;
        }
        if ((FollowRulebook(SHUTDOWN_RB) == 0)) {
            rtrue;
        }
    }
];
[ VIRTUAL_MACHINE_STARTUP_R;
    CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
    VM_Initialise();
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    print "^^^";
    rfalse;
];
[ INITIALISE_MEMORY_R;
    VM_PreInitialise();
    (not_yet_in_play = 1);
    (lookmode = KIT_CONFIGURATION_LOOKMODE);
    (player = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (the_time = (InitialSituation-->(START_TIME_INIS)));
    (real_location = 0);
    (location = 0);
    HeapInitialise();
    StackFramingInitialise();
    CreateDynamicRelations();
    rfalse;
];
[ POSITION_PLAYER_IN_MODEL_R player_to_be;
    (player = selfobj);
    (player_to_be = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (location = LocationOf(player_to_be));
    if ((location == 0)) {
        (location = (InitialSituation-->(START_ROOM_INIS)));
        if ((InitialSituation-->(START_OBJECT_INIS))) {
            move player_to_be to (InitialSituation-->(START_OBJECT_INIS));
        } else {
            move player_to_be to location;
        }
    }
    if ((player_to_be ~= player)) {
        remove selfobj;
        ChangePlayer(player_to_be);
    } else {
        (real_location = location);
        SilentlyConsiderLight();
    }
    NOTE_OBJECT_ACQUISITIONS_R();
    MoveFloatingObjects();
    (actor = player);
    (act_requester = 0);
    (actors_location = real_location);
    (action = ##Wait);
    ((InitialSituation-->(DONE_INIS)) = 1);
    rfalse;
];
[ PARSE_COMMAND_R;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (not_yet_in_play = 0);
    Parser__parse();
    TreatParserResults();
    rfalse;
];
[ TreatParserResults;
    if (((parser_results-->(ACTION_PRES)) == ##MistakeAction)) {
        (meta = 1);
    }
    if (((((((parser_results-->(ACTION_PRES)) == ##Tell)) && (((parser_results-->(INP1_PRES)) == player)))) && ((actor ~= player)))) {
        ((parser_results-->(ACTION_PRES)) = ##Ask);
        ((parser_results-->(INP1_PRES)) = actor);
        (actor = player);
    }
];
[ GENERATE_ACTION_R i;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (EarlyInTurnSequence = 0);
    (action = (parser_results-->(ACTION_PRES)));
    (act_requester = 0);
    if ((actor ~= player)) {
        (act_requester = player);
    }
    (inp1 = 0);
    (inp2 = 0);
    (multiflag = 0);
    if (((parser_results-->(NO_INPS_PRES)) >= 1)) {
        (inp1 = (parser_results-->(INP1_PRES)));
        if ((inp1 == 0)) {
            (multiflag = 1);
        }
    }
    if (((parser_results-->(NO_INPS_PRES)) >= 2)) {
        (inp2 = (parser_results-->(INP2_PRES)));
        if ((inp2 == 0)) {
            (multiflag = 1);
        }
    }
    if ((inp1 == 1)) {
        (noun = 0);
    } else {
        (noun = inp1);
    }
    if ((inp2 == 1)) {
        (second = 0);
    } else {
        (second = inp2);
    }
    if (multiflag) {
        if (((multiple_object-->(0)) == 0)) {
            if ((actor == player)) {
                GENERATE_ACTION_RM(66);
                print "^";
            }
            rtrue;
        }
        if (toomany_flag) {
            (toomany_flag = 0);
            if ((actor == player)) {
                GENERATE_ACTION_RM(65);
            }
        }
        (i = (multiple_object-->(0)));
        FollowRulebook(MULTIPLE_ACTION_PROCESSING_RB);
        if (((((multiple_object-->(0)) == 1)) && ((i > 1)))) {
            (multiflag = 0);
            if ((inp1 == 0)) {
                (noun = (multiple_object-->(1)));
            }
            if ((((inp2 == 0)) && (((parser_results-->(NO_INPS_PRES)) >= 2)))) {
                (second = (multiple_object-->(1)));
            }
        }
        if (((multiple_object-->(0)) == 0)) {
            rfalse;
        }
    }
    if (multiflag) {
        GenerateMultipleActions();
        (multiflag = 0);
    } else {
        BeginAction(action, noun, second);
    }
    if ((((actor ~= player)) || (act_requester))) {
        (action = ##Wait);
    }
    (actor = player);
    (act_requester = 0);
    if (meta) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenerateMultipleActions initial_location k item;
    (initial_location = location);
    for ((k = 1):(k <= (multiple_object-->(0))):(k)++) {
        (item = (multiple_object-->(k)));
        RunParagraphOn();
        if ((inp1 == 0)) {
            (inp1 = item);
            BeginAction(action, item, second, item);
            (inp1 = 0);
        } else {
            (inp2 = item);
            BeginAction(action, noun, item, item);
            (inp2 = 0);
        }
        if (deadflag) {
            rtrue;
        }
        if ((location ~= initial_location)) {
            if ((player == actor)) {
                ACTION_PROCESSING_INTERNAL_RM(74);
                print "^";
            }
            rtrue;
        }
    }
];
[ TIMED_EVENTS_R i d event_timer fire rule;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if (((rule = (TimedEventsTable-->(i))) ~= 0)) {
            (event_timer = (TimedEventTimesTable-->(i)));
            (fire = 0);
            if ((event_timer < 0)) {
                ((TimedEventTimesTable-->(i)))++;
                if (((TimedEventTimesTable-->(i)) == 0)) {
                    (fire = 1);
                }
            } else {
                (d = (((the_time - event_timer) + TWENTY_FOUR_HOURS)%TWENTY_FOUR_HOURS));
                if ((((d >= 0)) && ((d < 30)))) {
                    (fire = 1);
                }
            }
            if (fire) {
                ((TimedEventsTable-->(i)) = 0);
                FollowRulebook(rule);
            }
        }
    }
    rfalse;
];
[ SetTimedEvent rule event_time absolute_time i b;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if ((rule == (TimedEventsTable-->(i)))) {
            (b = i);
            break;
        }
        if ((((b == 0)) && (((TimedEventsTable-->(i)) == 0)))) {
            (b = i);
        }
    }
    if ((b == 0)) {
        return RunTimeProblem(RTP_TOOMANYEVENTS);
    }
    ((TimedEventsTable-->(b)) = rule);
    if (absolute_time) {
        ((TimedEventTimesTable-->(b)) = event_time);
    } else {
        ((TimedEventTimesTable-->(b)) = (-(event_time)));
    }
];
[ SetTime t s;
    (the_time = t);
    (time_rate = s);
    (time_step = 0);
    if ((s < 0)) {
        (time_step = (0 - s));
    }
];
[ ADVANCE_TIME_R;
    (turns)++;
    if ((the_time ~= NULL)) {
        if ((time_rate >= 0)) {
            (the_time = (the_time + time_rate));
        } else {
            (time_step)--;
            if ((time_step == 0)) {
                (the_time)++;
                (time_step = (-(time_rate)));
            }
        }
        (the_time = (the_time%TWENTY_FOUR_HOURS));
    }
    rfalse;
];
[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) {
        give obj moved;
    }
    objectloop (obj ofclass Object && (obj has concealed)) {
        if (IndirectlyContains(player, obj)) {
            give obj ~concealed;
        }
    }
    rfalse;
];
[ RESURRECT_PLAYER_IF_ASKED_R;
    if (resurrect_please) {
        RulebookSucceeds();
        (resurrect_please = 0);
        (deadflag = 0);
        (story_complete = 0);
        rtrue;
    }
    rfalse;
];
[ ASK_FINAL_QUESTION_R;
    print "^";
    while (1) {
        CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
        DivideParagraphPoint();
        if (resurrect_please) {
            rtrue;
        }
    }
];
[ READ_FINAL_ANSWER_R;
    DrawStatusLine();
    KeyboardPrimitive(buffer, parse);
    (players_command = (100 + WordCount()));
    (num_words = WordCount());
    (wn = 1);
    rfalse;
];
[ IMMEDIATELY_RESTART_VM_R;
    @restart;
];
[ IMMEDIATELY_RESTORE_SAVED_R;
    (actor = player);
    RESTORE_THE_GAME_R();
];
[ IMMEDIATELY_QUIT_R;
    @quit;
];
[ IMMEDIATELY_UNDO_R;
    Perform_Undo();
];
[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if ((deadflag == 1)) {
        PRINT_OBITUARY_HEADLINE_RM(65);
    }
    if ((deadflag == 2)) {
        PRINT_OBITUARY_HEADLINE_RM(66);
    }
    if ((deadflag == 3)) {
        PRINT_OBITUARY_HEADLINE_RM(67);
    }
    if ((deadflag ~= 0 or 1 or 2 or 3)) {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^^";
    rfalse;
];
[ PRINT_FINAL_SCORE_R;
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        ANNOUNCE_SCORE_R();
    }
    rfalse;
];
[ DISPLAY_FINAL_STATUS_LINE_R;
    (sline1 = score);
    (sline2 = turns);
    rfalse;
];
[ FindAction fa t;
    if ((fa == -1)) {
        (fa = action);
    }
    (t = 1);
    while ((t <= (ActionData-->(0)))) {
        if ((fa == (ActionData-->(t)))) {
            return t;
        }
        (t = (t + AD_RECORD_SIZE));
    }
    rfalse;
];
[ ActionNumberIndexed i;
    if ((((i >= 0)) && ((i < AD_RECORDS)))) {
        return (ActionData-->((((i*AD_RECORD_SIZE) + AD_ACTION) + 1)));
    }
    rfalse;
];
[ NeedToCarryNoun;
    return TestActionMask(CARRY_NOUN_ABIT);
];
[ NeedToCarrySecondNoun;
    return TestActionMask(CARRY_SECOND_ABIT);
];
[ NeedToTouchNoun;
    return TestActionMask(TOUCH_NOUN_ABIT);
];
[ NeedToTouchSecondNoun;
    return TestActionMask(TOUCH_SECOND_ABIT);
];
[ NeedLightForAction;
    return TestActionMask(LIGHT_ABIT);
];
[ TestActionMask match mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(match))) {
        rtrue;
    }
    rfalse;
];
[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
    if (stora) {
        return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
    }
    (tbits = ((req)&((16 + 32))));
    (req = ((req)&(1)));
    @push actor;
    @push act_requester;
    @push inp1;
    @push inp2;
    @push parsed_number;
    (smeta = meta);
    if ((by == 0)) {
        (by = player);
    }
    (actor = by);
    if (req) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
    (by = FindAction(ac));
    if (by) {
        if (((ActionData-->((by + AD_NOUN_KOV))) == OBJECT_TY)) {
            (inp1 = n);
        } else {
            (inp1 = 1);
            (parsed_number = n);
        }
        if (((ActionData-->((by + AD_SECOND_KOV))) == OBJECT_TY)) {
            (inp2 = s);
        } else {
            (inp2 = 1);
            (parsed_number = s);
        }
        if (((((((ActionData-->((by + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((by + AD_SECOND_KOV))) == UNDERSTANDING_TY)))) && (tbits))) {
            (saved_command = BlkValueCreate(TEXT_TY));
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            if ((tbits == 16)) {
                (n = players_command);
                (inp1 = 1);
                (parsed_number = players_command);
            } else {
                (s = players_command);
                (inp2 = 1);
                (parsed_number = players_command);
            }
            BlkValueFree(text_of_command);
            @push consult_from;
            @push consult_words;
            (consult_from = 1);
            (consult_words = (parsed_number - 100));
        }
    }
    BeginAction(ac, n, s, 0, 1);
    if (saved_command) {
        @pull consult_words;
        @pull consult_from;
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    (meta = smeta);
    @pull parsed_number;
    @pull inp2;
    @pull inp1;
    @pull act_requester;
    @pull actor;
    TrackActions(1, smeta);
];
[ R_Process a i j;
    @push inp1;
    @push inp2;
    (inp1 = i);
    (inp2 = j);
    BeginAction(a, i, j);
    @pull inp2;
    @pull inp1;
];
[ GVS_Convert ac n s;
    (converted_action_outcome = BeginAction(ac, n, s));
    if ((converted_action_outcome == 1)) {
        FollowRulebook(AFTER_RB, 0, 1);
    }
    rtrue;
];
[ ConvertToRequest X AN Y Z;
    WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if ((X == player)) {
        TryAction(0, X, AN, Y, Z);
    } else {
        TryAction(1, X, AN, Y, Z);
    }
    rtrue;
];
[ ConvertToGoingWithPush i oldrm newrm infl;
    (i = noun);
    if ((IndirectlyContains(noun, actor) == 0)) {
        move i to actor;
        (infl = 1);
    }
    (move_pushing = i);
    (oldrm = LocationOf(noun));
    BeginAction(##Go, second);
    (newrm = LocationOf(actor));
    (move_pushing = 0);
    move i to newrm;
    if ((newrm ~= oldrm)) {
        if (IndirectlyContains(i, player)) {
            TryAction(0, player, ##Look, 0, 0);
        }
        RulebookSucceeds();
    } else {
        RulebookFails();
    }
    rtrue;
];
[ ImplicitTake obj ks;
    if ((actor == player)) {
        STANDARD_IMPLICIT_TAKING_RM(65, obj);
    } else {
        if (TestVisibility(player, actor)) {
            STANDARD_IMPLICIT_TAKING_RM(66, obj, actor);
        }
    }
    ClearParagraphing(3);
    @push keep_silent;
    (keep_silent = 1);
    @push say__p;
    @push say__pc;
    ClearParagraphing(4);
    if (act_requester) {
        TryAction(1, actor, ##Take, obj, 0);
    } else {
        TryAction(0, actor, ##Take, obj, 0);
    }
    DivideParagraphPoint();
    @pull say__pc;
    @pull say__p;
    AdjustParagraphPoint();
    @pull keep_silent;
    if ((obj in actor)) {
        rtrue;
    }
    rfalse;
];
[ LookAfterGoing;
    GoingLookBreak();
    AbbreviatedRoomDescription();
];
[ AbbreviatedRoomDescription prior_action pos frame_id;
    (prior_action = action);
    (action = ##Look);
    (pos = FindAction(##Look));
    if (((pos) && ((ActionData-->((pos + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((pos + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
        FollowRulebook(SETTING_ACTION_VARIABLES_RB);
        ((MStack-->(MstVO(frame_id, 0))) = prior_action);
        ((MStack-->(MstVO(frame_id, 1))) = 1);
    }
    LookSub();
    if (frame_id) {
        Mstack_Destroy_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
    }
    (action = prior_action);
];
[ BeginAction a n s moi notrack rv;
    ChronologyPoint();
    @push action;
    @push noun;
    @push second;
    @push self;
    @push multiple_object_item;
    (action = a);
    (noun = n);
    (second = s);
    (self = noun);
    (multiple_object_item = moi);
    if ((action < 4096)) {
        (rv = ActionPrimitive());
    }
    @pull multiple_object_item;
    @pull self;
    @pull second;
    @pull noun;
    @pull action;
    if ((notrack == 0)) {
        TrackActions(1, meta);
    }
    return rv;
];
[ ActionPrimitive rv p1 p2 p3 p4 p5 frame_id;
    MStack_CreateRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    (reason_the_action_failed = 0);
    (frame_id = -1);
    (p1 = FindAction(action));
    if (((p1) && ((ActionData-->((p1 + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((p1 + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    if (ActionVariablesNotTypeSafe()) {
        if ((actor ~= player)) {
            ACTION_PROCESSING_INTERNAL_RM(75);
            print "^";
        }
        if ((frame_id ~= -1)) {
            Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
        }
        MStack_DestroyRBVars(ACTION_PROCESSING_RB);
        rtrue;
    }
    FollowRulebook(SETTING_ACTION_VARIABLES_RB);
    TrackActions(0, meta);
    if (((meta) && ((actor ~= player)))) {
        ACTION_PROCESSING_INTERNAL_RM(65, actor);
        print "^";
        (rv = RS_FAILS);
    } else {
        if (meta) {
            DESCEND_TO_SPECIFIC_ACTION_R();
            (rv = RulebookOutcome());
        } else {
            FollowRulebook(ACTION_PROCESSING_RB);
            (rv = RulebookOutcome());
        }
    }
    if ((rv == RS_SUCCEEDS)) {
        UpdateActionBitmap();
    }
    if ((frame_id ~= -1)) {
        (p1 = FindAction(action));
        Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    MStack_DestroyRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    if ((rv == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ACTION_PROCESSING_INTERNAL_R;
];
[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (noun_kova = (ActionData-->((at + AD_NOUN_KOV))));
    (second_kova = (ActionData-->((at + AD_SECOND_KOV))));
    if ((noun_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        if ((inp1 ~= 1)) {
            (inp2 = inp1);
            (second = noun);
        }
        (parsed_number = ((100*consult_from) + consult_words));
        (inp1 = 1);
        (noun = 0);
    }
    if ((second_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        (parsed_number = ((100*consult_from) + consult_words));
        (inp2 = 1);
        (second = 0);
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(OUT_OF_WORLD_ABIT))) {
        (meta = 1);
        rfalse;
    }
    (meta = 0);
    if ((inp1 == 1)) {
        if ((noun_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(66);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((noun_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(67);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_NOUN_ABIT))) && ((noun == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
            @pull act_requester;
            if ((noun == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(68);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_NOUN_ABIT)) == 0)) && ((noun ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(69);
                print "^";
            }
            rtrue;
        }
    }
    if ((inp2 == 1)) {
        if ((second_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(70);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((second_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(71);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_SECOND_ABIT))) && ((second == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
            @pull act_requester;
            if ((second == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(72);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_SECOND_ABIT)) == 0)) && ((second ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(73);
                print "^";
            }
            rtrue;
        }
    }
    rfalse;
];
[ BASIC_VISIBILITY_R;
    if (act_requester) {
        rfalse;
    }
    if (((((((NeedLightForAction()) && ((actor == player)))) && (FollowRulebook(VISIBLE_RB)))) && (RulebookSucceeded()))) {
        BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        if ((ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT) == 0)) {
            BASIC_VISIBILITY_RM(65);
            print "^";
        }
        EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        (reason_the_action_failed = BASIC_VISIBILITY_R);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ BASIC_ACCESSIBILITY_R mask at;
    if (act_requester) {
        rfalse;
    }
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if ((noun ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(noun, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if ((second ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(second, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    rfalse;
];
[ CARRYING_REQUIREMENTS_R mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if (((((mask)&(CARRY_NOUN_ABIT))) && ((noun notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
            if ((noun notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if (((((mask)&(CARRY_SECOND_ABIT))) && ((second notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
            if ((second notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    rfalse;
];
[ STANDARD_IMPLICIT_TAKING_R;
    ImplicitTake(parameter_value);
    rfalse;
];
[ REQUESTED_ACTIONS_REQUIRE_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push say__p;
        (say__p = 0);
        (rv = FollowRulebook(PERSUADE_RB));
        if ((RulebookSucceeded() == 0)) {
            if ((((deadflag == 0)) && ((say__p == 0)))) {
                REQUESTED_ACTIONS_REQUIRE_RM(65, actor);
                print "^";
            }
            ActRulebookFails(rv);
            rtrue;
        }
        @pull say__p;
    }
    rfalse;
];
[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push act_requester;
        (act_requester = 0);
        (rv = BeginAction(action, noun, second));
        if (((((meta) || ((rv == 0)))) && ((deadflag == 0)))) {
            if ((FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == 0)) {
                CARRY_OUT_REQUESTED_ACTIONS_RM(65, actor);
                print "^";
            }
        }
        @pull act_requester;
        FollowRulebook(AFTER_RB);
        ActRulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenericVerbSub ch co re vis rv;
    @push converted_action_outcome;
    (converted_action_outcome = -1);
    ((Details_of_Specific_Action-->(0)) = 1);
    if (meta) {
        ((Details_of_Specific_Action-->(0)) = 0);
    }
    ((Details_of_Specific_Action-->(1)) = keep_silent);
    ((Details_of_Specific_Action-->(2)) = ch);
    ((Details_of_Specific_Action-->(3)) = co);
    ((Details_of_Specific_Action-->(4)) = re);
    FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, 1);
    if (((RulebookFailed()) && ((converted_action_outcome == 1)))) {
        ActRulebookSucceeds();
    }
    @pull converted_action_outcome;
    rtrue;
];
[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0))) = (Details_of_Specific_Action-->(0)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1))) = (Details_of_Specific_Action-->(1)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2))) = (Details_of_Specific_Action-->(2)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3))) = (Details_of_Specific_Action-->(3)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4))) = (Details_of_Specific_Action-->(4)));
    rfalse;
];
[ TestActionBitmap obj act i j k bitmap;
    if ((obj == 0)) {
        (bitmap = ActionHappened);
    } else {
        if ((~~((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))))) {
            rfalse;
        }
        (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
    }
    if ((act == -1)) {
        return ((((bitmap->(0)))&(1)) ~= 0);
    }
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            return ((((bitmap->(j)))&(k)) ~= 0);
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
    rfalse;
];
[ UpdateActionBitmap;
    SetActionBitmap(noun, action);
    if ((action == ##Go)) {
        SetActionBitmap(location, ##Enter);
    }
];
[ SetActionBitmap obj act i j k bitmap;
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            if ((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))) {
                (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
                ((bitmap->(0)) = (((bitmap->(0)))|(1)));
                ((bitmap->(j)) = (((bitmap->(j)))|(k)));
            }
            ((ActionHappened->(0)) = (((ActionHappened->(0)))|(1)));
            ((ActionHappened->(j)) = (((ActionHappened->(j)))|(k)));
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
];
[ SayActionName act;
    DB_Action(0, 0, act, 0, 0, 2);
];
[ DA_Name n;
    if ((n ofclass K3_direction)) {
        PrintShortName(n);
    } else {
        DefArt(n);
    }
];
[ DA_Topic x a b c d i cf cw;
    (cw = (x%100));
    (cf = (x/100));
    print "~";
    for ((a = cf):(d < cw):((d)++,(a)++)) {
        (wn = a);
        (b = WordAddress(a));
        (c = WordLength(a));
        for ((i = b):(i < (b + c)):(i)++) {
            print (char) (0->(i));
        }
        if ((d < (cw - 1))) {
            print " ";
        }
    }
    print "~";
];
[ DB_Action ac acr act n s for_say t at l j v c clc;
    if ((((for_say == 0)) && ((debug_rule_nesting > 0)))) {
        print "(";
        print debug_rule_nesting;
        print ") ";
    }
    if ((((ac ~= player)) && ((for_say ~= 2)))) {
        if (acr) {
            print "asking ";
            DefArt(ac);
            print " to try ";
        } else {
            DefArt(ac);
            print " ";
        }
    }
    DB_Action_Details(act, n, s, for_say);
    if (((keep_silent) && ((for_say == 0)))) {
        print " - silently";
    }
];
[ FixInhibitFlag n act inhibit_rule_debugging;
    for ((n = 0):(n < activities_sp):(n)++) {
        (act = (activities_stack-->(n)));
        if ((act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)) {
            (inhibit_rule_debugging = 1);
        }
    }
    if ((((inhibit_flag == 0)) && (inhibit_rule_debugging))) {
        (saved_debug_rules = debug_rules);
        (debug_rules = 0);
    }
    if (((inhibit_flag) && ((inhibit_rule_debugging == 0)))) {
        (debug_rules = saved_debug_rules);
    }
    (inhibit_flag = inhibit_rule_debugging);
];
[ TestActivity A desc val i;
    for ((i = 0):(i < activities_sp):(i)++) {
        if (((activities_stack-->(i)) == A)) {
            if (desc) {
                if ((desc)((activity_parameters_stack-->(i)))) {
                    rtrue;
                }
            } else {
                if (val) {
                    if ((val == (activity_parameters_stack-->(i)))) {
                        rtrue;
                    }
                } else {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ ActivityEmpty A x;
    (x = (Activity_before_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_for_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_after_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ RulebookEmpty rb;
    if (((rulebooks_array-->(rb)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ ProcessActivityRulebook rulebook parameter rv;
    @push self;
    if (parameter) {
        (self = parameter);
    }
    (rv = FollowRulebook(rulebook, parameter, 1));
    @pull self;
    if (rv) {
        rtrue;
    }
    rfalse;
];
[ CarryOutActivity A o rv;
    BeginActivity(A, o);
    (rv = ForActivity(A, o));
    EndActivity(A, o);
    return rv;
];
[ BeginActivity A o x;
    if ((activities_sp == MAX_NESTED_ACTIVITIES)) {
        return RunTimeProblem(RTP_TOOMANYACTS);
    }
    ((activity_parameters_stack-->(activities_sp)) = o);
    ((activities_stack-->((activities_sp)++)) = A);
    FixInhibitFlag();
    MStack_CreateAVVars(A);
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_before_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ ForActivity A o x;
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_for_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ EndActivity A o rv x;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        if ((Activity_atb_rulebooks->(A))) {
            (x = action);
            (action = action_to_be);
        }
        (rv = ProcessActivityRulebook((Activity_after_rulebooks-->(A)), o));
        if ((Activity_atb_rulebooks->(A))) {
            (action = x);
        }
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        return rv;
    }
    return RunTimeProblem(RTP_CANTEND);
];
[ AbandonActivity A o;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        rtrue;
    }
    return RunTimeProblem(RTP_CANTABANDON);
];
[ DisplayFigure resource_ID one_time;
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    print "^";
    VM_Picture(resource_ID);
    print "^";
];
[ PlaySound resource_ID one_time;
    if ((resource_ID == 0)) {
        rtrue;
    }
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    VM_SoundEffect(resource_ID);
];
[ Perform_Undo;
    if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
        IMMEDIATELY_UNDO_RM(65);
        print "^";
        rtrue;
    }
    if ((IterationsOfTurnSequence == 0)) {
        IMMEDIATELY_UNDO_RM(66);
        print "^";
        rtrue;
    }
    if ((undo_flag == 0)) {
        IMMEDIATELY_UNDO_RM(67);
        print "^";
        rtrue;
    }
    if ((undo_flag == 1)) {
        IMMEDIATELY_UNDO_RM(68);
        print "^";
        rtrue;
    }
    if ((VM_Undo() == 0)) {
        IMMEDIATELY_UNDO_RM(70);
        print "^";
    }
];
[ ANNOUNCE_SCORE_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_RM(67);
        print "^";
    } else {
        ANNOUNCE_SCORE_RM(65);
        PrintRank();
    }
];
[ SWITCH_SCORE_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 1);
    }
];
[ REP_SWITCH_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_ON_RM(65);
        print "^";
    }
];
[ SWITCH_SCORE_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 0);
    }
];
[ REP_SWITCH_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_OFF_RM(65);
        print "^";
    }
];
[ PREFER_SOMETIMES_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 1);
];
[ REP_PREFER_SOMETIMES_ABBR_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_SOMETIMES_ABBR_RM(65);
    print "^";
];
[ PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 2);
];
[ REP_PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_UNABBREVIATED_RM(65);
    print "^";
];
[ PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 3);
];
[ REP_PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_ABBREVIATED_RM(65);
    print "^";
];
[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
    if ((actor ~= player)) {
        rfalse;
    }
    ANNOUNCE_PRONOUN_MEANINGS_RM(65);
    (c = ((LanguagePronouns-->(0))/3));
    if ((player ~= selfobj)) {
        (c)++;
    }
    if ((c == 0)) {
        ANNOUNCE_PRONOUN_MEANINGS_RM(68);
        rtrue;
    }
    for (((x = 1),(d = 0)):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        print "~";
        print (address) (LanguagePronouns-->(x));
        print "~ ";
        (y = (LanguagePronouns-->((x + 2))));
        if ((y == NULL)) {
            ANNOUNCE_PRONOUN_MEANINGS_RM(67);
        } else {
            ANNOUNCE_PRONOUN_MEANINGS_RM(66);
            DefArt(y);
        }
        (d)++;
        if ((d < (c - 1))) {
            print ", ";
        }
        if ((d == (c - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                print ",";
            }
            LIST_WRITER_INTERNAL_RM(67);
        }
    }
    if ((player ~= selfobj)) {
        print "~";
        print (address) ME1__WD;
        print "~ ";
        ANNOUNCE_PRONOUN_MEANINGS_RM(66);
        (c = player);
        (player = selfobj);
        DefArt(c);
        (player = c);
    }
    print ".";
    new_line;
    rtrue;
];
[ PrintPrompt i;
    RunTimeProblemShow();
    ClearRTP();
    style roman;
    EnsureBreakBeforePrompt();
    TEXT_TY_Say(CommandPromptText());
    ClearBoxedText();
    ClearParagraphing(14);
];
[ DisplayBoxedQuotation Q;
    (pending_boxed_quotation = Q);
];
[ ClearBoxedText i;
    if (pending_boxed_quotation) {
        ClearParagraphing(15);
        (pending_boxed_quotation)();
        ClearParagraphing(16);
        (pending_boxed_quotation = 0);
    }
];
[ NotifyTheScore d;
    if (((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) && ((notify_mode == 1)))) {
        DivideParagraphPoint();
        VM_Style(NOTE_VMSTY);
        (d = (score - last_score));
        if ((d > 0)) {
            ANNOUNCE_SCORE_RM(68, d);
        } else {
            if ((d < 0)) {
                ANNOUNCE_SCORE_RM(69, (-(d)));
            }
        }
        print "^";
        VM_Style(NORMAL_VMSTY);
    }
];
[ PrintRank i j v;
    if (((KIT_CONFIGURATION_BITMAP)&(RANKING_TABLE_TCBIT))) {
        ANNOUNCE_SCORE_RM(66);
        (j = TableRows(RANKING_TABLE));
        for ((i = j):(i >= 1):(i)--) {
            if ((score >= TableLookUpEntry(RANKING_TABLE, 1, i))) {
                (v = TableLookUpEntry(RANKING_TABLE, 2, i));
                TEXT_TY_Say(v);
                print ".";
                new_line;
                rtrue;
            }
        }
    }
    print ".";
    new_line;
    rtrue;
];
[ DrawStatusLine width posb;
    @push say__p;
    @push say__pc;
    BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
    VM_StatusLineHeight(1);
    VM_MoveCursorInStatusLine(1, 1);
    if (statuswin_current) {
        (width = VM_ScreenWidth());
        (posb = (width - 15));
        spaces width;
        ClearParagraphing(17);
        if ((ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == 0)) {
            VM_MoveCursorInStatusLine(1, 2);
            TEXT_TY_Say(left_hand_status_line);
            VM_MoveCursorInStatusLine(1, posb);
            TEXT_TY_Say(right_hand_status_line);
        }
        VM_MoveCursorInStatusLine(1, 1);
        VM_MainWindow();
    }
    ClearParagraphing(18);
    EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
    @pull say__pc;
    @pull say__p;
];
[ SL_Score_Moves;
    if (not_yet_in_play) {
        rtrue;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        print sline1;
        print "/";
        print sline2;
    }
];
[ SL_Location even_before;
    if (((not_yet_in_play) && ((even_before == 0)))) {
        rtrue;
    }
    if ((location == thedark)) {
        BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
        if ((ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == 0)) {
            DARKNESS_NAME_INTERNAL_RM(65);
        }
        EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
    } else {
        FindVisibilityLevels();
        if ((visibility_ceiling == location)) {
            PrintShortName(location);
        } else {
            CDefArt(visibility_ceiling);
        }
    }
];
[ DARKNESS_NAME_INTERNAL_R;
];
[ Banner;
    BeginActivity(PRINTING_BANNER_TEXT_ACT);
    if ((ForActivity(PRINTING_BANNER_TEXT_ACT) == 0)) {
        VM_Style(HEADER_VMSTY);
        TEXT_TY_Say(Story);
        VM_Style(NORMAL_VMSTY);
        print "^";
        TEXT_TY_Say(Headline);
        if (((KIT_CONFIGURATION_BITMAP)&(STORY_AUTHOR_TCBIT))) {
            print " by ";
            TEXT_TY_Say(Story_Author);
        }
        print "^";
        VM_Describe_Release();
        print " / Inform 7 v";
        PrintI6Text(I7_VERSION_NUMBER);
        print "^";
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];
[ CPrintOrRun obj prop v length i;
    if ((((obj ofclass String or Routine)) || ((prop == 0)))) {
        VM_PrintToBuffer(StorageForShortName, 160, obj);
    } else {
        if ((_final_propertyvalue(OBJECT_TY, obj, prop) == NULL)) {
            rfalse;
        }
        if ((metaclass(_final_propertyvalue(OBJECT_TY, obj, prop)) == Routine or String)) {
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        } else {
            return RunTimeError(2, obj, prop);
        }
    }
    (length = (StorageForShortName-->(0)));
    ((StorageForShortName->(WORDSIZE)) = VM_LowerToUpperCase((StorageForShortName->(WORDSIZE))));
    for ((i = WORDSIZE):(i < (length + WORDSIZE)):(i)++) {
        print (char) (StorageForShortName->(i));
    }
    if ((i > WORDSIZE)) {
        (say__p = 1);
    }
    rtrue;
];
[ Cap str nocaps;
    if (nocaps) {
        print (string) str;
    } else {
        CPrintOrRun(str, 0);
    }
];
[ PSN__ o;
    if ((o == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(o)) {
        Routine:
            print "<routine ";
            print o;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) o;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print o;
            print ">";
            rtrue;
            ;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];
[ PrintShortName obj i;
    (i = indef_mode);
    (indef_mode = NULL);
    PSN__(obj);
    (indef_mode = i);
];
[ STANDARD_NAME_PRINTING_R obj;
    (obj = parameter_value);
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(obj)) {
        Routine:
            print "<routine ";
            print obj;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) obj;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print obj;
            print ">";
            rtrue;
            ;
    }
    if ((obj == player)) {
        if ((((indef_mode == NULL)) && (caps_mode))) {
            PRINT_PROTAGONIST_INTERNAL_RM(65);
        } else {
            PRINT_PROTAGONIST_INTERNAL_RM(66);
        }
        rtrue;
    }
    if (((((indef_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_short_name_indef))))) && ((PrintOrRun(obj, A_short_name_indef, 1) ~= 0)))) {
        rtrue;
    }
    if (((((caps_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_cap_short_name))))) && ((PrintOrRun(obj, A_cap_short_name, 1) ~= 0)))) {
        (caps_mode = 0);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_short_name))) && ((PrintOrRun(obj, A_short_name, 1) ~= 0)))) {
        rtrue;
    }
    print (object) obj;
];
[ STANDARD_PLURAL_NAME_PRINTING_R obj;
    (obj = parameter_value);
    PrintOrRun(obj, A_plural, 1);
];
[ PRINT_PROTAGONIST_INTERNAL_R;
];
[ PrefaceByArticle obj acode pluralise capitalise i artform findout artval;
    if ((_final_propertyexists(OBJECT_TY, obj, A_articles))) {
        (artval = ((_final_propertyarray(OBJECT_TY, obj, A_articles))-->((acode + (short_name_case*LanguageCases)))));
        if (capitalise) {
            Cap(artval);
        } else {
            print (string) artval;
        }
        if (pluralise) {
            rtrue;
        }
        PSN__(obj);
        rtrue;
    }
    (i = GetGNAOfObject(obj));
    if (pluralise) {
        if ((((i < 3)) || ((((i >= 6)) && ((i < 9)))))) {
            (i = (i + 3));
        }
    }
    (i = (LanguageGNAsToArticles-->(i)));
    (artform = (LanguageArticles + (((3*WORDSIZE)*LanguageContractionForms)*(short_name_case + (i*LanguageCases)))));
    switch (LanguageContractionForms) {
        2:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            ;
        3:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            ;
        4:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 6))) ~= (artform-->((acode + 9))))) {
                (findout = 1);
            }
            ;
        default:
            (findout = 1);
            ;
    }
    if (findout) {
        if (pluralise) {
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        } else {
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        }
        (acode = (acode + (3*LanguageContraction(StorageForShortName))));
    }
    Cap((artform-->(acode)), (~~(capitalise)));
    if (pluralise) {
        rtrue;
    }
    PSN__(obj);
];
[ IndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        PrintOrRun(obj, A_article, 1);
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2);
    (indef_mode = i);
    (self = s);
];
[ CIndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(88);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        TEXT_TY_Say_Capitalised((obj.article));
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2, 0, 1);
    (indef_mode = i);
    (self = s);
];
[ DefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 1);
    (indef_mode = i);
    (self = s);
];
[ CDefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((obj ofclass Object)) && ((((obj has proper)) || ((obj == player)))))) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 0);
    (indef_mode = i);
    (self = s);
];
[ STANDARD_RESPONSE_ISSUING_R;
    RegardingSingleObject();
    TEXT_TY_Say((ResponseTexts-->((parameter_value - 1))));
];
[ HolderOf o;
    if (((InitialSituation-->(DONE_INIS)) == 0)) {
        return thedark;
    }
    if (((o) && ((o.component_parent)))) {
        return (o.component_parent);
    }
    if (((o) && (parent(o)))) {
        return parent(o);
    }
    rfalse;
];
[ ParentOf o;
    if (o) {
        (o = parent(o));
    }
    return o;
];
[ CoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ CoreOfParentOfCoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    if (o) {
        (o = parent(o));
    }
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ LocationOf o;
    if ((~~((o ofclass K1_room or K2_thing)))) {
        rfalse;
    }
    if ((o ofclass K4_door)) {
        if ((parent(o) == real_location)) {
            return real_location;
        }
        return FrontSideOfDoor(o);
    }
    if ((o ofclass K7_backdrop)) {
        return BackdropLocation(o);
    }
    while (o) {
        if ((o ofclass K1_room)) {
            return o;
        }
        (o = CoreOfParentOfCoreOf(o));
    }
    rfalse;
];
[ CommonAncestor o1 o2 i j;
    (o1 = CoreOf(o1));
    (o2 = CoreOf(o2));
    for ((i = o1):i:(i = CoreOfParentOfCoreOf(i))) {
        for ((j = o2):j:(j = CoreOfParentOfCoreOf(j))) {
            if ((j == i)) {
                return j;
            }
        }
    }
    rfalse;
];
[ IndirectlyContains o1 o2;
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K1_room)) && ((o2 ofclass K4_door)))) {
        if ((o1 == FrontSideOfDoor(o2))) {
            rtrue;
        }
        if ((o1 == BackSideOfDoor(o2))) {
            rtrue;
        }
        rfalse;
    }
    if ((o2 ofclass K7_backdrop)) {
        rfalse;
    }
    for ((o2 = HolderOf(o2)):((o2) && ((o2 ~= thedark))):(o2 = HolderOf(o2))) {
        if ((o2 == o1)) {
            rtrue;
        }
    }
    rfalse;
];
[ WhetherIn obj;
    if ((obj has enterable)) {
        if (IndirectlyContains(obj, player)) {
            rtrue;
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        return TestRegionalContainment(real_location, obj);
    }
    if ((obj ofclass K1_room)) {
        if ((obj == real_location)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_NOTINAROOM, obj);
    rfalse;
];
[ ContainerOf A p;
    if ((A ofclass K1_room)) {
        return (A.map_region);
    }
    (p = parent(A));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K5_container)) {
        return p;
    }
    if ((p ofclass K1_room)) {
        return p;
    }
    if ((p ofclass K9_region)) {
        return p;
    }
    rfalse;
];
[ TestContainmentRange obj e f;
    if ((obj ofclass K9_region)) {
        objectloop (f ofclass K1_room && (((f ofclass K1_room)) && (((f.map_region) == obj)))) {
            if ((f > e)) {
                return f;
            }
        }
        rfalse;
    }
    if ((obj ofclass K5_container or K1_room)) {
        if ((e == 0)) {
            return child(obj);
        }
        return sibling(e);
    }
    rfalse;
];
[ SupporterOf obj p;
    (p = parent(obj));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K6_supporter)) {
        return p;
    }
    rfalse;
];
[ CarrierOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((~~((obj has worn)))))) {
        return p;
    }
    rfalse;
];
[ WearerOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((obj has worn)))) {
        return p;
    }
    rfalse;
];
[ OwnerOf obj p;
    (p = parent(obj));
    if (((p) && ((p ofclass K8_person)))) {
        return p;
    }
    rfalse;
];
[ PartOf P;
    if ((P ofclass K2_thing)) {
        return (P.component_parent);
    }
    rfalse;
];
[ MakePart P Of First;
    if ((P == player)) {
        return RunTimeProblem(RTP_CANTMAKEPART, Of);
    }
    if (parent(P)) {
        remove P;
    }
    give P ~worn;
    if ((Of == 0)) {
        DetachPart(P);
        rtrue;
    }
    if ((P.component_parent)) {
        DetachPart(P);
    }
    ((P.component_parent) = Of);
    (First = (Of.component_child));
    ((Of.component_child) = P);
    ((P.component_sibling) = First);
];
[ DetachPart P From Daddy O;
    (Daddy = (P.component_parent));
    ((P.component_parent) = 0);
    if ((Daddy == 0)) {
        ((P.component_sibling) = 0);
        rtrue;
    }
    if (((Daddy.component_child) == P)) {
        ((Daddy.component_child) = (P.component_sibling));
        ((P.component_sibling) = 0);
        rtrue;
    }
    for ((O = (Daddy.component_child)):O:(O = (O.component_sibling))) {
        if (((O.component_sibling) == P)) {
            ((O.component_sibling) = (P.component_sibling));
            ((P.component_sibling) = 0);
            rtrue;
        }
    }
];
[ MoveObject F T opt going_mode was L;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTMOVENOTHING);
    }
    if ((F ofclass K7_backdrop)) {
        if ((T ofclass K9_region)) {
            give F ~absent;
            ((F.found_in) = (T.regional_found_in));
            if (TestRegionalContainment(LocationOf(player), T)) {
                move F to LocationOf(player);
            } else {
                remove F;
            }
            rtrue;
        }
        if ((T == FoundEverywhere)) {
            give F ~absent;
            ((F.found_in) = FoundEverywhere);
            rtrue;
        }
        return RunTimeProblem(RTP_BACKDROP, F, T);
    }
    if ((T ofclass K9_region)) {
        return RunTimeProblem(RTP_NOTBACKDROP, F, T);
    }
    if ((T == FoundEverywhere)) {
        return RunTimeProblem(RTP_BACKDROPONLY, F);
    }
    if ((~~((F ofclass K2_thing)))) {
        return RunTimeProblem(RTP_NOTTHING, F, T);
    }
    if ((F has worn)) {
        give F ~worn;
        if ((F in T)) {
            rtrue;
        }
    }
    DetachPart(F);
    if ((going_mode == 0)) {
        if ((F == player)) {
            PlayerTo(T, opt);
            rtrue;
        }
        if (IndirectlyContains(F, player)) {
            (L = LocationOf(T));
            if ((L == 0)) {
                return RunTimeProblem(RTP_CANTBEOFFSTAGE);
            }
            if ((LocationOf(player) ~= L)) {
                (was = parent(player));
                move player to real_location;
                move F to T;
                PlayerTo(was, 1);
                rtrue;
            }
        }
    }
    move F to T;
];
[ RemoveFromPlay F;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTREMOVENOTHING);
    }
    if ((F == player)) {
        return RunTimeProblem(RTP_CANTREMOVEPLAYER);
    }
    if ((F ofclass K4_door)) {
        return RunTimeProblem(RTP_CANTREMOVEDOORS);
    }
    if (IndirectlyContains(F, player)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    give F ~worn;
    DetachPart(F);
    if ((F ofclass K7_backdrop)) {
        give F absent;
    }
    remove F;
];
[ OnStage O set x;
    if ((O ofclass K1_room)) {
        rfalse;
    }
    if ((set < 0)) {
        while ((metaclass(O) == Object)) {
            if ((O ofclass K1_room)) {
                rtrue;
            }
            if ((O ofclass K9_region)) {
                rfalse;
            }
            if ((O ofclass K4_door)) {
                rtrue;
            }
            if ((O ofclass K7_backdrop)) {
                if ((O has absent)) {
                    rfalse;
                }
                rtrue;
            }
            (x = (O.component_parent));
            if (x) {
                (O = x);
                continue;
            }
            (x = parent(O));
            if (x) {
                (O = x);
                continue;
            }
            rfalse;
        }
    }
    (x = OnStage(O, (-(1))));
    if (((x) && ((set == 0)))) {
        RemoveFromPlay(O);
    }
    if ((((x == 0)) && (set))) {
        MoveObject(O, real_location);
    }
    rfalse;
];
[ PlayerTo newplace flag L;
    (L = LocationOf(newplace));
    if ((L == 0)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    @push actor;
    (actor = player);
    move player to newplace;
    (location = L);
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if ((flag == 0)) {
        R_Process(##Look);
    }
    if ((flag == 1)) {
        give location visited;
    }
    if ((flag == 2)) {
        AbbreviatedRoomDescription();
    }
    @pull actor;
];
[ MoveDuringGoing F T;
    MoveObject(F, T, 0, 1);
    if ((actor == player)) {
        (location = LocationOf(player));
        (real_location = location);
    }
];
[ FoundEverywhere;
    rtrue;
];
[ BackdropEverywhere O;
    if ((O ofclass K7_backdrop)) {
        if ((O has absent)) {
            rfalse;
        }
        if (((O.found_in) == FoundEverywhere)) {
            rtrue;
        }
    }
    rfalse;
];
[ ChangePlayer obj flag;
    if ((~~((obj ofclass K8_person)))) {
        return RunTimeProblem(RTP_CANTCHANGE, obj);
    }
    if ((~~(OnStage(obj, (-(1)))))) {
        return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
    }
    if ((obj.component_parent)) {
        return RunTimeProblem(RTP_CANTMAKEPART, obj);
    }
    if ((obj == player)) {
        rtrue;
    }
    give player ~concealed;
    if ((player has remove_proper)) {
        give player ~proper;
    }
    if ((player == selfobj)) {
        ((player.saved_short_name) = (player.short_name));
        ((player.short_name) = PRINT_PROTAGONIST_INTERNAL_RM(99));
    }
    (player = obj);
    if ((player == selfobj)) {
        ((player.short_name) = (player.saved_short_name));
    }
    if ((~~((player has proper)))) {
        give player remove_proper;
    }
    give player concealed;
    give player proper;
    (location = LocationOf(player));
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
];
[ MoveFloatingObjects toroom i k l m address flag;
    if ((toroom == 0)) {
        (toroom = real_location);
    }
    if ((toroom == 0)) {
        rtrue;
    }
    objectloop (i ofclass Object && i) {
        (address = (_final_propertyarray(OBJECT_TY, i, A_found_in)));
        if ((((address ~= 0)) && ((~~((i has absent)))))) {
            if ((ZRegion((address-->(0))) == 2)) {
                (m = (address-->(0)));
                .TestPropositionally;
                if (((m)(toroom) ~= 0)) {
                    move i to toroom;
                } else {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            } else {
                (k = (_final_propertylength(OBJECT_TY, i, A_found_in)));
                for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
                    (m = (address-->(l)));
                    if ((ZRegion(m) == 2)) {
                        jump TestPropositionally;
                    }
                    if ((((m == toroom)) || ((m in toroom)))) {
                        if ((i notin toroom)) {
                            move i to toroom;
                        }
                        (flag = 1);
                    }
                }
                if ((flag == 0)) {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            }
            if ((((i ofclass K4_door)) && ((parent(i) == 0)))) {
                move i to _final_message0(i, A_door_to);
            }
        }
    }
];
[ MoveBackdrop bd D x address;
    if ((~~((bd ofclass K7_backdrop)))) {
        return RunTimeProblem(RTP_BACKDROPONLY, bd);
    }
    if (((_final_propertylength(OBJECT_TY, bd, A_found_in)) > WORDSIZE)) {
        (address = (_final_propertyarray(OBJECT_TY, bd, A_found_in)));
        ((address-->(0)) = D);
    } else {
        ((bd.found_in) = D);
    }
    give bd ~absent;
    MoveFloatingObjects();
];
[ BackdropLocation O target address m x i k l r sl;
    if ((O has absent)) {
        rfalse;
    }
    if ((((target == 0 or real_location)) && ((parent(O) == real_location)))) {
        return real_location;
    }
    (address = (_final_propertyarray(OBJECT_TY, O, A_found_in)));
    if ((address ~= 0)) {
        (k = (_final_propertylength(OBJECT_TY, O, A_found_in)));
        for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
            (m = (address-->(l)));
            if ((ZRegion(m) == 2)) {
                (sl = location);
                if (target) {
                    (location = target);
                    (r = (m)());
                    if ((r ~= 0)) {
                        (location = sl);
                        return target;
                    }
                } else {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        (location = x);
                        (r = (m)());
                        if ((r ~= 0)) {
                            (location = sl);
                            return x;
                        }
                    }
                }
                (location = sl);
            } else {
                if ((m ofclass K9_region)) {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        if (TestRegionalContainment(x, m)) {
                            if ((target == 0 or x)) {
                                return x;
                            }
                        }
                    }
                } else {
                    if ((target == 0 or m)) {
                        return m;
                    }
                }
            }
        }
    }
    rfalse;
];
[ WearObject X P opt;
    if ((X == 0)) {
        rfalse;
    }
    if ((X notin P)) {
        MoveObject(X, P, opt);
    }
    give X worn;
];
[ MapConnection from_room dir in_direction through_door;
    if ((((from_room ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((from_room.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room)) {
            return in_direction;
        }
        if ((in_direction ofclass K4_door)) {
            @push location;
            (location = from_room);
            (through_door = _final_message0(in_direction, A_door_to));
            @pull location;
            if ((through_door ofclass K1_room)) {
                return through_door;
            }
        }
    }
    rfalse;
];
[ DoorFrom obj dir rv;
    (rv = RoomOrDoorFrom(obj, dir));
    if ((rv ofclass K4_door)) {
        return rv;
    }
    rfalse;
];
[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
    if ((((obj ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((obj.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room or K4_door)) {
            return in_direction;
        }
    }
    rfalse;
];
[ AssertMapConnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((((in_direction == 0)) || ((in_direction ofclass K1_room)))) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = r2);
        rtrue;
    }
    if ((in_direction ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    RunTimeProblem(RTP_NOEXIT, r1, dir);
];
[ AssertMapUnconnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((r1 ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    if ((in_direction == r2)) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = 0);
    }
    rtrue;
];
[ TestAdjacency R1 R2 i row;
    if ((((R1 == 0)) || ((R2 == 0)))) {
        rfalse;
    }
    if ((R1 ofclass K9_region)) {
        RunTimeProblem(RTP_REGIONSNOTADJACENT, R1);
    } else {
        if ((R2 ofclass K9_region)) {
            RunTimeProblem(RTP_REGIONSNOTADJACENT, R2);
        }
    }
    (row = ((R1.IK1_Count)*No_Directions));
    for ((i = 0):(i < No_Directions):((i)++,(row)++)) {
        if (((Map_Storage-->(row)) == R2)) {
            rtrue;
        }
    }
    rfalse;
];
[ TestRegionalContainment obj region o;
    if ((((obj == 0)) || ((region == 0)))) {
        rfalse;
    }
    if ((obj ofclass K7_backdrop or K4_door)) {
        if ((obj has absent)) {
            rfalse;
        }
        objectloop (o ofclass K1_room && (o ofclass K1_room)) {
            if (TestRegionalContainment(o, region)) {
                if (BackdropLocation(obj, o)) {
                    rtrue;
                }
            }
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        (o = obj);
    } else {
        if ((~~((obj ofclass K1_room)))) {
            (obj = LocationOf(obj));
        }
        if ((obj == 0)) {
            rfalse;
        }
        (o = (obj.map_region));
    }
    while (o) {
        if ((o == region)) {
            rtrue;
        }
        (o = parent(o));
    }
    rfalse;
];
[ FrontSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(0));
    }
    return parent(D);
];
[ BackSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(1));
    }
    rfalse;
];
[ OtherSideOfDoor D from_room rv;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_to));
        @pull location;
    }
    return rv;
];
[ DirectionDoorLeadsIn D from_room rv dir;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_dir));
        @pull location;
    }
    return rv;
];
[ TestVisibility A B;
    if ((~~(OffersLight(parent(CoreOf(A)))))) {
        rfalse;
    }
    if (suppress_scope_loops) {
        rtrue;
    }
    return TestScope(B, A);
];
[ TestTouchability A B rv;
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(B));
    }
    if ((B ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(A));
    }
    if ((TestScope(B, A) == 0)) {
        (rv = 1);
    } else {
        (rv = ObjectIsUntouchable(B, 1, A));
    }
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects();
    }
    if (rv) {
        rfalse;
    }
    rtrue;
];
[ TestConcealment A B;
    if ((((A ofclass K2_thing)) && ((B ofclass K2_thing)))) {
        if (IndirectlyContains(A, B)) {
            (particular_possession = B);
            if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ SignalMapChange;
    (map_has_changed = 1);
];
[ MapRouteTo from to filter use_doors count oy oyi ds;
    if ((from == 0)) {
        rfalse;
    }
    if ((to == 0)) {
        rfalse;
    }
    if ((from == to)) {
        rfalse;
    }
    if (((filter) && (((filter)(from) == 0)))) {
        rfalse;
    }
    if (((filter) && (((filter)(to) == 0)))) {
        rfalse;
    }
    if ((((last_filter ~= filter)) || ((last_use_doors ~= use_doors)))) {
        (map_has_changed = 1);
    }
    (oyi = 0);
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if ((((filter == 0)) || ((filter)(oy)))) {
            if (((oy.room_index) == -1)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = (oyi)++);
        } else {
            if (((oy.room_index) >= 0)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = -1);
        }
    }
    (oyi = 0);
    objectloop (oy ofclass K4_door && (oy ofclass K4_door)) {
        (ds = 0);
        if (((((((use_doors)&(2))) || ((oy has open)))) || ((((oy has openable)) && ((~~((oy has locked)))))))) {
            (ds = 1);
        }
        if (((DoorRoutingViable->(oyi)) ~= ds)) {
            (map_has_changed = 1);
        }
        ((DoorRoutingViable->(oyi)) = ds);
        (oyi)++;
    }
    if (map_has_changed) {
        ComputeFWMatrix(filter, use_doors);
        (map_has_changed = 0);
        (last_filter = filter);
        (last_use_doors = use_doors);
    }
    if (count) {
        return FastCountRouteTo(from, to, filter, use_doors);
    }
    return FastRouteTo(from, to, filter, use_doors);
];
[ FastRouteTo from to filter use_doors diri i dir oy;
    if ((from == to)) {
        rfalse;
    }
    (i = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((i == 0)) {
        rfalse;
    }
    (diri = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))%No_Directions));
    (i = 0);
    objectloop (dir ofclass K3_direction && (dir ofclass K3_direction)) {
        if ((i == diri)) {
            return dir;
        }
        (i)++;
    }
    rfalse;
];
[ FastCountRouteTo from to filter use_doors k;
    if ((from == to)) {
        rfalse;
    }
    (k = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((k == 0)) {
        return (-(1));
    }
    return k;
];
[ ComputeFWMatrix filter use_doors oy ox oj axy ayj axj dir diri nd row;
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = 0);
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            (row = ((oy.IK1_Count)*No_Directions));
            for ((diri = 0):(diri < No_Directions):(diri)++) {
                (ox = (Map_Storage-->((row + diri))));
                if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                    continue;
                }
                if (((((use_doors) && ((ox ofclass K4_door)))) && (((((use_doors)&(2))) || ((DoorRoutingViable->((ox.IK4_Count)))))))) {
                    @push location;
                    (location = oy);
                    (ox = _final_message0(ox, A_door_to));
                    @pull location;
                    if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                        ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                        continue;
                    }
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    (axy = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))/No_Directions));
                    if ((axy > 0)) {
                        objectloop (oj ofclass Object && (oj has mark_as_room)) {
                            if (((oj.room_index) >= 0)) {
                                (ayj = ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                if ((ayj > 0)) {
                                    (axj = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index)))) = (((axy + ayj)*No_Directions) + ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))%No_Directions)));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
];
[ RunTimeProblemShowWM n par1 par2 par3;
    switch (n) {
        RTP_BACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (a backdrop) to ";
            DefArt(par2);
            print ", which is not a region.^";
            ;
        RTP_CANTCHANGE:
            print "Tried to change player to ";
            DefArt(par1);
            print ", which is not a person.^";
            ;
        RTP_NOEXIT:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it didn't seem to have such an exit to change.^";
            ;
        RTP_EXITDOOR:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it led to a door, not a room.^";
            ;
        RTP_TOOMANYEVENTS:
            print "Too many timed events are going on at once.^";
            ;
        RTP_CANTMOVENOTHING:
            print "You can't move nothing.^";
            ;
        RTP_CANTREMOVENOTHING:
            print "You can't remove nothing from play.^";
            ;
        RTP_NOTBACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (not a backdrop) to ";
            DefArt(par2);
            print ", which is a region.^";
            ;
        RTP_NOTINAROOM:
            print "Attempt to test if the current location is '";
            DefArt(par1);
            print "', which is not a room or region.^";
            ;
        RTP_BADTOPIC:
            print "Attempt to see if a snippet of text matches something which is not a topic.^";
            ;
        RTP_DONTIGNORETURNSEQUENCE:
            print "Attempt to ignore the turn sequence rules.^";
            ;
        RTP_SAYINVALIDSNIPPET:
            print "Attempt to say a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_SPLICEINVALIDSNIPPET:
            print "Attempt to splice a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_INCLUDEINVALIDSNIPPET:
            print "Attempt to match a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_CANTREMOVEPLAYER:
            print "Attempt to remove the player from play.^";
            ;
        RTP_CANTBEOFFSTAGE:
            print "Attempt to move the player off-stage.^";
            ;
        RTP_CANTREMOVEDOORS:
            print "Attempt to remove a door from play.^";
            ;
        RTP_CANTCHANGEOFFSTAGE:
            print "Attempt to change the player to a person off-stage.^";
            ;
        RTP_BACKDROPONLY:
            print "Only backdrops can be moved to multiple places.^";
            ;
        RTP_NOTTHING:
            print "Tried to move ";
            DefArt(par1);
            print " (not a thing) to ";
            DefArt(par2);
            print ", but only things can move around.^";
            ;
        RTP_CANTMAKEPART:
            print "Tried to make the player part of something: ";
            DefArt(par1);
            print ".^";
            ;
        RTP_REGIONSNOTADJACENT:
            print "You can't test whether something is adjacent to a region: ";
            print "such as, in this case, ";
            DefArt(par1);
            print ".^";
            ;
        RTP_SCENEHASNTSTARTED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't started, so you can't ask when it did.^";
            ;
        RTP_SCENEHASNTENDED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't ended, so you can't ask when it did.^";
            ;
    }
];
[ NUMBER_TY_to_TIME_TY n;
    (n = (n%1440));
    if ((n < 0)) {
        return (n + 1440);
    }
    return n;
];
[ PrintTimeOfDay t h aop;
    if ((t < 0)) {
        print "<no time>";
        rtrue;
    }
    if ((t >= TWELVE_HOURS)) {
        (aop = "pm");
        (t = (t - TWELVE_HOURS));
    } else {
        (aop = "am");
    }
    (h = (t/ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    print h;
    print ":";
    if (((t%ONE_HOUR) < 10)) {
        print "0";
    }
    print (t%ONE_HOUR);
    print " ";
    print (string) aop;
];
[ PrintTimeOfDayEnglish t h m dir aop;
    (h = ((t/ONE_HOUR)%12));
    (m = (t%ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    if ((m == 0)) {
        LanguageNumber(h);
        print " o'clock";
        rtrue;
    }
    (dir = "past");
    if ((m > HALF_HOUR)) {
        (m = (ONE_HOUR - m));
        (h = ((h + 1)%12));
        if ((h == 0)) {
            (h = 12);
        }
        (dir = "to");
    }
    switch (m) {
        QUARTER_HOUR:
            print "quarter";
            ;
        HALF_HOUR:
            print "half";
            ;
        default:
            LanguageNumber(m);
            if (((m%5) ~= 0)) {
                if ((m == 1)) {
                    print " minute";
                } else {
                    print " minutes";
                }
            }
            ;
    }
    print " ";
    print (string) dir;
    print " ";
    LanguageNumber(h);
];
[ TIME_TOKEN first_word second_word at length flag illegal_char offhour hr mn i original_wn;
    (original_wn = wn);
    (i = TIME_TOKEN_INNER());
    if ((i ~= GPR_FAIL)) {
        return i;
    }
    (wn = original_wn);
    (first_word = NextWordStopped());
    switch (first_word) {
        'midnight':
            (parsed_number = 0);
            return GPR_NUMBER;
            ;
        'midday', 'noon':
            (parsed_number = TWELVE_HOURS);
            return GPR_NUMBER;
            ;
    }
    (at = WordAddress((wn - 1)));
    (length = WordLength((wn - 1)));
    for ((i = 0):(i < length):(i)++) {
        switch ((at->(i))) {
            58:
                if ((((((flag == 0)) && ((i > 0)))) && ((i < (length - 1))))) {
                    (flag = 1);
                } else {
                    (illegal_char = 1);
                }
                ;
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
                ;
            default:
                (illegal_char = 1);
                ;
        }
    }
    if ((((((length < 3)) || ((length > 5)))) || (illegal_char))) {
        (flag = 0);
    }
    if (flag) {
        for ((i = 0):((at->(i)) ~= 58):((i)++,(hr = (hr*10)))) {
            (hr = ((hr + (at->(i))) - 48));
        }
        (hr = (hr/10));
        for ((i)++:(i < length):((i)++,(mn = (mn*10)))) {
            (mn = ((mn + (at->(i))) - 48));
        }
        (mn = (mn/10));
        (second_word = NextWordStopped());
        (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
        if ((parsed_number == -1)) {
            return GPR_FAIL;
        }
        if ((second_word ~= 'pm' or 'am')) {
            (wn)--;
        }
        return GPR_NUMBER;
    }
    (offhour = -1);
    if ((first_word == 'half')) {
        (offhour = HALF_HOUR);
    }
    if ((first_word == 'quarter')) {
        (offhour = QUARTER_HOUR);
    }
    if ((offhour < 0)) {
        (offhour = TryNumber((wn - 1)));
    }
    if ((((offhour < 0)) || ((offhour >= ONE_HOUR)))) {
        return GPR_FAIL;
    }
    (second_word = NextWordStopped());
    switch (second_word) {
        'o^clock', 'am', 'pm', (-(1)):
            (hr = offhour);
            if ((hr > 12)) {
                return GPR_FAIL;
            }
            ;
        'to', 'past':
            (mn = offhour);
            (hr = TryNumber(wn));
            if ((hr <= 0)) {
                switch (NextWordStopped()) {
                    'noon', 'midday':
                        (hr = 12);
                        ;
                    'midnight':
                        (hr = 0);
                        ;
                    default:
                        return GPR_FAIL;
                        ;
                }
            }
            if ((hr >= 13)) {
                return GPR_FAIL;
            }
            if ((second_word == 'to')) {
                (mn = (ONE_HOUR - mn));
                (hr)--;
                if ((hr < 0)) {
                    (hr = 23);
                }
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
        default:
            (hr = offhour);
            (mn = TryNumber(--(wn)));
            if ((((mn < 0)) || ((mn >= ONE_HOUR)))) {
                return GPR_FAIL;
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
    }
    (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
    if ((parsed_number < 0)) {
        return GPR_FAIL;
    }
    if ((second_word ~= 'pm' or 'am' or 'o^clock')) {
        (wn)--;
    }
    return GPR_NUMBER;
];
[ HoursMinsWordToTime hour minute word x;
    if ((hour >= 24)) {
        return (-(1));
    }
    if ((minute >= ONE_HOUR)) {
        return (-(1));
    }
    (x = ((hour*ONE_HOUR) + minute));
    if ((hour >= 13)) {
        return x;
    }
    (x = (x%TWELVE_HOURS));
    if ((word == 'pm')) {
        (x = (x + TWELVE_HOURS));
    }
    if ((((word ~= 'am' or 'pm')) && ((hour == 12)))) {
        (x = (x + TWELVE_HOURS));
    }
    return x;
];
[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
    (original_wn = wn);
    (wn = original_wn);
    (first_word = NextWordStopped());
    (wn)--;
    if ((first_word == 'an' or 'a//')) {
        (mn = 1);
    } else {
        (mn = TryNumber(wn));
    }
    if ((mn == -1000)) {
        (first_word = NextWordStopped());
        if ((first_word == 'half')) {
            (offhour = HALF_HOUR);
        }
        if ((first_word == 'quarter')) {
            (offhour = QUARTER_HOUR);
        }
        if ((offhour > 0)) {
            (second_word = NextWordStopped());
            if ((second_word == 'of')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'an')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'hour')) {
                (parsed_number = offhour);
                return GPR_NUMBER;
            }
        }
        return GPR_FAIL;
    }
    (wn)++;
    (first_word = NextWordStopped());
    switch (first_word) {
        'minutes', 'minute':
            (mult = 1);
            ;
        'hours', 'hour':
            (mult = 60);
            ;
        default:
            return GPR_FAIL;
            ;
    }
    (parsed_number = (mn*mult));
    if ((mult == 60)) {
        (mn = TryNumber(wn));
        if ((mn ~= -1000)) {
            (wn)++;
            (first_word = NextWordStopped());
            if ((first_word == 'minutes' or 'minute')) {
                (parsed_number = (parsed_number + mn));
            } else {
                (wn = (wn - 2));
            }
        }
    }
    return GPR_NUMBER;
];
[ SCENE_CHANGE_MACHINERY_R;
    DetectSceneChange();
];
[ DuringSceneMatching prop sc;
    for ((sc = 0):(sc < NUMBER_SCENES_CREATED):(sc)++) {
        if (((((scene_status-->(sc)) == 1)) && ((prop)((sc + 1))))) {
            rtrue;
        }
    }
    rfalse;
];
[ SceneUtility sc task;
    if ((sc <= 0)) {
        rfalse;
    }
    if ((task == 1 or 2)) {
        if (((scene_endings-->((sc - 1))) == 0)) {
            return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
        }
    } else {
        if (((scene_endings-->((sc - 1))) <= 1)) {
            return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
        }
    }
    switch (task) {
        1:
            return ((the_time - (scene_started-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        2:
            return (scene_started-->((sc - 1)));
            ;
        3:
            return ((the_time - (scene_ended-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        4:
            return (scene_ended-->((sc - 1)));
            ;
    }
];
[ ChronologyPoint pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        ((past_chronological_record-->(pt)) = (present_chronological_record-->(pt)));
    }
];
[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        TestSinglePastState(0, pt, 1, (-(1)));
    }
    ChronologyPoint();
    rfalse;
];
[ TrackActions readjust oow i;
    for ((i = 0):(PastActionsI6Routines-->(i)):(i)++) {
        if (((PastActionsI6Routines-->(i)))()) {
            if (readjust) {
                continue;
            }
            ((TimesActionHasHappened-->(i)))++;
            if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                ((LastTurnActionHappenedOn-->(i)) = (turns + 5));
                ((ActionCurrentlyHappeningFlag->(i)) = 1);
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)))++;
                }
            }
        } else {
            if ((oow == 0)) {
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)) = 0);
                }
                if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                    ((ActionCurrentlyHappeningFlag->(i)) = 0);
                }
            }
        }
    }
];
[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return STORED_ACTION_TY_Create(arg2);
            ;
        DESTROY_KOVS:
            STORED_ACTION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return 6;
            ;
        COPY_KOVS:
            STORED_ACTION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return STORED_ACTION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return STORED_ACTION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            STORED_ACTION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ STORED_ACTION_TY_Create sb stora;
    (stora = FlexAllocate((6*WORDSIZE), STORED_ACTION_TY, BLK_FLAG_WORD));
    BlkValueWrite(stora, STORA_ACTION_F, ##Wait, 1);
    BlkValueWrite(stora, STORA_NOUN_F, 0, 1);
    BlkValueWrite(stora, STORA_SECOND_F, 0, 1);
    BlkValueWrite(stora, STORA_ACTOR_F, player, 1);
    BlkValueWrite(stora, STORA_REQUEST_F, 0, 1);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, 1);
    return BlkValueCreateSB1(sb, stora);
];
[ STORED_ACTION_TY_New a n s ac req stora;
    if ((stora == 0)) {
        (stora = BlkValueCreate(STORED_ACTION_TY));
    }
    BlkValueWrite(stora, STORA_ACTION_F, a);
    BlkValueWrite(stora, STORA_NOUN_F, n);
    BlkValueWrite(stora, STORA_SECOND_F, s);
    BlkValueWrite(stora, STORA_ACTOR_F, ac);
    BlkValueWrite(stora, STORA_REQUEST_F, req);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    return stora;
];
[ STORED_ACTION_TY_Destroy stora toc;
    (toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (toc) {
        BlkValueFree(toc);
    }
];
[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
    (tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F));
    if ((tocfrom == 0)) {
        rtrue;
    }
    (tocto = BlkValueCreate(TEXT_TY));
    BlkValueCopy(tocto, tocfrom);
    BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];
[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
    (delta = (BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F)));
    if (delta) {
        return delta;
    }
    (itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F));
    (itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F));
    if ((((itleft ~= 0)) && ((itright ~= 0)))) {
        return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
    }
    return (itleft - itright);
];
[ STORED_ACTION_TY_Distinguish stora1 stora2;
    if ((STORED_ACTION_TY_Compare(stora1, stora2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ STORED_ACTION_TY_Hash stora rv it;
    (rv = BlkValueRead(stora, STORA_ACTION_F));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_NOUN_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_SECOND_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_ACTOR_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_REQUEST_F)));
    (it = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if ((it ~= 0)) {
        (rv = ((rv*33) + TEXT_TY_Support(HASH_KOVS, it)));
    }
    return rv;
];
[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    (saved_pn = parsed_number);
    (saved_action = action);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (cf = consult_from);
    (cw = consult_words);
    (at = FindAction(-1));
    (K1 = (ActionData-->((at + AD_NOUN_KOV))));
    (K2 = (ActionData-->((at + AD_SECOND_KOV))));
    if ((K1 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        if ((((K1 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    if ((K2 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        if ((((K2 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    DB_Action(BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F), 1);
    (parsed_number = saved_pn);
    (action = saved_action);
    (consult_from = cf);
    (consult_words = cw);
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
];
[ STORED_ACTION_TY_Involves stora item at;
    (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
    if (at) {
        if (((((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_NOUN_F) == item)))) {
            rtrue;
        }
        if (((((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_SECOND_F) == item)))) {
            rtrue;
        }
    }
    if ((BlkValueRead(stora, STORA_ACTOR_F) == item)) {
        rtrue;
    }
    rfalse;
];
[ STORED_ACTION_TY_Part stora ind at ado;
    if ((ind == STORA_NOUN_F or STORA_SECOND_F)) {
        if ((ind == STORA_NOUN_F)) {
            (ado = AD_NOUN_KOV);
        } else {
            (ado = AD_SECOND_KOV);
        }
        (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
        if (((at) && (((ActionData-->((at + ado))) == OBJECT_TY)))) {
            return BlkValueRead(stora, ind);
        }
        rfalse;
    }
    return BlkValueRead(stora, ind);
];
[ STORED_ACTION_TY_Adopt stora at;
    ((SAT_Tmp-->(1)) = action);
    ((SAT_Tmp-->(2)) = noun);
    ((SAT_Tmp-->(3)) = second);
    ((SAT_Tmp-->(4)) = actor);
    ((SAT_Tmp-->(5)) = act_requester);
    ((SAT_Tmp-->(6)) = parsed_number);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        (noun = BlkValueRead(stora, STORA_NOUN_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        (noun = 0);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        (second = BlkValueRead(stora, STORA_SECOND_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        (second = 0);
    }
    (actor = BlkValueRead(stora, STORA_ACTOR_F));
    if (BlkValueRead(stora, STORA_REQUEST_F)) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
];
[ STORED_ACTION_TY_Unadopt;
    (action = (SAT_Tmp-->(1)));
    (noun = (SAT_Tmp-->(2)));
    (second = (SAT_Tmp-->(3)));
    (actor = (SAT_Tmp-->(4)));
    (act_requester = (SAT_Tmp-->(5)));
    (parsed_number = (SAT_Tmp-->(6)));
    return (SAT_Tmp-->(0));
];
[ STORED_ACTION_TY_Current stora at text_of_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rfalse;
    }
    BlkValueWrite(stora, STORA_ACTION_F, action);
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_NOUN_F, noun);
    } else {
        BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_SECOND_F, second);
    } else {
        BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
    }
    BlkValueWrite(stora, STORA_ACTOR_F, actor);
    if (act_requester) {
        BlkValueWrite(stora, STORA_REQUEST_F, 1);
    } else {
        BlkValueWrite(stora, STORA_REQUEST_F, 0);
    }
    if (((at) && (((((ActionData-->((at + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((at + AD_SECOND_KOV))) == UNDERSTANDING_TY)))))) {
        (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
        if ((text_of_command == 0)) {
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
        }
        BlkValueCast(text_of_command, SNIPPET_TY, players_command);
    } else {
        BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    }
    return stora;
];
[ STORED_ACTION_TY_Try stora ks text_of_command saved_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    if (ks) {
        @push keep_silent;
        (keep_silent = 1);
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    TryAction(BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F));
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    if (ks) {
        @pull keep_silent;
    }
];
[ WordCount;
    return (parse-->(0));
];
[ WordAddress wordnum;
    return (buffer + (parse-->((wordnum*3))));
];
[ WordLength wordnum;
    return (parse-->(((wordnum*3) - 1)));
];
[ WordFrom w p i j wc;
    (wc = (p-->(0)));
    (i = ((w*3) - 2));
    if ((((w < 1)) || ((w > wc)))) {
        rfalse;
    }
    (j = (p-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWord i j wc;
    (wc = (parse-->(0)));
    (i = ((wn*3) - 2));
    (wn)++;
    if ((((wn < 2)) || ((wn > (wc + 1))))) {
        rfalse;
    }
    (j = (parse-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWordStopped wc;
    (wc = (parse-->(0)));
    if ((((wn < 1)) || ((wn > wc)))) {
        (wn)++;
        return (-(1));
    }
    return NextWord();
];
[ PrintSnippet snip from to i w1 w2;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((((w2 < w1)) || ((w1 < 1)))) || ((w2 > WordCount())))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
    }
    (from = WordAddress(w1));
    (to = ((WordAddress(w2) + WordLength(w2)) - 1));
    for ((i = from):(i <= to):(i)++) {
        print (char) (i->(0));
    }
];
[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen saved;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rtrue;
        }
        return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
    }
    @push say__p;
    @push say__pc;
    (nextw = (w2 + 1));
    (at = (WordAddress(w1) - buffer));
    if ((nextw <= WordCount())) {
        (endsnippet = ((100*nextw) + ((WordCount() - nextw) + 1)));
    }
    (saved = (buffer2-->(0)));
    ((buffer2-->(0)) = 120);
    (newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet));
    for ((i = 0):(((i < newlen)) && (((at + i) < 120))):(i)++) {
        ((buffer->((at + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer-->(0)) = (at + i));
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    ((buffer2-->(0)) = saved);
    @pull say__pc;
    @pull say__p;
];
[ SpliceSnippet__TextPrinter t endsnippet;
    TEXT_TY_Say(t);
    if (endsnippet) {
        print " ";
        PrintSnippet(endsnippet);
    }
];
[ SnippetIncludes test snippet w1 w2 wlen i j;
    (w1 = (snippet/100));
    (w2 = ((w1 + (snippet%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
    }
    if ((metaclass(test) == Routine)) {
        (wlen = (snippet%100));
        for (((i = w1),(j = wlen)):(j > 0):((i)++,(j)--)) {
            if (((test)(i,0) ~= GPR_FAIL)) {
                return (((i*100) + wn) - i);
            }
        }
    }
    rfalse;
];
[ SnippetMatches snippet topic_gpr rv;
    (wn = 1);
    if ((topic_gpr == 0)) {
        rfalse;
    }
    if ((metaclass(topic_gpr) == Routine)) {
        (rv = (topic_gpr)((snippet/100),(snippet%100)));
        if ((rv ~= GPR_FAIL)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_BADTOPIC);
    rfalse;
];
[ UnpackGrammarLine line_address i size;
    for ((i = 0):(i < 32):(i)++) {
        ((line_token-->(i)) = ENDIT_TOKEN);
        ((line_ttype-->(i)) = ELEMENTARY_TT);
        ((line_tdata-->(i)) = ENDIT_TOKEN);
    }
    @aloads line_address 0 action_to_be;
    (action_reversed = ((((line_address->(2)))&(1)) ~= 0));
    (line_address = (line_address - 2));
    (size = 5);
    (params_wanted = 0);
    for ((i = 0):1:(i)++) {
        (line_address = (line_address + size));
        if (((line_address->(0)) == ENDIT_TOKEN)) {
            break;
        }
        ((line_token-->(i)) = line_address);
        AnalyseToken(line_address);
        if ((found_ttype ~= PREPOSITION_TT)) {
            (params_wanted)++;
        }
        ((line_ttype-->(i)) = found_ttype);
        ((line_tdata-->(i)) = found_tdata);
    }
    return (line_address + 1);
];
[ AnalyseToken token;
    if ((token == ENDIT_TOKEN)) {
        (found_ttype = ELEMENTARY_TT);
        (found_tdata = ENDIT_TOKEN);
        rtrue;
    }
    (found_ttype = (((token->(0)))&(15)));
    (found_tdata = ((token + 1)-->(0)));
];
[ KeyboardPrimitive a_buffer a_table;
    return VM_ReadKeyboard(a_buffer, a_table);
];
[ Keyboard a_buffer a_table nw i w w2 x1 x2;
    (sline1 = score);
    (sline2 = turns);
    while (1) {
        for ((i = 0):(i < 64):(i)++) {
            ((oops_workspace->(i)) = (a_buffer->(i)));
        }
        PrintPrompt();
        DrawStatusLine();
        KeyboardPrimitive(a_buffer, a_table);
        (nw = (a_table-->(0)));
        if ((nw == 0)) {
            @push etype;
            (etype = BLANKLINE_PE);
            (players_command = 100);
            BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
            if ((ForActivity(PRINTING_A_PARSER_ERROR_ACT) == 0)) {
                PARSER_ERROR_INTERNAL_RM(88, noun);
                print "^";
            }
            EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            @pull etype;
            continue;
        }
        (w = (a_table-->(1)));
        if ((w == OOPS1__WD or OOPS2__WD or OOPS3__WD)) {
            if ((oops_from == 0)) {
                PARSER_COMMAND_INTERNAL_RM(65);
                print "^";
                continue;
            }
            if ((nw == 1)) {
                PARSER_COMMAND_INTERNAL_RM(66);
                print "^";
                continue;
            }
            if ((nw > 2)) {
                PARSER_COMMAND_INTERNAL_RM(67);
                print "^";
                continue;
            }
            for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
                ((buffer2->(i)) = (a_buffer->(i)));
            }
            (x1 = (a_table-->(6)));
            (x2 = (a_table-->(5)));
            for ((i = 0):(i < 64):(i)++) {
                ((a_buffer->(i)) = (oops_workspace->(i)));
            }
            VM_Tokenise(a_buffer, a_table);
            (w = (a_table-->((3*oops_from))));
            (w2 = (a_table-->(((3*oops_from) - 1))));
            for ((i = 0):(i < w2):(i)++) {
                ((a_buffer->((i + w))) = 32);
            }
            if ((w2 < x2)) {
                for ((i = (INPUT_BUFFER_LEN - 1)):(i >= (w + x2)):(i)--) {
                    ((a_buffer->(i)) = (a_buffer->(((i - x2) + w2))));
                }
                ((a_buffer-->(0)) = ((a_buffer-->(0)) + (x2 - w2)));
            }
            for ((i = 0):(i < x2):(i)++) {
                ((a_buffer->((i + w))) = (buffer2->((i + x1))));
            }
            VM_Tokenise(a_buffer, a_table);
            (nw = (a_table-->(0)));
            return nw;
        }
        if ((((w == UNDO1__WD or UNDO2__WD or UNDO3__WD)) && ((nw == 1)))) {
            Perform_Undo();
            continue;
        }
        (i = VM_Save_Undo());
        if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
            (undo_flag = 0);
        } else {
            (undo_flag = 2);
        }
        if ((i == -1)) {
            (undo_flag = 0);
        }
        if ((i == 0)) {
            (undo_flag = 1);
        }
        if ((i == 2)) {
            DealWithUndo();
            continue;
        }
        return nw;
    }
];
[ DealWithUndo;
    VM_RestoreWindowColours();
    VM_Style(SUBHEADER_VMSTY);
    SL_Location();
    print "^";
    VM_Style(NORMAL_VMSTY);
    IMMEDIATELY_UNDO_RM(69);
    print "^";
];
[ Parser__parse syntax line num_lines line_address i j k token l m inferred_go;
    (cobj_flag = 0);
    ((parser_results-->(ACTION_PRES)) = 0);
    ((parser_results-->(NO_INPS_PRES)) = 0);
    ((parser_results-->(INP1_PRES)) = 0);
    ((parser_results-->(INP2_PRES)) = 0);
    (meta = 0);
    if (held_back_mode) {
        (held_back_mode = 0);
        (wn = hb_wn);
        if ((verb_wordnum > 0)) {
            (i = WordAddress(verb_wordnum));
        } else {
            (i = WordAddress(1));
        }
        (j = WordAddress(wn));
        if ((i <= j)) {
            for (:(i < j):(i)++) {
                ((i->(0)) = 32);
            }
        }
        (i = NextWord());
        if ((i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (i = (WordAddress((wn - 2)) - buffer));
            if ((wn > num_words)) {
                (j = (INPUT_BUFFER_LEN - 1));
            } else {
                (j = (WordAddress(wn) - buffer));
            }
            for (:(i < j):(i)++) {
                ((buffer3->(i)) = 32);
            }
        }
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }
    .ReType;
    (cobj_flag = 0);
    (actors_location = ScopeCeiling(player));
    BeginActivity(READING_A_COMMAND_ACT);
    if ((ForActivity(READING_A_COMMAND_ACT) == 0)) {
        Keyboard(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
    }
    if (EndActivity(READING_A_COMMAND_ACT)) {
        jump ReType;
    }
    .ReParse;
    (parser_inflection = A_name);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (inferred_go = 0);
    LanguageToInformese();
    VM_Tokenise(buffer, parse);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (token_filter = 0);
    (allow_plurals = 1);
    ResetDescriptors();
    (k = 0);
    (verb_wordnum = 1);
    (actor = player);
    (actors_location = ScopeCeiling(player));
    (usual_grammar_after = 0);
    .AlmostReParse;
    (scope_token = 0);
    (action_to_be = NULL);
    .BeginCommand;
    (wn = verb_wordnum);
    (verb_word = NextWordStopped());
    if ((verb_word == -1)) {
        (best_etype = STUCK_PE);
        jump GiveError;
    }
    if ((verb_word == comma_word)) {
        (best_etype = COMMABEGIN_PE);
        jump GiveError;
    }
    if ((verb_word == AGAIN2__WD or AGAIN3__WD)) {
        (verb_word = AGAIN1__WD);
    }
    if ((verb_word == AGAIN1__WD)) {
        if ((actor ~= player)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
        if (((buffer3-->(0)) == 0)) {
            PARSER_COMMAND_INTERNAL_RM(68);
            print "^";
            jump ReType;
        }
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer->(i)) = (buffer3->(i)));
        }
        VM_Tokenise(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
        jump ReParse;
    }
    if ((verb_word ~= AGAIN1__WD)) {
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer3->(i)) = (buffer->(i)));
        }
    }
    if ((usual_grammar_after == 0)) {
        (j = verb_wordnum);
        (i = RunRoutines(actor, A_grammar));
        if ((((i ~= 0 or 1)) && (VM_InvalidDictionaryAddress(i)))) {
            (usual_grammar_after = verb_wordnum);
            (i = (-(i)));
        }
        if ((i == 1)) {
            ((parser_results-->(ACTION_PRES)) = action);
            ((parser_results-->(NO_INPS_PRES)) = 0);
            ((parser_results-->(INP1_PRES)) = noun);
            ((parser_results-->(INP2_PRES)) = second);
            if (noun) {
                ((parser_results-->(NO_INPS_PRES)) = 1);
            }
            if (second) {
                ((parser_results-->(NO_INPS_PRES)) = 2);
            }
            rtrue;
        }
        if ((i ~= 0)) {
            (verb_word = i);
            (wn)--;
            (verb_wordnum)--;
        } else {
            (wn = verb_wordnum);
            (verb_word = NextWord());
        }
    } else {
        (usual_grammar_after = 0);
    }
    if ((verb_word == 0)) {
        (i = wn);
        (verb_word = LanguageIsVerb(buffer, parse, verb_wordnum));
        (wn = i);
    }
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (wn = verb_wordnum);
        (indef_mode = 0);
        (token_filter = 0);
        (parameters = 0);
        @push actor;
        @push action;
        @push action_to_be;
        (actor = player);
        (meta = 0);
        (action = ##Go);
        (action_to_be = ##Go);
        (l = NounDomain(Compass, 0, 0));
        @pull action_to_be;
        @pull action;
        @pull actor;
        if ((l == REPARSE_CODE)) {
            jump ReParse;
        }
        if ((((l ~= 0)) && ((l ofclass K3_direction)))) {
            ((parser_results-->(ACTION_PRES)) = ##Go);
            ((parser_results-->(NO_INPS_PRES)) = 1);
            ((parser_results-->(INP1_PRES)) = l);
            (inferred_go = 1);
            jump LookForMore;
        }
    }
    if ((actor == player)) {
        for ((j = 2):(j <= num_words):(j)++) {
            (i = NextWord());
            if ((i == comma_word)) {
                jump Conversation;
            }
        }
    }
    jump NotConversation;
    .Conversation;
    (j = (wn - 1));
    (wn = 1);
    (lookahead = HELD_TOKEN);
    (scope_reason = TALKING_REASON);
    (l = NounDomain(player, actors_location, CREATURE_TOKEN));
    (scope_reason = PARSING_REASON);
    if ((l == REPARSE_CODE)) {
        jump ReParse;
    }
    if ((l == 0)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = MISSINGPERSON_PE);
        jump GiveError;
    }
    if ((((~~((l has animate)))) && ((~~((l has talkable)))))) {
        (best_etype = ANIMALISTEN_PE);
        (noun = l);
        jump GiveError;
    }
    if ((wn ~= j)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = TOTALK_PE);
        jump GiveError;
    }
    PronounNotice(l);
    (verb_wordnum = (j + 1));
    if ((l == player)) {
        (wn = verb_wordnum);
        if ((NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
    }
    (actor = l);
    (actors_location = ScopeCeiling(l));
    jump BeginCommand;
    .NotConversation;
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (verb_word = UnknownVerb(verb_word));
        if ((verb_word ~= 0)) {
            jump VerbAccepted;
        }
        (best_etype = VERB_PE);
        jump GiveError;
    }
    .VerbAccepted;
    (meta = ((((verb_word->(#dict_par1)))&(2))/2));
    if ((((meta == 1)) && ((actor ~= player)))) {
        (best_etype = VERB_PE);
        (meta = 0);
        jump GiveError;
    }
    (i = DictionaryWordToVerbNum(verb_word));
    (syntax = (#grammar_table-->((i + 1))));
    (num_lines = ((syntax->(0)) - 1));
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    (best_etype = STUCK_PE);
    (nextbest_etype = STUCK_PE);
    (multiflag = 0);
    (line_address = (syntax + 1));
    for ((line = 0):(line <= num_lines):(line)++) {
        (line_address = UnpackGrammarLine(line_address));
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (multi_context = 0);
        (etype = STUCK_PE);
        (multi_had = 0);
        (wn = (verb_wordnum + 1));
        (advance_warning = -1);
        (indef_mode = 0);
        for (((i = 0),((m = 0),(pcount = 0))):((line_token-->(pcount)) ~= ENDIT_TOKEN):(pcount)++) {
            (scope_token = 0);
            if (((line_ttype-->(pcount)) ~= PREPOSITION_TT)) {
                (i)++;
            }
            if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
                if (((line_tdata-->(pcount)) == MULTI_TOKEN)) {
                    (m = 1);
                }
                if (((((line_tdata-->(pcount)) == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) && ((i == 1)))) {
                    (pcount)++;
                    if (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
                        do {(l = NextWord());
                        } until (
                            (((wn > num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                        ;
                        if ((wn > num_words)) {
                            jump EmptyLine;
                        }
                        do {if ((PrepositionChain(l, pcount) ~= -1)) {
                            if ((((((line_token-->(pcount))->(0)))&(32)) ~= 0)) {
                                (pcount)++;
                                while (((((line_token-->(pcount)) ~= ENDIT_TOKEN)) && ((((((line_token-->(pcount))->(0)))&(16)) ~= 0)))) {
                                    (pcount)++;
                                }
                            } else {
                                (pcount)++;
                            }
                        } else {
                            do {(l = NextWord());
                            } until (
                                (((wn >= num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                            ;
                            if (((l) && ((((l->(#dict_par1)))&(8))))) {
                                continue;
                            }
                            jump LineFailed;
                        }
                        if ((wn <= num_words)) {
                            (l = NextWord());
                        }
                        } until (
                            ((line_ttype-->(pcount)) ~= PREPOSITION_TT))
                        ;
                        .EmptyLine;
                        (wn)--;
                        if (((((line_ttype-->(pcount)) == ELEMENTARY_TT)) && (((line_tdata-->(pcount)) == NOUN_TOKEN)))) {
                            (l = Descriptors());
                            if ((l ~= 0)) {
                                (etype = l);
                            }
                            (k = (parser_results-->(INP1_PRES)));
                            @push k;
                            @push parameters;
                            (parameters = 1);
                            ((parser_results-->(INP1_PRES)) = 0);
                            (l = NounDomain(actors_location, actor, NOUN_TOKEN, 1));
                            @pull parameters;
                            @pull k;
                            ((parser_results-->(INP1_PRES)) = k);
                            if ((l == REPARSE_CODE)) {
                                jump ReParse;
                            }
                            if ((l >= 2)) {
                                (advance_warning = l);
                            }
                        }
                    }
                    break;
                }
            }
        }
        (take_all_rule = 0);
        if (((((m) && ((params_wanted == 1)))) && ((action_to_be == ##Take)))) {
            (take_all_rule = 1);
        }
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (etype = STUCK_PE);
        (multi_had = 1);
        (wn = (verb_wordnum + 1));
        (m = 1);
        for ((pcount = 1):1:(pcount)++) {
            if (((line_token-->((pcount - 1))) == ENDIT_TOKEN)) {
                if ((pcount >= 2)) {
                    while ((((((line_token-->((pcount - 2)))->(0)))&(16)) ~= 0)) {
                        (pcount)--;
                    }
                    AnalyseToken((line_token-->((pcount - 2))));
                    if ((found_ttype == PREPOSITION_TT)) {
                        (l = -1);
                        while (1) {
                            (m = NextWordStopped());
                            if ((m == -1)) {
                                break;
                            }
                            (l = m);
                        }
                        if ((PrepositionChain(l, (pcount - 2)) == -1)) {
                            (m = 0);
                        } else {
                            (m = 1);
                        }
                    }
                }
                break;
            }
        }
        (wn = (verb_wordnum + 1));
        if (m) {
            for ((pcount = 1):1:(pcount)++) {
                ((pattern-->(pcount)) = PATTERN_NULL);
                (scope_token = 0);
                (token = (line_token-->((pcount - 1))));
                (lookahead = (line_token-->(pcount)));
                if ((token ~= ENDIT_TOKEN)) {
                    (scope_reason = PARSING_REASON);
                    AnalyseToken(token);
                    (l = ParseToken(found_ttype, found_tdata, (pcount - 1), token));
                    while ((((l >= GPR_NOUN)) && ((l < -1)))) {
                        (l = ParseToken(ELEMENTARY_TT, (l + 256)));
                    }
                    (scope_reason = PARSING_REASON);
                    if ((l == GPR_PREPOSITION)) {
                        if ((((found_ttype ~= PREPOSITION_TT)) && ((((found_ttype ~= ELEMENTARY_TT)) || ((found_tdata ~= TOPIC_TOKEN)))))) {
                            (params_wanted)--;
                        }
                        (l = 1);
                    } else {
                        if ((l < 0)) {
                            (l = 0);
                        } else {
                            if ((l ~= GPR_REPARSE)) {
                                if ((l == GPR_NUMBER)) {
                                    if ((nsns == 0)) {
                                        (special_number1 = parsed_number);
                                    } else {
                                        (special_number2 = parsed_number);
                                    }
                                    (nsns)++;
                                    (l = 1);
                                }
                                if ((l == GPR_MULTIPLE)) {
                                    (l = 0);
                                }
                                ((parser_results-->((parameters + INP1_PRES))) = l);
                                (parameters)++;
                                ((pattern-->(pcount)) = l);
                                (l = 1);
                            }
                        }
                    }
                    if ((l == REPARSE_CODE)) {
                        jump ReParse;
                    }
                    if ((l == 0)) {
                        break;
                    }
                } else {
                    if ((wn <= num_words)) {
                        (l = NextWord());
                        if ((l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
                            (held_back_mode = 1);
                            (hb_wn = (wn - 1));
                        } else {
                            for ((m = 0):(m < 32):(m)++) {
                                ((pattern2-->(m)) = (pattern-->(m)));
                            }
                            (pcount2 = pcount);
                            (etype = UPTO_PE);
                            break;
                        }
                    }
                    if ((parameters >= 1)) {
                        if (((parser_results-->(INP1_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP2_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                ((parser_results-->(ACTION_PRES)) = action_to_be);
                                break;
                            }
                        }
                    }
                    if ((parameters >= 2)) {
                        if (((parser_results-->(INP2_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP1_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                break;
                            }
                        } else {
                            (k = (parser_results-->(INP1_PRES)));
                            (l = (parser_results-->(INP2_PRES)));
                            if (((k) && (l))) {
                                if ((((((multi_context == MULTIEXCEPT_TOKEN)) && ((k == l)))) || ((((((multi_context == MULTIINSIDE_TOKEN)) && ((k notin l)))) && ((l notin k)))))) {
                                    (best_etype = NOTHING_PE);
                                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                                    jump GiveError;
                                }
                            }
                        }
                    }
                    if ((((take_all_rule == 2)) && (((parser_results-->(INP1_PRES)) == actor)))) {
                        (best_etype = NOTHING_PE);
                        jump GiveError;
                    }
                    if ((multi_had > 1)) {
                        (best_etype = TOOFEW_PE);
                        jump GiveError;
                    }
                    (oops_from = 0);
                    if ((inferfrom ~= 0)) {
                        PrintInferredCommand(inferfrom);
                        ClearParagraphing(20);
                    }
                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                    ((parser_results-->(NO_INPS_PRES)) = parameters);
                    if (((action_reversed) && ((parameters == 2)))) {
                        (i = (parser_results-->(INP1_PRES)));
                        ((parser_results-->(INP1_PRES)) = (parser_results-->(INP2_PRES)));
                        ((parser_results-->(INP2_PRES)) = i);
                        if ((nsns == 2)) {
                            (i = special_number1);
                            (special_number1 = special_number2);
                            (special_number2 = i);
                        }
                    }
                    if ((((parameters > 0)) && (((parser_results-->(INP1_PRES)) >= 2)))) {
                        PronounNotice((parser_results-->(INP1_PRES)));
                    }
                    if (held_back_mode) {
                        (wn = hb_wn);
                        jump LookForMore;
                    }
                    rtrue;
                }
            }
        }
        .LineFailed;
        if ((etype > best_etype)) {
            (best_etype = etype);
        }
        if ((((etype ~= ASKSCOPE_PE)) && ((etype > nextbest_etype)))) {
            (nextbest_etype = etype);
        }
        if ((((take_all_rule == 2)) && ((etype == NOTHING_PE)))) {
            break;
        }
    }
    .GiveError;
    (etype = best_etype);
    if ((actor ~= player)) {
        if ((usual_grammar_after ~= 0)) {
            (verb_wordnum = usual_grammar_after);
            jump AlmostReParse;
        }
        (m = wn);
        (wn = 1);
        while ((((wn <= num_words)) && ((NextWord() ~= comma_word)))) {
        }
        ((parser_results-->(ACTION_PRES)) = ##Answer);
        ((parser_results-->(NO_INPS_PRES)) = 2);
        ((parser_results-->(INP1_PRES)) = actor);
        ((parser_results-->(INP2_PRES)) = 1);
        (special_number1 = special_word);
        (actor = player);
        (consult_from = wn);
        (consult_words = ((num_words - consult_from) + 1));
        (wn = m);
        rtrue;
    }
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        if ((ParserError(etype) ~= 0)) {
            jump ReType;
        }
    } else {
        if ((((verb_wordnum == 0)) && ((etype == CANTSEE_PE)))) {
            (etype = VERB_PE);
        }
        (players_command = (100 + WordCount()));
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) {
            jump SkipParserError;
        }
    }
    (pronoun_word = pronoun__word);
    (pronoun_obj = pronoun__obj);
    if ((etype == STUCK_PE)) {
        PARSER_ERROR_INTERNAL_RM(65);
        print "^";
        (oops_from = 1);
    }
    if ((etype == UPTO_PE)) {
        for ((m = 0):(m < 32):(m)++) {
            ((pattern-->(m)) = (pattern2-->(m)));
        }
        (pcount = pcount2);
        if (inferred_go) {
            PARSER_ERROR_INTERNAL_RM(67);
            PrintShortName((parser_results-->(INP1_PRES)));
        } else {
            PARSER_ERROR_INTERNAL_RM(66);
            PrintCommand(0);
        }
        print ".^";
    }
    if ((etype == NUMBER_PE)) {
        PARSER_ERROR_INTERNAL_RM(68);
        print "^";
    }
    if ((etype == CANTSEE_PE)) {
        PARSER_ERROR_INTERNAL_RM(69);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == TOOLIT_PE)) {
        PARSER_ERROR_INTERNAL_RM(70);
        print "^";
    }
    if ((etype == NOTHELD_PE)) {
        PARSER_ERROR_INTERNAL_RM(71);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == MULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(72);
        print "^";
    }
    if ((etype == MMULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(73);
        print "^";
    }
    if ((etype == VAGUE_PE)) {
        PARSER_ERROR_INTERNAL_RM(74);
        print "^";
    }
    if ((etype == ITGONE_PE)) {
        if ((pronoun_obj == NULL)) {
            PARSER_ERROR_INTERNAL_RM(74);
            print "^";
        } else {
            PARSER_ERROR_INTERNAL_RM(75, noun);
            print "^";
        }
    }
    if ((etype == EXCEPT_PE)) {
        PARSER_ERROR_INTERNAL_RM(76);
        print "^";
    }
    if ((etype == ANIMA_PE)) {
        PARSER_ERROR_INTERNAL_RM(77);
        print "^";
    }
    if ((etype == VERB_PE)) {
        PARSER_ERROR_INTERNAL_RM(78);
        print "^";
    }
    if ((etype == SCENERY_PE)) {
        PARSER_ERROR_INTERNAL_RM(79);
        print "^";
    }
    if ((etype == JUNKAFTER_PE)) {
        PARSER_ERROR_INTERNAL_RM(80);
        print "^";
    }
    if ((etype == TOOFEW_PE)) {
        PARSER_ERROR_INTERNAL_RM(81, multi_had);
        print "^";
    }
    if ((etype == NOTHING_PE)) {
        if (((((parser_results-->(ACTION_PRES)) == ##Remove)) && (((parser_results-->(INP2_PRES)) ofclass Object)))) {
            (noun = (parser_results-->(INP2_PRES)));
            if ((noun has animate)) {
                PARSER_N_ERROR_INTERNAL_RM(67, noun);
                print "^";
            } else {
                if ((~~(((or_tmp_var = noun) && (((or_tmp_var has container)) || ((or_tmp_var has supporter))))))) {
                    PARSER_N_ERROR_INTERNAL_RM(68, noun);
                    print "^";
                } else {
                    if ((((noun has container)) && ((~~((noun has open)))))) {
                        PARSER_N_ERROR_INTERNAL_RM(69, noun);
                        print "^";
                    } else {
                        if ((children(noun) == 0)) {
                            PARSER_N_ERROR_INTERNAL_RM(70, noun);
                            print "^";
                        } else {
                            ((parser_results-->(ACTION_PRES)) = 0);
                        }
                    }
                }
            }
        }
        if (((parser_results-->(ACTION_PRES)) ~= ##Remove)) {
            if ((multi_wanted == 100)) {
                PARSER_N_ERROR_INTERNAL_RM(65);
                print "^";
            } else {
                PARSER_N_ERROR_INTERNAL_RM(66);
                print "^";
            }
        }
    }
    if ((etype == NOTINCONTEXT_PE)) {
        PARSER_ERROR_INTERNAL_RM(82);
        print "^";
    }
    if ((etype == ANIMAAGAIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(83);
        print "^";
    }
    if ((etype == COMMABEGIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(84);
        print "^";
    }
    if ((etype == MISSINGPERSON_PE)) {
        PARSER_ERROR_INTERNAL_RM(85);
        print "^";
    }
    if ((etype == ANIMALISTEN_PE)) {
        PARSER_ERROR_INTERNAL_RM(86, noun);
        print "^";
    }
    if ((etype == TOTALK_PE)) {
        PARSER_ERROR_INTERNAL_RM(87);
        print "^";
    }
    if ((etype == ASKSCOPE_PE)) {
        (scope_stage = 3);
        if (((scope_error)() == -1)) {
            (best_etype = nextbest_etype);
            if ((~~((((etype ofclass Routine)) || ((etype ofclass String)))))) {
                EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            }
            jump GiveError;
        }
    }
    .SkipParserError;
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        jump ReType;
    }
    (say__p = 1);
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);
    jump ReType;
    .LookForMore;
    if ((wn > num_words)) {
        rtrue;
    }
    (i = NextWord());
    if ((i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
        if ((wn > num_words)) {
            (held_back_mode = 0);
            rtrue;
        }
        (hb_wn = wn);
        (held_back_mode = 1);
        rtrue;
    }
    (best_etype = UPTO_PE);
    jump GiveError;
];
[ PARSER_ERROR_INTERNAL_R;
];
[ PARSER_N_ERROR_INTERNAL_R;
];
[ PARSER_COMMAND_INTERNAL_R;
];
[ ParseTokenStopped x y;
    if ((wn > WordCount())) {
        return GPR_FAIL;
    }
    return ParseToken(x, y);
];
[ ParseToken given_ttype given_tdata token_n token i t rv;
    if ((parsetoken_nesting > 0)) {
        @push match_from;
        @push token_filter;
        @push match_length;
        @push number_of_classes;
        @push oops_from;
        for ((i = 0):(i < number_matched):(i)++) {
            (t = (match_list-->(i)));
            @push t;
            (t = (match_classes-->(i)));
            @push t;
            (t = (match_scores-->(i)));
            @push t;
        }
        @push number_matched;
    }
    (parsetoken_nesting)++;
    (rv = ParseToken__(given_ttype, given_tdata, token_n, token));
    (parsetoken_nesting)--;
    if ((parsetoken_nesting > 0)) {
        @pull number_matched;
        for ((i = (number_matched - 1)):(i >= 0):(i)--) {
            @pull t;
            ((match_scores-->(i)) = t);
            @pull t;
            ((match_classes-->(i)) = t);
            @pull t;
            ((match_list-->(i)) = t);
        }
        @pull oops_from;
        @pull number_of_classes;
        @pull match_length;
        @pull token_filter;
        @pull match_from;
    }
    return rv;
];
[ ParseToken__ given_ttype given_tdata token_n token l o i j k and_parity single_object desc_wn many_flag token_allows_multiple prev_indef_wanted;
    (token_filter = 0);
    (parser_inflection = A_name);
    switch (given_ttype) {
        ELEMENTARY_TT:
            switch (given_tdata) {
                SPECIAL_TOKEN:
                    (l = TryNumber(wn));
                    (special_word = NextWord());
                    if ((l == -1000)) {
                        (l = special_word);
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                NUMBER_TOKEN:
                    (l = TryNumber((wn)++));
                    if ((l == -1000)) {
                        (etype = NUMBER_PE);
                        return GPR_FAIL;
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                CREATURE_TOKEN:
                    if ((action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)) {
                        (scope_reason = TALKING_REASON);
                    }
                    ;
                TOPIC_TOKEN:
                    (consult_from = wn);
                    if (((((line_ttype-->((token_n + 1))) ~= PREPOSITION_TT)) && (((line_token-->((token_n + 1))) ~= ENDIT_TOKEN)))) {
                        RunTimeProblem(RTP_TEXTTOKENTOOHARD);
                        return GPR_PREPOSITION;
                    }
                    do {(o = NextWordStopped());
                    } until (
                        (((o == -1)) || ((PrepositionChain(o, (token_n + 1)) ~= -1))))
                    ;
                    (wn)--;
                    (consult_words = (wn - consult_from));
                    if ((consult_words == 0)) {
                        return GPR_FAIL;
                    }
                    if ((action_to_be == ##Ask or ##Answer or ##Tell)) {
                        (o = wn);
                        (wn = consult_from);
                        (parsed_number = NextWord());
                        (wn = o);
                        rtrue;
                    }
                    if ((((o == -1)) && (((line_ttype-->((token_n + 1))) == PREPOSITION_TT)))) {
                        return GPR_FAIL;
                    }
                    return GPR_PREPOSITION;
                    ;
            }
            ;
        PREPOSITION_TT:
            if ((((token->(0)))&(16))) {
                return GPR_PREPOSITION;
            }
            if ((wn > num_words)) {
                if ((((inferfrom == 0)) && ((parameters < params_wanted)))) {
                    (inferfrom = pcount);
                    (inferword = token);
                    ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                }
                if ((inferfrom == 0)) {
                    return (-(1));
                }
                ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                return GPR_PREPOSITION;
            }
            (o = NextWord());
            ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(o)));
            if ((o == given_tdata)) {
                return GPR_PREPOSITION;
            }
            if ((PrepositionChain(o, token_n) ~= -1)) {
                return GPR_PREPOSITION;
            }
            return (-(1));
            ;
        GPR_TT:
            (l = (given_tdata)());
            return l;
            ;
        SCOPE_TT:
            (scope_token = given_tdata);
            (scope_stage = 1);
            (l = (scope_token)());
            if ((l == 1)) {
                (given_tdata = MULTI_TOKEN);
            } else {
                (given_tdata = NOUN_TOKEN);
            }
            ;
        ATTR_FILTER_TT:
            (token_filter = (1 + given_tdata));
            (given_tdata = NOUN_TOKEN);
            ;
        ROUTINE_FILTER_TT:
            (token_filter = given_tdata);
            (given_tdata = NOUN_TOKEN);
            ;
    }
    (token = given_tdata);
    (token_allows_multiple = 0);
    if ((token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        (token_allows_multiple = 1);
    }
    (many_flag = 0);
    (and_parity = 1);
    (dont_infer = 0);
    (dont_infer_pronoun = 0);
    .ObjectList;
    (o = NextWord());
    (wn)--;
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    (l = PronounValue(o));
    if ((l ~= 0)) {
        (pronoun_word = o);
        (pronoun_obj = l);
        if ((l == NULL)) {
            for ((l = 1):(l <= (LanguageDescriptors-->(0))):(l = (l + 4))) {
                if ((o == (LanguageDescriptors-->(l)))) {
                    jump AssumeDescriptor;
                }
            }
            (pronoun__word = pronoun_word);
            (pronoun__obj = pronoun_obj);
            (etype = VAGUE_PE);
            if ((parser_trace >= 3)) {
                print "  [Stop: unset pronoun]^";
            }
            return GPR_FAIL;
        }
    }
    .AssumeDescriptor;
    if ((o == ME1__WD or ME2__WD or ME3__WD)) {
        (pronoun_word = o);
        (pronoun_obj = player);
    }
    (allow_plurals = 1);
    (desc_wn = wn);
    .TryAgain;
    (l = Descriptors(token_allows_multiple));
    if ((l ~= 0)) {
        (etype = l);
        rfalse;
    }
    .TryAgain2;
    (oops_from = wn);
    if ((token ~= HELD_TOKEN)) {
        (i = (multiple_object-->(0)));
        (l = NounDomain(actors_location, actor, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((((((indef_wanted == INDEF_ALL_WANTED)) && ((l == 0)))) && ((number_matched == 0)))) {
            (l = 1);
        }
        if (((token_allows_multiple) && ((~~(multiflag))))) {
            if ((best_etype == MULTI_PE)) {
                (best_etype = STUCK_PE);
            }
            (multiflag = 1);
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((etype == MULTI_PE)) && (multiflag))) {
                (etype = STUCK_PE);
            }
            (etype = CantSee());
            jump FailToken;
        }
        if ((l == 1)) {
            if ((~~(many_flag))) {
                (many_flag = 1);
            } else {
                (k = (multiple_object-->(0)));
                ((multiple_object-->(0)) = i);
                for ((j = (i + 1)):(j <= k):(j)++) {
                    if (and_parity) {
                        MultiAdd((multiple_object-->(j)));
                    } else {
                        MultiSub((multiple_object-->(j)));
                    }
                }
            }
        } else {
            if ((((match_length == 0)) && (indef_possambig))) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((token == CREATURE_TOKEN)) && ((CreatureTest(l) == 0)))) {
                (etype = ANIMA_PE);
                jump FailToken;
            }
            if ((~~(many_flag))) {
                (single_object = l);
            } else {
                if (and_parity) {
                    MultiAdd(l);
                } else {
                    MultiSub(l);
                }
            }
        }
    } else {
        (l = NounDomain(actor, actors_location, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            (etype = CantSee());
            jump FailToken;
        }
        (o = parent(l));
        if ((o ~= actor)) {
        }
        (single_object = l);
    }
    (wn = (match_from + match_length));
    (o = NextWord());
    if ((o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word)) {
        if ((~~(token_allows_multiple))) {
            if (multiflag) {
                jump PassToken;
            }
            (etype = MULTI_PE);
            jump FailToken;
        }
        if ((o == BUT1__WD or BUT2__WD or BUT3__WD)) {
            (and_parity = (1 - and_parity));
        }
        if ((~~(many_flag))) {
            ((multiple_object-->(0)) = 1);
            ((multiple_object-->(1)) = single_object);
            (many_flag = 1);
        }
        (dont_infer = 1);
        (dont_infer_pronoun = 0);
        (inferfrom = 0);
        jump ObjectList;
    }
    (wn)--;
    .PassToken;
    if (many_flag) {
        (single_object = GPR_MULTIPLE);
        (multi_context = token);
    } else {
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
                (multi_context = token);
            }
            if ((((indef_wanted < INDEF_ALL_WANTED)) && ((indef_wanted > 1)))) {
                (multi_had = 1);
                (multi_wanted = indef_wanted);
                jump FailToken;
            }
        }
    }
    return single_object;
    .FailToken;
    if (((allow_plurals) && ((indef_guess_p == 1)))) {
        (prev_indef_wanted = indef_wanted);
        (allow_plurals = 0);
        (wn = desc_wn);
        jump TryAgain;
    }
    if ((((((indef_wanted > 0)) || ((prev_indef_wanted > 0)))) && ((~~(multiflag))))) {
        (etype = MULTI_PE);
    }
    return GPR_FAIL;
];
[ ResetDescriptors;
    (indef_mode = 0);
    (indef_type = 0);
    (indef_wanted = 0);
    (indef_guess_p = 0);
    (indef_possambig = 0);
    (indef_owner = 0);
    (indef_cases = 4095);
    (indef_nspec_at = 0);
];
[ ArticleDescriptors o x flag cto type n;
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type == DEFART_PK or INDEFART_PK)) {
                    (flag = 1);
                }
            }
        }
    }
    (wn)--;
    rfalse;
];
[ Descriptors o x flag cto type n;
    ResetDescriptors();
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (flag = 1);
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type ~= DEFART_PK)) {
                    (indef_mode = 1);
                }
                (indef_possambig = 1);
                (indef_cases = ((indef_cases)&((LanguageDescriptors-->((x + 1))))));
                if ((type == POSSESS_PK)) {
                    (cto = (LanguageDescriptors-->((x + 3))));
                    switch (cto) {
                        0:
                            (indef_type = ((indef_type)|(MY_BIT)));
                            ;
                        1:
                            (indef_type = ((indef_type)|(THAT_BIT)));
                            ;
                        default:
                            (indef_owner = PronounValue(cto));
                            if ((indef_owner == NULL)) {
                                (indef_owner = 0);
                            }
                            ;
                    }
                }
                if ((type == LIGHTED_PK)) {
                    (indef_type = ((indef_type)|(LIT_BIT)));
                }
                if ((type == UNLIGHTED_PK)) {
                    (indef_type = ((indef_type)|(UNLIT_BIT)));
                }
            }
        }
        if ((o == OTHER1__WD or OTHER2__WD or OTHER3__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_type = ((indef_type)|(OTHER_BIT)));
        }
        if ((o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_wanted = INDEF_ALL_WANTED);
            if ((take_all_rule == 1)) {
                (take_all_rule = 2);
            }
            (indef_type = ((indef_type)|(PLURAL_BIT)));
        }
        if (allow_plurals) {
            if ((NextWordStopped() ~= -1 or THEN1__WD)) {
                (wn)--;
                (n = TryNumber((wn - 1)));
            } else {
                (n = 0);
                (wn)--;
            }
            if ((n == 1)) {
                (indef_mode = 1);
                (flag = 1);
            }
            if ((n > 1)) {
                (indef_guess_p = 1);
                (indef_mode = 1);
                (flag = 1);
                (indef_wanted = n);
                (indef_nspec_at = (wn - 1));
                (indef_type = ((indef_type)|(PLURAL_BIT)));
            }
        }
        if ((((flag == 1)) && ((NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)))) {
            (wn)--;
        }
    }
    (wn)--;
    rfalse;
];
[ SafeSkipDescriptors;
    @push indef_mode;
    @push indef_type;
    @push indef_wanted;
    @push indef_guess_p;
    @push indef_possambig;
    @push indef_owner;
    @push indef_cases;
    @push indef_nspec_at;
    Descriptors();
    @pull indef_nspec_at;
    @pull indef_cases;
    @pull indef_owner;
    @pull indef_possambig;
    @pull indef_guess_p;
    @pull indef_wanted;
    @pull indef_type;
    @pull indef_mode;
];
[ PrepositionChain wd index;
    if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    if ((((((line_token-->(index))->(0)))&(32)) == 0)) {
        return (-(1));
    }
    do {if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    (index)++;
    } until (
        ((((line_token-->(index)) == ENDIT_TOKEN)) || ((((((line_token-->(index))->(0)))&(16)) == 0))))
    ;
    return (-(1));
];
[ CreatureTest obj;
    if ((obj has animate)) {
        rtrue;
    }
    if ((~~((obj has talkable)))) {
        rfalse;
    }
    if ((action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor)) {
        rtrue;
    }
    rfalse;
];
[ NounDomain domain1 domain2 context dont_ask first_word i j k l answer_words marker;
    (match_length = 0);
    (number_matched = 0);
    (match_from = wn);
    SearchScope(domain1, domain2, context);
    (wn = (match_from + match_length));
    if ((number_matched == 0)) {
        (wn)++;
        rfalse;
    }
    if ((match_from <= num_words)) {
        if ((number_matched == 1)) {
            (i = (match_list-->(0)));
            return i;
        }
        if ((wn <= num_words)) {
            (i = NextWord());
            (wn)--;
            if ((i ~= AND1__WD or AND2__WD or AND3__WD or comma_word or THEN1__WD or THEN2__WD or THEN3__WD or BUT1__WD or BUT2__WD or BUT3__WD)) {
                if ((lookahead == ENDIT_TOKEN)) {
                    rfalse;
                }
            }
        }
    }
    (number_of_classes = 0);
    if ((number_matched == 1)) {
        (i = (match_list-->(0)));
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN)) {
                BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
                if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) && (RulebookFailed()))) {
                    rfalse;
                }
                EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
            }
        }
    }
    if ((number_matched > 1)) {
        (i = 1);
        if ((number_matched > 1)) {
            for ((j = 0):(j < (number_matched - 1)):(j)++) {
                if ((Identical((match_list-->(j)), (match_list-->((j + 1)))) == 0)) {
                    (i = 0);
                }
            }
        }
        if (i) {
            (dont_infer = 1);
        }
        (i = Adjudicate(context));
        if ((i == -1)) {
            rfalse;
        }
        if ((i == 1)) {
            rtrue;
        }
        (dont_infer_pronoun = 1);
    }
    if ((i ~= 0)) {
        if (dont_infer) {
            return i;
        }
        if ((inferfrom == 0)) {
            (inferfrom = pcount);
        }
        ((pattern-->(pcount)) = i);
        return i;
    }
    if (dont_ask) {
        return (match_list-->(0));
    }
    if ((match_from > num_words)) {
        jump Incomplete;
    }
    BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) {
        jump SkipWhichQuestion;
    }
    (j = 1);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        if ((~~(((match_list-->(marker)) has animate)))) {
            (j = 0);
        }
    }
    if (j) {
        PARSER_CLARIF_INTERNAL_RM(65);
    } else {
        PARSER_CLARIF_INTERNAL_RM(66);
    }
    (j = number_of_classes);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        (k = (match_list-->(marker)));
        if (((match_classes-->(marker)) > 0)) {
            DefArt(k);
        } else {
            IndefArt(k);
        }
        if ((i < (j - 1))) {
            print ", ";
        }
        if ((i == (j - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                if ((j ~= 2)) {
                    print ",";
                }
            }
            PARSER_CLARIF_INTERNAL_RM(72);
        }
    }
    print "?^";
    .SkipWhichQuestion;
    EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    .WhichOne;
    (answer_words = Keyboard(buffer2, parse2));
    (first_word = (parse2-->(1)));
    if ((first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
        if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (l = (multiple_object-->(0)));
            for ((i = 0):(((i < number_matched)) && (((l + i) < MATCH_LIST_WORDS))):(i)++) {
                (k = (match_list-->(i)));
                ((multiple_object-->(((i + 1) + l))) = k);
            }
            ((multiple_object-->(0)) = (i + l));
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM(67);
        jump WhichOne;
    }
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (k = (WordAddress(match_from) - buffer));
    (l = ((buffer2-->(0)) + 1));
    for ((j = ((buffer + INPUT_BUFFER_LEN) - 1)):(j >= ((buffer + k) + l)):(j)--) {
        ((j->(0)) = (j->((-(l)))));
    }
    for ((i = 0):(i < l):(i)++) {
        ((buffer->((k + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer->(((k + l) - 1))) = 32);
    ((buffer-->(0)) = ((buffer-->(0)) + l));
    if (((buffer-->(0)) > (INPUT_BUFFER_LEN - WORDSIZE))) {
        ((buffer-->(0)) = (INPUT_BUFFER_LEN - WORDSIZE));
    }
    .RECONSTRUCT_INPUT;
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (actors_location = ScopeCeiling(player));
    FollowRulebook((Activity_after_rulebooks-->(READING_A_COMMAND_ACT)));
    return REPARSE_CODE;
    .Incomplete;
    if ((context == CREATURE_TOKEN)) {
        PARSER_CLARIF_INTERNAL_RM(68, actor);
    } else {
        PARSER_CLARIF_INTERNAL_RM(69, actor);
    }
    print "^";
    (answer_words = Keyboard(buffer2, parse2));
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (first_word = (parse2-->(1)));
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((inferfrom ~= 0)) {
        for ((j = inferfrom):(j < pcount):(j)++) {
            if (((pattern-->(j)) == PATTERN_NULL)) {
                continue;
            }
            (i = (WORDSIZE + (buffer-->(0))));
            ((buffer-->(0)))++;
            ((buffer->((i)++)) = 32);
            ((parse2-->(1)) = 0);
            if (((((pattern-->(j)) >= 2)) && (((pattern-->(j)) < REPARSE_CODE)))) {
                if ((dont_infer_pronoun == 0)) {
                    PronounNotice((pattern-->(j)));
                    for ((k = 1):(k <= (LanguagePronouns-->(0))):(k = (k + 3))) {
                        if (((pattern-->(j)) == (LanguagePronouns-->((k + 2))))) {
                            ((parse2-->(1)) = (LanguagePronouns-->(k)));
                            break;
                        }
                    }
                }
            } else {
                ((parse2-->(1)) = VM_NumberToDictionaryAddress(((pattern-->(j)) - REPARSE_CODE)));
            }
            if (((parse2-->(1)) ~= 0)) {
                (k = (buffer + i));
                (k = Glulx_PrintAnyToArray((buffer + i), (INPUT_BUFFER_LEN - i), (parse2-->(1))));
                (i = (i + k));
                ((buffer-->(0)) = (i - WORDSIZE));
            }
        }
    }
    (i = (WORDSIZE + (buffer-->(0))));
    ((buffer-->(0)))++;
    ((buffer->((i)++)) = 32);
    for ((j = 0):(j < (buffer2-->(0))):((i)++,(j)++)) {
        ((buffer->(i)) = (buffer2->((j + WORDSIZE))));
        ((buffer-->(0)))++;
        if (((buffer-->(0)) == INPUT_BUFFER_LEN)) {
            break;
        }
    }
    jump RECONSTRUCT_INPUT;
];
[ PARSER_CLARIF_INTERNAL_R;
];
[ Adjudicate context i j k good_ones last n ultimate flag offset;
    (j = (number_matched - 1));
    (good_ones = 0);
    (last = (match_list-->(0)));
    for ((i = 0):(i <= j):(i)++) {
        (n = (match_list-->(i)));
        ((match_scores-->(i)) = good_ones);
        (ultimate = ScopeCeiling(n));
        if ((((context == HELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((((((((((context == MULTI_TOKEN)) && ((ultimate == ScopeCeiling(actor))))) && ((n ~= actor)))) && ((~~((n has concealed)))))) && ((~~((n has scenery)))))) {
            (good_ones)++;
            (last = n);
        }
        if ((((context == MULTIHELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            if ((advance_warning == -1)) {
                if ((context == MULTIEXCEPT_TOKEN)) {
                    (good_ones)++;
                    (last = n);
                }
                if ((context == MULTIINSIDE_TOKEN)) {
                    if ((parent(n) ~= actor)) {
                        (good_ones)++;
                        (last = n);
                    }
                }
            } else {
                if ((((context == MULTIEXCEPT_TOKEN)) && ((n ~= advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
                if ((((context == MULTIINSIDE_TOKEN)) && ((n in advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
            }
        }
        if ((((context == CREATURE_TOKEN)) && ((CreatureTest(n) == 1)))) {
            (good_ones)++;
            (last = n);
        }
        ((match_scores-->(i)) = (1000*(good_ones - (match_scores-->(i)))));
    }
    if ((good_ones == 1)) {
        if ((((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) && ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)))) {
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) && (RulebookFailed()))) {
                (good_ones = 0);
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((good_ones == 1)) {
                return last;
            }
        } else {
            return last;
        }
    }
    if ((((context == CREATURE_TOKEN)) && ((good_ones == 0)))) {
        return (match_list-->(0));
    }
    if ((indef_mode == 0)) {
        (indef_type = 0);
    }
    ScoreMatchL(context);
    if ((number_matched == 0)) {
        return (-(1));
    }
    if ((indef_mode == 0)) {
        (i = SingleBestGuess());
        if ((i >= 0)) {
            return i;
        }
    }
    if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
        if ((context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (etype = MULTI_PE);
            return (-(1));
        }
        (i = 0);
        (offset = (multiple_object-->(0)));
        for ((j = BestGuess()):(((((j ~= -1)) && ((i < indef_wanted)))) && (((i + offset) < (MATCH_LIST_WORDS - 1)))):(j = BestGuess())) {
            (flag = 0);
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j) == 0)) {
                if ((((~~((j has concealed)))) && ((~~((j has worn)))))) {
                    (flag = 1);
                }
                if ((((context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN)) && ((parent(j) ~= actor)))) {
                    (flag = 0);
                }
                if ((((action_to_be == ##Take or ##Remove)) && ((parent(j) == actor)))) {
                    (flag = 0);
                }
                (k = ChooseObjects(j, flag));
                if ((k == 1)) {
                    (flag = 1);
                } else {
                    if ((k == 2)) {
                        (flag = 0);
                    }
                }
            } else {
                (flag = 0);
                if (RulebookSucceeded()) {
                    (flag = 1);
                }
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((flag == 1)) {
                (i)++;
                ((multiple_object-->((i + offset))) = j);
            } else {
                (i = i);
            }
        }
        if ((((i < indef_wanted)) && ((indef_wanted < INDEF_ALL_WANTED)))) {
            (multi_wanted = indef_wanted);
            (multi_had = i);
        }
        ((multiple_object-->(0)) = (i + offset));
        (multi_context = context);
        rtrue;
    }
    for ((i = 0):(i < number_matched):(i)++) {
        ((match_classes-->(i)) = 0);
    }
    (n = 1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_classes-->(i)) == 0)) {
            ((match_classes-->(i)) = (n)++);
            (flag = 0);
            for ((j = (i + 1)):(j < number_matched):(j)++) {
                if (((((match_classes-->(j)) == 0)) && ((Identical((match_list-->(i)), (match_list-->(j))) == 1)))) {
                    (flag = 1);
                    ((match_classes-->(j)) = (match_classes-->(i)));
                }
            }
            if ((flag == 1)) {
                ((match_classes-->(i)) = (1 - n));
            }
        }
    }
    (n)--;
    (number_of_classes = n);
    if ((indef_mode == 0)) {
        if ((n > 1)) {
            (k = -1);
            for ((i = 0):(i < number_matched):(i)++) {
                if (((match_scores-->(i)) > k)) {
                    (k = (match_scores-->(i)));
                    (j = (match_classes-->(i)));
                    (j = (j*j));
                    (flag = 0);
                } else {
                    if (((match_scores-->(i)) == k)) {
                        if ((((match_classes-->(i))*(match_classes-->(i))) ~= j)) {
                            (flag = 1);
                        }
                    }
                }
            }
            if (flag) {
                rfalse;
            }
        }
    }
    if ((n == 1)) {
        (dont_infer = 1);
    }
    return BestGuess();
];
[ ReviseMulti second_p i low;
    if ((multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
            if ((((((multi_context == MULTIEXCEPT_TOKEN)) && (((multiple_object-->(i)) ~= second_p)))) || ((((multi_context == MULTIINSIDE_TOKEN)) && (((multiple_object-->(i)) in second_p)))))) {
                (low)++;
                ((multiple_object-->(low)) = (multiple_object-->(i)));
            }
        }
        ((multiple_object-->(0)) = low);
    }
    if ((((multi_context == MULTI_TOKEN)) && ((action_to_be == ##Take)))) {
        if ((take_all_rule == 2)) {
            for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
                if ((ScopeCeiling((multiple_object-->(i))) == ScopeCeiling(actor))) {
                    (low)++;
                    ((multiple_object-->(low)) = (multiple_object-->(i)));
                }
            }
            ((multiple_object-->(0)) = low);
        }
    }
    (i = (multiple_object-->(0)));
    if ((i == 0)) {
        return NOTHING_PE;
    }
    rfalse;
];
[ MakeMatch obj quality i;
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(obj) == 0)))) {
        rtrue;
    }
    if ((quality < match_length)) {
        rtrue;
    }
    if ((quality > match_length)) {
        (match_length = quality);
        (number_matched = 0);
    } else {
        if ((number_matched >= MATCH_LIST_WORDS)) {
            rtrue;
        }
        for ((i = 0):(i < number_matched):(i)++) {
            if (((match_list-->(i)) == obj)) {
                rtrue;
            }
        }
    }
    ((match_list-->((number_matched)++)) = obj);
];
[ ConsultNounFilterToken obj sn rv;
    if ((token_filter ofclass Routine)) {
        (sn = noun);
        (noun = obj);
        (rv = (token_filter)());
        (noun = sn);
        return rv;
    }
    if (_final_propertyvalue(OBJECT_TY, obj, (token_filter - 1))) {
        rtrue;
    }
    rfalse;
];
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
    if ((((indef_type)&(MY_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(THAT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(LIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(UNLIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((indef_owner ~= 0)) {
        (threshold)++;
    }
    (a_s = SCORE__BESTLOC);
    (l_s = SCORE__NEXTBESTLOC);
    if ((action_to_be == ##Take or ##Remove)) {
        (a_s = SCORE__NEXTBESTLOC);
        (l_s = SCORE__BESTLOC);
    }
    (context = context);
    for ((i = 0):(i < number_matched):(i)++) {
        (obj = (match_list-->(i)));
        (its_owner = parent(obj));
        (its_score = 0);
        (met = 0);
        if ((((((indef_type)&(MY_BIT)) ~= 0)) && ((its_owner == actor)))) {
            (met)++;
        }
        if ((((((indef_type)&(THAT_BIT)) ~= 0)) && ((its_owner == actors_location)))) {
            (met)++;
        }
        if ((((((indef_type)&(LIT_BIT)) ~= 0)) && ((obj has light)))) {
            (met)++;
        }
        if ((((((indef_type)&(UNLIT_BIT)) ~= 0)) && ((~~((obj has light)))))) {
            (met)++;
        }
        if ((((indef_owner ~= 0)) && ((((its_owner == indef_owner)) || ((CoreOf(obj) == indef_owner)))))) {
            (met)++;
        }
        if ((met < threshold)) {
            ((match_list-->(i)) = -1);
        } else {
            (its_score = 0);
            if ((~~((obj has concealed)))) {
                (its_score = SCORE__UNCONCEALED);
            }
            if ((its_owner == actor)) {
                (its_score = (its_score + a_s));
            } else {
                if ((its_owner == actors_location)) {
                    (its_score = (its_score + l_s));
                } else {
                    if ((its_owner ~= Compass)) {
                        (its_score = (its_score + SCORE__NOTCOMPASS));
                    }
                }
            }
            (its_score = (its_score + (SCORE__CHOOSEOBJ*ChooseObjects(obj, 2))));
            if ((~~((obj has scenery)))) {
                (its_score = (its_score + SCORE__NOTSCENERY));
            }
            if ((obj ~= actor)) {
                (its_score = (its_score + SCORE__NOTACTOR));
            }
            if (((indef_cases)&((PowersOfTwo_TB-->(GetGNAOfObject(obj)))))) {
                (its_score = (its_score + SCORE__GNA));
            }
            ((match_scores-->(i)) = ((match_scores-->(i)) + its_score));
        }
    }
    for ((i = 0):(i < number_matched):(i)++) {
        while (((match_list-->(i)) == -1)) {
            if ((i == (number_matched - 1))) {
                (number_matched)--;
                break;
            }
            for ((j = i):(j < (number_matched - 1)):(j)++) {
                ((match_list-->(j)) = (match_list-->((j + 1))));
                ((match_scores-->(j)) = (match_scores-->((j + 1))));
            }
            (number_matched)--;
        }
    }
];
[ BestGuess earliest its_score best i;
    (earliest = 0);
    (best = -1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_list-->(i)) >= 0)) {
            (its_score = (match_scores-->(i)));
            if ((its_score > best)) {
                (best = its_score);
                (earliest = i);
            }
        }
    }
    if ((best < 0)) {
        return (-(1));
    }
    (i = (match_list-->(earliest)));
    ((match_list-->(earliest)) = -1);
    return i;
];
[ SingleBestGuess earliest its_score best i;
    (earliest = -1);
    (best = -1000);
    for ((i = 0):(i < number_matched):(i)++) {
        (its_score = (match_scores-->(i)));
        if ((its_score == best)) {
            (earliest = -1);
        }
        if ((its_score > best)) {
            (best = its_score);
            (earliest = (match_list-->(i)));
        }
    }
    return earliest;
];
[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if ((o1 == o2)) {
        rtrue;
    }
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K3_direction)) || ((o2 ofclass K3_direction)))) {
        rfalse;
    }
    if (((((o1.parse_name) ~= 0)) || (((o2.parse_name) ~= 0)))) {
        if (((o1.parse_name) ~= (o2.parse_name))) {
            rfalse;
        }
        (parser_action = ##TheSame);
        (parser_one = o1);
        (parser_two = o2);
        (j = wn);
        (i = RunRoutines(o1, A_parse_name));
        (wn = j);
        if ((i == -1)) {
            rtrue;
        }
        if ((i == -2)) {
            rfalse;
        }
    }
    (p1 = (_final_propertyarray(OBJECT_TY, o1, A_name)));
    (n1 = ((_final_propertylength(OBJECT_TY, o1, A_name))/WORDSIZE));
    (p2 = (_final_propertyarray(OBJECT_TY, o2, A_name)));
    (n2 = ((_final_propertylength(OBJECT_TY, o2, A_name))/WORDSIZE));
    for ((i = 0):(i < n1):(i)++) {
        (flag = 0);
        for ((j = 0):(j < n2):(j)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    for ((j = 0):(j < n2):(j)++) {
        (flag = 0);
        for ((i = 0):(i < n1):(i)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ PrintInferredCommand from singleton_noun;
    (singleton_noun = 0);
    if ((((((((from ~= 0)) && ((from == (pcount - 1))))) && (((pattern-->(from)) > 1)))) && (((pattern-->(from)) < REPARSE_CODE)))) {
        (singleton_noun = 1);
    }
    if (singleton_noun) {
        BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
        if ((ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from))) == 0)) {
            print "(";
            PrintCommand(from);
            print ")^";
        }
        EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
    } else {
        print "(";
        PrintCommand(from);
        print ")^";
    }
];
[ PrintCommand from i k spacing_flag;
    if ((from == 0)) {
        (i = verb_word);
        if ((LanguageVerb(i) == 0)) {
            if ((PrintVerb(i) == 0)) {
                print (address) i;
            }
        }
        (from)++;
        (spacing_flag = 1);
    }
    for ((k = from):(k < pcount):(k)++) {
        (i = (pattern-->(k)));
        if ((i == PATTERN_NULL)) {
            continue;
        }
        if (spacing_flag) {
            print (char) 32;
        }
        if ((i == 0)) {
            PARSER_CLARIF_INTERNAL_RM(70);
            jump TokenPrinted;
        }
        if ((i == 1)) {
            PARSER_CLARIF_INTERNAL_RM(71);
            jump TokenPrinted;
        }
        if ((i >= REPARSE_CODE)) {
            print (address) VM_NumberToDictionaryAddress((i - REPARSE_CODE));
        } else {
            if ((i ofclass K3_direction)) {
                LanguageDirection(i);
            } else {
                DefArt(i);
            }
        }
        .TokenPrinted;
        (spacing_flag = 1);
    }
];
[ CantSee i w e;
    (saved_oops = oops_from);
    if ((scope_token ~= 0)) {
        (scope_error = scope_token);
        return ASKSCOPE_PE;
    }
    (wn)--;
    (w = NextWord());
    (e = CANTSEE_PE);
    if ((w == pronoun_word)) {
        (w = NextWordStopped());
        (wn)--;
        if ((((w == -1)) || (((line_token-->(pcount)) ~= ENDIT_TOKEN)))) {
            if ((pcount > 0)) {
                AnalyseToken((line_token-->((pcount - 1))));
            }
            if ((((pcount > 0)) && ((found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT)))) {
                (e = NOTINCONTEXT_PE);
            } else {
                (pronoun__word = pronoun_word);
                (pronoun__obj = pronoun_obj);
                (e = ITGONE_PE);
            }
        }
    }
    if ((etype > e)) {
        return etype;
    }
    return e;
];
[ MultiAdd o i j;
    (i = (multiple_object-->(0)));
    if ((i == (MATCH_LIST_WORDS - 1))) {
        (toomany_flag = 1);
        rtrue;
    }
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            rtrue;
        }
    }
    (i)++;
    ((multiple_object-->(i)) = o);
    ((multiple_object-->(0)) = i);
];
[ MultiSub o i j k;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            for ((k = j):(k <= i):(k)++) {
                ((multiple_object-->(k)) = (multiple_object-->((k + 1))));
            }
            ((multiple_object-->(0)) = --(i));
            rfalse;
        }
    }
    return VAGUE_PE;
];
[ MultiFilter attr i j o;
    .MFiltl;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        (o = (multiple_object-->(j)));
        if ((~~(_final_propertyvalue(OBJECT_TY, o, attr)))) {
            MultiSub(o);
            jump MFiltl;
        }
    }
];
[ PlaceInScope O opts ws;
    (ws = wn);
    (wn = match_from);
    if ((opts == 0)) {
        DoScopeActionAndRecurse(O);
    } else {
        DoScopeAction(O);
    }
    (wn = ws);
    rtrue;
];
[ AddToScope obj;
    if ((ats_flag >= 2)) {
        DoScopeActionAndRecurse(obj, 0, (ats_flag - 2));
    }
    if ((ats_flag == 1)) {
        if ((HasLightSource(obj) == 1)) {
            (ats_hls = 1);
        }
    }
];
[ TestScope obj act a al sr ss st x y;
    (x = parser_one);
    (y = parser_two);
    (parser_one = obj);
    (parser_two = 0);
    (a = actor);
    (al = actors_location);
    (ss = scope_stage);
    (st = scope_token);
    (scope_stage = 0);
    (scope_token = 0);
    (sr = scope_reason);
    (scope_reason = TESTSCOPE_REASON);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    SearchScope(actors_location, actor, 0);
    (scope_reason = sr);
    (actor = a);
    (scope_stage = ss);
    (scope_token = st);
    (actors_location = al);
    (parser_one = x);
    (x = parser_two);
    (parser_two = y);
    return x;
];
[ LoopOverScope routine act x y a al;
    (x = parser_one);
    (y = scope_reason);
    (a = actor);
    (al = actors_location);
    (parser_one = routine);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    (scope_reason = LOOPOVERSCOPE_REASON);
    SearchScope(actors_location, actor, 0);
    (parser_one = x);
    (scope_reason = y);
    (actor = a);
    (actors_location = al);
];
[ SearchScope domain1 domain2 context i;
    if ((domain1 == 0)) {
        rtrue;
    }
    if (scope_token) {
        (scope_stage = 2);
        if (((scope_token)() ~= 0)) {
            rtrue;
        }
    }
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if ((ForActivity(DECIDING_SCOPE_ACT, actor) == 0)) {
        if ((((((scope_reason == PARSING_REASON)) && ((context == MULTIINSIDE_TOKEN)))) && ((advance_warning ~= -1)))) {
            if ((IsSeeThrough(advance_warning) == 1)) {
                ScopeWithin(advance_warning, 0, context);
            }
        } else {
            if ((((((((scope_reason == PARSING_REASON)) && ((context ~= CREATURE_TOKEN)))) && ((indef_mode == 0)))) && ((domain1 == actors_location)))) {
                ScopeWithin(Compass);
            }
            if (((or_tmp_var = domain1) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeAction(domain1);
            }
            ScopeWithin(domain1, domain2, context);
            if (domain2) {
                if (((or_tmp_var = domain2) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                    DoScopeAction(domain2);
                }
                ScopeWithin(domain2, 0, context);
            }
        }
        if ((thedark == domain1 or domain2)) {
            DoScopeActionAndRecurse(actor, actor, context);
            if (((or_tmp_var = parent(actor)) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeActionAndRecurse(parent(actor), parent(actor), context);
            }
        }
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];
[ ScopeWithin domain nosearch context obj next_obj;
    if ((domain == 0)) {
        rtrue;
    }
    (obj = child(domain));
    while (obj) {
        (next_obj = sibling(obj));
        if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
            DoScopeActionAndRecurse(obj, nosearch, context);
        }
        (obj = next_obj);
    }
];
[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
    DoScopeAction(domain);
    if ((((domain ~= nosearch)) && ((((domain ofclass K1_room or K8_person)) || ((IsSeeThrough(domain) == 1)))))) {
        (obj = child(domain));
        while (obj) {
            (next_obj = sibling(obj));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, nosearch, context);
            }
            (obj = next_obj);
        }
    }
    if ((_final_propertyexists(OBJECT_TY, domain, A_component_child))) {
        (obj = (domain.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, 0, context);
            }
            (obj = next_obj);
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, domain, A_add_to_scope)));
    if ((ad ~= 0)) {
        (i = (metaclass((ad-->(0))) == Object));
        if (i) {
            (ats_flag = (2 + context));
            RunRoutines(domain, A_add_to_scope);
            (ats_flag = 0);
        } else {
            (n = (_final_propertylength(OBJECT_TY, domain, A_add_to_scope)));
            for ((i = 0):((WORDSIZE*i) < n):(i)++) {
                if ((ad-->(i))) {
                    DoScopeActionAndRecurse((ad-->(i)), 0, context);
                }
            }
        }
    }
];
[ DoScopeAction item;
    @push parser_one;
    @push scope_reason;
    switch (scope_reason) {
        TESTSCOPE_REASON:
            if ((item == parser_one)) {
                (parser_two = 1);
            }
            ;
        LOOPOVERSCOPE_REASON:
            if ((parser_one ofclass Routine)) {
                (parser_one)(item);
            }
            ;
        PARSING_REASON, TALKING_REASON:
            MatchTextAgainstObject(item);
            ;
    }
    @pull scope_reason;
    @pull parser_one;
];
[ MatchTextAgainstObject item i;
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(item) == 0)))) {
        rtrue;
    }
    if ((match_from <= num_words)) {
        (wn = match_from);
        (i = NounWord());
        if ((((i == 1)) && ((player == item)))) {
            MakeMatch(item, 1);
        }
        if ((((((i >= 2)) && ((i < 128)))) && (((LanguagePronouns-->(i)) == item)))) {
            MakeMatch(item, 1);
        }
    }
    (wn = match_from);
    if ((TryGivenObject(item) > 0)) {
        if ((((indef_nspec_at > 0)) && ((match_from ~= indef_nspec_at)))) {
            (wn = indef_nspec_at);
            if ((TryGivenObject(item) > 0)) {
                (match_from = indef_nspec_at);
                ResetDescriptors();
            }
            (wn = match_from);
        }
    }
];
[ TryGivenObject obj nomatch threshold k w j;
    if (((nomatch) && ((obj == 0)))) {
        rfalse;
    }
    (dict_flags_of_noun = 0);
    if ((wn > num_words)) {
        if (nomatch) {
            rfalse;
        }
        if ((indef_mode ~= 0)) {
            (dict_flags_of_noun = 112);
        }
        MakeMatch(obj, 0);
        rtrue;
    }
    if (((obj.parse_name) ~= 0)) {
        (parser_action = NULL);
        (j = wn);
        (k = RunRoutines(obj, A_parse_name));
        if ((k > 0)) {
            (wn = (j + k));
            .MMbyPN;
            if ((parser_action == ##PluralFound)) {
                (dict_flags_of_noun = ((dict_flags_of_noun)|(4)));
            }
            if (((dict_flags_of_noun)&(4))) {
                if ((~~(allow_plurals))) {
                    (k = 0);
                } else {
                    if ((indef_mode == 0)) {
                        (indef_mode = 1);
                        (indef_type = 0);
                        (indef_wanted = 0);
                    }
                    (indef_type = ((indef_type)|(PLURAL_BIT)));
                    if ((indef_wanted == 0)) {
                        (indef_wanted = INDEF_ALL_WANTED);
                    }
                }
            }
            if ((nomatch == 0)) {
                MakeMatch(obj, k);
            }
            return k;
        }
        if ((k == 0)) {
            jump NoWordsMatch;
        }
    }
    (parser_action = NULL);
    (w = NounWord());
    if ((((w == 1)) && ((player == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((((((w >= 2)) && ((w < 128)))) && (((LanguagePronouns-->(w)) == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((Refers(obj, (wn - 1)) == 0)) {
        .NoWordsMatch;
        if ((indef_mode ~= 0)) {
            (k = 0);
            (parser_action = NULL);
            jump MMbyPN;
        }
        rfalse;
    }
    (threshold = 1);
    (dict_flags_of_noun = (((w->(#dict_par1)))&(116)));
    (w = NextWord());
    while (Refers(obj, (wn - 1))) {
        (threshold)++;
        if (w) {
            (dict_flags_of_noun = ((dict_flags_of_noun)|((((w->(#dict_par1)))&(116)))));
        }
        (w = NextWord());
    }
    (k = threshold);
    jump MMbyPN;
];
[ Refers obj wnum wd k l m;
    if ((obj == 0)) {
        rfalse;
    }
    (k = wn);
    (wn = wnum);
    (wd = NextWordStopped());
    (wn = k);
    if (indirect_parser_inflection) {
        (k = (parser_inflection)(obj,wd));
        if ((k >= 0)) {
            return k;
        }
        (m = (-(k)));
    } else {
        (m = parser_inflection);
    }
    (k = (_final_propertyarray(OBJECT_TY, obj, m)));
    (l = (((_final_propertylength(OBJECT_TY, obj, m))/WORDSIZE) - 1));
    for ((m = 0):(m <= l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ WordInProperty wd obj prop k l m;
    (k = (_final_propertyarray(OBJECT_TY, obj, prop)));
    (l = ((_final_propertylength(OBJECT_TY, obj, prop))/WORDSIZE));
    for ((m = 0):(m < l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ NounWord i j s;
    (i = NextWord());
    if ((i == 0)) {
        rfalse;
    }
    if ((i == ME1__WD or ME2__WD or ME3__WD)) {
        rtrue;
    }
    (s = (LanguagePronouns-->(0)));
    for ((j = 1):(j <= s):(j = (j + 3))) {
        if ((i == (LanguagePronouns-->(j)))) {
            return (j + 2);
        }
    }
    if (((((i->(#dict_par1)))&(128)) == 0)) {
        rfalse;
    }
    return i;
];
[ TryNumber wordnum i j c num len mul tot d digit;
    (i = wn);
    (wn = wordnum);
    (j = NextWord());
    (wn = i);
    (j = NumberWord(j));
    if ((j >= 1)) {
        return j;
    }
    (i = (wordnum*3));
    (j = (parse-->(i)));
    (num = (j + buffer));
    (len = (parse-->((i - 1))));
    if ((len >= 4)) {
        (mul = 1000);
    }
    if ((len == 3)) {
        (mul = 100);
    }
    if ((len == 2)) {
        (mul = 10);
    }
    if ((len == 1)) {
        (mul = 1);
    }
    (tot = 0);
    (c = 0);
    (len = (len - 1));
    for ((c = 0):(c <= len):(c)++) {
        (digit = (num->(c)));
        if ((digit == 48)) {
            (d = 0);
            jump digok;
        }
        if ((digit == 49)) {
            (d = 1);
            jump digok;
        }
        if ((digit == 50)) {
            (d = 2);
            jump digok;
        }
        if ((digit == 51)) {
            (d = 3);
            jump digok;
        }
        if ((digit == 52)) {
            (d = 4);
            jump digok;
        }
        if ((digit == 53)) {
            (d = 5);
            jump digok;
        }
        if ((digit == 54)) {
            (d = 6);
            jump digok;
        }
        if ((digit == 55)) {
            (d = 7);
            jump digok;
        }
        if ((digit == 56)) {
            (d = 8);
            jump digok;
        }
        if ((digit == 57)) {
            (d = 9);
            jump digok;
        }
        return (-(1000));
        .digok;
        (tot = (tot + (mul*d)));
        (mul = (mul/10));
    }
    if ((len > 3)) {
        (tot = 10000);
    }
    return tot;
];
[ GetGender person;
    if ((~~((person has female)))) {
        rtrue;
    }
    rfalse;
];
[ GetGNAOfObject obj case gender;
    if ((~~((obj has animate)))) {
        (case = 6);
    }
    if ((obj has male)) {
        (gender = A_male);
    }
    if ((obj has female)) {
        (gender = A_female);
    }
    if ((obj has neuter)) {
        (gender = A_neuter);
    }
    if ((gender == 0)) {
        if ((case == 0)) {
            (gender = LanguageAnimateGender);
        } else {
            (gender = LanguageInanimateGender);
        }
    }
    if ((gender == A_female)) {
        (case = (case + 1));
    }
    if ((gender == A_neuter)) {
        (case = (case + 2));
    }
    if ((obj has pluralname)) {
        (case = (case + 3));
    }
    return case;
];
[ DetectPluralWord at n i w swn outcome;
    (swn = wn);
    (wn = at);
    for ((i = 0):(i < n):(i)++) {
        (w = NextWordStopped());
        if ((w == 0 or THEN1__WD or comma_word or -1)) {
            break;
        }
        if ((((w->(#dict_par1)))&(4))) {
            (parser_action = ##PluralFound);
            (outcome = 1);
        }
    }
    (wn = swn);
    return outcome;
];
[ SetPronoun dword value x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            ((LanguagePronouns-->((x + 2))) = value);
            rtrue;
        }
    }
    RunTimeError(14);
];
[ PronounValue dword x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            return (LanguagePronouns-->((x + 2)));
        }
    }
    rfalse;
];
[ ResetVagueWords obj;
    PronounNotice(obj);
];
[ PronounNotice obj x bm g;
    if ((obj == player)) {
        rtrue;
    }
    (g = GetGNAOfObject(obj));
    (bm = (PowersOfTwo_TB-->(g)));
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
            ((LanguagePronouns-->((x + 2))) = obj);
        }
    }
    if (((((g%6) < 3)) && ((obj has ambigpluralname)))) {
        (g = (g + 3));
        (bm = (PowersOfTwo_TB-->(g)));
        for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
            if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
                ((LanguagePronouns-->((x + 2))) = obj);
            }
        }
    }
];
[ PronounNoticeHeldObjects x;
    objectloop (x in player) {
        PronounNotice(x);
    }
    (x = 0);
    rfalse;
];
[ YesOrNo i j;
    for (:1:) {
        if ((((location ~= 0)) && ((parent(player) ~= 0)))) {
            DrawStatusLine();
        }
        KeyboardPrimitive(buffer2, parse2);
        (j = (parse2-->(0)));
        if (j) {
            (i = (parse2-->(1)));
            if ((i == YES1__WD or YES2__WD or YES3__WD)) {
                rtrue;
            }
            if ((i == NO1__WD or NO2__WD or NO3__WD)) {
                rfalse;
            }
        }
        YES_OR_NO_QUESTION_INTERNAL_RM(65);
        print "> ";
    }
];
[ YES_OR_NO_QUESTION_INTERNAL_R;
];
[ NumberWord o i n;
    (n = (LanguageNumbers-->(0)));
    for ((i = 1):(i <= n):(i = (i + 2))) {
        if ((o == (LanguageNumbers-->(i)))) {
            return (LanguageNumbers-->((i + 1)));
        }
    }
    rfalse;
];
[ COBJ__Copy words from to i;
    for ((i = 0):(i < words):(i)++) {
        ((to-->(i)) = (from-->(i)));
    }
];
[ COBJ__SwapMatches i x;
    (x = number_matched);
    (number_matched = (alt_match_list-->(0)));
    ((alt_match_list-->(0)) = x);
    if ((x < number_matched)) {
        (x = number_matched);
    }
    for ((i = x):(i > 0):(i)--) {
        (x = (match_list-->((i - 1))));
        ((match_list-->((i - 1))) = (alt_match_list-->(i)));
        ((alt_match_list-->(i)) = x);
    }
];
[ ChooseObjects obj code l i swn spcount;
    if ((code < 2)) {
        rfalse;
    }
    if ((cobj_flag == 1)) {
        .CodeOne;
        if ((parameters > 0)) {
            return ScoreDabCombo((parser_results-->(INP1_PRES)), obj);
        } else {
            (l = 0);
            for ((i = 1):(i <= (alt_match_list-->(0))):(i)++) {
                (spcount = ScoreDabCombo(obj, (alt_match_list-->(i))));
                if ((spcount == HIGHEST_DPMR_SCORE)) {
                    return spcount;
                }
                if ((spcount > l)) {
                    (l = spcount);
                }
            }
            return l;
        }
    }
    if ((cobj_flag == 2)) {
        .CodeTwo;
        @push action_to_be;
        if ((parameters == 0)) {
            if ((advance_warning > 0)) {
                (l = ScoreDabCombo(obj, advance_warning));
            } else {
                (l = ScoreDabCombo(obj, 0));
            }
        } else {
            (l = ScoreDabCombo((parser_results-->(INP1_PRES)), obj));
        }
        @pull action_to_be;
        return l;
    }
    (swn = wn);
    (spcount = pcount);
    while (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
        (pcount)++;
    }
    if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
        if (((line_tdata-->(pcount)) == TOPIC_TOKEN)) {
            (pcount = spcount);
            jump CodeTwo;
        }
        while ((wn <= num_words)) {
            (l = NextWordStopped());
            (wn)--;
            if ((l == THEN1__WD)) {
                break;
            }
            if ((((l ~= -1 or 0)) && ((((l->(#dict_par1)))&(8))))) {
                (wn)++;
                continue;
            }
            if ((l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
                (wn)++;
                continue;
            }
            SafeSkipDescriptors();
            @push match_length;
            @push token_filter;
            @push match_from;
            ((alt_match_list-->(0)) = number_matched);
            COBJ__Copy(number_matched, match_list, (alt_match_list + WORDSIZE));
            (match_length = 0);
            (number_matched = 0);
            (match_from = wn);
            (token_filter = 0);
            SearchScope(actor, actors_location, (line_tdata-->(pcount)));
            (wn = swn);
            (cobj_flag = 1);
            COBJ__SwapMatches();
            @pull match_from;
            @pull token_filter;
            @pull match_length;
            (pcount = spcount);
            jump CodeOne;
        }
    }
    (pcount = spcount);
    (wn = swn);
    (cobj_flag = 2);
    jump CodeTwo;
];
[ ScoreDabCombo a b result;
    @push action;
    @push act_requester;
    @push noun;
    @push second;
    (action = action_to_be);
    (act_requester = player);
    if (action_reversed) {
        (noun = b);
        (second = a);
    } else {
        (noun = a);
        (second = b);
    }
    (result = CheckDPMR());
    @pull second;
    @pull noun;
    @pull act_requester;
    @pull action;
    return result;
];
[ CheckDPMR result sinp1 sinp2 rv;
    (sinp1 = inp1);
    (sinp2 = inp2);
    (inp1 = noun);
    (inp2 = second);
    (rv = FollowRulebook(DOES_THE_PLAYER_MEAN_RB));
    (inp1 = sinp1);
    (inp2 = sinp2);
    if (((rv) && (RulebookSucceeded()))) {
        (result = ResultOfRule());
        if ((result == RBNO4_OUTCOME_U1)) {
            return 4;
        }
        if ((result == RBNO3_OUTCOME_U1)) {
            return 3;
        }
        if ((result == RBNO2_OUTCOME_U1)) {
            return 2;
        }
        if ((result == RBNO1_OUTCOME_U1)) {
            rtrue;
        }
        if ((result == RBNO0_OUTCOME_U1)) {
            rfalse;
        }
    }
    return 2;
];
[ DefaultTopic;
    return GPR_FAIL;
];
[ TEXT_TY_ROGPR txt p cp r;
    if ((txt == 0)) {
        return GPR_FAIL;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (r = TEXT_TY_ROGPRI(txt));
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_ROGPRI txt pos len wa wl wpos bdm ch own;
    (bdm = 1);
    (own = wn);
    (len = BlkValueLBCapacity(txt));
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 32 or 9 or 10 or 0)) {
            if (bdm) {
                continue;
            }
            (bdm = 1);
            if ((wpos ~= wl)) {
                return GPR_FAIL;
            }
            if ((ch == 0)) {
                break;
            }
        } else {
            if (bdm) {
                (bdm = 0);
                if ((NextWordStopped() == -1)) {
                    return GPR_FAIL;
                }
                (wa = WordAddress((wn - 1)));
                (wl = WordLength((wn - 1)));
                (wpos = 0);
            }
            if (((wa->(wpos)) ~= ch or TEXT_TY_RevCase(ch))) {
                return GPR_FAIL;
            }
            (wpos)++;
        }
    }
    if ((wn == own)) {
        return GPR_FAIL;
    }
    return GPR_PREPOSITION;
];
[ RunRoutines obj prop;
    if ((obj == thedark)) {
        (obj = real_location);
    }
    if (((_final_propertyarray(OBJECT_TY, obj, prop)) == 0)) {
        rfalse;
    }
    return _final_message0(obj, prop);
];
[ SetPlayersCommand from_txt i len at p cp;
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (len = TEXT_TY_CharacterLength(from_txt));
    if ((len > 118)) {
        (len = 118);
    }
    ((buffer-->(0)) = len);
    (at = 4);
    for ((i = 0):(i < len):(i)++) {
        ((buffer->((i + at))) = CharToCase(BlkValueRead(from_txt, i), 0));
    }
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    TEXT_TY_Untransmute(from_txt, p, cp);
];
[ LIST_OF_TY_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = (multiple_object-->(0)));
    LIST_OF_TY_SetLength(list, len);
    for ((i = 1):(i <= len):(i)++) {
        LIST_OF_TY_PutItem(list, i, (multiple_object-->(i)));
    }
    return list;
];
[ LIST_OF_TY_Set_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = BlkValueRead(list, LIST_LENGTH_F));
    if ((len > 63)) {
        (len = 63);
    }
    ((multiple_object-->(0)) = len);
    for ((i = 1):(i <= len):(i)++) {
        ((multiple_object-->(i)) = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    }
];
[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
    (wnc = wn);
    (original_wn = wn);
    (group_wn = wn);
    (r = DECIMAL_TOKEN_INNER());
    if ((r ~= GPR_FAIL)) {
        return r;
    }
    (wn = wnc);
    (r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN));
    if ((((r == GPR_NUMBER)) && ((parsed_number ~= 10000)))) {
        return r;
    }
    (wn = wnc);
    (wa = WordAddress(wn));
    (wl = WordLength(wn));
    (sign = 1);
    (base = 10);
    (digit_count = 0);
    if (((wa->(0)) ~= 45 or 36 or 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
        return GPR_FAIL;
    }
    if (((wa->(0)) == 45)) {
        (sign = -1);
        (wl)--;
        (wa)++;
    }
    if ((wl == 0)) {
        return GPR_FAIL;
    }
    (n = 0);
    while ((wl > 0)) {
        if (((wa->(0)) >= 97)) {
            (digit = (((wa->(0)) - 97) + 10));
        } else {
            (digit = ((wa->(0)) - 48));
        }
        (digit_count)++;
        switch (base) {
            2:
                if ((digit_count == 17)) {
                    return GPR_FAIL;
                }
                ;
            10:
                if ((digit_count == 11)) {
                    return GPR_FAIL;
                }
                if ((digit_count == 10)) {
                    if ((n > 214748364)) {
                        return GPR_FAIL;
                    }
                    if ((n == 214748364)) {
                        if ((((sign == 1)) && ((digit > 7)))) {
                            return GPR_FAIL;
                        }
                        if ((((sign == -1)) && ((digit > 8)))) {
                            return GPR_FAIL;
                        }
                    }
                }
                ;
            16:
                if ((digit_count == 5)) {
                    return GPR_FAIL;
                }
                ;
        }
        if ((((digit >= 0)) && ((digit < base)))) {
            (n = ((base*n) + digit));
        } else {
            return GPR_FAIL;
        }
        (wl)--;
        (wa)++;
    }
    (parsed_number = (n*sign));
    (wn)++;
    return GPR_NUMBER;
];
[ TRUTH_STATE_TOKEN original_wn wd;
    (original_wn = wn);
    (wd = TRUTH_STATE_TOKEN_INNER());
    if ((wd ~= GPR_FAIL)) {
        return wd;
    }
    (wn = original_wn);
    (wd = NextWordStopped());
    if ((wd == 'true')) {
        (parsed_number = 1);
        return GPR_NUMBER;
    }
    if ((wd == 'false')) {
        (parsed_number = 0);
        return GPR_NUMBER;
    }
    (wn = original_wn);
    return GPR_FAIL;
];
[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
    if ((wn > num_words)) {
        return GPR_FAIL;
    }
    (firstwd = wn);
    (buf = WordAddress(wn));
    (bufend = buf);
    (lastchar = 0);
    while ((wn <= num_words)) {
        (newstart = WordAddress(wn));
        if ((newstart ~= bufend)) {
            if ((((lastchar ~= 42 or 120 or 88 or 215)) && (((newstart->(0)) ~= 42 or 120 or 88 or 215)))) {
                break;
            }
        }
        (newlen = WordLength(wn));
        for ((ix = 0):(ix < newlen):(ix)++) {
            (ch = (newstart->(ix)));
            if ((~~((((((ch >= 48)) && ((ch <= 57)))) || ((ch == 45 or 43 or 69 or 101 or 46 or 120 or 88 or 42 or 215 or 94)))))) {
                break;
            }
        }
        if ((ix < newlen)) {
            break;
        }
        (bufend = (newstart + newlen));
        (wn)++;
        (lastchar = ((bufend - 1)->(0)));
        (lastwasdot = (((newlen == 1)) && ((lastchar == 46))));
    }
    if ((((wn > firstwd)) && (lastwasdot))) {
        (wn)--;
        (bufend)--;
    }
    if ((wn == firstwd)) {
        return GPR_FAIL;
    }
    (parsed_number = FloatParse(buf, (bufend - buf), 1));
    if ((parsed_number == FLOAT_NAN)) {
        return GPR_FAIL;
    }
    return GPR_NUMBER;
];
#ifdef BASICINFORMKIT;
[ _final_propertyvalue K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) { if (o has p) rtrue; rfalse; }
            if (o provides p) return o.p;
        }
        rfalse;
    } else {
        t = value_property_holders-->K;
        return (t.(p-->1))-->(o+COL_HSIZE);
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyexists K o p holder;
if (K == OBJECT_TY) {
    if ((o) && (metaclass(o) == Object)) {
        if ((p-->0 == 2) || (o provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
} else {
    if ((o >= 1) && (o <= value_ranges-->K)) {
        holder = value_property_holders-->K;
        if ((holder) && (holder provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
}
rfalse; ];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyarray K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.&p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertylength K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.#p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_store_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v) give o p; else give o ~p;
            } else if (o provides p) {
                o.p = v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) = v;
    }
];
[ _final_preinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return ++(o.p);
            }
        }
    } else {
       return ++(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_predec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return --(o.p);
            }
        }
    } else {
       return --(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_postinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)++;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))++;
    }
    return 0;
];
[ _final_postdec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)--;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))--;
    }
    return 0;
];
[ _final_setbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o p;
            } else if (o provides p) {
                o.p = o.p | v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) | v;
    }
];
[ _final_clearbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o ~p;
            } else if (o provides p) {
                o.p = o.p & ~v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) & ~v;
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_message0 o p q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q();
];
[ _final_message1 o p v1 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1);
];
[ _final_message2 o p v1 v2 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2);
];
[ _final_message3 o p v1 v2 v3 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2, v3);
];
#endif;
Verb 'take' 'carry' 'hold' 
	* 'inventory' -> Inv 
	* multi -> Take 
	* 'off' noun -> Disrobe 
	* noun 'off' -> Disrobe 
	* multiinside 'from' noun -> Remove 
	* multiinside 'off' noun -> Remove;
Verb 'get' 
	* 'out' / 'off' / 'down' / 'up' -> Exit 
	* 'in' / 'on' -> Enter 
	* multi -> Take 
	* 'in' / 'into' / 'on' / 'onto' noun -> Enter 
	* 'off' / 'down' noun -> GetOff 
	* multiinside 'from' noun -> Remove;
Verb 'pick' 
	* 'up' multi -> Take 
	* multi 'up' -> Take;
Verb 'stand' 
	* -> Exit 
	* 'up' -> Exit 
	* 'on' noun -> Enter;
Verb 'remove' 
	* held -> Disrobe 
	* multiinside 'from' noun -> Remove;
Verb 'shed' 'doff' 'disrobe' 
	* held -> Disrobe;
Verb 'wear' 'don' 
	* held -> Wear;
Verb 'put' 
	* 'on' held -> Wear 
	* held 'on' -> Wear 
	* 'down' multiheld -> Drop 
	* multiheld 'down' -> Drop 
	*  noun=Noun_Filter1 'on'  noun=Noun_Filter2 -> PutOn 
	* held 'under' noun -> A_hiding_it_under 
	* multiexcept 'in' / 'inside' / 'into' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'insert' 
	* multiexcept 'in' / 'into' noun -> Insert;
Verb 'drop' 'throw' 'discard' 
	* multiheld -> Drop 
	* held 'at' / 'against' noun -> ThrowAt 
	* multiexcept 'in' / 'into' / 'down' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'give' 'pay' 'offer' 'feed' 
	* creature held -> Give reverse 
	* held 'to' creature -> Give;
Verb 'show' 'present' 'display' 
	* creature held -> Show reverse 
	* held 'to' creature -> Show;
Verb 'go' 'walk' 'run' 
	* -> Go 
	*  noun=Noun_Filter3 -> Go 
	* noun -> Enter 
	* 'into' / 'in' / 'inside' / 'through' noun -> Enter;
Verb 'inventory' 'i//' 'inv' 
	* -> Inv;
Verb 'look' 'l//' 
	* -> Look 
	* noun -> Examine 
	* 'at' noun -> Examine 
	* 'inside' / 'in' / 'into' / 'through' noun -> Search 
	* 'under' noun -> LookUnder 
	* 'up' topic 'in' noun -> Consult reverse;
Verb 'consult' 
	* noun 'on' / 'about' topic -> Consult;
Verb 'unwrap' 
	* noun -> Open;
Verb 'close' 'shut' 'cover' 
	* noun -> Close 
	* 'up' noun -> Close 
	* 'off' noun -> SwitchOff;
Verb 'enter' 'cross' 
	* -> Enter 
	* noun -> Enter;
Verb 'sit' 
	* 'on' / 'in' / 'inside' noun -> Enter 
	* 'on' 'top' 'of' noun -> Enter;
Verb 'exit' 'leave' 'out' 
	* -> Exit;
Verb 'examine' 'x//' 'watch' 'describe' 'check' 
	* noun -> Examine;
Verb 'read' 
	* noun -> Examine 
	* 'about' topic 'in' noun -> Consult reverse 
	* topic 'in' noun -> Consult reverse;
Verb 'yes' 'y//' 
	* -> Yes;
Verb 'no' 
	* -> No;
Verb 'sorry' 
	* -> Sorry;
Verb 'search' 
	* noun -> Search;
Verb 'wave' 
	* -> WaveHands 
	* noun -> Wave;
Verb 'set' 'adjust' 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to 
	* noun 'to' topic -> SetTo;
Verb 'pull' 'drag' 
	* noun -> Pull;
Verb 'push' 'move' 'shift' 'clear' 'press' 
	* noun -> Push 
	* noun  noun=Noun_Filter4 -> PushDir 
	* noun 'to'  noun=Noun_Filter5 -> PushDir;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw' 
	* noun -> Turn 
	* noun 'on' -> SwitchOn 
	* 'on' noun -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to;
Verb 'switch' 
	*  noun=Noun_Filter6 -> SwitchOff 
	* noun -> SwitchOn 
	* 'on' noun -> SwitchOn 
	* noun 'on' -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff;
Verb 'lock' 
	*  noun=Noun_Filter7 -> A_locking_keylessly 
	*  noun=Noun_Filter8 -> A_locking_keylessly 
	* noun -> A_locking_keylessly 
	*  noun=Noun_Filter9 'with' noun -> Lock 
	*  noun=Noun_Filter10 'with' noun -> Lock 
	* noun '|__' 'with' noun -> Lock;
Verb 'unlock' 
	*  noun=Noun_Filter11 -> A_unlocking_keylessly 
	*  noun=Noun_Filter12 -> A_unlocking_keylessly 
	* noun -> A_unlocking_keylessly 
	*  noun=Noun_Filter13 'with' noun -> Unlock 
	*  noun=Noun_Filter14 'with' noun -> Unlock 
	* noun 'with' noun -> Unlock;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump' 
	* noun -> Attack 
	* noun -> A_hitting 
	* noun 'with' held -> A_hitting;
Verb 'wait' 'z//' 
	* -> Wait;
Verb 'answer' 'say' 'shout' 'speak' 
	* 'xyzzy' -> A_casting_xyzzy 
	* topic 'to' creature -> Answer reverse;
Verb 'tell' 
	* creature 'about' topic -> Tell;
Verb 'ask' 
	* creature 'for' noun -> AskFor 
	* creature 'about' topic -> Ask;
Verb 'eat' 
	* held -> Eat;
Verb 'sleep' 'nap' 
	* -> Sleep;
Verb 'climb' 'scale' 
	* noun -> Climb 
	* 'up' / 'over' noun -> Climb;
Verb 'buy' 'purchase' 
	* noun -> Buy;
Verb 'squeeze' 'squash' 
	* noun -> Squeeze;
Verb 'swing' 
	* noun -> Swing 
	* 'on' noun -> Swing;
Verb 'wake' 'awake' 'awaken' 
	* -> Wake 
	* 'up' -> Wake 
	* creature -> WakeOther 
	* creature 'up' -> WakeOther 
	* 'up' creature -> WakeOther;
Verb 'kiss' 'embrace' 'hug' 
	* creature -> Kiss;
Verb 'think' 
	* -> Think;
Verb 'smell' 'sniff' 
	* -> Smell 
	* noun -> Smell;
Verb 'listen' 
	* -> Listen 
	* 'to' noun -> Listen;
Verb 'hear' 
	* noun -> Listen;
Verb 'taste' 
	* noun -> Taste;
Verb 'touch' 'feel' 
	* noun -> Touch;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub' 
	* noun -> Rub;
Verb 'tie' 'attach' 'fasten' 
	* noun 'to' noun -> Tie;
Verb 'burn' 'light' 
	* noun -> Burn;
Verb 'drink' 'swallow' 'sip' 
	* noun -> Drink 
	* 'from'  noun=Noun_Filter15 -> Drink;
Verb 'cut' 'slice' 'prune' 'chop' 
	* noun -> Cut;
Verb 'jump' 'skip' 'hop' 
	* -> Jump;
Verb 'score' 
	* -> Score;
Verb 'quit' 
	* -> Quit;
Verb 'q//' 
	* -> Quit;
Verb 'save' 
	* -> Save;
Verb 'restart' 
	* -> Restart;
Verb 'restore' 
	* -> Restore;
Verb 'verify' 
	* -> Verify;
Verb 'version' 
	* -> Version;
Verb 'script' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'transcript' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'superbrief' 
	* -> LMode3;
Verb 'short' 
	* -> LMode3;
Verb 'verbose' 
	* -> LMode2;
Verb 'long' 
	* -> LMode2;
Verb 'brief' 
	* -> LMode1;
Verb 'normal' 
	* -> LMode1;
Verb 'nouns' 
	* -> Pronouns;
Verb 'pronouns' 
	* -> Pronouns;
Verb 'notify' 
	* -> NotifyOn 
	* 'on' -> NotifyOn 
	* 'off' -> NotifyOff;
Verb 'open' 
	* noun -> Open 
	*  noun=Noun_Filter16 'with' noun -> Unlock 
	*  noun=Noun_Filter17 'with' noun -> Unlock 
	* noun 'with' noun -> Unlock;
Verb 'uncover' 
	* noun -> Open;
Verb 'help' 
	* -> A_asking_for_help;
Verb 'hint' 
	* -> A_asking_for_help;
Verb 'hints' 
	* -> A_asking_for_help;
Verb 'about' 
	* -> A_asking_for_help;
Verb 'info' 
	* -> A_asking_for_help;
Verb 'ride' 
	* noun -> A_mounting;
Verb 'mount' 
	* noun -> A_mounting;
Verb 'dismount' 
	* -> A_dismounting;
Verb 'bother' 'curses' 'drat' 'darn' 
	* -> Mild;
Verb 'shit' 'fuck' 'damn' 
	* -> Strong;
Verb 'sing' 
	* -> Sing;
Verb 'pour' 
	*  noun=Noun_Filter18 'in' / 'into' / 'on' / 'onto'  noun=Noun_Filter19 -> A_pouring_it_into 
	* noun 'in' / 'into' / 'on' / 'onto' noun -> A_pouring_it_into;
Verb 'empty' 
	*  noun=Noun_Filter20 'into'  noun=Noun_Filter21 -> A_pouring_it_into 
	* noun 'into' noun -> A_pouring_it_into;
Verb 'fill' 
	*  noun=Noun_Filter22 'with' / 'from'  noun=Noun_Filter23 -> A_pouring_it_into reverse 
	* noun 'with' / 'from' noun -> A_pouring_it_into reverse;
Verb 'hide' 'shove' 'conceal' 'stick' 
	* held 'under' noun -> A_hiding_it_under;
Verb 'hello' 
	* noun -> A_hi_speaking;
Verb 'hi' 
	* noun -> A_hi_speaking;
Verb 'xyzzy' 
	* -> A_casting_xyzzy;
Verb 'cast' 
	* 'xyzzy' -> A_casting_xyzzy;
Verb 'spin' 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to;
