!% $ZCODE_LESS_DICT_DATA=1;
!% $OMIT_UNUSED_ROUTINES=1;
!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=350
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=1000000
!% $MAX_STATIC_DATA=500000
!% $MAX_NUM_STATIC_STRINGS=500000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=28000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256
!% $DICT_WORD_SIZE=25
!% $MAX_ACTIONS=280
Constant Grammar__Version 2;
Global debug_flag;
Global or_tmp_var;
Attribute absent;
Attribute animate;
Attribute clothing;
Attribute concealed;
Attribute container;
Attribute door;
Attribute edible;
Attribute enterable;
Attribute light;
Attribute lockable;
Attribute locked;
Attribute moved;
Attribute on;
Attribute open;
Attribute openable;
Attribute scenery;
Attribute static;
Attribute supporter;
Attribute switchable;
Attribute talkable;
Attribute transparent;
Attribute visited;
Attribute worn;
Attribute male;
Attribute female;
Attribute neuter;
Attribute pluralname;
Attribute ambigpluralname;
Attribute proper;
Attribute remove_proper;
Attribute privately_named;
Attribute mentioned;
Attribute pushable;
Attribute mark_as_room;
Attribute mark_as_thing;
Attribute workflag;
Attribute workflag2;
Attribute P_indoors;
Attribute P_electromagnetic;
Attribute P_consumed;
Property add_to_scope;
Property article;
Property capacity;
Property component_child;
Property component_parent;
Property component_sibling;
Property description;
Property door_dir;
Property door_to;
Property found_in;
Property initial;
Property list_together;
Property map_region;
Property parse_name;
Property plural;
Property regional_found_in;
Property room_index;
Property short_name;
Property saved_short_name;
Property vector;
Property with_key;
Property KD_Count;
Property IK1_Count;
Property IK2_Count;
Property IK4_Count;
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;
Property IK3_Count;
Property IK1_link;
Property IK2_link;
Property IK5_link;
Property IK6_link;
Property IK8_link;
Property articles;
Property grammar;
Property inside_description;
Property short_name_indef;
Global right_alignment_depth = 14;
Global unicode_gestalt_ok = 0;
Global formal_rv = 0;
Global formal_par0 = 0;
Global formal_par1 = 0;
Global formal_par2 = 0;
Global formal_par3 = 0;
Global formal_par4 = 0;
Global formal_par5 = 0;
Global formal_par6 = 0;
Global formal_par7 = 0;
Global unicode_temp = 0;
Global I7SFRAME = 0;
Global TEXT_TY_RE_Err = 0;
Global prior_named_noun = 0;
Global prior_named_list = 0;
Global prior_named_list_gender = 0;
Global story_tense = 1;
Global story_viewpoint = 2;
Global say__p = 1;
Global say__pc = 0;
Global say__pc_save = 0;
Global say__n = 0;
Global say__comp = 0;
Global los_rv = 0;
Global parameter_object = 0;
Global parameter_value = 0;
Global property_to_be_totalled = 0;
Global property_loop_sign = 0;
Global suppress_scope_loops = 0;
Global temporary_value = 0;
Global clr_fg = 1;
Global clr_bg = 1;
Global clr_fgstatus = 1;
Global clr_bgstatus = 1;
Global clr_on = 0;
Global statuswin_current = 0;
Global suppress_text_substitution = 0;
Global deadflag = 0;
Global statuswin_cursize = 0;
Global statuswin_size = 1;
Global debug_rules = 0;
Global debug_rule_nesting = 0;
Global reason_the_action_failed = 0;
Global indef_mode = 0;
Global standard_interpreter = 0;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;
Global I7S_Tab = 0;
Global I7S_Col = 0;
Global I7S_Dir = 0;
Global I7S_Swap = 0;
Global I7S_Comp = 0;
Global MStack_Top = 0;
Global MStack_Frame_Extent = 0;
Global process_rulebook_count = 0;
Global debugging_rules = 0;
Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;
Global TEXT_TY_CastPrimitiveNesting = 0;
Global TEXT_TY_RE_Trace = 0;
Global TEXT_TY_RE_RewindCount = 0;
Global LIST_OF_TY_Sort_cf = 0;
Global location = 0;
Global sline1 = 0;
Global sline2 = 0;
Global undo_flag = 0;
Global story_complete = 0;
Global resurrect_please = 0;
Global not_yet_in_play = 1;
Global turns = 1;
Global the_time = NULL;
Global time_rate = 1;
Global score = 0;
Global last_score = 0;
Global notify_mode = 1;
Global left_hand_status_line = T_SL_Location;
Global right_hand_status_line = T_SL_Score_Moves;
Global player = 0;
Global real_location = 0;
Global visibility_ceiling = 0;
Global visibility_levels = 0;
Global SACK_OBJECT = 0;
Global act_requester = 0;
Global actor = 0;
Global actors_location = 0;
Global actor_location = 0;
Global action = 0;
Global meta = 0;
Global inp1 = 0;
Global inp2 = 0;
Global toomany_flag = 0;
Global multiflag = 0;
Global multiple_object_item = 0;
Global noun = 0;
Global second = 0;
Global keep_silent = 0;
Global trace_actions = 0;
Global untouchable_object = 0;
Global untouchable_silence = 0;
Global touch_persona = 0;
Global special_word = 0;
Global consult_from = 0;
Global consult_words = 0;
Global parsed_number = 0;
Global special_number1 = 0;
Global special_number2 = 0;
Global parser_trace = 0;
Global pronoun_word = 0;
Global pronoun_obj = 0;
Global players_command = 100;
Global matched_text = 0;
Global understand_as_mistake_number = 0;
Global particular_possession = 0;
Global parser_action = 0;
Global parser_one = 0;
Global parser_two = 0;
Global parameters = 0;
Global action_to_be = 0;
Global action_reversed = 0;
Global wn = 0;
Global num_words = 0;
Global verb_word = 0;
Global verb_wordnum = 0;
Global scope_reason = PARSING_REASON;
Global scope_token = 0;
Global scope_error = 0;
Global scope_stage = 0;
Global advance_warning = 0;
Global reason_code = NULL;
Global ats_flag = 0;
Global ats_hls = 0;
Global move_pushing = 0;
Global move_from = 0;
Global move_to = 0;
Global move_by = 0;
Global move_through = 0;
Global lookmode = KIT_CONFIGURATION_LOOKMODE;
Global c_style = 0;
Global c_depth = 0;
Global c_iterator = 0;
Global lt_value = EMPTY_TEXT_VALUE;
Global listing_together = 0;
Global listing_size = 0;
Global c_margin = 0;
Global inventory_stage = 1;
Global debug_scenes = 0;
Global MAX_SCORE = INITIAL_MAX_SCORE;
Global lightflag = 0;
Global requisition_stack_pointer = 0;
Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;
Global list_filter_routine = 0;
Global EarlyInTurnSequence = 0;
Global IterationsOfTurnSequence = 0;
Global time_step = 0;
Global converted_action_outcome = -1;
Global activities_sp = 0;
Global inhibit_flag = 0;
Global saved_debug_rules = 0;
Global pending_boxed_quotation = 0;
Global caps_mode = 0;
Global short_name_case = 0;
Global map_has_changed = 1;
Global last_filter = 0;
Global last_use_doors = 0;
Global x_scope_count = 0;
Global test_sp = 0;
Global etype = 0;
Global best_etype = 0;
Global nextbest_etype = 0;
Global parser_inflection = 0;
Global indirect_parser_inflection = 0;
Global pcount = 0;
Global pcount2 = 0;
Global nsns = 0;
Global params_wanted = 0;
Global inferfrom = 0;
Global inferword = 0;
Global dont_infer_pronoun = 0;
Global dont_infer = 0;
Global cobj_flag = 0;
Global oops_from = 0;
Global saved_oops = 0;
Global held_back_mode = 0;
Global hb_wn = 0;
Global usual_grammar_after = 0;
Global found_ttype = 0;
Global found_tdata = 0;
Global token_filter = 0;
Global length_of_noun = 0;
Global lookahead = 0;
Global multi_mode = 0;
Global multi_wanted = 0;
Global multi_had = 0;
Global multi_context = 0;
Global indef_type = 0;
Global indef_wanted = 0;
Global indef_guess_p = 0;
Global indef_owner = 0;
Global indef_cases = 0;
Global indef_possambig = 0;
Global indef_nspec_at = 0;
Global allow_plurals = 0;
Global take_all_rule = 0;
Global dict_flags_of_noun = 0;
Global pronoun__word = 0;
Global pronoun__obj = 0;
Global number_matched = 0;
Global number_of_classes = 0;
Global match_length = 0;
Global match_from = 0;
Global parsetoken_nesting = 0;
Array Global_Vars --> 0
  (0) ! -->1 = V80_number_understood (V80_number_understood)
  (0) ! -->2 = V81_real_number_understood (V81_real_number_understood)
  (0) ! -->3 = V82_truth_state_understood (V82_truth_state_understood)
  (0) ! -->4 = V83_external_file_understood (V83_external_file_understood)
  (540) ! -->5 = V84_time_understood (V84_time_understood)
  (I_entire_game_U1) ! -->6 = V85_scene_understood (V85_scene_understood)
  (I_figure_of_cover_U1) ! -->7 = V86_figure_name_understood (V86_figure_name_understood)
  (I_sound_of_bell_U1) ! -->8 = V87_sound_name_understood (V87_sound_name_understood)
  (I_english_language_U1) ! -->9 = V88_natural_language_understo (V88_natural_language_understo)
  (I_present_tense_U1) ! -->10 = V89_grammatical_tense_underst (V89_grammatical_tense_underst)
  (I_first_person_singular_U1) ! -->11 = V90_narrative_viewpoint_under (V90_narrative_viewpoint_under)
  (I_nominative_U1) ! -->12 = V91_grammatical_case_understo (V91_grammatical_case_understo)
  (I_neuter_gender_U1) ! -->13 = V92_grammatical_gender_unders (V92_grammatical_gender_unders)
  (I_didn_t_understand_error_U1) ! -->14 = V93_command_parser_error_unde (V93_command_parser_error_unde)
  (I_brief_U1) ! -->15 = V94_verbosity_understood (V94_verbosity_understood)
  (0) ! -->16 = V95_price_understood (V95_price_understood)
  (0) ! -->17 = V96_volume_understood (V96_volume_understood)
  (I_water_U1) ! -->18 = V97_liquid_understood (V97_liquid_understood)
  (I_nondescript_U1) ! -->19 = V98_color_understood (V98_color_understood)
  (I_weakling_U1) ! -->20 = V99_strength_pattern_understo (V99_strength_pattern_understo)
  (I_allowed_U1) ! -->21 = V100_permission_understood (V100_permission_understood)
  (I_english_language_U1) ! -->22 = V1_language_of_play (V1_language_of_play)
  (0) ! -->23 = V12_darkness_witnessed (V12_darkness_witnessed)
  (bc_U325) ! -->24 = V26_command_prompt (V26_command_prompt)
  (bc_U326) ! -->25 = V31_story_author (V31_story_author)
  (bc_U327) ! -->26 = V32_story_headline (V32_story_headline)
  (bc_U328) ! -->27 = V33_story_genre (V33_story_genre)
  (bc_U329) ! -->28 = V34_story_description (V34_story_description)
  (122) ! -->29 = V35_release_number (V35_release_number)
  (2025) ! -->30 = V36_story_creation_year (V36_story_creation_year)
  (0) ! -->31 = V43_locale_paragraph_count (V43_locale_paragraph_count)
  (I_parking_lot_U1) ! -->32 = V44_room_gone_from (V44_room_gone_from)
  (0) ! -->33 = V45_room_gone_to (V45_room_gone_to)
  (0) ! -->34 = V46_door_gone_through (V46_door_gone_through)
  (0) ! -->35 = V47_vehicle_gone_by (V47_vehicle_gone_by)
  (0) ! -->36 = V48_thing_gone_with (V48_thing_gone_with)
  (0) ! -->37 = V49_container_exited_from (V49_container_exited_from)
  (##Wait) ! -->38 = V50_room_describing_action (V50_room_describing_action)
  (0) ! -->39 = V51_abbreviated_form_allowed (V51_abbreviated_form_allowed)
  (0) ! -->40 = V52_visibility_level_count (V52_visibility_level_count)
  (0) ! -->41 = V53_visibility_ceiling (V53_visibility_ceiling)
  (0) ! -->42 = V54_examine_text_printed (V54_examine_text_printed)
  (selfobj) ! -->43 = V101_actor (V101_actor)
  (0) ! -->44 = V102_action_in_world (V102_action_in_world)
  (0) ! -->45 = V103_action_keeping_silent (V103_action_keeping_silent)
  (0) ! -->46 = V104_specific_check_rulebook (V104_specific_check_rulebook)
  (0) ! -->47 = V105_specific_carry_out_rulebo (V105_specific_carry_out_rulebo)
  (0) ! -->48 = V106_specific_report_rulebook (V106_specific_report_rulebook)
  (0) ! -->49 = V107_within_the_player_s_sight (V107_within_the_player_s_sight)
  (0) ! -->50 = V56_key_unlocked_with (V56_key_unlocked_with)
  (0) ! -->51 = V57_key_locked_with (V57_key_locked_with)
  (0) ! -->52 = V58_menu_depth (V58_menu_depth)
  (0) ! -->53 = V59_endnode_flag (V59_endnode_flag)
  (bc_U347) ! -->54 = V60_current_menu_title (V60_current_menu_title)
  (table_data_U3) ! -->55 = V61_current_menu (V61_current_menu)
  (1) ! -->56 = V62_current_menu_selection (V62_current_menu_selection)
  (table_data_U13) ! -->57 = V63_status_bar_table (V63_status_bar_table)
  (0) ! -->58 = V65_toadaway (V65_toadaway)
  (0) ! -->59 = V66_dark_terminus_count (V66_dark_terminus_count)
  (table_data_U14) ! -->60 = V67_prize_table (V67_prize_table)
  (0) ! -->61 = V68_prize_taken (V68_prize_taken)
  (0) ! -->62 = V69_points_awarded (V69_points_awarded)
  (0) ! -->63 = V70_object_taken_from (V70_object_taken_from)
  (0) ! -->64 = V71_switch_count (V71_switch_count)
  (table_data_U15) ! -->65 = V72_price_table (V72_price_table)
  (0) ! -->66 = V73_highstrikerwin (V73_highstrikerwin)
  (0) ! -->67 = V74_tossadimewin (V74_tossadimewin)
  (0) ! -->68 = V75_pitchersmoundwin (V75_pitchersmoundwin)
  (0) ! -->69 = V76_electrocuted (V76_electrocuted)
  (0) ! -->70 = V77_dial_count (V77_dial_count)
  (I_figure_of_controlpanel_U1) ! -->71 = V78_controlpanelimage (V78_controlpanelimage)
  (I_allowed_U1) ! -->72 = V79_hint_usage (V79_hint_usage)
;
Constant subterfuge_1 = absent;
Constant subterfuge_2 = animate;
Constant subterfuge_3 = clothing;
Constant subterfuge_4 = concealed;
Constant subterfuge_5 = container;
Constant subterfuge_6 = door;
Constant subterfuge_7 = edible;
Constant subterfuge_8 = enterable;
Constant subterfuge_9 = light;
Constant subterfuge_10 = lockable;
Constant subterfuge_11 = locked;
Constant subterfuge_12 = moved;
Constant subterfuge_13 = on;
Constant subterfuge_14 = open;
Constant subterfuge_15 = openable;
Constant subterfuge_16 = scenery;
Constant subterfuge_17 = static;
Constant subterfuge_18 = supporter;
Constant subterfuge_19 = switchable;
Constant subterfuge_20 = talkable;
Constant subterfuge_21 = transparent;
Constant subterfuge_22 = visited;
Constant subterfuge_23 = worn;
Constant subterfuge_24 = male;
Constant subterfuge_25 = female;
Constant subterfuge_26 = neuter;
Constant subterfuge_27 = pluralname;
Constant subterfuge_28 = ambigpluralname;
Constant subterfuge_29 = proper;
Constant subterfuge_30 = remove_proper;
Constant subterfuge_31 = privately_named;
Constant subterfuge_32 = mentioned;
Constant subterfuge_33 = pushable;
Constant subterfuge_34 = mark_as_room;
Constant subterfuge_35 = mark_as_thing;
Constant subterfuge_36 = workflag;
Constant subterfuge_37 = workflag2;
Constant subterfuge_38 = add_to_scope;
Constant subterfuge_39 = article;
Constant subterfuge_40 = capacity;
Constant subterfuge_41 = component_child;
Constant subterfuge_42 = component_parent;
Constant subterfuge_43 = component_sibling;
Constant subterfuge_44 = description;
Constant subterfuge_45 = door_dir;
Constant subterfuge_46 = door_to;
Constant subterfuge_47 = found_in;
Constant subterfuge_48 = initial;
Constant subterfuge_49 = list_together;
Constant subterfuge_50 = map_region;
Constant subterfuge_51 = parse_name;
Constant subterfuge_52 = plural;
Constant subterfuge_53 = regional_found_in;
Constant subterfuge_54 = room_index;
Constant subterfuge_55 = short_name;
Constant subterfuge_56 = saved_short_name;
Constant subterfuge_57 = vector;
Constant subterfuge_58 = with_key;
Constant subterfuge_59 = KD_Count;
Constant subterfuge_60 = IK1_Count;
Constant subterfuge_61 = IK2_Count;
Constant subterfuge_62 = IK4_Count;
Constant subterfuge_63 = IK5_Count;
Constant subterfuge_64 = IK6_Count;
Constant subterfuge_65 = IK8_Count;
Constant subterfuge_66 = IK3_Count;
Constant subterfuge_67 = IK1_link;
Constant subterfuge_68 = IK2_link;
Constant subterfuge_69 = IK5_link;
Constant subterfuge_70 = IK6_link;
Constant subterfuge_71 = IK8_link;
Constant subterfuge_72 = articles;
Constant subterfuge_73 = grammar;
Constant subterfuge_74 = inside_description;
Constant subterfuge_75 = short_name_indef;
Constant subterfuge_76 = cap_short_name;
Constant subterfuge_77 = before;
Constant subterfuge_78 = action_bitmap;
Constant subterfuge_79 = name;
Constant subterfuge_80 = P_variable_initial_value;
Constant subterfuge_81 = P_specification;
Constant subterfuge_82 = P_indefinite_appearance_text;
Constant subterfuge_83 = P_adaptive_text_viewpoint;
Constant subterfuge_84 = P_opposite;
Constant subterfuge_85 = P_recurring;
Constant subterfuge_86 = K1_room_Next;
Constant subterfuge_87 = K2_thing_Next;
Constant subterfuge_88 = K3_direction_Next;
Constant subterfuge_89 = K4_door_Next;
Constant subterfuge_90 = K5_container_Next;
Constant subterfuge_91 = K6_supporter_Next;
Constant subterfuge_92 = IK7_Count;
Constant subterfuge_93 = K7_backdrop_Next;
Constant subterfuge_94 = K8_person_Next;
Constant subterfuge_95 = IK9_Count;
Constant subterfuge_96 = K9_region_Next;
Constant subterfuge_97 = IK10_Count;
Constant subterfuge_98 = K10_man_Next;
Constant subterfuge_99 = K11_woman_Count;
Constant subterfuge_100 = K11_woman_Next;
Constant subterfuge_101 = K12_animal_Count;
Constant subterfuge_102 = K12_animal_Next;
Constant subterfuge_103 = K13_device_Count;
Constant subterfuge_104 = K13_device_Next;
Constant subterfuge_105 = K14_vehicle_Count;
Constant subterfuge_106 = K14_vehicle_Next;
Constant subterfuge_107 = K15_player_s_holdall_Count;
Constant subterfuge_108 = K15_player_s_holdall_Next;
Constant subterfuge_109 = K16_passkey_Count;
Constant subterfuge_110 = K16_passkey_Next;
Constant subterfuge_111 = K17_keychain_Count;
Constant subterfuge_112 = K17_keychain_Next;
Constant subterfuge_113 = P_unbolting_relation_storage;
Constant subterfuge_114 = K18_fluid_container_Count;
Constant subterfuge_115 = K18_fluid_container_Next;
Constant subterfuge_116 = K19_electric_lamp_Count;
Constant subterfuge_117 = K19_electric_lamp_Next;
Constant subterfuge_118 = K20_attendant_Count;
Constant subterfuge_119 = K20_attendant_Next;
Constant subterfuge_120 = K21_coin_Count;
Constant subterfuge_121 = K21_coin_Next;
Constant subterfuge_122 = K22_nickel_Count;
Constant subterfuge_123 = K22_nickel_Next;
Constant subterfuge_124 = K23_dime_Count;
Constant subterfuge_125 = K23_dime_Next;
Constant subterfuge_126 = K24_quarter_Count;
Constant subterfuge_127 = K24_quarter_Next;
Constant subterfuge_128 = K25_electrical_closet_Count;
Constant subterfuge_129 = K25_electrical_closet_Next;
Constant subterfuge_130 = K26_electrical_panel_Count;
Constant subterfuge_131 = K26_electrical_panel_Next;
Constant subterfuge_132 = K27_socket_Count;
Constant subterfuge_133 = K27_socket_Next;
Constant subterfuge_134 = K28_indicator_Count;
Constant subterfuge_135 = K28_indicator_Next;
Constant subterfuge_136 = K29_fuse_Count;
Constant subterfuge_137 = K29_fuse_Next;
Constant subterfuge_138 = K30_switch_Count;
Constant subterfuge_139 = K30_switch_Next;
Constant subterfuge_140 = K31_ride_ticket_Count;
Constant subterfuge_141 = K31_ride_ticket_Next;
Constant subterfuge_142 = K32_baseball_Count;
Constant subterfuge_143 = K32_baseball_Next;
Constant subterfuge_144 = K33_wooden_door_Count;
Constant subterfuge_145 = K33_wooden_door_Next;
Constant subterfuge_146 = K34_control_panel_Count;
Constant subterfuge_147 = K34_control_panel_Next;
Constant subterfuge_148 = K35_button_Count;
Constant subterfuge_149 = K35_button_Next;
Constant subterfuge_150 = K36_dial_Count;
Constant subterfuge_151 = K36_dial_Next;
Constant subterfuge_152 = K37_light_Count;
Constant subterfuge_153 = K37_light_Next;
Constant subterfuge_154 = P_indoors;
Constant subterfuge_155 = P_price;
Constant subterfuge_156 = P_fluid_capacity;
Constant subterfuge_157 = P_current_volume;
Constant subterfuge_158 = P_liquid;
Constant subterfuge_159 = P_panel_id;
Constant subterfuge_160 = P_color;
Constant subterfuge_161 = P_fuse_id;
Constant subterfuge_162 = P_dial_setting;
Constant subterfuge_163 = P_figure_id;
Constant subterfuge_164 = P_underlying_relation_storag;
Constant subterfuge_165 = P_electromagnetic;
Constant subterfuge_166 = P_consumed;
Constant subterfuge_167 = P_tossing_relation_storage;
Constant I_english_language_U1 = 1;
Constant I_french_language_U1 = 2;
Constant I_german_language_U1 = 3;
Constant I_italian_language_U1 = 4;
Constant I_spanish_language_U1 = 5;
Constant I_swedish_language_U1 = 6;
Constant I_present_tense_U1 = 1;
Constant I_past_tense_U1 = 2;
Constant I_perfect_tense_U1 = 3;
Constant I_past_perfect_tense_U1 = 4;
Constant I_future_tense_U1 = 5;
Constant I_first_person_singular_U1 = 1;
Constant I_second_person_singular_U1 = 2;
Constant I_third_person_singular_U1 = 3;
Constant I_first_person_plural_U1 = 4;
Constant I_second_person_plural_U1 = 5;
Constant I_third_person_plural_U1 = 6;
Constant I_nominative_U1 = 1;
Constant I_accusative_U1 = 2;
Constant I_neuter_gender_U1 = 1;
Constant I_masculine_gender_U1 = 2;
Constant I_feminine_gender_U1 = 3;
Constant I_figure_of_cover_U1 = 1;
Constant I_entire_game_U1 = 1;
Constant I_didn_t_understand_error_U1 = 1;
Constant I_only_understood_as_far_as__U1 = 2;
Constant I_didn_t_understand_that_num_U1 = 3;
Constant I_can_only_do_that_to_someth_U1 = 4;
Constant I_can_t_see_any_such_thing_e_U1 = 5;
Constant I_said_too_little_error_U1 = 6;
Constant I_aren_t_holding_that_error_U1 = 7;
Constant I_can_t_use_multiple_objects_U1 = 8;
Constant I_can_only_use_multiple_obje_U1 = 9;
Constant I_not_sure_what_it_refers_to_U1 = 10;
Constant I_excepted_something_not_inc_U1 = 11;
Constant I_not_a_verb_i_recognise_err_U1 = 12;
Constant I_not_something_you_need_to__U1 = 13;
Constant I_can_t_see_it_at_the_moment_U1 = 14;
Constant I_didn_t_understand_the_way__U1 = 15;
Constant I_not_enough_of_those_availa_U1 = 16;
Constant I_nothing_to_do_error_U1 = 17;
Constant I_referred_to_a_determinatio_U1 = 18;
Constant I_noun_did_not_make_sense_in_U1 = 19;
Constant I_i_beg_your_pardon_error_U1 = 20;
Constant I_can_t_again_the_addressee__U1 = 21;
Constant I_comma_can_t_begin_error_U1 = 22;
Constant I_can_t_see_whom_to_talk_to__U1 = 23;
Constant I_can_t_talk_to_inanimate_th_U1 = 24;
Constant I_didn_t_understand_addresse_U1 = 25;
Constant I_brief_U1 = 1;
Constant I_verbose_U1 = 2;
Constant I_superbrief_U1 = 3;
Constant I_water_U1 = 1;
Constant I_cola_U1 = 2;
Constant I_milk_U1 = 3;
Constant I_lemonade_U1 = 4;
Constant I_iced_tea_U1 = 5;
Constant I_figure_of_hell_ride_U1 = 2;
Constant I_figure_of_ticketbooth_U1 = 3;
Constant I_figure_of_concessionstand_U1 = 4;
Constant I_figure_of_littleegyptfacad_U1 = 5;
Constant I_figure_of_littleegyptshow_U1 = 6;
Constant I_figure_of_highstriker_U1 = 7;
Constant I_figure_of_controlpanel_U1 = 8;
Constant I_figure_of_controlpanelstoc_U1 = 9;
Constant I_figure_of_controlpanelgall_U1 = 10;
Constant I_figure_of_controlpanelstak_U1 = 11;
Constant I_figure_of_controlpaneldung_U1 = 12;
Constant I_figure_of_controlpanelguil_U1 = 13;
Constant I_figure_of_controlpanelexit_U1 = 14;
Constant I_figure_of_coupon_U1 = 15;
Constant I_figure_of_maintenanceoffic_U1 = 16;
Constant I_figure_of_ferriswheel_U1 = 17;
Constant I_figure_of_bumpercars_U1 = 18;
Constant I_figure_of_fortuneteller_U1 = 19;
Constant I_figure_of_carousel_U1 = 20;
Constant I_figure_of_dimetoss_U1 = 21;
Constant I_figure_of_milkbottles_U1 = 22;
Constant I_figure_of_ridestocks_U1 = 23;
Constant I_figure_of_ridegallows_U1 = 24;
Constant I_figure_of_ridestake_U1 = 25;
Constant I_figure_of_ridedungeon_U1 = 26;
Constant I_figure_of_rideguillotine_U1 = 27;
Constant I_figure_of_rideexit_U1 = 28;
Constant I_figure_of_mercurydime_U1 = 29;
Constant I_sound_of_bell_U1 = 1;
Constant I_nondescript_U1 = 1;
Constant I_aqua_U1 = 2;
Constant I_crimson_U1 = 3;
Constant I_emerald_U1 = 4;
Constant I_gray_U1 = 5;
Constant I_indigo_U1 = 6;
Constant I_khaki_U1 = 7;
Constant I_magenta_U1 = 8;
Constant I_orange_U1 = 9;
Constant I_quartz_U1 = 10;
Constant I_weakling_U1 = 1;
Constant I_getting_stronger_U1 = 2;
Constant I_average_U1 = 3;
Constant I_almost_there_U1 = 4;
Constant I_muscle_man_U1 = 5;
Constant I_little_egypt_autoplay_U1 = 2;
Constant I_hell_ride_autoplay_U1 = 3;
Constant I_allowed_U1 = 1;
Constant I_denied_U1 = 2;
Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
Constant REPARSE_CODE = 1073741824;
Constant VERB_DIRECTIVE_META = 1;
Constant VERB_DIRECTIVE_NOUN_FILTER = 1;
Constant VERB_DIRECTIVE_SCOPE_FILTER = 1;
Constant VERB_DIRECTIVE_REVERSE = 1;
Constant VERB_DIRECTIVE_SLASH = 1;
Constant VERB_DIRECTIVE_DIVIDER = 1;
Constant VERB_DIRECTIVE_RESULT = 2;
Constant VERB_DIRECTIVE_SPECIAL = 3;
Constant VERB_DIRECTIVE_NUMBER = 4;
Constant VERB_DIRECTIVE_NOUN = 5;
Constant VERB_DIRECTIVE_MULTI = 6;
Constant VERB_DIRECTIVE_MULTIINSIDE = 7;
Constant VERB_DIRECTIVE_MULTIHELD = 8;
Constant VERB_DIRECTIVE_HELD = 9;
Constant VERB_DIRECTIVE_CREATURE = 10;
Constant VERB_DIRECTIVE_TOPIC = 11;
Constant VERB_DIRECTIVE_MULTIEXCEPT = 12;
#ifndef DICT_WORD_SIZE;
Constant DICT_WORD_SIZE = 25;
#endif;
Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DIALECT_US = 0;
Constant SERIAL_COMMA = 0;
Constant DynamicMemoryAllocation = 131072;
Constant Computed_Constant_Value_0_U1 = 4096;
Constant Computed_Constant_Value_1_U1 = 3;
Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50;
Constant USE_SCORING = 1;
Constant MATCH_LIST_WORDS = 300;
Constant DONE_INIS = 4;
Constant RELS_SYMMETRIC = 32768;
Constant RELS_EQUIVALENCE = 16384;
Constant RELS_X_UNIQUE = 8192;
Constant RELS_Y_UNIQUE = 4096;
Constant RELS_TEST = 2048;
Constant RELS_ASSERT_TRUE = 1024;
Constant RELS_ASSERT_FALSE = 512;
Constant RELS_SHOW = 256;
Constant RELS_ROUTE_FIND = 128;
Constant RELS_ROUTE_FIND_COUNT = 64;
Constant RELS_LOOKUP_ANY = 8;
Constant RELS_LOOKUP_ALL_X = 4;
Constant RELS_LOOKUP_ALL_Y = 2;
Constant RELS_LIST = 1;
Constant TTF_sum = 3584;
Constant REL_BLOCK_HEADER = 101515264;
Constant relation_id_U1 = 190;
Constant relation_id_U2 = 191;
Constant relation_id_U3 = 192;
Constant relation_id_U4 = 193;
Constant relation_id_U5 = 194;
Constant relation_id_U6 = 195;
Constant relation_id_U7 = 196;
Constant relation_id_U8 = 197;
Constant relation_id_U9 = 198;
Constant relation_id_U10 = 199;
Constant relation_id_U11 = 200;
Constant relation_id_U12 = 201;
Constant relation_id_U13 = 202;
Constant relation_id_U14 = 203;
Constant relation_id_U15 = 204;
Constant relation_id_U16 = 205;
Constant relation_id_U17 = 206;
Constant relation_id_U18 = 207;
Constant relation_id_U19 = 208;
Constant relation_id_U20 = 209;
Constant relation_id_U21 = 210;
Constant relation_id_U22 = 211;
Constant relation_id_U23 = 212;
Constant relation_id_U24 = 213;
Constant relation_id_U25 = 214;
Constant relation_id_U26 = 215;
Constant relation_id_U27 = 216;
Constant relation_id_U28 = 217;
Constant kind_ref_U1 = 561;
Constant OBJECT_TY = 52;
Constant ICOUNT_OBJECT = 305;
Constant kind_ref_U2 = 561;
Constant SCENE_TY = 53;
Constant ICOUNT_SCENE = 3;
Constant kind_ref_U3 = 561;
Constant NUMBER_TY = 54;
Constant call_U8 = DecimalNumber;
Constant kind_ref_U4 = 561;
Constant REAL_NUMBER_TY = 55;
Constant call_U11 = REAL_NUMBER_TY_Say;
Constant kind_ref_U5 = 561;
Constant TRUTH_STATE_TY = 56;
Constant kind_ref_U6 = 561;
Constant TEXT_TY = 57;
Constant kind_ref_U7 = 561;
Constant SNIPPET_TY = 58;
Constant kind_ref_U8 = 561;
Constant UNICODE_CHARACTER_TY = 59;
Constant kind_ref_U9 = 561;
Constant USE_OPTION_TY = 60;
Constant kind_ref_U10 = 561;
Constant RESPONSE_TY = 61;
Constant kind_ref_U11 = 561;
Constant VERB_TY = 62;
Constant kind_ref_U12 = 561;
Constant TABLE_TY = 63;
Constant kind_ref_U13 = 561;
Constant EQUATION_TY = 64;
Constant kind_ref_U14 = 561;
Constant RULEBOOK_OUTCOME_TY = 65;
Constant kind_ref_U15 = 561;
Constant EXTERNAL_FILE_TY = 66;
Constant ICOUNT_EXTERNAL_FILE = 0;
Constant kind_ref_U16 = 561;
Constant DESCRIPTION_OF_ACTION_TY = 67;
Constant kind_ref_U17 = 561;
Constant STORED_ACTION_TY = 68;
Constant kind_ref_U18 = 561;
Constant ACTION_NAME_TY = 69;
Constant kind_ref_U19 = 561;
Constant TIME_TY = 70;
Constant call_U30 = PrintTimeOfDay;
Constant kind_ref_U20 = 561;
Constant FIGURE_NAME_TY = 71;
Constant ICOUNT_FIGURE_NAME = 29;
Constant kind_ref_U21 = 561;
Constant SOUND_NAME_TY = 72;
Constant ICOUNT_SOUND_NAME = 1;
Constant kind_ref_U22 = 561;
Constant UNDERSTANDING_TY = 73;
Constant kind_ref_U23 = 561;
Constant LIST_OF_TY = 74;
Constant kind_ref_U24 = 561;
Constant VALUE_TY = 75;
Constant kind_ref_U25 = 561;
Constant STORED_VALUE_TY = 76;
Constant kind_ref_U26 = 561;
Constant SAYABLE_VALUE_TY = 77;
Constant kind_ref_U27 = 561;
Constant UNDERSTANDABLE_VALUE_TY = 78;
Constant kind_ref_U28 = 561;
Constant ARITHMETIC_VALUE_TY = 79;
Constant kind_ref_U29 = 561;
Constant REAL_ARITHMETIC_VALUE_TY = 80;
Constant kind_ref_U30 = 561;
Constant ENUMERATED_VALUE_TY = 81;
Constant kind_ref_U31 = 561;
Constant POINTER_VALUE_TY = 82;
Constant kind_ref_U32 = 561;
Constant PHRASE_TY = 83;
Constant kind_ref_U33 = 561;
Constant VARIABLE_TY = 84;
Constant kind_ref_U34 = 561;
Constant RELATION_TY = 85;
Constant kind_ref_U35 = 561;
Constant RULE_TY = 86;
Constant kind_ref_U36 = 561;
Constant RULEBOOK_TY = 87;
Constant kind_ref_U37 = 561;
Constant ACTIVITY_TY = 88;
Constant kind_ref_U38 = 561;
Constant DESCRIPTION_OF_TY = 89;
Constant kind_ref_U39 = 561;
Constant PROPERTY_TY = 90;
Constant kind_ref_U40 = 561;
Constant TABLE_COLUMN_TY = 91;
Constant kind_ref_U41 = 561;
Constant COMBINATION_TY = 92;
Constant kind_ref_U42 = 561;
Constant NIL_TY = 93;
Constant kind_ref_U43 = 561;
Constant UNKNOWN_TY = 94;
Constant kind_ref_U44 = 561;
Constant VOID_TY = 95;
Constant kind_ref_U45 = 561;
Constant TUPLE_ENTRY_TY = 96;
Constant property_id_U1 = 56;
Constant property_id_U2 = 57;
Constant property_id_U3 = 58;
Constant property_id_U4 = 59;
Constant property_id_U5 = 60;
Constant property_id_U6 = 61;
Constant property_id_U7 = 62;
Constant property_id_U8 = 63;
Constant property_id_U9 = 64;
Constant property_id_U10 = 65;
Constant property_id_U11 = 66;
Constant property_id_U12 = 67;
Constant property_id_U13 = 68;
Constant property_id_U14 = 69;
Constant property_id_U15 = 70;
Constant property_id_U16 = 71;
Constant property_id_U17 = 72;
Constant property_id_U18 = 73;
Constant property_id_U19 = 74;
Constant property_id_U20 = 75;
Constant property_id_U21 = 76;
Constant property_id_U22 = 77;
Constant property_id_U23 = 78;
Constant property_id_U24 = 79;
Constant property_id_U25 = 80;
Constant property_id_U26 = 81;
Constant property_id_U27 = 82;
Constant property_id_U28 = 83;
Constant property_id_U29 = 84;
Constant property_id_U30 = 85;
Constant property_id_U31 = 86;
Constant property_id_U32 = 87;
Constant property_id_U33 = 88;
Constant property_id_U34 = 89;
Constant property_id_U35 = 90;
Constant property_id_U36 = 91;
Constant property_id_U37 = 92;
Constant property_id_U38 = 93;
Constant property_id_U39 = 94;
Constant property_id_U40 = 95;
Constant property_id_U41 = 96;
Constant property_id_U42 = 97;
Constant property_id_U43 = 98;
Constant property_id_U44 = 99;
Constant property_id_U45 = 100;
Constant property_id_U46 = 101;
Constant property_id_U47 = 102;
Constant property_id_U48 = 103;
Constant property_id_U49 = 104;
Constant property_id_U50 = 105;
Constant property_id_U51 = 106;
Constant property_id_U52 = 107;
Constant property_id_U53 = 108;
Constant property_id_U54 = 109;
Constant property_id_U55 = 110;
Constant property_id_U56 = 111;
Constant property_id_U57 = 112;
Constant property_id_U58 = 113;
Constant property_id_U59 = 114;
Constant property_id_U60 = 115;
Constant property_id_U61 = 116;
Constant property_id_U62 = 117;
Constant property_id_U63 = 118;
Constant property_id_U64 = 119;
Constant property_id_U65 = 120;
Constant property_id_U66 = 121;
Constant property_id_U67 = 122;
Constant property_id_U68 = 123;
Constant property_id_U69 = 124;
Constant property_id_U70 = 125;
Constant property_id_U71 = 126;
Constant property_id_U72 = 127;
Constant property_id_U73 = 128;
Constant property_id_U74 = 129;
Constant property_id_U75 = 130;
Constant property_id_U76 = 131;
Constant property_id_U77 = 132;
Constant property_id_U78 = 133;
Constant property_id_U79 = 134;
Constant property_id_U80 = 135;
Constant property_id_U81 = 136;
Constant property_id_U82 = 137;
Constant property_id_U83 = 138;
Constant property_id_U84 = 139;
Constant property_id_U85 = 140;
Constant property_id_U86 = 141;
Constant property_id_U87 = 142;
Constant property_id_U88 = 143;
Constant property_id_U89 = 144;
Constant property_id_U90 = 145;
Constant property_id_U91 = 146;
Constant property_id_U92 = 147;
Constant property_id_U93 = 148;
Constant property_id_U94 = 149;
Constant property_id_U95 = 150;
Constant property_id_U96 = 151;
Constant property_id_U97 = 152;
Constant property_id_U98 = 153;
Constant CCOUNT_ACTION_NAME = 125;
Constant AD_RECORDS = 125;
Constant NO_PAST_TENSE_CONDS = 3;
Constant NO_PAST_TENSE_ACTIONS = 6;
Constant BASE_KIND_HWM = 97;
Constant RUCKSACK_CLASS = K15_player_s_holdall;
Constant NO_EXTERNAL_FILES = 0;
Constant CCOUNT_PROPERTY = 229;
Constant CCOUNT_BINARY_PREDICATE = 218;
Constant NUMBER_RULEBOOKS_CREATED = 453;
Constant NO_RESPONSES = 411;
Constant RANKING_TABLE = 0;
Constant NO_USE_OPTIONS = 29;
#ifndef WORDSIZE;
Constant WORDSIZE = 4;
#endif;
Constant NULL = -1;
Constant WORD_HIGHBIT = -2147483648;
Constant WORD_NEXTTOHIGHBIT = 1073741824;
Constant IMPROBABLE_VALUE = -559034863;
Constant MAX_POSITIVE_NUMBER = 2147483647;
Constant MIN_NEGATIVE_NUMBER = -2147483648;
#ifndef TARGET_GLULX;
Constant TARGET_GLULX = 1;
#endif;
#ifndef DEBUG;
Constant DEBUG = 1;
#endif;
Constant use_option_id_U1 = 0;
Constant use_option_id_U2 = 1;
Constant use_option_id_U3 = 2;
Constant use_option_id_U4 = 3;
Constant use_option_id_U5 = 4;
Constant use_option_id_U6 = 5;
Constant use_option_id_U7 = 6;
Constant use_option_id_U8 = 7;
Constant use_option_id_U9 = 8;
Constant use_option_id_U10 = 9;
Constant use_option_id_U11 = 10;
Constant use_option_id_U12 = 11;
Constant use_option_id_U13 = 12;
Constant use_option_id_U14 = 13;
Constant use_option_id_U15 = 14;
Constant use_option_id_U16 = 15;
Constant use_option_id_U17 = 16;
Constant property_id_U99 = 0;
Constant property_id_U100 = 1;
Constant property_id_U101 = 2;
Constant property_id_U102 = 3;
Constant property_id_U103 = 4;
Constant property_id_U104 = 5;
Constant property_id_U105 = 6;
Constant property_id_U106 = 7;
Constant property_id_U107 = 8;
Constant rulebook_id_U1 = 0;
Constant rulebook_id_U2 = 1;
Constant call_U195 = EMPTY_RULEBOOK;
Constant rulebook_id_U3 = 2;
Constant rulebook_id_U4 = 3;
Constant call_U197 = EMPTY_RULEBOOK;
Constant rulebook_id_U5 = 4;
Constant activity_id_U1 = 0;
Constant var_id_U1 = 10000;
Constant rulebook_id_U6 = 5;
Constant rulebook_id_U7 = 6;
Constant rulebook_id_U8 = 7;
Constant activity_id_U2 = 1;
Constant var_id_U2 = 10001;
Constant call_U201 = EMPTY_RULEBOOK;
Constant rulebook_id_U9 = 8;
Constant rulebook_id_U10 = 9;
Constant call_U203 = EMPTY_RULEBOOK;
Constant rulebook_id_U11 = 10;
Constant activity_id_U3 = 2;
Constant var_id_U3 = 10002;
Constant kind_ref_U46 = 561;
Constant WEAK_ID_47 = 2;
Constant ICOUNT_NATURAL_LANGUAGE = 6;
Constant extension_id_U1 = 1;
Constant anchor_U1 = 1105;
Constant anchor_U2 = 1105;
Constant anchor_U3 = 1105;
Constant relation_id_U29 = 0;
Constant relation_id_U30 = 1;
Constant relation_id_U31 = 2;
Constant relation_id_U32 = 3;
Constant relation_id_U33 = 4;
Constant relation_id_U34 = 5;
Constant kind_ref_U47 = 561;
Constant WEAK_ID_48 = 19;
Constant ICOUNT_GRAMMATICAL_TENSE = 5;
Constant kind_ref_U48 = 561;
Constant WEAK_ID_49 = 20;
Constant ICOUNT_NARRATIVE_VIEWPOINT = 6;
Constant kind_ref_U49 = 561;
Constant WEAK_ID_50 = 21;
Constant ICOUNT_GRAMMATICAL_CASE = 2;
Constant kind_ref_U50 = 561;
Constant WEAK_ID_51 = 22;
Constant ICOUNT_GRAMMATICAL_GENDER = 3;
Constant property_id_U108 = 40;
Constant extension_id_U2 = 2;
Constant relation_id_U35 = 118;
Constant property_id_U109 = 9;
Constant property_id_U110 = 10;
Constant property_id_U111 = 11;
Constant property_id_U112 = 12;
Constant property_id_U113 = 13;
Constant property_id_U114 = 14;
Constant property_id_U115 = 15;
Constant property_id_U116 = 16;
Constant property_id_U117 = 17;
Constant property_id_U118 = 18;
Constant property_id_U119 = 19;
Constant property_id_U120 = 20;
Constant property_id_U121 = 21;
Constant property_id_U122 = 22;
Constant property_id_U123 = 23;
Constant property_id_U124 = 24;
Constant property_id_U125 = 25;
Constant property_id_U126 = 26;
Constant property_id_U127 = 27;
Constant property_id_U128 = 28;
Constant property_id_U129 = 29;
Constant property_id_U130 = 30;
Constant property_id_U131 = 31;
Constant property_id_U132 = 32;
Constant property_id_U133 = 33;
Constant property_id_U134 = 34;
Constant property_id_U135 = 35;
Constant property_id_U136 = 36;
Constant property_id_U137 = 37;
Constant property_id_U138 = 38;
Constant property_id_U139 = 39;
Constant table_column_id_U1 = 100;
Constant table_column_id_U2 = 101;
Constant table_column_id_U3 = 102;
Constant table_column_id_U4 = 103;
Constant table_column_id_U5 = 104;
Constant table_column_id_U6 = 105;
Constant table_column_id_U7 = 106;
Constant use_option_id_U18 = 17;
Constant use_option_id_U19 = 18;
Constant use_option_id_U20 = 19;
Constant use_option_id_U21 = 20;
Constant use_option_id_U22 = 21;
Constant use_option_id_U23 = 22;
Constant use_option_id_U24 = 23;
Constant use_option_id_U25 = 24;
Constant use_option_id_U26 = 25;
Constant use_option_id_U27 = 26;
Constant use_option_id_U28 = 27;
Constant relation_id_U36 = 6;
Constant relation_id_U37 = 7;
Constant relation_id_U38 = 8;
Constant relation_id_U39 = 9;
Constant relation_id_U40 = 10;
Constant relation_id_U41 = 11;
Constant relation_id_U42 = 12;
Constant relation_id_U43 = 13;
Constant relation_id_U44 = 14;
Constant relation_id_U45 = 15;
Constant relation_id_U46 = 16;
Constant relation_id_U47 = 17;
Constant relation_id_U48 = 18;
Constant relation_id_U49 = 19;
Constant relation_id_U50 = 20;
Constant relation_id_U51 = 21;
Constant relation_id_U52 = 22;
Constant relation_id_U53 = 23;
Constant relation_id_U54 = 24;
Constant relation_id_U55 = 25;
Constant relation_id_U56 = 26;
Constant relation_id_U57 = 27;
Constant relation_id_U58 = 28;
Constant relation_id_U59 = 29;
Constant relation_id_U60 = 30;
Constant relation_id_U61 = 31;
Constant relation_id_U62 = 32;
Constant relation_id_U63 = 33;
Constant relation_id_U64 = 34;
Constant relation_id_U65 = 35;
Constant relation_id_U66 = 36;
Constant relation_id_U67 = 37;
Constant relation_id_U68 = 38;
Constant relation_id_U69 = 39;
Constant relation_id_U70 = 40;
Constant relation_id_U71 = 41;
Constant relation_id_U72 = 42;
Constant relation_id_U73 = 43;
Constant relation_id_U74 = 44;
Constant relation_id_U75 = 45;
Constant relation_id_U76 = 46;
Constant relation_id_U77 = 47;
Constant relation_id_U78 = 48;
Constant relation_id_U79 = 49;
Constant relation_id_U80 = 50;
Constant relation_id_U81 = 51;
Constant relation_id_U82 = 52;
Constant relation_id_U83 = 53;
Constant relation_id_U84 = 54;
Constant relation_id_U85 = 55;
Constant relation_id_U86 = 56;
Constant relation_id_U87 = 57;
Constant relation_id_U88 = 58;
Constant relation_id_U89 = 59;
Constant relation_id_U90 = 60;
Constant relation_id_U91 = 61;
Constant relation_id_U92 = 62;
Constant relation_id_U93 = 63;
Constant relation_id_U94 = 64;
Constant relation_id_U95 = 65;
Constant relation_id_U96 = 66;
Constant relation_id_U97 = 67;
Constant relation_id_U98 = 68;
Constant relation_id_U99 = 69;
Constant relation_id_U100 = 70;
Constant relation_id_U101 = 71;
Constant relation_id_U102 = 72;
Constant relation_id_U103 = 73;
Constant relation_id_U104 = 74;
Constant relation_id_U105 = 75;
Constant relation_id_U106 = 76;
Constant relation_id_U107 = 77;
Constant relation_id_U108 = 78;
Constant relation_id_U109 = 79;
Constant relation_id_U110 = 80;
Constant relation_id_U111 = 81;
Constant relation_id_U112 = 82;
Constant relation_id_U113 = 83;
Constant relation_id_U114 = 84;
Constant relation_id_U115 = 85;
Constant relation_id_U116 = 86;
Constant relation_id_U117 = 87;
Constant relation_id_U118 = 88;
Constant relation_id_U119 = 89;
Constant relation_id_U120 = 90;
Constant relation_id_U121 = 91;
Constant relation_id_U122 = 92;
Constant relation_id_U123 = 93;
Constant relation_id_U124 = 94;
Constant relation_id_U125 = 95;
Constant relation_id_U126 = 96;
Constant relation_id_U127 = 97;
Constant relation_id_U128 = 98;
Constant relation_id_U129 = 99;
Constant relation_id_U130 = 100;
Constant relation_id_U131 = 101;
Constant relation_id_U132 = 102;
Constant relation_id_U133 = 103;
Constant relation_id_U134 = 104;
Constant relation_id_U135 = 105;
Constant relation_id_U136 = 106;
Constant relation_id_U137 = 107;
Constant relation_id_U138 = 108;
Constant relation_id_U139 = 109;
Constant relation_id_U140 = 110;
Constant relation_id_U141 = 111;
Constant relation_id_U142 = 112;
Constant relation_id_U143 = 113;
Constant relation_id_U144 = 114;
Constant relation_id_U145 = 115;
Constant relation_id_U146 = 116;
Constant relation_id_U147 = 117;
Constant rulebook_id_U12 = 11;
Constant rulebook_id_U13 = 12;
Constant rulebook_id_U14 = 13;
Constant call_U445 = EMPTY_RULEBOOK;
Constant rulebook_id_U15 = 14;
Constant rulebook_id_U16 = 15;
Constant call_U447 = EMPTY_RULEBOOK;
Constant rulebook_id_U17 = 16;
Constant rulebook_id_U18 = 17;
Constant rulebook_id_U19 = 18;
Constant rulebook_id_U20 = 19;
Constant rulebook_id_U21 = 20;
Constant rulebook_id_U22 = 21;
Constant rulebook_id_U23 = 22;
Constant rulebook_id_U24 = 23;
Constant rulebook_id_U25 = 24;
Constant rulebook_id_U26 = 25;
Constant rulebook_id_U27 = 26;
Constant call_U460 = EMPTY_RULEBOOK;
Constant rulebook_id_U28 = 27;
Constant rulebook_id_U29 = 28;
Constant rulebook_id_U30 = 29;
Constant call_U463 = EMPTY_RULEBOOK;
Constant rulebook_id_U31 = 30;
Constant call_U464 = EMPTY_RULEBOOK;
Constant rulebook_id_U32 = 31;
Constant rulebook_id_U33 = 32;
Constant call_U466 = EMPTY_RULEBOOK;
Constant rulebook_id_U34 = 33;
Constant rulebook_id_U35 = 34;
Constant call_U468 = EMPTY_RULEBOOK;
Constant rulebook_id_U36 = 35;
Constant call_U469 = EMPTY_RULEBOOK;
Constant rulebook_id_U37 = 36;
Constant call_U470 = EMPTY_RULEBOOK;
Constant rulebook_id_U38 = 37;
Constant call_U471 = EMPTY_RULEBOOK;
Constant rulebook_id_U39 = 38;
Constant rulebook_id_U40 = 39;
Constant call_U473 = EMPTY_RULEBOOK;
Constant rulebook_id_U41 = 40;
Constant activity_id_U4 = 3;
Constant var_id_U4 = 10003;
Constant call_U474 = EMPTY_RULEBOOK;
Constant rulebook_id_U42 = 41;
Constant rulebook_id_U43 = 42;
Constant call_U476 = EMPTY_RULEBOOK;
Constant rulebook_id_U44 = 43;
Constant activity_id_U5 = 4;
Constant var_id_U5 = 10004;
Constant call_U477 = EMPTY_RULEBOOK;
Constant rulebook_id_U45 = 44;
Constant call_U478 = EMPTY_RULEBOOK;
Constant rulebook_id_U46 = 45;
Constant call_U479 = EMPTY_RULEBOOK;
Constant rulebook_id_U47 = 46;
Constant activity_id_U6 = 5;
Constant var_id_U6 = 10005;
Constant call_U480 = EMPTY_RULEBOOK;
Constant rulebook_id_U48 = 47;
Constant call_U481 = EMPTY_RULEBOOK;
Constant rulebook_id_U49 = 48;
Constant call_U482 = EMPTY_RULEBOOK;
Constant rulebook_id_U50 = 49;
Constant activity_id_U7 = 6;
Constant var_id_U7 = 10006;
Constant call_U483 = EMPTY_RULEBOOK;
Constant rulebook_id_U51 = 50;
Constant rulebook_id_U52 = 51;
Constant call_U485 = EMPTY_RULEBOOK;
Constant rulebook_id_U53 = 52;
Constant activity_id_U8 = 7;
Constant var_id_U8 = 10007;
Constant call_U486 = EMPTY_RULEBOOK;
Constant rulebook_id_U54 = 53;
Constant call_U487 = EMPTY_RULEBOOK;
Constant rulebook_id_U55 = 54;
Constant call_U488 = EMPTY_RULEBOOK;
Constant rulebook_id_U56 = 55;
Constant activity_id_U9 = 8;
Constant var_id_U9 = 10008;
Constant call_U489 = EMPTY_RULEBOOK;
Constant rulebook_id_U57 = 56;
Constant call_U490 = EMPTY_RULEBOOK;
Constant rulebook_id_U58 = 57;
Constant call_U491 = EMPTY_RULEBOOK;
Constant rulebook_id_U59 = 58;
Constant activity_id_U10 = 9;
Constant var_id_U10 = 10009;
Constant call_U492 = EMPTY_RULEBOOK;
Constant rulebook_id_U60 = 59;
Constant call_U493 = EMPTY_RULEBOOK;
Constant rulebook_id_U61 = 60;
Constant call_U494 = EMPTY_RULEBOOK;
Constant rulebook_id_U62 = 61;
Constant activity_id_U11 = 10;
Constant var_id_U11 = 10010;
Constant call_U495 = EMPTY_RULEBOOK;
Constant rulebook_id_U63 = 62;
Constant call_U496 = EMPTY_RULEBOOK;
Constant rulebook_id_U64 = 63;
Constant call_U497 = EMPTY_RULEBOOK;
Constant rulebook_id_U65 = 64;
Constant activity_id_U12 = 11;
Constant var_id_U12 = 10011;
Constant call_U498 = EMPTY_RULEBOOK;
Constant rulebook_id_U66 = 65;
Constant rulebook_id_U67 = 66;
Constant call_U500 = EMPTY_RULEBOOK;
Constant rulebook_id_U68 = 67;
Constant activity_id_U13 = 12;
Constant var_id_U13 = 10012;
Constant call_U501 = EMPTY_RULEBOOK;
Constant rulebook_id_U69 = 68;
Constant call_U502 = EMPTY_RULEBOOK;
Constant rulebook_id_U70 = 69;
Constant call_U503 = EMPTY_RULEBOOK;
Constant rulebook_id_U71 = 70;
Constant activity_id_U14 = 13;
Constant var_id_U14 = 10013;
Constant call_U504 = EMPTY_RULEBOOK;
Constant rulebook_id_U72 = 71;
Constant rulebook_id_U73 = 72;
Constant call_U506 = EMPTY_RULEBOOK;
Constant rulebook_id_U74 = 73;
Constant activity_id_U15 = 14;
Constant var_id_U15 = 10014;
Constant call_U507 = EMPTY_RULEBOOK;
Constant rulebook_id_U75 = 74;
Constant rulebook_id_U76 = 75;
Constant call_U509 = EMPTY_RULEBOOK;
Constant rulebook_id_U77 = 76;
Constant activity_id_U16 = 15;
Constant var_id_U16 = 10015;
Constant call_U510 = EMPTY_RULEBOOK;
Constant rulebook_id_U78 = 77;
Constant rulebook_id_U79 = 78;
Constant call_U512 = EMPTY_RULEBOOK;
Constant rulebook_id_U80 = 79;
Constant activity_id_U17 = 16;
Constant var_id_U17 = 10016;
Constant call_U513 = EMPTY_RULEBOOK;
Constant rulebook_id_U81 = 80;
Constant call_U514 = EMPTY_RULEBOOK;
Constant rulebook_id_U82 = 81;
Constant call_U515 = EMPTY_RULEBOOK;
Constant rulebook_id_U83 = 82;
Constant activity_id_U18 = 17;
Constant var_id_U18 = 10017;
Constant call_U516 = EMPTY_RULEBOOK;
Constant rulebook_id_U84 = 83;
Constant call_U517 = EMPTY_RULEBOOK;
Constant rulebook_id_U85 = 84;
Constant rulebook_id_U86 = 85;
Constant activity_id_U19 = 18;
Constant var_id_U19 = 10018;
Constant call_U519 = EMPTY_RULEBOOK;
Constant rulebook_id_U87 = 86;
Constant call_U520 = EMPTY_RULEBOOK;
Constant rulebook_id_U88 = 87;
Constant call_U521 = EMPTY_RULEBOOK;
Constant rulebook_id_U89 = 88;
Constant activity_id_U20 = 19;
Constant var_id_U20 = 10019;
Constant call_U522 = EMPTY_RULEBOOK;
Constant rulebook_id_U90 = 89;
Constant call_U523 = EMPTY_RULEBOOK;
Constant rulebook_id_U91 = 90;
Constant call_U524 = EMPTY_RULEBOOK;
Constant rulebook_id_U92 = 91;
Constant activity_id_U21 = 20;
Constant var_id_U21 = 10020;
Constant call_U525 = EMPTY_RULEBOOK;
Constant rulebook_id_U93 = 92;
Constant rulebook_id_U94 = 93;
Constant call_U527 = EMPTY_RULEBOOK;
Constant rulebook_id_U95 = 94;
Constant activity_id_U22 = 21;
Constant var_id_U22 = 10021;
Constant call_U528 = EMPTY_RULEBOOK;
Constant rulebook_id_U96 = 95;
Constant call_U529 = EMPTY_RULEBOOK;
Constant rulebook_id_U97 = 96;
Constant call_U530 = EMPTY_RULEBOOK;
Constant rulebook_id_U98 = 97;
Constant activity_id_U23 = 22;
Constant var_id_U23 = 10022;
Constant call_U531 = EMPTY_RULEBOOK;
Constant rulebook_id_U99 = 98;
Constant call_U532 = EMPTY_RULEBOOK;
Constant rulebook_id_U100 = 99;
Constant call_U533 = EMPTY_RULEBOOK;
Constant rulebook_id_U101 = 100;
Constant activity_id_U24 = 23;
Constant var_id_U24 = 10023;
Constant call_U534 = EMPTY_RULEBOOK;
Constant rulebook_id_U102 = 101;
Constant call_U535 = EMPTY_RULEBOOK;
Constant rulebook_id_U103 = 102;
Constant call_U536 = EMPTY_RULEBOOK;
Constant rulebook_id_U104 = 103;
Constant activity_id_U25 = 24;
Constant var_id_U25 = 10024;
Constant call_U537 = EMPTY_RULEBOOK;
Constant rulebook_id_U105 = 104;
Constant rulebook_id_U106 = 105;
Constant call_U539 = EMPTY_RULEBOOK;
Constant rulebook_id_U107 = 106;
Constant activity_id_U26 = 25;
Constant var_id_U26 = 10025;
Constant call_U540 = EMPTY_RULEBOOK;
Constant rulebook_id_U108 = 107;
Constant call_U541 = EMPTY_RULEBOOK;
Constant rulebook_id_U109 = 108;
Constant call_U542 = EMPTY_RULEBOOK;
Constant rulebook_id_U110 = 109;
Constant activity_id_U27 = 26;
Constant var_id_U27 = 10026;
Constant call_U543 = EMPTY_RULEBOOK;
Constant rulebook_id_U111 = 110;
Constant rulebook_id_U112 = 111;
Constant call_U545 = EMPTY_RULEBOOK;
Constant rulebook_id_U113 = 112;
Constant activity_id_U28 = 27;
Constant var_id_U28 = 10027;
Constant call_U546 = EMPTY_RULEBOOK;
Constant rulebook_id_U114 = 113;
Constant call_U547 = EMPTY_RULEBOOK;
Constant rulebook_id_U115 = 114;
Constant call_U548 = EMPTY_RULEBOOK;
Constant rulebook_id_U116 = 115;
Constant activity_id_U29 = 28;
Constant var_id_U29 = 10028;
Constant call_U549 = EMPTY_RULEBOOK;
Constant rulebook_id_U117 = 116;
Constant rulebook_id_U118 = 117;
Constant rulebook_id_U119 = 118;
Constant activity_id_U30 = 29;
Constant var_id_U30 = 10029;
Constant rulebook_id_U120 = 119;
Constant rulebook_id_U121 = 120;
Constant call_U554 = EMPTY_RULEBOOK;
Constant rulebook_id_U122 = 121;
Constant activity_id_U31 = 30;
Constant var_id_U31 = 10030;
Constant rulebook_id_U123 = 122;
Constant rulebook_id_U124 = 123;
Constant call_U557 = EMPTY_RULEBOOK;
Constant rulebook_id_U125 = 124;
Constant activity_id_U32 = 31;
Constant var_id_U32 = 10031;
Constant call_U558 = EMPTY_RULEBOOK;
Constant rulebook_id_U126 = 125;
Constant rulebook_id_U127 = 126;
Constant call_U560 = EMPTY_RULEBOOK;
Constant rulebook_id_U128 = 127;
Constant activity_id_U33 = 32;
Constant var_id_U33 = 10032;
Constant call_U561 = EMPTY_RULEBOOK;
Constant rulebook_id_U129 = 128;
Constant rulebook_id_U130 = 129;
Constant call_U563 = EMPTY_RULEBOOK;
Constant rulebook_id_U131 = 130;
Constant activity_id_U34 = 33;
Constant var_id_U34 = 10033;
Constant call_U564 = EMPTY_RULEBOOK;
Constant rulebook_id_U132 = 131;
Constant rulebook_id_U133 = 132;
Constant rulebook_id_U134 = 133;
Constant action_id_U1 = 0;
Constant var_id_U35 = 20000;
Constant rulebook_id_U135 = 134;
Constant rulebook_id_U136 = 135;
Constant rulebook_id_U137 = 136;
Constant action_id_U2 = 1;
Constant var_id_U36 = 20001;
Constant rulebook_id_U138 = 137;
Constant call_U572 = EMPTY_RULEBOOK;
Constant rulebook_id_U139 = 138;
Constant call_U573 = EMPTY_RULEBOOK;
Constant rulebook_id_U140 = 139;
Constant action_id_U3 = 2;
Constant var_id_U37 = 20002;
Constant rulebook_id_U141 = 140;
Constant rulebook_id_U142 = 141;
Constant rulebook_id_U143 = 142;
Constant action_id_U4 = 3;
Constant var_id_U38 = 20003;
Constant rulebook_id_U144 = 143;
Constant rulebook_id_U145 = 144;
Constant rulebook_id_U146 = 145;
Constant action_id_U5 = 4;
Constant var_id_U39 = 20004;
Constant rulebook_id_U147 = 146;
Constant rulebook_id_U148 = 147;
Constant rulebook_id_U149 = 148;
Constant action_id_U6 = 5;
Constant var_id_U40 = 20005;
Constant rulebook_id_U150 = 149;
Constant rulebook_id_U151 = 150;
Constant rulebook_id_U152 = 151;
Constant action_id_U7 = 6;
Constant var_id_U41 = 20006;
Constant rulebook_id_U153 = 152;
Constant rulebook_id_U154 = 153;
Constant rulebook_id_U155 = 154;
Constant action_id_U8 = 7;
Constant var_id_U42 = 20007;
Constant rulebook_id_U156 = 155;
Constant rulebook_id_U157 = 156;
Constant rulebook_id_U158 = 157;
Constant action_id_U9 = 8;
Constant var_id_U43 = 20008;
Constant rulebook_id_U159 = 158;
Constant rulebook_id_U160 = 159;
Constant rulebook_id_U161 = 160;
Constant action_id_U10 = 9;
Constant var_id_U44 = 20009;
Constant rulebook_id_U162 = 161;
Constant rulebook_id_U163 = 162;
Constant rulebook_id_U164 = 163;
Constant action_id_U11 = 10;
Constant var_id_U45 = 20010;
Constant call_U600 = EMPTY_RULEBOOK;
Constant rulebook_id_U165 = 164;
Constant rulebook_id_U166 = 165;
Constant rulebook_id_U167 = 166;
Constant action_id_U12 = 11;
Constant var_id_U46 = 20011;
Constant call_U604 = EMPTY_RULEBOOK;
Constant rulebook_id_U168 = 167;
Constant rulebook_id_U169 = 168;
Constant rulebook_id_U170 = 169;
Constant action_id_U13 = 12;
Constant var_id_U47 = 20012;
Constant call_U608 = EMPTY_RULEBOOK;
Constant rulebook_id_U171 = 170;
Constant rulebook_id_U172 = 171;
Constant rulebook_id_U173 = 172;
Constant action_id_U14 = 13;
Constant var_id_U48 = 20013;
Constant rulebook_id_U174 = 173;
Constant call_U612 = EMPTY_RULEBOOK;
Constant rulebook_id_U175 = 174;
Constant rulebook_id_U176 = 175;
Constant action_id_U15 = 14;
Constant var_id_U49 = 20014;
Constant call_U614 = EMPTY_RULEBOOK;
Constant rulebook_id_U177 = 176;
Constant call_U615 = EMPTY_RULEBOOK;
Constant rulebook_id_U178 = 177;
Constant rulebook_id_U179 = 178;
Constant action_id_U16 = 15;
Constant var_id_U50 = 20015;
Constant rulebook_id_U180 = 179;
Constant rulebook_id_U181 = 180;
Constant rulebook_id_U182 = 181;
Constant action_id_U17 = 16;
Constant var_id_U51 = 20016;
Constant rulebook_id_U183 = 182;
Constant rulebook_id_U184 = 183;
Constant rulebook_id_U185 = 184;
Constant action_id_U18 = 17;
Constant var_id_U52 = 20017;
Constant rulebook_id_U186 = 185;
Constant rulebook_id_U187 = 186;
Constant rulebook_id_U188 = 187;
Constant action_id_U19 = 18;
Constant var_id_U53 = 20018;
Constant rulebook_id_U189 = 188;
Constant rulebook_id_U190 = 189;
Constant rulebook_id_U191 = 190;
Constant action_id_U20 = 19;
Constant var_id_U54 = 20019;
Constant rulebook_id_U192 = 191;
Constant rulebook_id_U193 = 192;
Constant rulebook_id_U194 = 193;
Constant action_id_U21 = 20;
Constant var_id_U55 = 20020;
Constant rulebook_id_U195 = 194;
Constant rulebook_id_U196 = 195;
Constant rulebook_id_U197 = 196;
Constant action_id_U22 = 21;
Constant var_id_U56 = 20021;
Constant rulebook_id_U198 = 197;
Constant rulebook_id_U199 = 198;
Constant rulebook_id_U200 = 199;
Constant action_id_U23 = 22;
Constant var_id_U57 = 20022;
Constant rulebook_id_U201 = 200;
Constant rulebook_id_U202 = 201;
Constant rulebook_id_U203 = 202;
Constant action_id_U24 = 23;
Constant var_id_U58 = 20023;
Constant rulebook_id_U204 = 203;
Constant rulebook_id_U205 = 204;
Constant rulebook_id_U206 = 205;
Constant action_id_U25 = 24;
Constant var_id_U59 = 20024;
Constant rulebook_id_U207 = 206;
Constant call_U645 = EMPTY_RULEBOOK;
Constant rulebook_id_U208 = 207;
Constant call_U646 = EMPTY_RULEBOOK;
Constant rulebook_id_U209 = 208;
Constant action_id_U26 = 25;
Constant var_id_U60 = 20025;
Constant rulebook_id_U210 = 209;
Constant call_U648 = EMPTY_RULEBOOK;
Constant rulebook_id_U211 = 210;
Constant call_U649 = EMPTY_RULEBOOK;
Constant rulebook_id_U212 = 211;
Constant action_id_U27 = 26;
Constant var_id_U61 = 20026;
Constant rulebook_id_U213 = 212;
Constant call_U651 = EMPTY_RULEBOOK;
Constant rulebook_id_U214 = 213;
Constant call_U652 = EMPTY_RULEBOOK;
Constant rulebook_id_U215 = 214;
Constant action_id_U28 = 27;
Constant var_id_U62 = 20027;
Constant rulebook_id_U216 = 215;
Constant call_U654 = EMPTY_RULEBOOK;
Constant rulebook_id_U217 = 216;
Constant call_U655 = EMPTY_RULEBOOK;
Constant rulebook_id_U218 = 217;
Constant action_id_U29 = 28;
Constant var_id_U63 = 20028;
Constant rulebook_id_U219 = 218;
Constant call_U657 = EMPTY_RULEBOOK;
Constant rulebook_id_U220 = 219;
Constant call_U658 = EMPTY_RULEBOOK;
Constant rulebook_id_U221 = 220;
Constant action_id_U30 = 29;
Constant var_id_U64 = 20029;
Constant call_U659 = EMPTY_RULEBOOK;
Constant rulebook_id_U222 = 221;
Constant call_U660 = EMPTY_RULEBOOK;
Constant rulebook_id_U223 = 222;
Constant rulebook_id_U224 = 223;
Constant action_id_U31 = 30;
Constant var_id_U65 = 20030;
Constant rulebook_id_U225 = 224;
Constant call_U663 = EMPTY_RULEBOOK;
Constant rulebook_id_U226 = 225;
Constant rulebook_id_U227 = 226;
Constant action_id_U32 = 31;
Constant var_id_U66 = 20031;
Constant call_U665 = EMPTY_RULEBOOK;
Constant rulebook_id_U228 = 227;
Constant call_U666 = EMPTY_RULEBOOK;
Constant rulebook_id_U229 = 228;
Constant rulebook_id_U230 = 229;
Constant action_id_U33 = 32;
Constant var_id_U67 = 20032;
Constant rulebook_id_U231 = 230;
Constant call_U669 = EMPTY_RULEBOOK;
Constant rulebook_id_U232 = 231;
Constant call_U670 = EMPTY_RULEBOOK;
Constant rulebook_id_U233 = 232;
Constant action_id_U34 = 33;
Constant var_id_U68 = 20033;
Constant call_U671 = EMPTY_RULEBOOK;
Constant rulebook_id_U234 = 233;
Constant call_U672 = EMPTY_RULEBOOK;
Constant rulebook_id_U235 = 234;
Constant rulebook_id_U236 = 235;
Constant action_id_U35 = 34;
Constant var_id_U69 = 20034;
Constant call_U674 = EMPTY_RULEBOOK;
Constant rulebook_id_U237 = 236;
Constant call_U675 = EMPTY_RULEBOOK;
Constant rulebook_id_U238 = 237;
Constant rulebook_id_U239 = 238;
Constant action_id_U36 = 35;
Constant var_id_U70 = 20035;
Constant rulebook_id_U240 = 239;
Constant call_U678 = EMPTY_RULEBOOK;
Constant rulebook_id_U241 = 240;
Constant rulebook_id_U242 = 241;
Constant action_id_U37 = 36;
Constant var_id_U71 = 20036;
Constant rulebook_id_U243 = 242;
Constant call_U681 = EMPTY_RULEBOOK;
Constant rulebook_id_U244 = 243;
Constant rulebook_id_U245 = 244;
Constant action_id_U38 = 37;
Constant var_id_U72 = 20037;
Constant rulebook_id_U246 = 245;
Constant call_U684 = EMPTY_RULEBOOK;
Constant rulebook_id_U247 = 246;
Constant rulebook_id_U248 = 247;
Constant action_id_U39 = 38;
Constant var_id_U73 = 20038;
Constant rulebook_id_U249 = 248;
Constant call_U687 = EMPTY_RULEBOOK;
Constant rulebook_id_U250 = 249;
Constant rulebook_id_U251 = 250;
Constant action_id_U40 = 39;
Constant var_id_U74 = 20039;
Constant rulebook_id_U252 = 251;
Constant call_U690 = EMPTY_RULEBOOK;
Constant rulebook_id_U253 = 252;
Constant call_U691 = EMPTY_RULEBOOK;
Constant rulebook_id_U254 = 253;
Constant action_id_U41 = 40;
Constant var_id_U75 = 20040;
Constant rulebook_id_U255 = 254;
Constant call_U693 = EMPTY_RULEBOOK;
Constant rulebook_id_U256 = 255;
Constant rulebook_id_U257 = 256;
Constant action_id_U42 = 41;
Constant var_id_U76 = 20041;
Constant rulebook_id_U258 = 257;
Constant call_U696 = EMPTY_RULEBOOK;
Constant rulebook_id_U259 = 258;
Constant call_U697 = EMPTY_RULEBOOK;
Constant rulebook_id_U260 = 259;
Constant action_id_U43 = 42;
Constant var_id_U77 = 20042;
Constant rulebook_id_U261 = 260;
Constant call_U699 = EMPTY_RULEBOOK;
Constant rulebook_id_U262 = 261;
Constant call_U700 = EMPTY_RULEBOOK;
Constant rulebook_id_U263 = 262;
Constant action_id_U44 = 43;
Constant var_id_U78 = 20043;
Constant rulebook_id_U264 = 263;
Constant call_U702 = EMPTY_RULEBOOK;
Constant rulebook_id_U265 = 264;
Constant call_U703 = EMPTY_RULEBOOK;
Constant rulebook_id_U266 = 265;
Constant action_id_U45 = 44;
Constant var_id_U79 = 20044;
Constant rulebook_id_U267 = 266;
Constant call_U705 = EMPTY_RULEBOOK;
Constant rulebook_id_U268 = 267;
Constant call_U706 = EMPTY_RULEBOOK;
Constant rulebook_id_U269 = 268;
Constant action_id_U46 = 45;
Constant var_id_U80 = 20045;
Constant rulebook_id_U270 = 269;
Constant call_U708 = EMPTY_RULEBOOK;
Constant rulebook_id_U271 = 270;
Constant call_U709 = EMPTY_RULEBOOK;
Constant rulebook_id_U272 = 271;
Constant action_id_U47 = 46;
Constant var_id_U81 = 20046;
Constant call_U710 = EMPTY_RULEBOOK;
Constant rulebook_id_U273 = 272;
Constant call_U711 = EMPTY_RULEBOOK;
Constant rulebook_id_U274 = 273;
Constant rulebook_id_U275 = 274;
Constant action_id_U48 = 47;
Constant var_id_U82 = 20047;
Constant call_U713 = EMPTY_RULEBOOK;
Constant rulebook_id_U276 = 275;
Constant call_U714 = EMPTY_RULEBOOK;
Constant rulebook_id_U277 = 276;
Constant rulebook_id_U278 = 277;
Constant action_id_U49 = 48;
Constant var_id_U83 = 20048;
Constant call_U716 = EMPTY_RULEBOOK;
Constant rulebook_id_U279 = 278;
Constant call_U717 = EMPTY_RULEBOOK;
Constant rulebook_id_U280 = 279;
Constant rulebook_id_U281 = 280;
Constant action_id_U50 = 49;
Constant var_id_U84 = 20049;
Constant rulebook_id_U282 = 281;
Constant call_U720 = EMPTY_RULEBOOK;
Constant rulebook_id_U283 = 282;
Constant call_U721 = EMPTY_RULEBOOK;
Constant rulebook_id_U284 = 283;
Constant action_id_U51 = 50;
Constant var_id_U85 = 20050;
Constant call_U722 = EMPTY_RULEBOOK;
Constant rulebook_id_U285 = 284;
Constant call_U723 = EMPTY_RULEBOOK;
Constant rulebook_id_U286 = 285;
Constant rulebook_id_U287 = 286;
Constant action_id_U52 = 51;
Constant var_id_U86 = 20051;
Constant rulebook_id_U288 = 287;
Constant call_U726 = EMPTY_RULEBOOK;
Constant rulebook_id_U289 = 288;
Constant call_U727 = EMPTY_RULEBOOK;
Constant rulebook_id_U290 = 289;
Constant action_id_U53 = 52;
Constant var_id_U87 = 20052;
Constant rulebook_id_U291 = 290;
Constant call_U729 = EMPTY_RULEBOOK;
Constant rulebook_id_U292 = 291;
Constant call_U730 = EMPTY_RULEBOOK;
Constant rulebook_id_U293 = 292;
Constant action_id_U54 = 53;
Constant var_id_U88 = 20053;
Constant rulebook_id_U294 = 293;
Constant call_U732 = EMPTY_RULEBOOK;
Constant rulebook_id_U295 = 294;
Constant call_U733 = EMPTY_RULEBOOK;
Constant rulebook_id_U296 = 295;
Constant action_id_U55 = 54;
Constant var_id_U89 = 20054;
Constant rulebook_id_U297 = 296;
Constant call_U735 = EMPTY_RULEBOOK;
Constant rulebook_id_U298 = 297;
Constant call_U736 = EMPTY_RULEBOOK;
Constant rulebook_id_U299 = 298;
Constant action_id_U56 = 55;
Constant var_id_U90 = 20055;
Constant rulebook_id_U300 = 299;
Constant call_U738 = EMPTY_RULEBOOK;
Constant rulebook_id_U301 = 300;
Constant rulebook_id_U302 = 301;
Constant action_id_U57 = 56;
Constant var_id_U91 = 20056;
Constant rulebook_id_U303 = 302;
Constant call_U741 = EMPTY_RULEBOOK;
Constant rulebook_id_U304 = 303;
Constant call_U742 = EMPTY_RULEBOOK;
Constant rulebook_id_U305 = 304;
Constant action_id_U58 = 57;
Constant var_id_U92 = 20057;
Constant call_U743 = EMPTY_RULEBOOK;
Constant rulebook_id_U306 = 305;
Constant call_U744 = EMPTY_RULEBOOK;
Constant rulebook_id_U307 = 306;
Constant rulebook_id_U308 = 307;
Constant action_id_U59 = 58;
Constant var_id_U93 = 20058;
Constant rulebook_id_U309 = 308;
Constant call_U747 = EMPTY_RULEBOOK;
Constant rulebook_id_U310 = 309;
Constant call_U748 = EMPTY_RULEBOOK;
Constant rulebook_id_U311 = 310;
Constant action_id_U60 = 59;
Constant var_id_U94 = 20059;
Constant rulebook_id_U312 = 311;
Constant call_U750 = EMPTY_RULEBOOK;
Constant rulebook_id_U313 = 312;
Constant call_U751 = EMPTY_RULEBOOK;
Constant rulebook_id_U314 = 313;
Constant action_id_U61 = 60;
Constant var_id_U95 = 20060;
Constant rulebook_id_U315 = 314;
Constant call_U753 = EMPTY_RULEBOOK;
Constant rulebook_id_U316 = 315;
Constant call_U754 = EMPTY_RULEBOOK;
Constant rulebook_id_U317 = 316;
Constant action_id_U62 = 61;
Constant var_id_U96 = 20061;
Constant call_U755 = EMPTY_RULEBOOK;
Constant rulebook_id_U318 = 317;
Constant rulebook_id_U319 = 318;
Constant call_U757 = EMPTY_RULEBOOK;
Constant rulebook_id_U320 = 319;
Constant action_id_U63 = 62;
Constant var_id_U97 = 20062;
Constant call_U758 = EMPTY_RULEBOOK;
Constant rulebook_id_U321 = 320;
Constant rulebook_id_U322 = 321;
Constant call_U760 = EMPTY_RULEBOOK;
Constant rulebook_id_U323 = 322;
Constant action_id_U64 = 63;
Constant var_id_U98 = 20063;
Constant call_U761 = EMPTY_RULEBOOK;
Constant rulebook_id_U324 = 323;
Constant rulebook_id_U325 = 324;
Constant call_U763 = EMPTY_RULEBOOK;
Constant rulebook_id_U326 = 325;
Constant action_id_U65 = 64;
Constant var_id_U99 = 20064;
Constant call_U764 = EMPTY_RULEBOOK;
Constant rulebook_id_U327 = 326;
Constant rulebook_id_U328 = 327;
Constant call_U766 = EMPTY_RULEBOOK;
Constant rulebook_id_U329 = 328;
Constant action_id_U66 = 65;
Constant var_id_U100 = 20065;
Constant call_U767 = EMPTY_RULEBOOK;
Constant rulebook_id_U330 = 329;
Constant rulebook_id_U331 = 330;
Constant call_U769 = EMPTY_RULEBOOK;
Constant rulebook_id_U332 = 331;
Constant action_id_U67 = 66;
Constant var_id_U101 = 20066;
Constant call_U770 = EMPTY_RULEBOOK;
Constant rulebook_id_U333 = 332;
Constant rulebook_id_U334 = 333;
Constant call_U772 = EMPTY_RULEBOOK;
Constant rulebook_id_U335 = 334;
Constant action_id_U68 = 67;
Constant var_id_U102 = 20067;
Constant call_U773 = EMPTY_RULEBOOK;
Constant rulebook_id_U336 = 335;
Constant rulebook_id_U337 = 336;
Constant call_U775 = EMPTY_RULEBOOK;
Constant rulebook_id_U338 = 337;
Constant action_id_U69 = 68;
Constant var_id_U103 = 20068;
Constant call_U776 = EMPTY_RULEBOOK;
Constant rulebook_id_U339 = 338;
Constant rulebook_id_U340 = 339;
Constant call_U778 = EMPTY_RULEBOOK;
Constant rulebook_id_U341 = 340;
Constant action_id_U70 = 69;
Constant var_id_U104 = 20069;
Constant rulebook_id_U342 = 341;
Constant rulebook_id_U343 = 342;
Constant call_U781 = EMPTY_RULEBOOK;
Constant rulebook_id_U344 = 343;
Constant action_id_U71 = 70;
Constant var_id_U105 = 20070;
Constant call_U782 = EMPTY_RULEBOOK;
Constant rulebook_id_U345 = 344;
Constant rulebook_id_U346 = 345;
Constant rulebook_id_U347 = 346;
Constant action_id_U72 = 71;
Constant var_id_U106 = 20071;
Constant call_U785 = EMPTY_RULEBOOK;
Constant rulebook_id_U348 = 347;
Constant rulebook_id_U349 = 348;
Constant rulebook_id_U350 = 349;
Constant action_id_U73 = 72;
Constant var_id_U107 = 20072;
Constant call_U788 = EMPTY_RULEBOOK;
Constant rulebook_id_U351 = 350;
Constant rulebook_id_U352 = 351;
Constant rulebook_id_U353 = 352;
Constant action_id_U74 = 73;
Constant var_id_U108 = 20073;
Constant call_U791 = EMPTY_RULEBOOK;
Constant rulebook_id_U354 = 353;
Constant rulebook_id_U355 = 354;
Constant rulebook_id_U356 = 355;
Constant action_id_U75 = 74;
Constant var_id_U109 = 20074;
Constant call_U794 = EMPTY_RULEBOOK;
Constant rulebook_id_U357 = 356;
Constant rulebook_id_U358 = 357;
Constant rulebook_id_U359 = 358;
Constant action_id_U76 = 75;
Constant var_id_U110 = 20075;
Constant call_U797 = EMPTY_RULEBOOK;
Constant rulebook_id_U360 = 359;
Constant rulebook_id_U361 = 360;
Constant call_U799 = EMPTY_RULEBOOK;
Constant rulebook_id_U362 = 361;
Constant action_id_U77 = 76;
Constant var_id_U111 = 20076;
Constant response_id_U1 = 1;
Constant anchor_U4 = 1105;
Constant response_id_U2 = 2;
Constant response_id_U3 = 3;
Constant anchor_U5 = 1105;
Constant response_id_U4 = 4;
Constant anchor_U6 = 1105;
Constant response_id_U5 = 5;
Constant anchor_U7 = 1105;
Constant response_id_U6 = 6;
Constant anchor_U8 = 1105;
Constant response_id_U7 = 7;
Constant anchor_U9 = 1105;
Constant response_id_U8 = 8;
Constant anchor_U10 = 1105;
Constant response_id_U9 = 9;
Constant anchor_U11 = 1105;
Constant response_id_U10 = 10;
Constant anchor_U12 = 1105;
Constant response_id_U11 = 11;
Constant anchor_U13 = 1105;
Constant response_id_U12 = 12;
Constant response_id_U13 = 13;
Constant response_id_U14 = 14;
Constant response_id_U15 = 15;
Constant response_id_U16 = 16;
Constant response_id_U17 = 17;
Constant response_id_U18 = 18;
Constant response_id_U19 = 19;
Constant response_id_U20 = 20;
Constant response_id_U21 = 21;
Constant response_id_U22 = 22;
Constant response_id_U23 = 23;
Constant response_id_U24 = 24;
Constant response_id_U25 = 25;
Constant response_id_U26 = 26;
Constant response_id_U27 = 27;
Constant response_id_U28 = 28;
Constant response_id_U29 = 29;
Constant response_id_U30 = 30;
Constant response_id_U31 = 31;
Constant response_id_U32 = 32;
Constant response_id_U33 = 33;
Constant response_id_U34 = 34;
Constant response_id_U35 = 35;
Constant response_id_U36 = 36;
Constant anchor_U14 = 1105;
Constant response_id_U37 = 37;
Constant response_id_U38 = 38;
Constant response_id_U39 = 39;
Constant response_id_U40 = 40;
Constant response_id_U41 = 41;
Constant response_id_U42 = 42;
Constant response_id_U43 = 43;
Constant response_id_U44 = 44;
Constant response_id_U45 = 45;
Constant response_id_U46 = 46;
Constant response_id_U47 = 47;
Constant anchor_U15 = 1105;
Constant response_id_U48 = 48;
Constant response_id_U49 = 49;
Constant response_id_U50 = 50;
Constant response_id_U51 = 51;
Constant response_id_U52 = 52;
Constant response_id_U53 = 53;
Constant response_id_U54 = 54;
Constant response_id_U55 = 55;
Constant response_id_U56 = 56;
Constant response_id_U57 = 57;
Constant response_id_U58 = 58;
Constant response_id_U59 = 59;
Constant response_id_U60 = 60;
Constant response_id_U61 = 61;
Constant response_id_U62 = 62;
Constant response_id_U63 = 63;
Constant response_id_U64 = 64;
Constant response_id_U65 = 65;
Constant response_id_U66 = 66;
Constant response_id_U67 = 67;
Constant response_id_U68 = 68;
Constant response_id_U69 = 69;
Constant response_id_U70 = 70;
Constant response_id_U71 = 71;
Constant anchor_U16 = 1105;
Constant response_id_U72 = 72;
Constant response_id_U73 = 73;
Constant response_id_U74 = 74;
Constant response_id_U75 = 75;
Constant response_id_U76 = 76;
Constant response_id_U77 = 77;
Constant anchor_U17 = 1105;
Constant response_id_U78 = 78;
Constant anchor_U18 = 1105;
Constant response_id_U79 = 79;
Constant response_id_U80 = 80;
Constant response_id_U81 = 81;
Constant response_id_U82 = 82;
Constant anchor_U19 = 1105;
Constant response_id_U83 = 83;
Constant response_id_U84 = 84;
Constant response_id_U85 = 85;
Constant response_id_U86 = 86;
Constant response_id_U87 = 87;
Constant response_id_U88 = 88;
Constant response_id_U89 = 89;
Constant response_id_U90 = 90;
Constant anchor_U20 = 1105;
Constant response_id_U91 = 91;
Constant anchor_U21 = 1105;
Constant response_id_U92 = 92;
Constant response_id_U93 = 93;
Constant response_id_U94 = 94;
Constant anchor_U22 = 1105;
Constant response_id_U95 = 95;
Constant response_id_U96 = 96;
Constant anchor_U23 = 1105;
Constant response_id_U97 = 97;
Constant response_id_U98 = 98;
Constant response_id_U99 = 99;
Constant anchor_U24 = 1105;
Constant response_id_U100 = 100;
Constant response_id_U101 = 101;
Constant response_id_U102 = 102;
Constant response_id_U103 = 103;
Constant response_id_U104 = 104;
Constant response_id_U105 = 105;
Constant anchor_U25 = 1105;
Constant response_id_U106 = 106;
Constant anchor_U26 = 1105;
Constant response_id_U107 = 107;
Constant response_id_U108 = 108;
Constant anchor_U27 = 1105;
Constant response_id_U109 = 109;
Constant response_id_U110 = 110;
Constant anchor_U28 = 1105;
Constant response_id_U111 = 111;
Constant response_id_U112 = 112;
Constant anchor_U29 = 1105;
Constant response_id_U113 = 113;
Constant response_id_U114 = 114;
Constant anchor_U30 = 1105;
Constant response_id_U115 = 115;
Constant response_id_U116 = 116;
Constant response_id_U117 = 117;
Constant anchor_U31 = 1105;
Constant response_id_U118 = 118;
Constant response_id_U119 = 119;
Constant response_id_U120 = 120;
Constant anchor_U32 = 1105;
Constant response_id_U121 = 121;
Constant response_id_U122 = 122;
Constant response_id_U123 = 123;
Constant response_id_U124 = 124;
Constant response_id_U125 = 125;
Constant anchor_U33 = 1105;
Constant response_id_U126 = 126;
Constant anchor_U34 = 1105;
Constant response_id_U127 = 127;
Constant anchor_U35 = 1105;
Constant response_id_U128 = 128;
Constant anchor_U36 = 1105;
Constant response_id_U129 = 129;
Constant anchor_U37 = 1105;
Constant response_id_U130 = 130;
Constant anchor_U38 = 1105;
Constant response_id_U131 = 131;
Constant response_id_U132 = 132;
Constant response_id_U133 = 133;
Constant response_id_U134 = 134;
Constant anchor_U39 = 1105;
Constant anchor_U40 = 1105;
Constant anchor_U41 = 1105;
Constant anchor_U42 = 1105;
Constant anchor_U43 = 1105;
Constant anchor_U44 = 1105;
Constant anchor_U45 = 1105;
Constant anchor_U46 = 1105;
Constant anchor_U47 = 1105;
Constant anchor_U48 = 1105;
Constant anchor_U49 = 1105;
Constant anchor_U50 = 1105;
Constant anchor_U51 = 1105;
Constant anchor_U52 = 1105;
Constant anchor_U53 = 1105;
Constant response_id_U135 = 135;
Constant anchor_U54 = 1105;
Constant anchor_U55 = 1105;
Constant anchor_U56 = 1105;
Constant anchor_U57 = 1105;
Constant anchor_U58 = 1105;
Constant anchor_U59 = 1105;
Constant anchor_U60 = 1105;
Constant anchor_U61 = 1105;
Constant anchor_U62 = 1105;
Constant anchor_U63 = 1105;
Constant anchor_U64 = 1105;
Constant anchor_U65 = 1105;
Constant anchor_U66 = 1105;
Constant anchor_U67 = 1105;
Constant anchor_U68 = 1105;
Constant anchor_U69 = 1105;
Constant anchor_U70 = 1105;
Constant anchor_U71 = 1105;
Constant anchor_U72 = 1105;
Constant anchor_U73 = 1105;
Constant anchor_U74 = 1105;
Constant anchor_U75 = 1105;
Constant anchor_U76 = 1105;
Constant anchor_U77 = 1105;
Constant anchor_U78 = 1105;
Constant anchor_U79 = 1105;
Constant anchor_U80 = 1105;
Constant anchor_U81 = 1105;
Constant response_id_U136 = 136;
Constant anchor_U82 = 1105;
Constant response_id_U137 = 137;
Constant anchor_U83 = 1105;
Constant response_id_U138 = 138;
Constant response_id_U139 = 139;
Constant anchor_U84 = 1105;
Constant response_id_U140 = 140;
Constant anchor_U85 = 1105;
Constant anchor_U86 = 1105;
Constant anchor_U87 = 1105;
Constant anchor_U88 = 1105;
Constant response_id_U141 = 141;
Constant response_id_U142 = 142;
Constant response_id_U143 = 143;
Constant response_id_U144 = 144;
Constant response_id_U145 = 145;
Constant response_id_U146 = 146;
Constant anchor_U89 = 1105;
Constant anchor_U90 = 1105;
Constant anchor_U91 = 1105;
Constant anchor_U92 = 1105;
Constant anchor_U93 = 1105;
Constant anchor_U94 = 1105;
Constant anchor_U95 = 1105;
Constant response_id_U147 = 147;
Constant anchor_U96 = 1105;
Constant anchor_U97 = 1105;
Constant response_id_U148 = 148;
Constant anchor_U98 = 1105;
Constant response_id_U149 = 149;
Constant anchor_U99 = 1105;
Constant response_id_U150 = 150;
Constant anchor_U100 = 1105;
Constant response_id_U151 = 151;
Constant anchor_U101 = 1105;
Constant response_id_U152 = 152;
Constant anchor_U102 = 1105;
Constant response_id_U153 = 153;
Constant anchor_U103 = 1105;
Constant response_id_U154 = 154;
Constant anchor_U104 = 1105;
Constant response_id_U155 = 155;
Constant anchor_U105 = 1105;
Constant response_id_U156 = 156;
Constant anchor_U106 = 1105;
Constant response_id_U157 = 157;
Constant anchor_U107 = 1105;
Constant response_id_U158 = 158;
Constant anchor_U108 = 1105;
Constant response_id_U159 = 159;
Constant anchor_U109 = 1105;
Constant response_id_U160 = 160;
Constant anchor_U110 = 1105;
Constant response_id_U161 = 161;
Constant anchor_U111 = 1105;
Constant response_id_U162 = 162;
Constant anchor_U112 = 1105;
Constant response_id_U163 = 163;
Constant anchor_U113 = 1105;
Constant response_id_U164 = 164;
Constant anchor_U114 = 1105;
Constant anchor_U115 = 1105;
Constant response_id_U165 = 165;
Constant response_id_U166 = 166;
Constant anchor_U116 = 1105;
Constant response_id_U167 = 167;
Constant anchor_U117 = 1105;
Constant response_id_U168 = 168;
Constant anchor_U118 = 1105;
Constant anchor_U119 = 1105;
Constant response_id_U169 = 169;
Constant anchor_U120 = 1105;
Constant response_id_U170 = 170;
Constant anchor_U121 = 1105;
Constant response_id_U171 = 171;
Constant anchor_U122 = 1105;
Constant response_id_U172 = 172;
Constant anchor_U123 = 1105;
Constant response_id_U173 = 173;
Constant anchor_U124 = 1105;
Constant response_id_U174 = 174;
Constant response_id_U175 = 175;
Constant anchor_U125 = 1105;
Constant anchor_U126 = 1105;
Constant response_id_U176 = 176;
Constant response_id_U177 = 177;
Constant anchor_U127 = 1105;
Constant anchor_U128 = 1105;
Constant anchor_U129 = 1105;
Constant response_id_U178 = 178;
Constant anchor_U130 = 1105;
Constant response_id_U179 = 179;
Constant anchor_U131 = 1105;
Constant response_id_U180 = 180;
Constant anchor_U132 = 1105;
Constant response_id_U181 = 181;
Constant anchor_U133 = 1105;
Constant anchor_U134 = 1105;
Constant response_id_U182 = 182;
Constant anchor_U135 = 1105;
Constant response_id_U183 = 183;
Constant anchor_U136 = 1105;
Constant anchor_U137 = 1105;
Constant response_id_U184 = 184;
Constant anchor_U138 = 1105;
Constant response_id_U185 = 185;
Constant anchor_U139 = 1105;
Constant anchor_U140 = 1105;
Constant response_id_U186 = 186;
Constant anchor_U141 = 1105;
Constant response_id_U187 = 187;
Constant anchor_U142 = 1105;
Constant response_id_U188 = 188;
Constant anchor_U143 = 1105;
Constant response_id_U189 = 189;
Constant anchor_U144 = 1105;
Constant anchor_U145 = 1105;
Constant response_id_U190 = 190;
Constant anchor_U146 = 1105;
Constant response_id_U191 = 191;
Constant anchor_U147 = 1105;
Constant response_id_U192 = 192;
Constant anchor_U148 = 1105;
Constant response_id_U193 = 193;
Constant anchor_U149 = 1105;
Constant response_id_U194 = 194;
Constant anchor_U150 = 1105;
Constant anchor_U151 = 1105;
Constant anchor_U152 = 1105;
Constant response_id_U195 = 195;
Constant response_id_U196 = 196;
Constant anchor_U153 = 1105;
Constant anchor_U154 = 1105;
Constant response_id_U197 = 197;
Constant anchor_U155 = 1105;
Constant response_id_U198 = 198;
Constant response_id_U199 = 199;
Constant anchor_U156 = 1105;
Constant response_id_U200 = 200;
Constant anchor_U157 = 1105;
Constant response_id_U201 = 201;
Constant anchor_U158 = 1105;
Constant anchor_U159 = 1105;
Constant response_id_U202 = 202;
Constant response_id_U203 = 203;
Constant anchor_U160 = 1105;
Constant anchor_U161 = 1105;
Constant anchor_U162 = 1105;
Constant anchor_U163 = 1105;
Constant response_id_U204 = 204;
Constant response_id_U205 = 205;
Constant response_id_U206 = 206;
Constant response_id_U207 = 207;
Constant response_id_U208 = 208;
Constant response_id_U209 = 209;
Constant response_id_U210 = 210;
Constant response_id_U211 = 211;
Constant response_id_U212 = 212;
Constant response_id_U213 = 213;
Constant response_id_U214 = 214;
Constant response_id_U215 = 215;
Constant response_id_U216 = 216;
Constant response_id_U217 = 217;
Constant response_id_U218 = 218;
Constant response_id_U219 = 219;
Constant response_id_U220 = 220;
Constant response_id_U221 = 221;
Constant response_id_U222 = 222;
Constant anchor_U164 = 1105;
Constant anchor_U165 = 1105;
Constant anchor_U166 = 1105;
Constant anchor_U167 = 1105;
Constant response_id_U223 = 223;
Constant response_id_U224 = 224;
Constant anchor_U168 = 1105;
Constant response_id_U225 = 225;
Constant response_id_U226 = 226;
Constant response_id_U227 = 227;
Constant response_id_U228 = 228;
Constant anchor_U169 = 1105;
Constant response_id_U229 = 229;
Constant anchor_U170 = 1105;
Constant response_id_U230 = 230;
Constant response_id_U231 = 231;
Constant anchor_U171 = 1105;
Constant response_id_U232 = 232;
Constant anchor_U172 = 1105;
Constant response_id_U233 = 233;
Constant response_id_U234 = 234;
Constant response_id_U235 = 235;
Constant response_id_U236 = 236;
Constant response_id_U237 = 237;
Constant anchor_U173 = 1105;
Constant anchor_U174 = 1105;
Constant response_id_U238 = 238;
Constant response_id_U239 = 239;
Constant response_id_U240 = 240;
Constant response_id_U241 = 241;
Constant anchor_U175 = 1105;
Constant anchor_U176 = 1105;
Constant anchor_U177 = 1105;
Constant anchor_U178 = 1105;
Constant response_id_U242 = 242;
Constant anchor_U179 = 1105;
Constant response_id_U243 = 243;
Constant anchor_U180 = 1105;
Constant anchor_U181 = 1105;
Constant anchor_U182 = 1105;
Constant response_id_U244 = 244;
Constant response_id_U245 = 245;
Constant response_id_U246 = 246;
Constant anchor_U183 = 1105;
Constant anchor_U184 = 1105;
Constant response_id_U247 = 247;
Constant anchor_U185 = 1105;
Constant anchor_U186 = 1105;
Constant response_id_U248 = 248;
Constant anchor_U187 = 1105;
Constant anchor_U188 = 1105;
Constant anchor_U189 = 1105;
Constant anchor_U190 = 1105;
Constant response_id_U249 = 249;
Constant response_id_U250 = 250;
Constant response_id_U251 = 251;
Constant anchor_U191 = 1105;
Constant response_id_U252 = 252;
Constant anchor_U192 = 1105;
Constant anchor_U193 = 1105;
Constant anchor_U194 = 1105;
Constant response_id_U253 = 253;
Constant anchor_U195 = 1105;
Constant anchor_U196 = 1105;
Constant response_id_U254 = 254;
Constant anchor_U197 = 1105;
Constant response_id_U255 = 255;
Constant response_id_U256 = 256;
Constant anchor_U198 = 1105;
Constant response_id_U257 = 257;
Constant anchor_U199 = 1105;
Constant response_id_U258 = 258;
Constant anchor_U200 = 1105;
Constant response_id_U259 = 259;
Constant anchor_U201 = 1105;
Constant response_id_U260 = 260;
Constant anchor_U202 = 1105;
Constant response_id_U261 = 261;
Constant anchor_U203 = 1105;
Constant response_id_U262 = 262;
Constant anchor_U204 = 1105;
Constant response_id_U263 = 263;
Constant anchor_U205 = 1105;
Constant response_id_U264 = 264;
Constant anchor_U206 = 1105;
Constant response_id_U265 = 265;
Constant response_id_U266 = 266;
Constant anchor_U207 = 1105;
Constant response_id_U267 = 267;
Constant response_id_U268 = 268;
Constant anchor_U208 = 1105;
Constant response_id_U269 = 269;
Constant anchor_U209 = 1105;
Constant response_id_U270 = 270;
Constant response_id_U271 = 271;
Constant anchor_U210 = 1105;
Constant response_id_U272 = 272;
Constant anchor_U211 = 1105;
Constant response_id_U273 = 273;
Constant anchor_U212 = 1105;
Constant response_id_U274 = 274;
Constant anchor_U213 = 1105;
Constant response_id_U275 = 275;
Constant anchor_U214 = 1105;
Constant anchor_U215 = 1105;
Constant response_id_U276 = 276;
Constant response_id_U277 = 277;
Constant anchor_U216 = 1105;
Constant response_id_U278 = 278;
Constant anchor_U217 = 1105;
Constant response_id_U279 = 279;
Constant anchor_U218 = 1105;
Constant response_id_U280 = 280;
Constant anchor_U219 = 1105;
Constant anchor_U220 = 1105;
Constant response_id_U281 = 281;
Constant response_id_U282 = 282;
Constant anchor_U221 = 1105;
Constant response_id_U283 = 283;
Constant anchor_U222 = 1105;
Constant response_id_U284 = 284;
Constant anchor_U223 = 1105;
Constant anchor_U224 = 1105;
Constant response_id_U285 = 285;
Constant anchor_U225 = 1105;
Constant response_id_U286 = 286;
Constant anchor_U226 = 1105;
Constant response_id_U287 = 287;
Constant anchor_U227 = 1105;
Constant anchor_U228 = 1105;
Constant response_id_U288 = 288;
Constant anchor_U229 = 1105;
Constant response_id_U289 = 289;
Constant anchor_U230 = 1105;
Constant response_id_U290 = 290;
Constant anchor_U231 = 1105;
Constant response_id_U291 = 291;
Constant anchor_U232 = 1105;
Constant anchor_U233 = 1105;
Constant response_id_U292 = 292;
Constant anchor_U234 = 1105;
Constant response_id_U293 = 293;
Constant response_id_U294 = 294;
Constant response_id_U295 = 295;
Constant anchor_U235 = 1105;
Constant response_id_U296 = 296;
Constant anchor_U236 = 1105;
Constant response_id_U297 = 297;
Constant anchor_U237 = 1105;
Constant anchor_U238 = 1105;
Constant response_id_U298 = 298;
Constant response_id_U299 = 299;
Constant response_id_U300 = 300;
Constant anchor_U239 = 1105;
Constant response_id_U301 = 301;
Constant anchor_U240 = 1105;
Constant response_id_U302 = 302;
Constant anchor_U241 = 1105;
Constant response_id_U303 = 303;
Constant anchor_U242 = 1105;
Constant anchor_U243 = 1105;
Constant response_id_U304 = 304;
Constant response_id_U305 = 305;
Constant anchor_U244 = 1105;
Constant anchor_U245 = 1105;
Constant response_id_U306 = 306;
Constant anchor_U246 = 1105;
Constant response_id_U307 = 307;
Constant anchor_U247 = 1105;
Constant anchor_U248 = 1105;
Constant response_id_U308 = 308;
Constant response_id_U309 = 309;
Constant anchor_U249 = 1105;
Constant response_id_U310 = 310;
Constant anchor_U250 = 1105;
Constant response_id_U311 = 311;
Constant anchor_U251 = 1105;
Constant response_id_U312 = 312;
Constant anchor_U252 = 1105;
Constant response_id_U313 = 313;
Constant anchor_U253 = 1105;
Constant response_id_U314 = 314;
Constant anchor_U254 = 1105;
Constant response_id_U315 = 315;
Constant anchor_U255 = 1105;
Constant anchor_U256 = 1105;
Constant response_id_U316 = 316;
Constant response_id_U317 = 317;
Constant response_id_U318 = 318;
Constant anchor_U257 = 1105;
Constant response_id_U319 = 319;
Constant anchor_U258 = 1105;
Constant anchor_U259 = 1105;
Constant response_id_U320 = 320;
Constant anchor_U260 = 1105;
Constant response_id_U321 = 321;
Constant anchor_U261 = 1105;
Constant response_id_U322 = 322;
Constant anchor_U262 = 1105;
Constant response_id_U323 = 323;
Constant anchor_U263 = 1105;
Constant response_id_U324 = 324;
Constant anchor_U264 = 1105;
Constant response_id_U325 = 325;
Constant anchor_U265 = 1105;
Constant response_id_U326 = 326;
Constant anchor_U266 = 1105;
Constant response_id_U327 = 327;
Constant anchor_U267 = 1105;
Constant response_id_U328 = 328;
Constant anchor_U268 = 1105;
Constant response_id_U329 = 329;
Constant anchor_U269 = 1105;
Constant response_id_U330 = 330;
Constant anchor_U270 = 1105;
Constant response_id_U331 = 331;
Constant anchor_U271 = 1105;
Constant anchor_U272 = 1105;
Constant anchor_U273 = 1105;
Constant response_id_U332 = 332;
Constant response_id_U333 = 333;
Constant anchor_U274 = 1105;
Constant response_id_U334 = 334;
Constant response_id_U335 = 335;
Constant anchor_U275 = 1105;
Constant response_id_U336 = 336;
Constant response_id_U337 = 337;
Constant response_id_U338 = 338;
Constant anchor_U276 = 1105;
Constant response_id_U339 = 339;
Constant response_id_U340 = 340;
Constant anchor_U277 = 1105;
Constant response_id_U341 = 341;
Constant anchor_U278 = 1105;
Constant response_id_U342 = 342;
Constant response_id_U343 = 343;
Constant anchor_U279 = 1105;
Constant response_id_U344 = 344;
Constant anchor_U280 = 1105;
Constant response_id_U345 = 345;
Constant anchor_U281 = 1105;
Constant response_id_U346 = 346;
Constant anchor_U282 = 1105;
Constant response_id_U347 = 347;
Constant response_id_U348 = 348;
Constant anchor_U283 = 1105;
Constant response_id_U349 = 349;
Constant anchor_U284 = 1105;
Constant response_id_U350 = 350;
Constant anchor_U285 = 1105;
Constant response_id_U351 = 351;
Constant anchor_U286 = 1105;
Constant response_id_U352 = 352;
Constant response_id_U353 = 353;
Constant anchor_U287 = 1105;
Constant response_id_U354 = 354;
Constant anchor_U288 = 1105;
Constant response_id_U355 = 355;
Constant anchor_U289 = 1105;
Constant response_id_U356 = 356;
Constant anchor_U290 = 1105;
Constant response_id_U357 = 357;
Constant response_id_U358 = 358;
Constant anchor_U291 = 1105;
Constant response_id_U359 = 359;
Constant anchor_U292 = 1105;
Constant response_id_U360 = 360;
Constant anchor_U293 = 1105;
Constant response_id_U361 = 361;
Constant anchor_U294 = 1105;
Constant response_id_U362 = 362;
Constant anchor_U295 = 1105;
Constant anchor_U296 = 1105;
Constant response_id_U363 = 363;
Constant anchor_U297 = 1105;
Constant response_id_U364 = 364;
Constant anchor_U298 = 1105;
Constant response_id_U365 = 365;
Constant response_id_U366 = 366;
Constant anchor_U299 = 1105;
Constant response_id_U367 = 367;
Constant anchor_U300 = 1105;
Constant response_id_U368 = 368;
Constant anchor_U301 = 1105;
Constant response_id_U369 = 369;
Constant anchor_U302 = 1105;
Constant response_id_U370 = 370;
Constant anchor_U303 = 1105;
Constant response_id_U371 = 371;
Constant anchor_U304 = 1105;
Constant response_id_U372 = 372;
Constant response_id_U373 = 373;
Constant anchor_U305 = 1105;
Constant response_id_U374 = 374;
Constant response_id_U375 = 375;
Constant anchor_U306 = 1105;
Constant response_id_U376 = 376;
Constant response_id_U377 = 377;
Constant anchor_U307 = 1105;
Constant response_id_U378 = 378;
Constant anchor_U308 = 1105;
Constant response_id_U379 = 379;
Constant response_id_U380 = 380;
Constant anchor_U309 = 1105;
Constant response_id_U381 = 381;
Constant anchor_U310 = 1105;
Constant response_id_U382 = 382;
Constant anchor_U311 = 1105;
Constant response_id_U383 = 383;
Constant anchor_U312 = 1105;
Constant response_id_U384 = 384;
Constant anchor_U313 = 1105;
Constant response_id_U385 = 385;
Constant anchor_U314 = 1105;
Constant response_id_U386 = 386;
Constant response_id_U387 = 387;
Constant anchor_U315 = 1105;
Constant response_id_U388 = 388;
Constant anchor_U316 = 1105;
Constant response_id_U389 = 389;
Constant response_id_U390 = 390;
Constant anchor_U317 = 1105;
Constant response_id_U391 = 391;
Constant anchor_U318 = 1105;
Constant response_id_U392 = 392;
Constant anchor_U319 = 1105;
Constant response_id_U393 = 393;
Constant anchor_U320 = 1105;
Constant anchor_U321 = 1105;
Constant anchor_U322 = 1105;
Constant anchor_U323 = 1105;
Constant anchor_U324 = 1105;
Constant anchor_U325 = 1105;
Constant anchor_U326 = 1105;
Constant anchor_U327 = 1105;
Constant anchor_U328 = 1105;
Constant anchor_U329 = 1105;
Constant anchor_U330 = 1105;
Constant anchor_U331 = 1105;
Constant anchor_U332 = 1105;
Constant anchor_U333 = 1105;
Constant anchor_U334 = 1105;
Constant anchor_U335 = 1105;
Constant anchor_U336 = 1105;
Constant anchor_U337 = 1105;
Constant anchor_U338 = 1105;
Constant anchor_U339 = 1105;
Constant anchor_U340 = 1105;
Constant anchor_U341 = 1105;
Constant anchor_U342 = 1105;
Constant anchor_U343 = 1105;
Constant anchor_U344 = 1105;
Constant anchor_U345 = 1105;
Constant anchor_U346 = 1105;
Constant anchor_U347 = 1105;
Constant anchor_U348 = 1105;
Constant anchor_U349 = 1105;
Constant kind_ref_U51 = 561;
Constant WEAK_ID_52 = 3;
Constant ICOUNT_ROOM = 37;
Constant K1_room_First = I_parking_lot_U1;
Constant kind_ref_U52 = 561;
Constant WEAK_ID_53 = 4;
Constant ICOUNT_THING = 251;
Constant K2_thing_First = selfobj;
Constant kind_ref_U53 = 561;
Constant WEAK_ID_54 = 5;
Constant ICOUNT_DIRECTION = 12;
Constant K3_direction_First = I_north_U1;
Constant kind_ref_U54 = 561;
Constant WEAK_ID_55 = 6;
Constant ICOUNT_DOOR = 8;
Constant K4_door_First = I_door1_U1;
Constant kind_ref_U55 = 561;
Constant WEAK_ID_56 = 7;
Constant ICOUNT_CONTAINER = 31;
Constant K5_container_First = I_wallet_U1;
Constant kind_ref_U56 = 561;
Constant WEAK_ID_57 = 8;
Constant ICOUNT_SUPPORTER = 10;
Constant K6_supporter_First = I_seat_U1;
Constant kind_ref_U57 = 561;
Constant WEAK_ID_58 = 9;
Constant ICOUNT_BACKDROP = 5;
Constant K7_backdrop_First = I_lurking_grue_U1;
Constant kind_ref_U58 = 561;
Constant WEAK_ID_59 = 10;
Constant ICOUNT_PERSON = 13;
Constant K8_person_First = selfobj;
Constant kind_ref_U59 = 561;
Constant WEAK_ID_60 = 11;
Constant ICOUNT_REGION = 5;
Constant K9_region_First = I_midway_U1;
Constant kind_ref_U60 = 561;
Constant WEAK_ID_61 = 12;
Constant ICOUNT_MAN = 0;
Constant kind_ref_U61 = 561;
Constant WEAK_ID_62 = 13;
Constant ICOUNT_WOMAN = 2;
Constant K11_woman_First = I_mysterious_woman_U1;
Constant kind_ref_U62 = 561;
Constant WEAK_ID_63 = 14;
Constant ICOUNT_ANIMAL = 0;
Constant kind_ref_U63 = 561;
Constant WEAK_ID_64 = 15;
Constant ICOUNT_DEVICE = 16;
Constant K13_device_First = I_electrical_closet_one_s_el_U4;
Constant kind_ref_U64 = 561;
Constant WEAK_ID_65 = 16;
Constant ICOUNT_VEHICLE = 1;
Constant K14_vehicle_First = I_hell_ride_car_U1;
Constant kind_ref_U65 = 561;
Constant WEAK_ID_66 = 17;
Constant ICOUNT_PLAYER_S_HOLDALL = 0;
Constant kind_ref_U66 = 561;
Constant WEAK_ID_67 = 18;
Constant ICOUNT_COMMAND_PARSER_ERROR = 25;
Constant INITIAL_MAX_SCORE = 150;
Constant extension_id_U3 = 3;
Constant column_bits_U1 = 1636;
Constant column_blanks_U1 = 0;
Constant column_bits_U2 = 1125;
Constant column_blanks_U2 = 1;
Constant column_bits_U3 = 8294;
Constant column_blanks_U3 = 2;
Constant column_bits_U4 = 103;
Constant column_blanks_U4 = 3;
Constant column_bits_U5 = 104;
Constant column_blanks_U5 = 4;
Constant table_id_U1 = 1;
Constant column_bits_U6 = 2153;
Constant column_bits_U7 = 17514;
Constant column_blanks_U6 = 5;
Constant table_id_U2 = 2;
Constant use_option_id_U29 = 28;
Constant rulebook_id_U363 = 362;
Constant rulebook_id_U364 = 363;
Constant call_U2006 = EMPTY_RULEBOOK;
Constant rulebook_id_U365 = 364;
Constant action_id_U78 = 77;
Constant var_id_U112 = 20077;
Constant anchor_U350 = 1105;
Constant anchor_U351 = 1105;
Constant anchor_U352 = 1105;
Constant anchor_U353 = 1105;
Constant anchor_U354 = 1105;
Constant response_id_U394 = 394;
Constant anchor_U355 = 1105;
Constant anchor_U356 = 1105;
Constant response_id_U395 = 395;
Constant anchor_U357 = 1105;
Constant anchor_U358 = 1105;
Constant anchor_U359 = 1105;
Constant extension_id_U4 = 4;
Constant call_U2024 = EMPTY_RULEBOOK;
Constant rulebook_id_U366 = 365;
Constant rulebook_id_U367 = 366;
Constant call_U2026 = EMPTY_RULEBOOK;
Constant rulebook_id_U368 = 367;
Constant activity_id_U35 = 34;
Constant var_id_U113 = 10034;
Constant rulebook_id_U369 = 368;
Constant rulebook_id_U370 = 369;
Constant call_U2029 = EMPTY_RULEBOOK;
Constant rulebook_id_U371 = 370;
Constant action_id_U79 = 78;
Constant var_id_U114 = 20078;
Constant rulebook_id_U372 = 371;
Constant rulebook_id_U373 = 372;
Constant call_U2033 = EMPTY_RULEBOOK;
Constant rulebook_id_U374 = 373;
Constant action_id_U80 = 79;
Constant var_id_U115 = 20079;
Constant call_U2035 = EMPTY_RULEBOOK;
Constant rulebook_id_U375 = 374;
Constant rulebook_id_U376 = 375;
Constant rulebook_id_U377 = 376;
Constant action_id_U81 = 80;
Constant var_id_U116 = 20080;
Constant relation_id_U148 = 119;
Constant relation_id_U149 = 120;
Constant kind_ref_U67 = 561;
Constant WEAK_ID_68 = 23;
Constant ICOUNT_PASSKEY = 0;
Constant kind_ref_U68 = 561;
Constant WEAK_ID_69 = 24;
Constant ICOUNT_KEYCHAIN = 0;
Constant anchor_U360 = 1105;
Constant response_id_U396 = 396;
Constant anchor_U361 = 1105;
Constant response_id_U397 = 397;
Constant anchor_U362 = 1105;
Constant response_id_U398 = 398;
Constant anchor_U363 = 1105;
Constant response_id_U399 = 399;
Constant anchor_U364 = 1105;
Constant anchor_U365 = 1105;
Constant anchor_U366 = 1105;
Constant anchor_U367 = 1105;
Constant anchor_U368 = 1105;
Constant anchor_U369 = 1105;
Constant response_id_U400 = 400;
Constant anchor_U370 = 1105;
Constant anchor_U371 = 1105;
Constant response_id_U401 = 401;
Constant anchor_U372 = 1105;
Constant anchor_U373 = 1105;
Constant response_id_U402 = 402;
Constant anchor_U374 = 1105;
Constant anchor_U375 = 1105;
Constant anchor_U376 = 1105;
Constant response_id_U403 = 403;
Constant anchor_U377 = 1105;
Constant response_id_U404 = 404;
Constant anchor_U378 = 1105;
Constant response_id_U405 = 405;
Constant anchor_U379 = 1105;
Constant anchor_U380 = 1105;
Constant anchor_U381 = 1105;
Constant anchor_U382 = 1105;
Constant anchor_U383 = 1105;
Constant response_id_U406 = 406;
Constant anchor_U384 = 1105;
Constant anchor_U385 = 1105;
Constant anchor_U386 = 1105;
Constant anchor_U387 = 1105;
Constant anchor_U388 = 1105;
Constant anchor_U389 = 1105;
Constant anchor_U390 = 1105;
Constant response_id_U407 = 407;
Constant anchor_U391 = 1105;
Constant response_id_U408 = 408;
Constant anchor_U392 = 1105;
Constant response_id_U409 = 409;
Constant anchor_U393 = 1105;
Constant response_id_U410 = 410;
Constant property_id_U140 = 41;
Constant extension_id_U5 = 5;
Constant table_column_id_U8 = 107;
Constant table_column_id_U9 = 108;
Constant table_column_id_U10 = 109;
Constant table_column_id_U11 = 110;
Constant table_column_id_U12 = 111;
Constant table_column_id_U13 = 112;
Constant table_column_id_U14 = 113;
Constant table_column_id_U15 = 114;
Constant table_column_id_U16 = 115;
Constant table_column_id_U17 = 116;
Constant table_column_id_U18 = 117;
Constant call_U2112 = EMPTY_RULEBOOK;
Constant rulebook_id_U378 = 377;
Constant rulebook_id_U379 = 378;
Constant call_U2114 = EMPTY_RULEBOOK;
Constant rulebook_id_U380 = 379;
Constant activity_id_U36 = 35;
Constant var_id_U117 = 10035;
Constant anchor_U394 = 1105;
Constant anchor_U395 = 1105;
Constant anchor_U396 = 1105;
Constant anchor_U397 = 1105;
Constant anchor_U398 = 1105;
Constant anchor_U399 = 1105;
Constant anchor_U400 = 1105;
Constant column_bits_U8 = 1643;
Constant column_blanks_U7 = 37;
Constant column_bits_U9 = 108;
Constant column_blanks_U8 = 38;
Constant column_bits_U10 = 1645;
Constant column_blanks_U9 = 39;
Constant column_bits_U11 = 110;
Constant column_blanks_U10 = 40;
Constant table_id_U3 = 3;
Constant column_bits_U12 = 17519;
Constant column_blanks_U11 = 41;
Constant column_bits_U13 = 112;
Constant column_blanks_U12 = 43;
Constant table_id_U4 = 4;
Constant column_bits_U14 = 1649;
Constant column_blanks_U13 = 45;
Constant column_bits_U15 = 1650;
Constant column_blanks_U14 = 46;
Constant column_bits_U16 = 1651;
Constant column_blanks_U15 = 47;
Constant table_id_U5 = 5;
Constant column_bits_U17 = 1649;
Constant column_blanks_U16 = 48;
Constant column_bits_U18 = 1650;
Constant column_blanks_U17 = 49;
Constant column_bits_U19 = 1651;
Constant column_blanks_U18 = 50;
Constant table_id_U6 = 6;
Constant column_bits_U20 = 1652;
Constant column_blanks_U19 = 51;
Constant column_bits_U21 = 17525;
Constant column_blanks_U20 = 52;
Constant table_id_U7 = 7;
Constant extension_id_U6 = 6;
Constant relation_id_U150 = 121;
Constant relation_id_U151 = 122;
Constant relation_id_U152 = 123;
Constant relation_id_U153 = 124;
Constant relation_id_U154 = 125;
Constant relation_id_U155 = 126;
Constant relation_id_U156 = 127;
Constant relation_id_U157 = 128;
Constant relation_id_U158 = 129;
Constant relation_id_U159 = 130;
Constant relation_id_U160 = 131;
Constant rulebook_id_U381 = 380;
Constant rulebook_id_U382 = 381;
Constant call_U2131 = EMPTY_RULEBOOK;
Constant rulebook_id_U383 = 382;
Constant action_id_U82 = 81;
Constant var_id_U118 = 20081;
Constant kind_ref_U69 = 561;
Constant WEAK_ID_70 = 25;
Constant ICOUNT_VERBOSITY = 3;
Constant anchor_U401 = 1105;
Constant anchor_U402 = 1105;
Constant anchor_U403 = 1105;
Constant extension_id_U7 = 7;
Constant column_bits_U22 = 1643;
Constant column_blanks_U21 = 53;
Constant column_bits_U23 = 108;
Constant column_blanks_U22 = 55;
Constant column_bits_U24 = 1645;
Constant column_blanks_U23 = 57;
Constant column_bits_U25 = 110;
Constant column_blanks_U24 = 59;
Constant table_id_U8 = 8;
Constant column_bits_U26 = 1643;
Constant column_blanks_U25 = 61;
Constant column_bits_U27 = 108;
Constant column_blanks_U26 = 62;
Constant column_bits_U28 = 1645;
Constant column_blanks_U27 = 63;
Constant column_bits_U29 = 110;
Constant column_blanks_U28 = 64;
Constant table_id_U9 = 9;
Constant column_bits_U30 = 1643;
Constant column_blanks_U29 = 65;
Constant column_bits_U31 = 108;
Constant column_blanks_U30 = 66;
Constant column_bits_U32 = 1645;
Constant column_blanks_U31 = 67;
Constant column_bits_U33 = 110;
Constant column_blanks_U32 = 68;
Constant table_id_U10 = 10;
Constant column_bits_U34 = 1643;
Constant column_blanks_U33 = 69;
Constant column_bits_U35 = 108;
Constant column_blanks_U34 = 70;
Constant column_bits_U36 = 1645;
Constant column_blanks_U35 = 71;
Constant column_bits_U37 = 110;
Constant column_blanks_U36 = 72;
Constant table_id_U11 = 11;
Constant column_bits_U38 = 1643;
Constant column_blanks_U37 = 73;
Constant column_bits_U39 = 108;
Constant column_blanks_U38 = 74;
Constant column_bits_U40 = 1645;
Constant column_blanks_U39 = 75;
Constant column_bits_U41 = 110;
Constant column_blanks_U40 = 76;
Constant table_id_U12 = 12;
Constant call_U2154 = EMPTY_RULEBOOK;
Constant rulebook_id_U384 = 383;
Constant rulebook_id_U385 = 384;
Constant call_U2156 = EMPTY_RULEBOOK;
Constant rulebook_id_U386 = 385;
Constant activity_id_U37 = 36;
Constant var_id_U119 = 10036;
Constant anchor_U404 = 1105;
Constant response_id_U411 = 411;
Constant column_bits_U42 = 1649;
Constant column_blanks_U41 = 77;
Constant column_bits_U43 = 1650;
Constant column_blanks_U42 = 78;
Constant column_bits_U44 = 1651;
Constant column_blanks_U43 = 79;
Constant table_id_U13 = 13;
Constant extension_id_U8 = 8;
Constant rulebook_id_U387 = 386;
Constant call_U2165 = EMPTY_RULEBOOK;
Constant rulebook_id_U388 = 387;
Constant call_U2166 = EMPTY_RULEBOOK;
Constant rulebook_id_U389 = 388;
Constant action_id_U83 = 82;
Constant var_id_U120 = 20082;
Constant anchor_U405 = 1105;
Constant extension_id_U9 = 9;
Constant table_column_id_U19 = 118;
Constant table_column_id_U20 = 119;
Constant table_column_id_U21 = 120;
Constant table_column_id_U22 = 121;
Constant table_column_id_U23 = 122;
Constant table_column_id_U24 = 123;
Constant table_column_id_U25 = 124;
Constant table_column_id_U26 = 125;
Constant table_column_id_U27 = 126;
Constant table_column_id_U28 = 127;
Constant table_column_id_U29 = 128;
Constant table_column_id_U30 = 129;
Constant table_column_id_U31 = 130;
Constant table_column_id_U32 = 131;
Constant table_column_id_U33 = 132;
Constant rulebook_id_U390 = 389;
Constant rulebook_id_U391 = 390;
Constant rulebook_id_U392 = 391;
Constant action_id_U84 = 83;
Constant var_id_U121 = 20083;
Constant rulebook_id_U393 = 392;
Constant rulebook_id_U394 = 393;
Constant rulebook_id_U395 = 394;
Constant action_id_U85 = 84;
Constant var_id_U122 = 20084;
Constant rulebook_id_U396 = 395;
Constant rulebook_id_U397 = 396;
Constant call_U2363 = EMPTY_RULEBOOK;
Constant rulebook_id_U398 = 397;
Constant action_id_U86 = 85;
Constant var_id_U123 = 20085;
Constant call_U2364 = EMPTY_RULEBOOK;
Constant rulebook_id_U399 = 398;
Constant rulebook_id_U400 = 399;
Constant call_U2366 = EMPTY_RULEBOOK;
Constant rulebook_id_U401 = 400;
Constant action_id_U87 = 86;
Constant var_id_U124 = 20086;
Constant call_U2367 = EMPTY_RULEBOOK;
Constant rulebook_id_U402 = 401;
Constant rulebook_id_U403 = 402;
Constant call_U2369 = EMPTY_RULEBOOK;
Constant rulebook_id_U404 = 403;
Constant action_id_U88 = 87;
Constant var_id_U125 = 20087;
Constant call_U2370 = EMPTY_RULEBOOK;
Constant rulebook_id_U405 = 404;
Constant call_U2371 = EMPTY_RULEBOOK;
Constant rulebook_id_U406 = 405;
Constant call_U2372 = EMPTY_RULEBOOK;
Constant rulebook_id_U407 = 406;
Constant action_id_U89 = 88;
Constant var_id_U126 = 20088;
Constant call_U2373 = EMPTY_RULEBOOK;
Constant rulebook_id_U408 = 407;
Constant call_U2374 = EMPTY_RULEBOOK;
Constant rulebook_id_U409 = 408;
Constant call_U2375 = EMPTY_RULEBOOK;
Constant rulebook_id_U410 = 409;
Constant action_id_U90 = 89;
Constant var_id_U127 = 20089;
Constant rulebook_id_U411 = 410;
Constant rulebook_id_U412 = 411;
Constant call_U2378 = EMPTY_RULEBOOK;
Constant rulebook_id_U413 = 412;
Constant action_id_U91 = 90;
Constant var_id_U128 = 20090;
Constant rulebook_id_U414 = 413;
Constant call_U2380 = EMPTY_RULEBOOK;
Constant rulebook_id_U415 = 414;
Constant call_U2381 = EMPTY_RULEBOOK;
Constant rulebook_id_U416 = 415;
Constant action_id_U92 = 91;
Constant var_id_U129 = 20091;
Constant call_U2382 = EMPTY_RULEBOOK;
Constant rulebook_id_U417 = 416;
Constant call_U2383 = EMPTY_RULEBOOK;
Constant rulebook_id_U418 = 417;
Constant call_U2384 = EMPTY_RULEBOOK;
Constant rulebook_id_U419 = 418;
Constant action_id_U93 = 92;
Constant var_id_U130 = 20092;
Constant rulebook_id_U420 = 419;
Constant call_U2386 = EMPTY_RULEBOOK;
Constant rulebook_id_U421 = 420;
Constant call_U2387 = EMPTY_RULEBOOK;
Constant rulebook_id_U422 = 421;
Constant action_id_U94 = 93;
Constant var_id_U131 = 20093;
Constant call_U2388 = EMPTY_RULEBOOK;
Constant rulebook_id_U423 = 422;
Constant call_U2389 = EMPTY_RULEBOOK;
Constant rulebook_id_U424 = 423;
Constant call_U2390 = EMPTY_RULEBOOK;
Constant rulebook_id_U425 = 424;
Constant action_id_U95 = 94;
Constant var_id_U132 = 20094;
Constant call_U2391 = EMPTY_RULEBOOK;
Constant rulebook_id_U426 = 425;
Constant call_U2392 = EMPTY_RULEBOOK;
Constant rulebook_id_U427 = 426;
Constant call_U2393 = EMPTY_RULEBOOK;
Constant rulebook_id_U428 = 427;
Constant action_id_U96 = 95;
Constant var_id_U133 = 20095;
Constant call_U2394 = EMPTY_RULEBOOK;
Constant rulebook_id_U429 = 428;
Constant call_U2395 = EMPTY_RULEBOOK;
Constant rulebook_id_U430 = 429;
Constant call_U2396 = EMPTY_RULEBOOK;
Constant rulebook_id_U431 = 430;
Constant action_id_U97 = 96;
Constant var_id_U134 = 20096;
Constant rulebook_id_U432 = 431;
Constant rulebook_id_U433 = 432;
Constant call_U2399 = EMPTY_RULEBOOK;
Constant rulebook_id_U434 = 433;
Constant action_id_U98 = 97;
Constant var_id_U135 = 20097;
Constant rulebook_id_U435 = 434;
Constant call_U2401 = EMPTY_RULEBOOK;
Constant rulebook_id_U436 = 435;
Constant call_U2402 = EMPTY_RULEBOOK;
Constant rulebook_id_U437 = 436;
Constant action_id_U99 = 98;
Constant var_id_U136 = 20098;
Constant call_U2403 = EMPTY_RULEBOOK;
Constant rulebook_id_U438 = 437;
Constant call_U2404 = EMPTY_RULEBOOK;
Constant rulebook_id_U439 = 438;
Constant call_U2405 = EMPTY_RULEBOOK;
Constant rulebook_id_U440 = 439;
Constant action_id_U100 = 99;
Constant var_id_U137 = 20099;
Constant rulebook_id_U441 = 440;
Constant call_U2407 = EMPTY_RULEBOOK;
Constant rulebook_id_U442 = 441;
Constant rulebook_id_U443 = 442;
Constant action_id_U101 = 100;
Constant var_id_U138 = 20100;
Constant call_U2409 = EMPTY_RULEBOOK;
Constant rulebook_id_U444 = 443;
Constant call_U2410 = EMPTY_RULEBOOK;
Constant rulebook_id_U445 = 444;
Constant rulebook_id_U446 = 445;
Constant action_id_U102 = 101;
Constant var_id_U139 = 20101;
Constant relation_id_U161 = 132;
Constant relation_id_U162 = 133;
Constant relation_id_U163 = 134;
Constant relation_id_U164 = 135;
Constant relation_id_U165 = 136;
Constant relation_id_U166 = 137;
Constant relation_id_U167 = 138;
Constant relation_id_U168 = 139;
Constant relation_id_U169 = 140;
Constant relation_id_U170 = 141;
Constant relation_id_U171 = 142;
Constant relation_id_U172 = 143;
Constant relation_id_U173 = 144;
Constant relation_id_U174 = 145;
Constant relation_id_U175 = 146;
Constant relation_id_U176 = 147;
Constant relation_id_U177 = 148;
Constant relation_id_U178 = 149;
Constant relation_id_U179 = 150;
Constant relation_id_U180 = 151;
Constant relation_id_U181 = 152;
Constant relation_id_U182 = 153;
Constant relation_id_U183 = 154;
Constant relation_id_U184 = 155;
Constant relation_id_U185 = 156;
Constant relation_id_U186 = 157;
Constant relation_id_U187 = 158;
Constant relation_id_U188 = 159;
Constant relation_id_U189 = 160;
Constant relation_id_U190 = 161;
Constant relation_id_U191 = 162;
Constant relation_id_U192 = 163;
Constant relation_id_U193 = 164;
Constant relation_id_U194 = 165;
Constant relation_id_U195 = 166;
Constant relation_id_U196 = 167;
Constant relation_id_U197 = 168;
Constant relation_id_U198 = 169;
Constant relation_id_U199 = 170;
Constant relation_id_U200 = 171;
Constant relation_id_U201 = 172;
Constant relation_id_U202 = 173;
Constant relation_id_U203 = 174;
Constant relation_id_U204 = 175;
Constant relation_id_U205 = 176;
Constant relation_id_U206 = 177;
Constant relation_id_U207 = 178;
Constant relation_id_U208 = 179;
Constant relation_id_U209 = 180;
Constant relation_id_U210 = 181;
Constant relation_id_U211 = 182;
Constant relation_id_U212 = 183;
Constant relation_id_U213 = 184;
Constant relation_id_U214 = 185;
Constant relation_id_U215 = 186;
Constant relation_id_U216 = 187;
Constant relation_id_U217 = 188;
Constant relation_id_U218 = 189;
Constant call_U2439 = EMPTY_RULEBOOK;
Constant rulebook_id_U447 = 446;
Constant rulebook_id_U448 = 447;
Constant call_U2441 = EMPTY_RULEBOOK;
Constant rulebook_id_U449 = 448;
Constant activity_id_U38 = 37;
Constant var_id_U140 = 10037;
Constant call_U2442 = EMPTY_RULEBOOK;
Constant rulebook_id_U450 = 449;
Constant rulebook_id_U451 = 450;
Constant call_U2444 = EMPTY_RULEBOOK;
Constant rulebook_id_U452 = 451;
Constant rulebook_id_U453 = 452;
Constant kind_ref_U70 = 561;
Constant WEAK_ID_71 = 26;
Constant kind_ref_U71 = 561;
Constant WEAK_ID_72 = 27;
Constant kind_ref_U72 = 561;
Constant WEAK_ID_73 = 28;
Constant ICOUNT_FLUID_CONTAINER = 1;
Constant K18_fluid_container_First = I_soda_can_U1;
Constant kind_ref_U73 = 561;
Constant WEAK_ID_74 = 29;
Constant ICOUNT_LIQUID = 5;
Constant kind_ref_U74 = 561;
Constant WEAK_ID_75 = 30;
Constant ICOUNT_ELECTRIC_LAMP = 2;
Constant K19_electric_lamp_First = I_lantern_U1;
Constant kind_ref_U75 = 561;
Constant WEAK_ID_76 = 31;
Constant ICOUNT_ATTENDANT = 9;
Constant K20_attendant_First = I_parking_attendant_U1;
Constant kind_ref_U76 = 561;
Constant WEAK_ID_77 = 32;
Constant ICOUNT_COIN = 10;
Constant K21_coin_First = I_U1;
Constant kind_ref_U77 = 561;
Constant WEAK_ID_78 = 33;
Constant ICOUNT_NICKEL = 1;
Constant K22_nickel_First = I_U4;
Constant kind_ref_U78 = 561;
Constant WEAK_ID_79 = 34;
Constant ICOUNT_DIME = 6;
Constant K23_dime_First = I_U5;
Constant kind_ref_U79 = 561;
Constant WEAK_ID_80 = 35;
Constant ICOUNT_QUARTER = 3;
Constant K24_quarter_First = I_U1;
Constant kind_ref_U80 = 561;
Constant WEAK_ID_81 = 36;
Constant ICOUNT_COLOR = 10;
Constant kind_ref_U81 = 561;
Constant WEAK_ID_82 = 37;
Constant ICOUNT_ELECTRICAL_CLOSET = 6;
Constant K25_electrical_closet_First = I_electrical_closet_one_U1;
Constant kind_ref_U82 = 561;
Constant WEAK_ID_83 = 38;
Constant ICOUNT_ELECTRICAL_PANEL = 6;
Constant K26_electrical_panel_First = I_electrical_closet_one_s_el_U1;
Constant kind_ref_U83 = 561;
Constant WEAK_ID_84 = 39;
Constant ICOUNT_SOCKET = 6;
Constant K27_socket_First = I_electrical_closet_one_s_el_U2;
Constant kind_ref_U84 = 561;
Constant WEAK_ID_85 = 40;
Constant ICOUNT_INDICATOR = 6;
Constant K28_indicator_First = I_electrical_closet_one_s_el_U3;
Constant kind_ref_U85 = 561;
Constant WEAK_ID_86 = 41;
Constant ICOUNT_FUSE = 9;
Constant K29_fuse_First = I_fuse5_U1;
Constant kind_ref_U86 = 561;
Constant WEAK_ID_87 = 42;
Constant ICOUNT_SWITCH = 6;
Constant K30_switch_First = I_electrical_closet_one_s_el_U4;
Constant kind_ref_U87 = 561;
Constant WEAK_ID_88 = 43;
Constant ICOUNT_RIDE_TICKET = 5;
Constant K31_ride_ticket_First = I_hell_ride_ticket_U1;
Constant kind_ref_U88 = 561;
Constant WEAK_ID_89 = 44;
Constant ICOUNT_STRENGTH_PATTERN = 5;
Constant kind_ref_U89 = 561;
Constant WEAK_ID_90 = 45;
Constant ICOUNT_BASEBALL = 3;
Constant K32_baseball_First = I_U10;
Constant kind_ref_U90 = 561;
Constant WEAK_ID_91 = 46;
Constant ICOUNT_WOODEN_DOOR = 6;
Constant K33_wooden_door_First = I_door1_U1;
Constant kind_ref_U91 = 561;
Constant WEAK_ID_92 = 47;
Constant ICOUNT_CONTROL_PANEL = 6;
Constant K34_control_panel_First = I_control_panel_one_U1;
Constant kind_ref_U92 = 561;
Constant WEAK_ID_93 = 48;
Constant ICOUNT_BUTTON = 6;
Constant K35_button_First = I_control_panel_one_s_button_U1;
Constant kind_ref_U93 = 561;
Constant WEAK_ID_94 = 49;
Constant ICOUNT_DIAL = 6;
Constant K36_dial_First = I_control_panel_one_s_dial_U1;
Constant kind_ref_U94 = 561;
Constant WEAK_ID_95 = 50;
Constant ICOUNT_LIGHT = 6;
Constant K37_light_First = I_control_panel_one_s_light_U1;
Constant kind_ref_U95 = 561;
Constant WEAK_ID_96 = 51;
Constant ICOUNT_PERMISSION = 2;
Constant anchor_U406 = 1105;
Constant anchor_U407 = 1105;
Constant anchor_U408 = 1105;
Constant anchor_U409 = 1105;
Constant anchor_U410 = 1105;
Constant anchor_U411 = 1105;
Constant anchor_U412 = 1105;
Constant anchor_U413 = 1105;
Constant anchor_U414 = 1105;
Constant anchor_U415 = 1105;
Constant anchor_U416 = 1105;
Constant anchor_U417 = 1105;
Constant anchor_U418 = 1105;
Constant anchor_U419 = 1105;
Constant anchor_U420 = 1105;
Constant anchor_U421 = 1105;
Constant anchor_U422 = 1105;
Constant anchor_U423 = 1105;
Constant anchor_U424 = 1105;
Constant anchor_U425 = 1105;
Constant anchor_U426 = 1105;
Constant anchor_U427 = 1105;
Constant anchor_U428 = 1105;
Constant anchor_U429 = 1105;
Constant anchor_U430 = 1105;
Constant anchor_U431 = 1105;
Constant anchor_U432 = 1105;
Constant anchor_U433 = 1105;
Constant anchor_U434 = 1105;
Constant anchor_U435 = 1105;
Constant anchor_U436 = 1105;
Constant anchor_U437 = 1105;
Constant anchor_U438 = 1105;
Constant anchor_U439 = 1105;
Constant anchor_U440 = 1105;
Constant anchor_U441 = 1105;
Constant anchor_U442 = 1105;
Constant anchor_U443 = 1105;
Constant anchor_U444 = 1105;
Constant anchor_U445 = 1105;
Constant anchor_U446 = 1105;
Constant anchor_U447 = 1105;
Constant anchor_U448 = 1105;
Constant anchor_U449 = 1105;
Constant anchor_U450 = 1105;
Constant anchor_U451 = 1105;
Constant anchor_U452 = 1105;
Constant anchor_U453 = 1105;
Constant anchor_U454 = 1105;
Constant anchor_U455 = 1105;
Constant anchor_U456 = 1105;
Constant anchor_U457 = 1105;
Constant anchor_U458 = 1105;
Constant anchor_U459 = 1105;
Constant anchor_U460 = 1105;
Constant anchor_U461 = 1105;
Constant anchor_U462 = 1105;
Constant anchor_U463 = 1105;
Constant anchor_U464 = 1105;
Constant anchor_U465 = 1105;
Constant anchor_U466 = 1105;
Constant anchor_U467 = 1105;
Constant anchor_U468 = 1105;
Constant anchor_U469 = 1105;
Constant anchor_U470 = 1105;
Constant anchor_U471 = 1105;
Constant anchor_U472 = 1105;
Constant anchor_U473 = 1105;
Constant anchor_U474 = 1105;
Constant anchor_U475 = 1105;
Constant anchor_U476 = 1105;
Constant anchor_U477 = 1105;
Constant anchor_U478 = 1105;
Constant anchor_U479 = 1105;
Constant anchor_U480 = 1105;
Constant anchor_U481 = 1105;
Constant anchor_U482 = 1105;
Constant anchor_U483 = 1105;
Constant anchor_U484 = 1105;
Constant anchor_U485 = 1105;
Constant anchor_U486 = 1105;
Constant anchor_U487 = 1105;
Constant anchor_U488 = 1105;
Constant anchor_U489 = 1105;
Constant anchor_U490 = 1105;
Constant anchor_U491 = 1105;
Constant anchor_U492 = 1105;
Constant anchor_U493 = 1105;
Constant anchor_U494 = 1105;
Constant anchor_U495 = 1105;
Constant anchor_U496 = 1105;
Constant anchor_U497 = 1105;
Constant anchor_U498 = 1105;
Constant anchor_U499 = 1105;
Constant anchor_U500 = 1105;
Constant anchor_U501 = 1105;
Constant anchor_U502 = 1105;
Constant anchor_U503 = 1105;
Constant anchor_U504 = 1105;
Constant anchor_U505 = 1105;
Constant anchor_U506 = 1105;
Constant anchor_U507 = 1105;
Constant anchor_U508 = 1105;
Constant anchor_U509 = 1105;
Constant anchor_U510 = 1105;
Constant anchor_U511 = 1105;
Constant anchor_U512 = 1105;
Constant anchor_U513 = 1105;
Constant anchor_U514 = 1105;
Constant anchor_U515 = 1105;
Constant anchor_U516 = 1105;
Constant anchor_U517 = 1105;
Constant anchor_U518 = 1105;
Constant anchor_U519 = 1105;
Constant anchor_U520 = 1105;
Constant anchor_U521 = 1105;
Constant anchor_U522 = 1105;
Constant anchor_U523 = 1105;
Constant anchor_U524 = 1105;
Constant anchor_U525 = 1105;
Constant anchor_U526 = 1105;
Constant anchor_U527 = 1105;
Constant anchor_U528 = 1105;
Constant anchor_U529 = 1105;
Constant anchor_U530 = 1105;
Constant anchor_U531 = 1105;
Constant anchor_U532 = 1105;
Constant anchor_U533 = 1105;
Constant anchor_U534 = 1105;
Constant anchor_U535 = 1105;
Constant anchor_U536 = 1105;
Constant anchor_U537 = 1105;
Constant anchor_U538 = 1105;
Constant anchor_U539 = 1105;
Constant anchor_U540 = 1105;
Constant anchor_U541 = 1105;
Constant anchor_U542 = 1105;
Constant anchor_U543 = 1105;
Constant anchor_U544 = 1105;
Constant anchor_U545 = 1105;
Constant anchor_U546 = 1105;
Constant anchor_U547 = 1105;
Constant anchor_U548 = 1105;
Constant anchor_U549 = 1105;
Constant anchor_U550 = 1105;
Constant anchor_U551 = 1105;
Constant anchor_U552 = 1105;
Constant anchor_U553 = 1105;
Constant anchor_U554 = 1105;
Constant anchor_U555 = 1105;
Constant anchor_U556 = 1105;
Constant anchor_U557 = 1105;
Constant anchor_U558 = 1105;
Constant anchor_U559 = 1105;
Constant anchor_U560 = 1105;
Constant anchor_U561 = 1105;
Constant anchor_U562 = 1105;
Constant anchor_U563 = 1105;
Constant anchor_U564 = 1105;
Constant anchor_U565 = 1105;
Constant anchor_U566 = 1105;
Constant anchor_U567 = 1105;
Constant anchor_U568 = 1105;
Constant anchor_U569 = 1105;
Constant anchor_U570 = 1105;
Constant anchor_U571 = 1105;
Constant anchor_U572 = 1105;
Constant anchor_U573 = 1105;
Constant anchor_U574 = 1105;
Constant anchor_U575 = 1105;
Constant anchor_U576 = 1105;
Constant anchor_U577 = 1105;
Constant anchor_U578 = 1105;
Constant anchor_U579 = 1105;
Constant anchor_U580 = 1105;
Constant anchor_U581 = 1105;
Constant anchor_U582 = 1105;
Constant anchor_U583 = 1105;
Constant anchor_U584 = 1105;
Constant anchor_U585 = 1105;
Constant anchor_U586 = 1105;
Constant anchor_U587 = 1105;
Constant anchor_U588 = 1105;
Constant anchor_U589 = 1105;
Constant anchor_U590 = 1105;
Constant anchor_U591 = 1105;
Constant anchor_U592 = 1105;
Constant anchor_U593 = 1105;
Constant anchor_U594 = 1105;
Constant anchor_U595 = 1105;
Constant anchor_U596 = 1105;
Constant anchor_U597 = 1105;
Constant anchor_U598 = 1105;
Constant anchor_U599 = 1105;
Constant anchor_U600 = 1105;
Constant anchor_U601 = 1105;
Constant anchor_U602 = 1105;
Constant anchor_U603 = 1105;
Constant anchor_U604 = 1105;
Constant anchor_U605 = 1105;
Constant anchor_U606 = 1105;
Constant anchor_U607 = 1105;
Constant anchor_U608 = 1105;
Constant anchor_U609 = 1105;
Constant anchor_U610 = 1105;
Constant anchor_U611 = 1105;
Constant anchor_U612 = 1105;
Constant anchor_U613 = 1105;
Constant anchor_U614 = 1105;
Constant anchor_U615 = 1105;
Constant anchor_U616 = 1105;
Constant anchor_U617 = 1105;
Constant anchor_U618 = 1105;
Constant anchor_U619 = 1105;
Constant anchor_U620 = 1105;
Constant property_id_U141 = 42;
Constant property_id_U142 = 43;
Constant property_id_U143 = 44;
Constant property_id_U144 = 45;
Constant property_id_U145 = 46;
Constant property_id_U146 = 47;
Constant property_id_U147 = 48;
Constant property_id_U148 = 49;
Constant property_id_U149 = 50;
Constant property_id_U150 = 51;
Constant property_id_U151 = 52;
Constant property_id_U152 = 53;
Constant property_id_U153 = 54;
Constant property_id_U154 = 55;
Constant column_bits_U45 = 1663;
Constant column_blanks_U44 = 80;
Constant column_bits_U46 = 2176;
Constant column_bits_U47 = 1645;
Constant column_blanks_U45 = 81;
Constant table_id_U14 = 14;
Constant column_bits_U48 = 1663;
Constant column_blanks_U46 = 82;
Constant column_bits_U49 = 2176;
Constant column_bits_U50 = 17537;
Constant column_blanks_U47 = 83;
Constant table_id_U15 = 15;
Constant column_bits_U51 = 1645;
Constant column_blanks_U48 = 84;
Constant table_id_U16 = 16;
Constant column_bits_U52 = 2178;
Constant column_bits_U53 = 1667;
Constant column_blanks_U49 = 85;
Constant column_bits_U54 = 2180;
Constant column_bits_U55 = 1645;
Constant column_blanks_U50 = 86;
Constant table_id_U17 = 17;
Constant column_bits_U56 = 1643;
Constant column_blanks_U51 = 87;
Constant column_bits_U57 = 108;
Constant column_blanks_U52 = 88;
Constant column_bits_U58 = 1645;
Constant column_blanks_U53 = 89;
Constant column_bits_U59 = 110;
Constant column_blanks_U54 = 90;
Constant table_id_U18 = 18;
Constant column_bits_U60 = 1643;
Constant column_blanks_U55 = 91;
Constant column_bits_U61 = 108;
Constant column_blanks_U56 = 92;
Constant column_bits_U62 = 1645;
Constant column_blanks_U57 = 93;
Constant column_bits_U63 = 110;
Constant column_blanks_U58 = 94;
Constant table_id_U19 = 19;
Constant column_bits_U64 = 1643;
Constant column_blanks_U59 = 95;
Constant column_bits_U65 = 108;
Constant column_blanks_U60 = 96;
Constant column_bits_U66 = 1645;
Constant column_blanks_U61 = 97;
Constant column_bits_U67 = 110;
Constant column_blanks_U62 = 98;
Constant table_id_U20 = 20;
Constant column_bits_U68 = 1643;
Constant column_blanks_U63 = 99;
Constant column_bits_U69 = 108;
Constant column_blanks_U64 = 100;
Constant column_bits_U70 = 1645;
Constant column_blanks_U65 = 101;
Constant column_bits_U71 = 110;
Constant column_blanks_U66 = 102;
Constant table_id_U21 = 21;
Constant column_bits_U72 = 1643;
Constant column_blanks_U67 = 103;
Constant column_bits_U73 = 108;
Constant column_blanks_U68 = 104;
Constant column_bits_U74 = 1645;
Constant column_blanks_U69 = 105;
Constant column_bits_U75 = 110;
Constant column_blanks_U70 = 106;
Constant table_id_U22 = 22;
Constant column_bits_U76 = 1643;
Constant column_blanks_U71 = 107;
Constant column_bits_U77 = 108;
Constant column_blanks_U72 = 108;
Constant column_bits_U78 = 1645;
Constant column_blanks_U73 = 109;
Constant column_bits_U79 = 110;
Constant column_blanks_U74 = 110;
Constant table_id_U23 = 23;
Constant column_bits_U80 = 1643;
Constant column_blanks_U75 = 111;
Constant column_bits_U81 = 108;
Constant column_blanks_U76 = 112;
Constant column_bits_U82 = 1645;
Constant column_blanks_U77 = 113;
Constant column_bits_U83 = 110;
Constant column_blanks_U78 = 114;
Constant table_id_U24 = 24;
Constant column_bits_U84 = 1654;
Constant column_blanks_U79 = 115;
Constant column_bits_U85 = 17527;
Constant column_blanks_U80 = 120;
Constant column_bits_U86 = 1645;
Constant column_blanks_U81 = 125;
Constant column_bits_U87 = 17528;
Constant column_blanks_U82 = 130;
Constant table_id_U25 = 25;
Constant column_bits_U88 = 1657;
Constant column_blanks_U83 = 135;
Constant table_id_U26 = 26;
Constant column_bits_U89 = 1658;
Constant column_blanks_U84 = 136;
Constant column_bits_U90 = 1659;
Constant column_blanks_U85 = 141;
Constant column_bits_U91 = 1148;
Constant column_blanks_U86 = 146;
Constant table_id_U27 = 27;
Constant column_bits_U92 = 17533;
Constant column_blanks_U87 = 151;
Constant column_bits_U93 = 2174;
Constant column_bits_U94 = 1645;
Constant column_blanks_U88 = 152;
Constant table_id_U28 = 28;
Constant column_bits_U95 = 1663;
Constant column_blanks_U89 = 153;
Constant column_bits_U96 = 2176;
Constant column_bits_U97 = 1645;
Constant column_blanks_U90 = 154;
Constant table_id_U29 = 29;
Constant column_bits_U98 = 1663;
Constant column_blanks_U91 = 155;
Constant column_bits_U99 = 2176;
Constant column_bits_U100 = 1645;
Constant column_blanks_U92 = 156;
Constant table_id_U30 = 30;
Constant column_bits_U101 = 1663;
Constant column_blanks_U93 = 157;
Constant column_bits_U102 = 2176;
Constant column_bits_U103 = 17537;
Constant column_blanks_U94 = 158;
Constant table_id_U31 = 31;
Constant column_bits_U104 = 1652;
Constant column_blanks_U95 = 159;
Constant column_bits_U105 = 17525;
Constant column_blanks_U96 = 160;
Constant table_id_U32 = 32;
Constant column_bits_U106 = 1652;
Constant column_blanks_U97 = 161;
Constant column_bits_U107 = 17525;
Constant column_blanks_U98 = 162;
Constant table_id_U33 = 33;
Constant column_bits_U108 = 1652;
Constant column_blanks_U99 = 163;
Constant column_bits_U109 = 17525;
Constant column_blanks_U100 = 164;
Constant table_id_U34 = 34;
Constant column_bits_U110 = 1652;
Constant column_blanks_U101 = 165;
Constant column_bits_U111 = 17525;
Constant column_blanks_U102 = 166;
Constant table_id_U35 = 35;
Constant column_bits_U112 = 1652;
Constant column_blanks_U103 = 167;
Constant column_bits_U113 = 17525;
Constant column_blanks_U104 = 168;
Constant table_id_U36 = 36;
Constant column_bits_U114 = 1652;
Constant column_blanks_U105 = 169;
Constant column_bits_U115 = 17525;
Constant column_blanks_U106 = 170;
Constant table_id_U37 = 37;
Constant column_bits_U116 = 1652;
Constant column_blanks_U107 = 171;
Constant column_bits_U117 = 17525;
Constant column_blanks_U108 = 172;
Constant table_id_U38 = 38;
Constant column_bits_U118 = 1652;
Constant column_blanks_U109 = 173;
Constant column_bits_U119 = 17525;
Constant column_blanks_U110 = 174;
Constant table_id_U39 = 39;
Constant column_bits_U120 = 1652;
Constant column_blanks_U111 = 175;
Constant column_bits_U121 = 17525;
Constant column_blanks_U112 = 176;
Constant table_id_U40 = 40;
Constant column_bits_U122 = 1652;
Constant column_blanks_U113 = 177;
Constant column_bits_U123 = 17525;
Constant column_blanks_U114 = 178;
Constant table_id_U41 = 41;
Constant column_bits_U124 = 1652;
Constant column_blanks_U115 = 179;
Constant column_bits_U125 = 17525;
Constant column_blanks_U116 = 180;
Constant table_id_U42 = 42;
Constant column_bits_U126 = 1652;
Constant column_blanks_U117 = 181;
Constant column_bits_U127 = 17525;
Constant column_blanks_U118 = 182;
Constant table_id_U43 = 43;
Constant column_bits_U128 = 1652;
Constant column_blanks_U119 = 183;
Constant column_bits_U129 = 17525;
Constant column_blanks_U120 = 184;
Constant table_id_U44 = 44;
Constant column_bits_U130 = 1652;
Constant column_blanks_U121 = 185;
Constant column_bits_U131 = 17525;
Constant column_blanks_U122 = 186;
Constant table_id_U45 = 45;
Constant column_bits_U132 = 1652;
Constant column_blanks_U123 = 187;
Constant column_bits_U133 = 17525;
Constant column_blanks_U124 = 188;
Constant table_id_U46 = 46;
Constant column_bits_U134 = 1652;
Constant column_blanks_U125 = 189;
Constant column_bits_U135 = 17525;
Constant column_blanks_U126 = 190;
Constant table_id_U47 = 47;
Constant column_bits_U136 = 1652;
Constant column_blanks_U127 = 191;
Constant column_bits_U137 = 17525;
Constant column_blanks_U128 = 192;
Constant table_id_U48 = 48;
Constant column_bits_U138 = 1652;
Constant column_blanks_U129 = 193;
Constant column_bits_U139 = 17525;
Constant column_blanks_U130 = 194;
Constant table_id_U49 = 49;
Constant column_bits_U140 = 1652;
Constant column_blanks_U131 = 195;
Constant column_bits_U141 = 17525;
Constant column_blanks_U132 = 196;
Constant table_id_U50 = 50;
Constant ptc_id_U1 = 0;
Constant ptc_id_U2 = 1;
Constant ptc_id_U3 = 2;
Constant ahc_id_U1 = 0;
Constant ahc_id_U2 = 1;
Constant ahc_id_U3 = 2;
Constant ahc_id_U4 = 3;
Constant ahc_id_U5 = 4;
Constant ahc_id_U6 = 5;
Release 122;
Constant No_Directions = 12;
Constant line_ref_U1 = 561;
Constant line_ref_U2 = 561;
Constant line_ref_U3 = 561;
Constant line_ref_U4 = 561;
Constant line_ref_U5 = 561;
Constant line_ref_U6 = 561;
Constant line_ref_U7 = 561;
Constant line_ref_U8 = 561;
Constant line_ref_U9 = 561;
Constant line_ref_U10 = 561;
Constant line_ref_U11 = 561;
Constant line_ref_U12 = 561;
Constant line_ref_U13 = 561;
Constant line_ref_U14 = 561;
Constant line_ref_U15 = 561;
Constant line_ref_U16 = 561;
Constant line_ref_U17 = 561;
Constant line_ref_U18 = 561;
Constant line_ref_U19 = 561;
Constant line_ref_U20 = 561;
Constant line_ref_U21 = 561;
Constant line_ref_U22 = 561;
Constant line_ref_U23 = 561;
Constant line_ref_U24 = 561;
Constant line_ref_U25 = 561;
Constant line_ref_U26 = 561;
Constant line_ref_U27 = 561;
Constant line_ref_U28 = 561;
Constant line_ref_U29 = 561;
Constant line_ref_U30 = 561;
Constant line_ref_U31 = 561;
Constant line_ref_U32 = 561;
Constant line_ref_U33 = 561;
Constant line_ref_U34 = 561;
Constant line_ref_U35 = 561;
Constant line_ref_U36 = 561;
Constant line_ref_U37 = 561;
Constant line_ref_U38 = 561;
Constant line_ref_U39 = 561;
Constant line_ref_U40 = 561;
Constant line_ref_U41 = 561;
Constant line_ref_U42 = 561;
Constant line_ref_U43 = 561;
Constant line_ref_U44 = 561;
Constant line_ref_U45 = 561;
Constant line_ref_U46 = 561;
Constant line_ref_U47 = 561;
Constant line_ref_U48 = 561;
Constant line_ref_U49 = 561;
Constant line_ref_U50 = 561;
Constant line_ref_U51 = 561;
Constant line_ref_U52 = 561;
Constant line_ref_U53 = 561;
Constant line_ref_U54 = 561;
Constant line_ref_U55 = 561;
Constant line_ref_U56 = 561;
Constant line_ref_U57 = 561;
Constant line_ref_U58 = 561;
Constant line_ref_U59 = 561;
Constant line_ref_U60 = 561;
Constant line_ref_U61 = 561;
Constant line_ref_U62 = 561;
Constant line_ref_U63 = 561;
Constant line_ref_U64 = 561;
Constant line_ref_U65 = 561;
Constant line_ref_U66 = 561;
Constant line_ref_U67 = 561;
Constant line_ref_U68 = 561;
Constant line_ref_U69 = 561;
Constant line_ref_U70 = 561;
Constant line_ref_U71 = 561;
Constant line_ref_U72 = 561;
Constant line_ref_U73 = 561;
Constant line_ref_U74 = 561;
Constant line_ref_U75 = 561;
Constant line_ref_U76 = 561;
Constant line_ref_U77 = 561;
Constant line_ref_U78 = 561;
Constant line_ref_U79 = 561;
Constant line_ref_U80 = 561;
Constant line_ref_U81 = 561;
Constant line_ref_U82 = 561;
Constant line_ref_U83 = 561;
Constant line_ref_U84 = 561;
Constant line_ref_U85 = 561;
Constant line_ref_U86 = 561;
Constant line_ref_U87 = 561;
Constant line_ref_U88 = 561;
Constant line_ref_U89 = 561;
Constant line_ref_U90 = 561;
Constant line_ref_U91 = 561;
Constant line_ref_U92 = 561;
Constant line_ref_U93 = 561;
Constant line_ref_U94 = 561;
Constant line_ref_U95 = 561;
Constant line_ref_U96 = 561;
Constant line_ref_U97 = 561;
Constant line_ref_U98 = 561;
Constant line_ref_U99 = 561;
Constant line_ref_U100 = 561;
Constant line_ref_U101 = 561;
Constant line_ref_U102 = 561;
Constant line_ref_U103 = 561;
Constant line_ref_U104 = 561;
Constant line_ref_U105 = 561;
Constant line_ref_U106 = 561;
Constant line_ref_U107 = 561;
Constant line_ref_U108 = 561;
Constant line_ref_U109 = 561;
Constant line_ref_U110 = 561;
Constant line_ref_U111 = 561;
Constant line_ref_U112 = 561;
Constant line_ref_U113 = 561;
Constant line_ref_U114 = 561;
Constant line_ref_U115 = 561;
Constant line_ref_U116 = 561;
Constant line_ref_U117 = 561;
Constant line_ref_U118 = 561;
Constant line_ref_U119 = 561;
Constant line_ref_U120 = 561;
Constant line_ref_U121 = 561;
Constant line_ref_U122 = 561;
Constant line_ref_U123 = 561;
Constant line_ref_U124 = 561;
Constant line_ref_U125 = 561;
Constant line_ref_U126 = 561;
Constant line_ref_U127 = 561;
Constant line_ref_U128 = 561;
Constant line_ref_U129 = 561;
Constant line_ref_U130 = 561;
Constant line_ref_U131 = 561;
Constant line_ref_U132 = 561;
Constant line_ref_U133 = 561;
Constant line_ref_U134 = 561;
Constant line_ref_U135 = 561;
Constant line_ref_U136 = 561;
Constant line_ref_U137 = 561;
Constant line_ref_U138 = 561;
Constant line_ref_U139 = 561;
Constant line_ref_U140 = 561;
Constant line_ref_U141 = 561;
Constant line_ref_U142 = 561;
Constant line_ref_U143 = 561;
Constant line_ref_U144 = 561;
Constant line_ref_U145 = 561;
Constant line_ref_U146 = 561;
Constant line_ref_U147 = 561;
Constant line_ref_U148 = 561;
Constant line_ref_U149 = 561;
Constant line_ref_U150 = 561;
Constant line_ref_U151 = 561;
Constant line_ref_U152 = 561;
Constant line_ref_U153 = 561;
Constant line_ref_U154 = 561;
Constant line_ref_U155 = 561;
Constant line_ref_U156 = 561;
Constant line_ref_U157 = 561;
Constant line_ref_U158 = 561;
Constant line_ref_U159 = 561;
Constant line_ref_U160 = 561;
Constant line_ref_U161 = 561;
Constant line_ref_U162 = 561;
Constant line_ref_U163 = 561;
Constant line_ref_U164 = 561;
Constant line_ref_U165 = 561;
Constant line_ref_U166 = 561;
Constant line_ref_U167 = 561;
Constant line_ref_U168 = 561;
Constant line_ref_U169 = 561;
Constant line_ref_U170 = 561;
Constant line_ref_U171 = 561;
Constant line_ref_U172 = 561;
Constant line_ref_U173 = 561;
Constant line_ref_U174 = 561;
Constant line_ref_U175 = 561;
Constant line_ref_U176 = 561;
Constant line_ref_U177 = 561;
Constant line_ref_U178 = 561;
Constant line_ref_U179 = 561;
Constant line_ref_U180 = 561;
Constant line_ref_U181 = 561;
Constant line_ref_U182 = 561;
Constant line_ref_U183 = 561;
Constant line_ref_U184 = 561;
Constant line_ref_U185 = 561;
Constant line_ref_U186 = 561;
Constant line_ref_U187 = 561;
Constant line_ref_U188 = 561;
Constant line_ref_U189 = 561;
Constant line_ref_U190 = 561;
Constant line_ref_U191 = 561;
Constant line_ref_U192 = 561;
Constant line_ref_U193 = 561;
Constant line_ref_U194 = 561;
Constant line_ref_U195 = 561;
Constant line_ref_U196 = 561;
Constant line_ref_U197 = 561;
Constant line_ref_U198 = 561;
Constant line_ref_U199 = 561;
Constant line_ref_U200 = 561;
Constant line_ref_U201 = 561;
Constant line_ref_U202 = 561;
Constant line_ref_U203 = 561;
Constant line_ref_U204 = 561;
Constant line_ref_U205 = 561;
Constant line_ref_U206 = 561;
Constant line_ref_U207 = 561;
Constant line_ref_U208 = 561;
Constant line_ref_U209 = 561;
Constant line_ref_U210 = 561;
Constant line_ref_U211 = 561;
Constant line_ref_U212 = 561;
Constant line_ref_U213 = 561;
Constant line_ref_U214 = 561;
Constant line_ref_U215 = 561;
Constant line_ref_U216 = 561;
Constant line_ref_U217 = 561;
Constant line_ref_U218 = 561;
Constant line_ref_U219 = 561;
Constant line_ref_U220 = 561;
Constant line_ref_U221 = 561;
Constant line_ref_U222 = 561;
Constant line_ref_U223 = 561;
Constant line_ref_U224 = 561;
Constant line_ref_U225 = 561;
Constant line_ref_U226 = 561;
Constant line_ref_U227 = 561;
Constant line_ref_U228 = 561;
Constant line_ref_U229 = 561;
Constant line_ref_U230 = 561;
Constant line_ref_U231 = 561;
Constant line_ref_U232 = 561;
Constant line_ref_U233 = 561;
Constant line_ref_U234 = 561;
Constant line_ref_U235 = 561;
Constant line_ref_U236 = 561;
Constant line_ref_U237 = 561;
Constant line_ref_U238 = 561;
Constant line_ref_U239 = 561;
Constant line_ref_U240 = 561;
Constant line_ref_U241 = 561;
Constant line_ref_U242 = 561;
Constant line_ref_U243 = 561;
Constant line_ref_U244 = 561;
Constant line_ref_U245 = 561;
Constant line_ref_U246 = 561;
Constant line_ref_U247 = 561;
Constant line_ref_U248 = 561;
Constant line_ref_U249 = 561;
Constant line_ref_U250 = 561;
Constant line_ref_U251 = 561;
Constant line_ref_U252 = 561;
Constant line_ref_U253 = 561;
Constant line_ref_U254 = 561;
Constant line_ref_U255 = 561;
Constant line_ref_U256 = 561;
Constant line_ref_U257 = 561;
Constant line_ref_U258 = 561;
Constant line_ref_U259 = 561;
Constant line_ref_U260 = 561;
Constant line_ref_U261 = 561;
Constant line_ref_U262 = 561;
Constant line_ref_U263 = 561;
Constant line_ref_U264 = 561;
Constant line_ref_U265 = 561;
Constant line_ref_U266 = 561;
Constant line_ref_U267 = 561;
Constant line_ref_U268 = 561;
Constant line_ref_U269 = 561;
Constant line_ref_U270 = 561;
Constant line_ref_U271 = 561;
Constant line_ref_U272 = 561;
Constant line_ref_U273 = 561;
Constant line_ref_U274 = 561;
Constant line_ref_U275 = 561;
Constant line_ref_U276 = 561;
Constant line_ref_U277 = 561;
Constant line_ref_U278 = 561;
Constant line_ref_U279 = 561;
Constant line_ref_U280 = 561;
Constant line_ref_U281 = 561;
Constant line_ref_U282 = 561;
Constant line_ref_U283 = 561;
Constant line_ref_U284 = 561;
Constant line_ref_U285 = 561;
Constant line_ref_U286 = 561;
Constant line_ref_U287 = 561;
Constant line_ref_U288 = 561;
Constant line_ref_U289 = 561;
Constant line_ref_U290 = 561;
Constant line_ref_U291 = 561;
Constant line_ref_U292 = 561;
Constant line_ref_U293 = 561;
Constant line_ref_U294 = 561;
Constant line_ref_U295 = 561;
Constant line_ref_U296 = 561;
Constant line_ref_U297 = 561;
Constant line_ref_U298 = 561;
Constant line_ref_U299 = 561;
Constant line_ref_U300 = 561;
Constant line_ref_U301 = 561;
Constant line_ref_U302 = 561;
Constant line_ref_U303 = 561;
Constant line_ref_U304 = 561;
Constant line_ref_U305 = 561;
Constant line_ref_U306 = 561;
Constant line_ref_U307 = 561;
Constant line_ref_U308 = 561;
Constant line_ref_U309 = 561;
Constant line_ref_U310 = 561;
Constant line_ref_U311 = 561;
Constant line_ref_U312 = 561;
Constant line_ref_U313 = 561;
Constant line_ref_U314 = 561;
Constant line_ref_U315 = 561;
Constant line_ref_U316 = 561;
Constant line_ref_U317 = 561;
Constant line_ref_U318 = 561;
Constant line_ref_U319 = 561;
Constant line_ref_U320 = 561;
Constant line_ref_U321 = 561;
Constant line_ref_U322 = 561;
Constant line_ref_U323 = 561;
Constant line_ref_U324 = 561;
Constant line_ref_U325 = 561;
Constant line_ref_U326 = 561;
Constant line_ref_U327 = 561;
Constant line_ref_U328 = 561;
Constant line_ref_U329 = 561;
Constant line_ref_U330 = 561;
Constant line_ref_U331 = 561;
Constant line_ref_U332 = 561;
Constant line_ref_U333 = 561;
Constant line_ref_U334 = 561;
Constant line_ref_U335 = 561;
Constant line_ref_U336 = 561;
Constant line_ref_U337 = 561;
Constant line_ref_U338 = 561;
Constant line_ref_U339 = 561;
Constant line_ref_U340 = 561;
Constant line_ref_U341 = 561;
Constant line_ref_U342 = 561;
Constant line_ref_U343 = 561;
Constant line_ref_U344 = 561;
Constant line_ref_U345 = 561;
Constant line_ref_U346 = 561;
Constant line_ref_U347 = 561;
Constant line_ref_U348 = 561;
Constant line_ref_U349 = 561;
Constant NO_VERB_VERB_DEFINED = 1;
Constant line_ref_U350 = 561;
Constant line_ref_U351 = 561;
Constant line_ref_U352 = 561;
Constant line_ref_U353 = 561;
Constant line_ref_U354 = 561;
Constant line_ref_U355 = 561;
Constant line_ref_U356 = 561;
Constant line_ref_U357 = 561;
Constant line_ref_U358 = 561;
Constant line_ref_U359 = 561;
Constant line_ref_U360 = 561;
Constant line_ref_U361 = 561;
Constant KIT_CONFIGURATION_BITMAP = 453;
Constant KIT_CONFIGURATION_LOOKMODE = 2;
Constant MAX_FRAME_SIZE_NEEDED = 6;
Constant RNG_SEED_AT_START_OF_PLAY = 0;
Constant id_U1 = 561;
Constant id_U2 = 561;
Constant id_U3 = 561;
Constant id_U4 = 561;
Constant id_U5 = 561;
Constant id_U6 = 561;
Constant id_U7 = 561;
Constant id_U8 = 561;
Constant id_U9 = 561;
Constant id_U10 = 561;
Constant id_U11 = 561;
Constant id_U12 = 561;
Constant id_U13 = 561;
Constant id_U14 = 561;
Constant id_U15 = 561;
Constant id_U16 = 561;
Constant id_U17 = 561;
Constant id_U18 = 561;
Constant id_U19 = 561;
Constant id_U20 = 561;
Constant id_U21 = 561;
Constant id_U22 = 561;
Constant id_U23 = 561;
Constant id_U24 = 561;
Constant id_U25 = 561;
Constant id_U26 = 561;
Constant id_U27 = 561;
Constant id_U28 = 561;
Constant id_U29 = 561;
Constant id_U30 = 561;
Constant id_U31 = 561;
Constant id_U32 = 561;
Constant id_U33 = 561;
Constant id_U34 = 561;
Constant id_U35 = 561;
Constant id_U36 = 561;
Constant id_U37 = 561;
Constant id_U38 = 561;
Constant id_U39 = 561;
Constant id_U40 = 561;
Constant id_U41 = 561;
Constant id_U42 = 561;
Constant id_U43 = 561;
Constant id_U44 = 561;
Constant id_U45 = 561;
Constant id_U46 = 561;
Constant id_U47 = 561;
Constant id_U48 = 561;
Constant id_U49 = 561;
Constant id_U50 = 561;
Constant id_U51 = 561;
Constant id_U52 = 561;
Constant id_U53 = 561;
Constant id_U54 = 561;
Constant id_U55 = 561;
Constant id_U56 = 561;
Constant id_U57 = 561;
Constant id_U58 = 561;
Constant id_U59 = 561;
Constant id_U60 = 561;
Constant id_U61 = 561;
Constant id_U62 = 561;
Constant id_U63 = 561;
Constant id_U64 = 561;
Constant id_U65 = 561;
Constant id_U66 = 561;
Constant id_U67 = 561;
Constant id_U68 = 561;
Constant id_U69 = 561;
Constant id_U70 = 561;
Constant id_U71 = 561;
Constant id_U72 = 561;
Constant id_U73 = 561;
Constant id_U74 = 561;
Constant id_U75 = 561;
Constant id_U76 = 561;
Constant id_U77 = 561;
Constant id_U78 = 561;
Constant id_U79 = 561;
Constant id_U80 = 561;
Constant id_U81 = 561;
Constant id_U82 = 561;
Constant id_U83 = 561;
Constant id_U84 = 561;
Constant id_U85 = 561;
Constant id_U86 = 561;
Constant id_U87 = 561;
Constant id_U88 = 561;
Constant id_U89 = 561;
Constant id_U90 = 561;
Constant id_U91 = 561;
Constant id_U92 = 561;
Constant id_U93 = 561;
Constant id_U94 = 561;
Constant id_U95 = 561;
Constant id_U96 = 561;
Constant id_U97 = 561;
Constant id_U98 = 561;
Constant id_U99 = 561;
Constant id_U100 = 561;
Constant id_U101 = 561;
Constant id_U102 = 561;
Constant id_U103 = 561;
Constant id_U104 = 561;
Constant id_U105 = 561;
Constant id_U106 = 561;
Constant id_U107 = 561;
Constant id_U108 = 561;
Constant id_U109 = 561;
Constant id_U110 = 561;
Constant id_U111 = 561;
Constant id_U112 = 561;
Constant id_U113 = 561;
Constant id_U114 = 561;
Constant id_U115 = 561;
Constant id_U116 = 561;
Constant id_U117 = 561;
Constant id_U118 = 561;
Constant id_U119 = 561;
Constant id_U120 = 561;
Constant id_U121 = 561;
Constant id_U122 = 561;
Constant id_U123 = 561;
Constant id_U124 = 561;
Constant id_U125 = 561;
Constant id_U126 = 561;
Constant id_U127 = 561;
Constant id_U128 = 561;
Constant id_U129 = 561;
Constant id_U130 = 561;
Constant id_U131 = 561;
Constant id_U132 = 561;
Constant id_U133 = 561;
Constant id_U134 = 561;
Constant id_U135 = 561;
Constant id_U136 = 561;
Constant id_U137 = 561;
Constant id_U138 = 561;
Constant id_U139 = 561;
Constant id_U140 = 561;
Constant id_U141 = 561;
Constant id_U142 = 561;
Constant id_U143 = 561;
Constant id_U144 = 561;
Constant id_U145 = 561;
Constant id_U146 = 561;
Constant id_U147 = 561;
Constant id_U148 = 561;
Constant id_U149 = 561;
Constant id_U150 = 561;
Constant id_U151 = 561;
Constant id_U152 = 561;
Constant id_U153 = 561;
Constant id_U154 = 561;
Constant id_U155 = 561;
Constant id_U156 = 561;
Constant id_U157 = 561;
Constant id_U158 = 561;
Constant id_U159 = 561;
Constant id_U160 = 561;
Constant id_U161 = 561;
Constant id_U162 = 561;
Constant id_U163 = 561;
Constant id_U164 = 561;
Constant id_U165 = 561;
Constant id_U166 = 561;
Constant id_U167 = 561;
Constant id_U168 = 561;
Constant id_U169 = 561;
Constant id_U170 = 561;
Constant id_U171 = 561;
Constant id_U172 = 561;
Constant id_U173 = 561;
Constant id_U174 = 561;
Constant id_U175 = 561;
Constant id_U176 = 561;
Constant id_U177 = 561;
Constant id_U178 = 561;
Constant id_U179 = 561;
Constant id_U180 = 561;
Constant id_U181 = 561;
Constant id_U182 = 561;
Constant id_U183 = 561;
Constant id_U184 = 561;
Constant id_U185 = 561;
Constant id_U186 = 561;
Constant id_U187 = 561;
Constant id_U188 = 561;
Constant id_U189 = 561;
Constant id_U190 = 561;
Constant id_U191 = 561;
Constant id_U192 = 561;
Constant id_U193 = 561;
Constant id_U194 = 561;
Constant id_U195 = 561;
Constant id_U196 = 561;
Constant id_U197 = 561;
Constant id_U198 = 561;
Constant id_U199 = 561;
Constant id_U200 = 561;
Constant id_U201 = 561;
Constant id_U202 = 561;
Constant id_U203 = 561;
Constant id_U204 = 561;
Constant id_U205 = 561;
Constant id_U206 = 561;
Constant id_U207 = 561;
Constant id_U208 = 561;
Constant id_U209 = 561;
Constant id_U210 = 561;
Constant id_U211 = 561;
Constant id_U212 = 561;
Constant id_U213 = 561;
Constant id_U214 = 561;
Constant id_U215 = 561;
Constant id_U216 = 561;
Constant id_U217 = 561;
Constant id_U218 = 561;
Constant id_U219 = 561;
Constant id_U220 = 561;
Constant id_U221 = 561;
Constant id_U222 = 561;
Constant id_U223 = 561;
Constant id_U224 = 561;
Constant id_U225 = 561;
Constant id_U226 = 561;
Constant id_U227 = 561;
Constant id_U228 = 561;
Constant id_U229 = 561;
Constant id_U230 = 561;
Constant id_U231 = 561;
Constant id_U232 = 561;
Constant id_U233 = 561;
Constant id_U234 = 561;
Constant id_U235 = 561;
Constant id_U236 = 561;
Constant id_U237 = 561;
Constant id_U238 = 561;
Constant id_U239 = 561;
Constant id_U240 = 561;
Constant id_U241 = 561;
Constant id_U242 = 561;
Constant id_U243 = 561;
Constant id_U244 = 561;
Constant id_U245 = 561;
Constant id_U246 = 561;
Constant id_U247 = 561;
Constant id_U248 = 561;
Constant id_U249 = 561;
Constant id_U250 = 561;
Constant id_U251 = 561;
Constant id_U252 = 561;
Constant id_U253 = 561;
Constant id_U254 = 561;
Constant id_U255 = 561;
Constant id_U256 = 561;
Constant id_U257 = 561;
Constant id_U258 = 561;
Constant id_U259 = 561;
Constant id_U260 = 561;
Constant id_U261 = 561;
Constant id_U262 = 561;
Constant id_U263 = 561;
Constant id_U264 = 561;
Constant id_U265 = 561;
Constant id_U266 = 561;
Constant id_U267 = 561;
Constant id_U268 = 561;
Constant id_U269 = 561;
Constant id_U270 = 561;
Constant id_U271 = 561;
Constant id_U272 = 561;
Constant id_U273 = 561;
Constant id_U274 = 561;
Constant id_U275 = 561;
Constant id_U276 = 561;
Constant id_U277 = 561;
Constant id_U278 = 561;
Constant id_U279 = 561;
Constant id_U280 = 561;
Constant id_U281 = 561;
Constant id_U282 = 561;
Constant id_U283 = 561;
Constant id_U284 = 561;
Constant id_U285 = 561;
Constant id_U286 = 561;
Constant id_U287 = 561;
Constant id_U288 = 561;
Constant id_U289 = 561;
Constant id_U290 = 561;
Constant id_U291 = 561;
Constant id_U292 = 561;
Constant id_U293 = 561;
Constant id_U294 = 561;
Constant id_U295 = 561;
Constant id_U296 = 561;
Constant id_U297 = 561;
Constant id_U298 = 561;
Constant id_U299 = 561;
Constant id_U300 = 561;
Constant id_U301 = 561;
Constant id_U302 = 561;
Constant id_U303 = 561;
Constant id_U304 = 561;
Constant id_U305 = 561;
Constant id_U306 = 561;
Constant id_U307 = 561;
Constant id_U308 = 561;
Constant id_U309 = 561;
Constant id_U310 = 561;
Constant id_U311 = 561;
Constant id_U312 = 561;
Constant id_U313 = 561;
Constant id_U314 = 561;
Constant id_U315 = 561;
Constant id_U316 = 561;
Constant id_U317 = 561;
Constant id_U318 = 561;
Constant id_U319 = 561;
Constant id_U320 = 561;
Constant id_U321 = 561;
Constant id_U322 = 561;
Constant id_U323 = 561;
Constant id_U324 = 561;
Constant id_U325 = 561;
Constant id_U326 = 561;
Constant id_U327 = 561;
Constant id_U328 = 561;
Constant id_U329 = 561;
Constant id_U330 = 561;
Constant id_U331 = 561;
Constant id_U332 = 561;
Constant id_U333 = 561;
Constant id_U334 = 561;
Constant id_U335 = 561;
Constant id_U336 = 561;
Constant id_U337 = 561;
Constant id_U338 = 561;
Constant id_U339 = 561;
Constant id_U340 = 561;
Constant id_U341 = 561;
Constant id_U342 = 561;
Constant MEMORY_HEAP_SIZE = 524288;
Constant BASICINFORMKIT = 1;
Constant HDR_MAGICNUMBER = 0;
Constant HDR_GLULXVERSION = 4;
Constant HDR_RAMSTART = 8;
Constant HDR_EXTSTART = 12;
Constant HDR_ENDMEM = 16;
Constant HDR_STACKSIZE = 20;
Constant HDR_STARTFUNC = 24;
Constant HDR_DECODINGTBL = 28;
Constant HDR_CHECKSUM = 32;
Constant ROM_INFO = 36;
Constant ROM_MEMORYLAYOUT = 40;
Constant ROM_INFORMVERSION = 44;
Constant ROM_COMPVERSION = 48;
Constant ROM_GAMERELEASE = 52;
Constant ROM_GAMESERIAL = 54;
Constant NORMAL_VMSTY = 0;
Constant HEADER_VMSTY = 3;
Constant SUBHEADER_VMSTY = 4;
Constant ALERT_VMSTY = 5;
Constant NOTE_VMSTY = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY = 8;
Constant CLR_DEFAULT = 1;
Constant CLR_BLACK = 2;
Constant CLR_RED = 3;
Constant CLR_GREEN = 4;
Constant CLR_YELLOW = 5;
Constant CLR_BLUE = 6;
Constant CLR_MAGENTA = 7;
Constant CLR_PURPLE = 7;
Constant CLR_CYAN = 8;
Constant CLR_AZURE = 8;
Constant CLR_WHITE = 9;
Constant WIN_ALL = 0;
Constant WIN_STATUS = 1;
Constant WIN_MAIN = 2;
Constant PARA_COMPLETED = 1;
Constant PARA_PROMPTSKIP = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS = 8;
Constant PARA_CONTENTEXPECTED = 16;
Constant POSSESS_PK = 256;
Constant DEFART_PK = 257;
Constant INDEFART_PK = 258;
Constant LIGHTED_PK = 259;
Constant UNLIGHTED_PK = 260;
Constant RTP_BACKDROP = 1;
Constant RTP_EXITDOOR = 2;
Constant RTP_NOEXIT = 3;
Constant RTP_CANTCHANGE = 4;
Constant RTP_IMPREL = 5;
Constant RTP_RULESTACK = 6;
Constant RTP_TOOMANYRULEBOOKS = 7;
Constant RTP_TOOMANYEVENTS = 8;
Constant RTP_BADPROPERTY = 9;
Constant RTP_UNPROVIDED = 10;
Constant RTP_UNSET = 11;
Constant RTP_TOOMANYACTS = 12;
Constant RTP_CANTABANDON = 13;
Constant RTP_CANTEND = 14;
Constant RTP_CANTMOVENOTHING = 15;
Constant RTP_CANTREMOVENOTHING = 16;
Constant RTP_DIVZERO = 17;
Constant RTP_BADVALUEPROPERTY = 18;
Constant RTP_NOTBACKDROP = 19;
Constant RTP_TABLE_NOCOL = 20;
Constant RTP_TABLE_NOCORR = 21;
Constant RTP_TABLE_NOROW = 22;
Constant RTP_TABLE_NOENTRY = 23;
Constant RTP_TABLE_NOTABLE = 24;
Constant RTP_TABLE_NOMOREBLANKS = 25;
Constant RTP_TABLE_NOROWS = 26;
Constant RTP_TABLE_CANTSORT = 27;
Constant RTP_NOTINAROOM = 28;
Constant RTP_BADTOPIC = 29;
Constant RTP_ROUTELESS = 30;
Constant RTP_PROPOFNOTHING = 31;
Constant RTP_DECIDEONWRONGKIND = 32;
Constant RTP_DECIDEONNOTHING = 33;
Constant RTP_TABLE_CANTSAVE = 34;
Constant RTP_TABLE_WONTFIT = 35;
Constant RTP_TABLE_BADFILE = 36;
Constant RTP_LOWLEVELERROR = 37;
Constant RTP_DONTIGNORETURNSEQUENCE = 38;
Constant RTP_SAYINVALIDSNIPPET = 39;
Constant RTP_SPLICEINVALIDSNIPPET = 40;
Constant RTP_INCLUDEINVALIDSNIPPET = 41;
Constant RTP_LISTWRITERMEMORY = 42;
Constant RTP_CANTREMOVEPLAYER = 43;
Constant RTP_CANTREMOVEDOORS = 44;
Constant RTP_CANTCHANGEOFFSTAGE = 45;
Constant RTP_MSTACKMEMORY = 46;
Constant RTP_TYPECHECK = 47;
Constant RTP_FILEIOERROR = 48;
Constant RTP_HEAPERROR = 49;
Constant RTP_LISTRANGEERROR = 50;
Constant RTP_REGEXPSYNTAXERROR = 51;
Constant RTP_NOGLULXUNICODE = 52;
Constant RTP_BACKDROPONLY = 53;
Constant RTP_NOTTHING = 54;
Constant RTP_SCENEHASNTSTARTED = 55;
Constant RTP_SCENEHASNTENDED = 56;
Constant RTP_NEGATIVEROOT = 57;
Constant RTP_TABLE_CANTRUNTHROUGH = 58;
Constant RTP_CANTITERATE = 59;
Constant RTP_WRONGASSIGNEDKIND = 60;
Constant RTP_CANTBEOFFSTAGE = 61;
Constant RTP_RELKINDVIOLATION = 62;
Constant RTP_CANTMAKEPART = 63;
Constant RTP_TEXTTOKENTOOHARD = 64;
Constant RTP_TABLE_NOTABLE2 = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL = 67;
Constant RTP_LISTSIZENEGATIVE = 68;
Constant RTP_REGIONSNOTADJACENT = 69;
Constant STARTING_VIRTUAL_MACHINE_ACT = 0;
Constant PRINTING_THE_NAME_ACT = 1;
Constant PRINTING_THE_PLURAL_NAME_ACT = 2;
Constant PRINTING_RESPONSE_ACT = 3;
Constant PRINTING_A_NUMBER_OF_ACT = 4;
Constant PRINTING_ROOM_DESC_DETAILS_ACT = 5;
Constant PRINTING_INVENTORY_DETAILS_ACT = 6;
Constant LISTING_CONTENTS_ACT = 7;
Constant GROUPING_TOGETHER_ACT = 8;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT = 9;
Constant LISTING_NONDESCRIPT_ITEMS_ACT = 10;
Constant PRINTING_NAME_OF_DARK_ROOM_ACT = 11;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT = 12;
Constant PRINTING_NEWS_OF_DARKNESS_ACT = 13;
Constant PRINTING_NEWS_OF_LIGHT_ACT = 14;
Constant REFUSAL_TO_ACT_IN_DARK_ACT = 15;
Constant CONSTRUCTING_STATUS_LINE_ACT = 16;
Constant PRINTING_BANNER_TEXT_ACT = 17;
Constant READING_A_COMMAND_ACT = 18;
Constant DECIDING_SCOPE_ACT = 19;
Constant DECIDING_CONCEALED_POSSESS_ACT = 20;
Constant DECIDING_WHETHER_ALL_INC_ACT = 21;
Constant CLARIFYING_PARSERS_CHOICE_ACT = 22;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT = 23;
Constant PRINTING_A_PARSER_ERROR_ACT = 24;
Constant SUPPLYING_A_MISSING_NOUN_ACT = 25;
Constant SUPPLYING_A_MISSING_SECOND_ACT = 26;
Constant IMPLICITLY_TAKING_ACT = 27;
Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 28;
Constant PRINTING_PLAYERS_OBITUARY_ACT = 29;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 30;
Constant PRINTING_LOCALE_DESCRIPTION_ACT = 31;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 32;
Constant PRINTING_LOCALE_PARAGRAPH_ACT = 33;
Constant STARTUP_RB = 0;
Constant SHUTDOWN_RB = 1;
Constant TURN_SEQUENCE_RB = 11;
Constant WHEN_PLAY_BEGINS_RB = 13;
Constant WHEN_PLAY_ENDS_RB = 14;
Constant WHEN_SCENE_BEGINS_RB = 15;
Constant WHEN_SCENE_ENDS_RB = 16;
Constant ACTION_PROCESSING_RB = 18;
Constant SETTING_ACTION_VARIABLES_RB = 19;
Constant SPECIFIC_ACTION_PROCESSING_RB = 20;
Constant ACCESSIBILITY_RB = 22;
Constant REACHING_INSIDE_RB = 23;
Constant REACHING_OUTSIDE_RB = 24;
Constant VISIBLE_RB = 25;
Constant PERSUADE_RB = 26;
Constant UNSUCCESSFUL_ATTEMPT_RB = 27;
Constant AFTER_RB = 32;
Constant REPORT_RB = 33;
Constant DOES_THE_PLAYER_MEAN_RB = 34;
Constant MULTIPLE_ACTION_PROCESSING_RB = 35;
Constant PARSING_REASON = 0;
Constant TALKING_REASON = 1;
Constant EACH_TURN_REASON = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON = 6;
Constant ILLEGAL_TT = 0;
Constant ELEMENTARY_TT = 1;
Constant PREPOSITION_TT = 2;
Constant ROUTINE_FILTER_TT = 3;
Constant ATTR_FILTER_TT = 4;
Constant SCOPE_TT = 5;
Constant GPR_TT = 6;
Constant NOUN_TOKEN = 0;
Constant HELD_TOKEN = 1;
Constant MULTI_TOKEN = 2;
Constant MULTIHELD_TOKEN = 3;
Constant MULTIEXCEPT_TOKEN = 4;
Constant MULTIINSIDE_TOKEN = 5;
Constant CREATURE_TOKEN = 6;
Constant SPECIAL_TOKEN = 7;
Constant NUMBER_TOKEN = 8;
Constant TOPIC_TOKEN = 9;
Constant ENDIT_TOKEN = 15;
Constant GPR_FAIL = -1;
Constant GPR_PREPOSITION = 0;
Constant GPR_NUMBER = 1;
Constant GPR_MULTIPLE = 2;
Constant GPR_NOUN = -256;
Constant Computed_Constant_Value_0_U2 = 1;
Constant Computed_Constant_Value_2_U2 = 2;
Constant Computed_Constant_Value_4_U1 = 3;
Constant Computed_Constant_Value_6_U1 = 4;
Constant Computed_Constant_Value_8_U1 = 5;
Constant Computed_Constant_Value_10_U1 = 6;
Constant NEWLINE_BIT = 1;
Constant INDENT_BIT = 2;
Constant FULLINV_BIT = 4;
Constant ENGLISH_BIT = 8;
Constant RECURSE_BIT = 16;
Constant ALWAYS_BIT = 32;
Constant TERSE_BIT = 64;
Constant PARTINV_BIT = 128;
Constant DEFART_BIT = 256;
Constant WORKFLAG_BIT = 512;
Constant ISARE_BIT = 1024;
Constant CONCEAL_BIT = 2048;
Constant NOARTICLE_BIT = 4096;
Constant EXTRAINDENT_BIT = 8192;
Constant CFIRSTART_BIT = 16384;
Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;
Constant list_filter_permits = A_privately_named;
Constant USE_SCORING_TCBIT = 1;
Constant PREVENT_UNDO_TCBIT = 2;
Constant SERIAL_COMMA_TCBIT = 4;
Constant PROGRAMMING_EXPONENTS_TCBIT = 8;
Constant FIX_RNG_TCBIT = 16;
Constant ECHO_COMMANDS_TCBIT = 32;
Constant NO_VERB_VERB_DEFINED_TCBIT = 64;
Constant DIALECT_US_TCBIT = 128;
Constant STORY_AUTHOR_TCBIT = 256;
Constant RANKING_TABLE_TCBIT = 512;
Constant Computed_Constant_Value_12_U1 = 4;
Constant LanguageCases = 1;
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;
Constant GLK_NULL = 0;
Constant INPUT_BUFFER_LEN = 260;
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;
Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = -7;
Constant keycode_Down = -5;
Constant keycode_End = -13;
Constant keycode_Escape = -8;
Constant keycode_Func1 = -17;
Constant keycode_Func10 = -26;
Constant keycode_Func11 = -27;
Constant keycode_Func12 = -28;
Constant keycode_Func2 = -18;
Constant keycode_Func3 = -19;
Constant keycode_Func4 = -20;
Constant keycode_Func5 = -21;
Constant keycode_Func6 = -22;
Constant keycode_Func7 = -23;
Constant keycode_Func8 = -24;
Constant keycode_Func9 = -25;
Constant keycode_Home = -12;
Constant keycode_Left = -2;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = -11;
Constant keycode_PageUp = -10;
Constant keycode_Return = -6;
Constant keycode_Right = -3;
Constant keycode_Tab = -9;
Constant keycode_Unknown = -1;
Constant keycode_Up = -4;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;
Constant GG_MAINWIN_ROCK = 201;
Constant GG_STATUSWIN_ROCK = 202;
Constant GG_QUOTEWIN_ROCK = 203;
Constant GG_SAVESTR_ROCK = 301;
Constant GG_SCRIPTSTR_ROCK = 302;
Constant GG_COMMANDWSTR_ROCK = 303;
Constant GG_COMMANDRSTR_ROCK = 304;
Constant GG_SCRIPTFREF_ROCK = 401;
Constant GG_FOREGROUNDCHAN_ROCK = 410;
Constant GG_BACKGROUNDCHAN_ROCK = 411;
Constant GG_ANYTOSTRING_LEN = 66;
Constant M_0 = 0;
Constant M_1 = 1065353216;
Constant M_HALF = 1056964608;
Constant M_THIRD = 1051372203;
Constant M_LOG10 = 1075010958;
Constant M_N1 = -1082130432;
Constant M_PI = 1078530011;
Constant M_NPI = -1068953637;
Constant M_2PI = 1086918619;
Constant M_PI2 = 1070141403;
Constant M_NPI2 = -1077342245;
Constant M_E = 1076754516;
Constant M_E2 = 1089237798;
Constant M_N0 = -2147483648;
Constant M_INF = 2139095040;
Constant M_NINF = -8388608;
Constant M_NAN = 2139095041;
Constant M_NNAN = -8388607;
Constant AUXF_MAGIC = 0;
Constant AUXF_MAGIC_VALUE = 16339;
Constant AUXF_STATUS = 1;
Constant AUXF_STATUS_IS_CLOSED = 1;
Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2;
Constant AUXF_STREAM = 3;
Constant AUXF_FILENAME = 4;
Constant AUXF_IFID_OF_OWNER = 5;
Constant TB_COLUMN_REAL = 32768;
Constant TB_COLUMN_SIGNED = 16384;
Constant TB_COLUMN_TOPIC = 8192;
Constant TB_COLUMN_DONTSORTME = 4096;
Constant TB_COLUMN_NOBLANKBITS = 2048;
Constant TB_COLUMN_CANEXCHANGE = 1024;
Constant TB_COLUMN_ALLOCATED = 512;
Constant TB_COLUMN_NUMBER = 511;
Constant COL_HSIZE = 2;
Constant Computed_Constant_Value_16_U1 = 2;
Constant MSTACK_CAPACITY = 20;
Constant RS_NEITHER = 0;
Constant RS_SUCCEEDS = 1;
Constant RS_FAILS = 2;
Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = 1;
Constant BLK_FLAG_16_BIT = 2;
Constant BLK_FLAG_WORD = 4;
Constant BLK_FLAG_RESIDENT = 8;
Constant BLK_FLAG_TRUNCMULT = 16;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;
Constant Computed_Constant_Value_19_U1 = 3;
Constant Computed_Constant_Value_21_U1 = 2;
Constant BLK_NEXT = 3;
Constant BLK_PREV = 4;
Constant SMALLEST_BLK_WORTH_ALLOCATING = 12;
Constant BLK_BVBITMAP = 255;
Constant BLK_BVBITMAP_LONGBLOCK = 16;
Constant BLK_BVBITMAP_TEXT = 32;
Constant BLK_BVBITMAP_CONSTANT = 64;
Constant BLK_BVBITMAP_LONGBLOCKMASK = -240;
Constant BLK_BVBITMAP_TEXTMASK = -224;
Constant BLK_BVBITMAP_CONSTANTMASK = -192;
Constant CREATE_KOVS = 1;
Constant CAST_KOVS = 2;
Constant DESTROY_KOVS = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS = 5;
Constant EXTENT_KOVS = 6;
Constant COPYQUICK_KOVS = 7;
Constant COPYSB_KOVS = 8;
Constant KINDDATA_KOVS = 9;
Constant COPY_KOVS = 10;
Constant COMPARE_KOVS = 11;
Constant READ_FILE_KOVS = 12;
Constant WRITE_FILE_KOVS = 13;
Constant HASH_KOVS = 14;
Constant DEBUG_KOVS = 15;
Constant Computed_Constant_Value_26_U1 = 1;
Constant Computed_Constant_Value_29_U1 = 2;
Constant Computed_Constant_Value_31_U1 = 3;
Constant Computed_Constant_Value_34_U1 = 4;
Constant Large_Unicode_Tables = 0;
Constant TEXT_TY_NoBuffers = 2;
Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;
Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;
Constant UNIC_NCT = 10000;
Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;
Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;
Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;
Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;
Constant SENSITIVITY_RE_CC = -50;
Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;
Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;
Constant LIST_ITEM_KOV_F = 0;
Constant LIST_LENGTH_F = 1;
Constant LIST_ITEM_BASE = 2;
Constant COMBINATION_KIND_F = 0;
Constant COMBINATION_ITEM_BASE = 1;
Constant Computed_Constant_Value_42_U1 = 5;
Constant Computed_Constant_Value_44_U1 = 5;
Constant Computed_Constant_Value_46_U1 = 5;
Constant Computed_Constant_Value_48_U1 = 5;
Constant Computed_Constant_Value_50_U1 = 5;
Constant Computed_Constant_Value_52_U1 = 5;
Constant RRV_USED = 6;
Constant RRV_FILLED = 7;
Constant RRV_DATA_BASE = 8;
Constant RRVAL_V_TO_V = 0;
Constant RRF_USED = 1;
Constant RRF_DELETED = 2;
Constant RRF_SINGLE = 4;
Constant RRF_HASX = 16;
Constant RRF_HASY = 32;
Constant RRF_ENTKEYX = 64;
Constant RRF_ENTKEYY = 128;
Constant RELS_COPY = 32;
Constant RELS_DESTROY = 16;
Constant RELS_EMPTY = 3;
Constant RELS_SET_VALENCY = 5;
Constant RLANY_GET_X = 1;
Constant RLANY_GET_Y = 2;
Constant RLANY_CAN_GET_X = 3;
Constant RLANY_CAN_GET_Y = 4;
Constant RLIST_ALL_X = 1;
Constant RLIST_ALL_Y = 2;
Constant RLIST_ALL_PAIRS = 3;
Constant RRP_MIN_SIZE = 8;
Constant RRP_PERTURB_SHIFT = 5;
Constant MINUS_RRP_PERTURB_SHIFT = -5;
Constant RRP_RESIZE_SMALL = 4;
Constant RRP_RESIZE_LARGE = 2;
Constant RRP_LARGE_IS = 256;
Constant RRP_CROWDED_IS = 2;
Constant RR_NAME = 5;
Constant RR_PERMISSIONS = 6;
Constant RR_STORAGE = 7;
Constant RR_KIND = 8;
Constant RR_HANDLER = 9;
Constant RR_DESCRIPTION = 10;
Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;
Constant Computed_Constant_Value_61_U1 = 32;
Constant MAX_TIMERS = 0;
Constant Computed_Constant_Value_14_U1 = 1;
Constant Computed_Constant_Value_37_U1 = 2;
Constant property_id_U155 = 154;
Constant property_id_U156 = 155;
Constant property_id_U157 = 156;
Constant property_id_U158 = 157;
Constant property_id_U159 = 158;
Constant property_id_U160 = 159;
Constant property_id_U161 = 160;
Constant property_id_U162 = 161;
Constant property_id_U163 = 162;
Constant property_id_U164 = 163;
Constant property_id_U165 = 164;
Constant property_id_U166 = 165;
Constant property_id_U167 = 166;
Constant property_id_U168 = 167;
Constant property_id_U169 = 168;
Constant property_id_U170 = 169;
Constant property_id_U171 = 170;
Constant property_id_U172 = 171;
Constant property_id_U173 = 172;
Constant property_id_U174 = 173;
Constant property_id_U175 = 174;
Constant property_id_U176 = 175;
Constant property_id_U177 = 176;
Constant property_id_U178 = 177;
Constant property_id_U179 = 178;
Constant property_id_U180 = 179;
Constant property_id_U181 = 180;
Constant property_id_U182 = 181;
Constant property_id_U183 = 182;
Constant property_id_U184 = 183;
Constant property_id_U185 = 184;
Constant property_id_U186 = 185;
Constant property_id_U187 = 186;
Constant property_id_U188 = 187;
Constant property_id_U189 = 188;
Constant property_id_U190 = 189;
Constant property_id_U191 = 190;
Constant property_id_U192 = 191;
Constant property_id_U193 = 192;
Constant property_id_U194 = 193;
Constant property_id_U195 = 194;
Constant property_id_U196 = 195;
Constant property_id_U197 = 196;
Constant property_id_U198 = 197;
Constant property_id_U199 = 198;
Constant property_id_U200 = 199;
Constant property_id_U201 = 200;
Constant property_id_U202 = 201;
Constant property_id_U203 = 202;
Constant property_id_U204 = 203;
Constant property_id_U205 = 204;
Constant property_id_U206 = 205;
Constant property_id_U207 = 206;
Constant property_id_U208 = 207;
Constant property_id_U209 = 208;
Constant property_id_U210 = 209;
Constant property_id_U211 = 210;
Constant property_id_U212 = 211;
Constant property_id_U213 = 212;
Constant property_id_U214 = 213;
Constant property_id_U215 = 214;
Constant property_id_U216 = 215;
Constant property_id_U217 = 216;
Constant property_id_U218 = 217;
Constant property_id_U219 = 218;
Constant property_id_U220 = 219;
Constant property_id_U221 = 220;
Constant property_id_U222 = 221;
Constant property_id_U223 = 222;
Constant property_id_U224 = 223;
Constant property_id_U225 = 224;
Constant property_id_U226 = 225;
Constant property_id_U227 = 226;
Constant property_id_U228 = 227;
Constant property_id_U229 = 228;
Constant ENGLISHLANGUAGEKIT = 1;
Constant AGAIN1__WD = 'again';
Constant AGAIN2__WD = 'g//';
Constant AGAIN3__WD = 'again';
Constant OOPS1__WD = 'oops';
Constant OOPS2__WD = 'o//';
Constant OOPS3__WD = 'oops';
Constant UNDO1__WD = 'undo';
Constant UNDO2__WD = 'undo';
Constant UNDO3__WD = 'undo';
Constant ALL1__WD = 'all';
Constant ALL2__WD = 'each';
Constant ALL3__WD = 'every';
Constant ALL4__WD = 'everything';
Constant ALL5__WD = 'both';
Constant AND1__WD = 'and';
Constant AND2__WD = 'and';
Constant AND3__WD = 'and';
Constant BUT1__WD = 'but';
Constant BUT2__WD = 'except';
Constant BUT3__WD = 'but';
Constant ME1__WD = 'me';
Constant ME2__WD = 'myself';
Constant ME3__WD = 'self';
Constant OF1__WD = 'of';
Constant OF2__WD = 'of';
Constant OF3__WD = 'of';
Constant OF4__WD = 'of';
Constant OTHER1__WD = 'another';
Constant OTHER2__WD = 'other';
Constant OTHER3__WD = 'other';
Constant THEN1__WD = 'then';
Constant THEN2__WD = 'then';
Constant THEN3__WD = 'then';
Constant NO1__WD = 'n//';
Constant NO2__WD = 'no';
Constant NO3__WD = 'no';
Constant YES1__WD = 'y//';
Constant YES2__WD = 'yes';
Constant YES3__WD = 'yes';
Constant AMUSING__WD = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD = 'q//';
Constant QUIT2__WD = 'quit';
Constant RESTART__WD = 'restart';
Constant RESTORE__WD = 'restore';
Constant LanguageAnimateGender = A_male;
Constant LanguageInanimateGender = A_neuter;
Constant LanguageContractionForms = 2;
Constant WORLDMODELKIT = 1;
Constant Computed_Constant_Value_0_U3 = 2;
Constant Computed_Constant_Value_2_U3 = 3;
Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;
Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3;
Constant AD_ACTION = 0;
Constant AD_REQUIREMENTS = 1;
Constant AD_NOUN_KOV = 2;
Constant AD_SECOND_KOV = 3;
Constant AD_VARIABLES_CREATOR = 4;
Constant AD_VARIABLES_ID = 5;
Constant AD_RECORD_SIZE = 6;
Constant TOUCH_NOUN_ABIT = 1;
Constant TOUCH_SECOND_ABIT = 2;
Constant LIGHT_ABIT = 4;
Constant NEED_NOUN_ABIT = 8;
Constant NEED_SECOND_ABIT = 16;
Constant OUT_OF_WORLD_ABIT = 32;
Constant CARRY_NOUN_ABIT = 64;
Constant CARRY_SECOND_ABIT = 128;
Constant MAX_NESTED_ACTIVITIES = 20;
Constant FAST_ROUTE_FINDING = 0;
Constant TEST_STACK_SIZE = 128;
Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;
Constant Computed_Constant_Value_4_U2 = 0;
Constant Computed_Constant_Value_6_U2 = 5;
Constant Computed_Constant_Value_8_U2 = 1;
Constant Computed_Constant_Value_11_U2 = 1;
Constant Computed_Constant_Value_13_U2 = 1;
Constant Computed_Constant_Value_15_U2 = 1;
Constant Computed_Constant_Value_17_U2 = 1;
Constant Computed_Constant_Value_19_U2 = 1;
Constant Computed_Constant_Value_21_U2 = 1;
Constant action_id_U103 = 102;
Constant action_id_U104 = 103;
Constant action_id_U105 = 104;
Constant action_id_U106 = 105;
Constant action_id_U107 = 106;
Constant action_id_U108 = 107;
Constant action_id_U109 = 108;
Constant action_id_U110 = 109;
Constant action_id_U111 = 110;
Constant action_id_U112 = 111;
Constant action_id_U113 = 112;
Constant action_id_U114 = 113;
Constant action_id_U115 = 114;
Constant action_id_U116 = 115;
Constant action_id_U117 = 116;
Constant action_id_U118 = 117;
Constant action_id_U119 = 118;
Constant action_id_U120 = 119;
Constant action_id_U121 = 120;
Constant action_id_U122 = 121;
Constant action_id_U123 = 122;
Constant action_id_U124 = 123;
Constant action_id_U125 = 124;
Constant COMMANDPARSERKIT = 1;
Constant STUCK_PE = 1;
Constant UPTO_PE = 2;
Constant NUMBER_PE = 3;
Constant ANIMA_PE = 4;
Constant CANTSEE_PE = 5;
Constant TOOLIT_PE = 6;
Constant NOTHELD_PE = 7;
Constant MULTI_PE = 8;
Constant MMULTI_PE = 9;
Constant VAGUE_PE = 10;
Constant EXCEPT_PE = 11;
Constant VERB_PE = 12;
Constant SCENERY_PE = 13;
Constant ITGONE_PE = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE = 16;
Constant NOTHING_PE = 17;
Constant ASKSCOPE_PE = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20;
Constant ANIMAAGAIN_PE = 21;
Constant COMMABEGIN_PE = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE = 24;
Constant TOTALK_PE = 25;
Constant PATTERN_NULL = 65535;
Constant INDEF_ALL_WANTED = 32767;
Constant comma_word = 'comma,';
Constant OTHER_BIT = 1;
Constant MY_BIT = 2;
Constant THAT_BIT = 4;
Constant PLURAL_BIT = 8;
Constant LIT_BIT = 16;
Constant UNLIT_BIT = 32;
Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;
Constant PREFER_HELD = 0;
Constant HIGHEST_DPMR_SCORE = 4;
Constant Computed_Constant_Value_0_U4 = 1;
Constant EMPTY_TEXT_PACKED = "";
Constant alphabetised_text_0 = " ";
Constant alphabetised_text_1 = " N = Next";
Constant alphabetised_text_2 = " P = Previous";
Constant alphabetised_text_3 = " The generator room is a compact, utilitarian space where the lifeblood of the carnival's power is produced. Its reinforced concrete walls bear grime, oil streaks, and faint graffiti from past workers. The air carries a mix of diesel, hot metal, ozone, and damp earth, creating a distinctly industrial scent.^^At the center, the main generator hums steadily, its scuffed steel casing evidence of years of service. Thick rubberized cables extend from it like veins, connecting to junction boxes and circuit breakers along the walls. A large panel nearby is cluttered with buttons, switches, and gauges, many with faded labels like ~Fuel Intake~ and ~Emergency Shutoff.~ A flickering display screen shows power levels and load distribution.^^The rough concrete floor is uneven, marked by small puddles of spilled fuel or condensation. Shelves along the walls hold spare parts - filters, spark plugs, and wire coils - while tools lie scattered on a workbench beside a grease canister and a worn maintenance manual.^^A single industrial bulb in a protective cage casts harsh light, leaving deep shadows across the machinery. In the corner, a vent fan whirs faintly, struggling to cool the warm, vibrating air. A row of diesel canisters gleams beneath a faded safety poster that warns, ~Fuel Safely - No Open Flames!~^^Though isolated and utilitarian, the generator room is the carnival's heartbeat, powering its lights, rides, and sounds. Its quiet separation from the carnival's chaos serves as a stark reminder of the machinery driving the magic.^^The backstage area continues north and south of here. There is a wooden door to the west.";
Constant alphabetised_text_4 = "1";
Constant I7_FULL_VERSION_NUMBER = "10.1.2";
Constant I7_VERSION_NUMBER = "10.1.2";
Constant alphabetised_text_5 = "2";
Serial "250119";
Constant alphabetised_text_6 = "3";
Constant alphabetised_text_7 = "4";
Constant alphabetised_text_8 = "5";
Constant alphabetised_text_9 = "6";
Constant alphabetised_text_10 = ">";
Constant alphabetised_text_11 = "A car waits to take you through the horror that is Hell Ride.";
Constant alphabetised_text_12 = "A faux leather seat that looked great when it was new.";
Constant alphabetised_text_13 = "A spiked chair looms in the corner, its cruel design gleaming faintly in the dim light.";
Constant alphabetised_text_14 = "A teddy bear to make up with your sweetie?";
Constant alphabetised_text_15 = "About Interactive Fiction";
Constant alphabetised_text_16 = "Acquiring the Aqua fuse";
Constant alphabetised_text_17 = "Acquiring the Emerald fuse";
Constant alphabetised_text_18 = "Acquiring the Gray fuse";
Constant alphabetised_text_19 = "Acquiring the Indigo fuse";
Constant alphabetised_text_20 = "Acquiring the Khaki fuse";
Constant alphabetised_text_21 = "Aerosmith";
Constant alphabetised_text_22 = "Africa";
Constant alphabetised_text_23 = "Aja";
Constant alphabetised_text_24 = "Are the doors important?";
Constant alphabetised_text_25 = "Are the fuses important?";
Constant alphabetised_text_26 = "Are the prizes important?";
Constant alphabetised_text_27 = "Are you sure?";
Constant alphabetised_text_28 = "Aretha Franklin";
Constant alphabetised_text_29 = "At the center of the square stands a raised wooden platform, stark and imposing, where the grim sentence is to be carried out.";
Constant alphabetised_text_30 = "At the center of the square, rising like a grim monument to mortality, stands the gallows - a wooden platform, darkened by age and weather, with thick ropes hanging like vipers poised to strike.";
Constant alphabetised_text_31 = "Back Stage";
Constant alphabetised_text_32 = "Barker";
Constant alphabetised_text_33 = "Be creative";
Constant alphabetised_text_34 = "Ben E. King";
Constant alphabetised_text_35 = "Billy Joel";
Constant alphabetised_text_36 = "Blondie";
Constant alphabetised_text_37 = "Blueberries";
Constant alphabetised_text_38 = "Bob Marley";
Constant alphabetised_text_39 = "Bob Seger";
Constant alphabetised_text_40 = "Bohemian Rhapsody";
Constant alphabetised_text_41 = "Born To Run";
Constant alphabetised_text_42 = "Boston";
Constant alphabetised_text_43 = "Bringing the wrench to the Bumper Cars";
Constant alphabetised_text_44 = "Brown Eyed Girl";
Constant alphabetised_text_45 = "Bruce Springsteen";
Constant alphabetised_text_46 = "Bruddah Iz";
Constant alphabetised_text_47 = "Bubblegum";
Constant alphabetised_text_48 = "Bumper Cars Ride";
Constant alphabetised_text_49 = "Bumper Cars attendant";
Constant alphabetised_text_50 = "Bumper Cars ticket";
Constant alphabetised_text_51 = "Buy the parking ticket.";
Constant alphabetised_text_52 = "Buying the Hell Ride ticket";
Constant alphabetised_text_53 = "Can I ride the rides?";
Constant alphabetised_text_54 = "Can you go in the direction you intend?";
Constant alphabetised_text_55 = "Car Interior";
Constant alphabetised_text_56 = "Carousel Ride";
Constant alphabetised_text_57 = "Carousel attendant";
Constant alphabetised_text_58 = "Carousel ticket";
Constant alphabetised_text_59 = "Cat Stevens";
Constant alphabetised_text_60 = "Chains";
Constant alphabetised_text_61 = "Channel locks";
Constant alphabetised_text_62 = "Comfortably Numb";
Constant alphabetised_text_63 = "Concession Stand";
Constant alphabetised_text_64 = "Contacting the Author";
Constant alphabetised_text_65 = "Containment";
Constant alphabetised_text_66 = "Control Panel Eleven";
Constant alphabetised_text_67 = "Control Panel Five";
Constant alphabetised_text_68 = "Control Panel Nine";
Constant alphabetised_text_69 = "Control Panel One";
Constant alphabetised_text_70 = "Control Panel Seven";
Constant alphabetised_text_71 = "Control Panel Three";
Constant alphabetised_text_72 = "Control Room";
Constant alphabetised_text_73 = "Controlling the Game";
Constant alphabetised_text_74 = "Cooperate";
Constant alphabetised_text_75 = "Cotton candy";
Constant alphabetised_text_76 = "Crawl Space";
Constant alphabetised_text_77 = "Dark Hallway";
Constant alphabetised_text_78 = "Dark Passage";
Constant alphabetised_text_79 = "Dave Edmunds";
Constant alphabetised_text_80 = "David Bowie";
Constant alphabetised_text_81 = "Devil horns";
Constant alphabetised_text_82 = "Did you die because your hands were unprotected?";
Constant alphabetised_text_83 = "Did you notice it chop you in half?";
Constant alphabetised_text_84 = "Did you notice the guillotine rising and falling?";
Constant alphabetised_text_85 = "Dime Toss Game";
Constant alphabetised_text_86 = "Dime Toss attendant";
Constant alphabetised_text_87 = "Dime Toss booth";
Constant alphabetised_text_88 = "Do you have a light?";
Constant alphabetised_text_89 = "Dolly Parton";
Constant alphabetised_text_90 = "Dream On";
Constant alphabetised_text_91 = "Dungeon";
Constant alphabetised_text_92 = "Dusty Springfield";
Constant alphabetised_text_93 = "ENTER = Select";
Constant alphabetised_text_94 = "Each room shows a different manner of punishment.";
Constant alphabetised_text_95 = "Eating the blueberries";
Constant alphabetised_text_96 = "Electrical Area";
Constant alphabetised_text_97 = "Electrical Closet Eleven";
Constant alphabetised_text_98 = "Electrical Closet Five";
Constant alphabetised_text_99 = "Electrical Closet Nine";
Constant alphabetised_text_100 = "Electrical Closet One";
Constant alphabetised_text_101 = "Electrical Closet Seven";
Constant alphabetised_text_102 = "Electrical Closet Three";
Constant alphabetised_text_103 = "Electrical Room";
Constant alphabetised_text_104 = "Elvis Presley";
Constant alphabetised_text_105 = "Everybody dies.";
Constant alphabetised_text_106 = "Everything sure looks realistic.";
Constant alphabetised_text_107 = "Explore";
Constant alphabetised_text_108 = "Ferris Wheel Ride";
Constant alphabetised_text_109 = "Ferris Wheel attendant";
Constant alphabetised_text_110 = "Ferris Wheel ticket";
Constant alphabetised_text_111 = "Finding the Control Room";
Constant alphabetised_text_112 = "Finding the Dark Passage";
Constant alphabetised_text_113 = "Finding the coins and keys";
Constant alphabetised_text_114 = "Five cents, a nickel. And very shiny.";
Constant alphabetised_text_115 = "Flipping the Aqua switch";
Constant alphabetised_text_116 = "Flipping the Crimson switch";
Constant alphabetised_text_117 = "Flipping the Emerald switch";
Constant alphabetised_text_118 = "Flipping the Gray switch";
Constant alphabetised_text_119 = "Flipping the Indigo switch";
Constant alphabetised_text_120 = "Flipping the Khaki switch";
Constant alphabetised_text_121 = "Folsom Prison Blues";
Constant alphabetised_text_122 = "Fool In The Rain";
Constant alphabetised_text_123 = "Fortune Teller Booth";
Constant alphabetised_text_124 = "Fortune Teller ticket";
Constant alphabetised_text_125 = "Friday I'm In Love";
Constant alphabetised_text_126 = "Gallows Room";
Constant alphabetised_text_127 = "Generator Room";
Constant alphabetised_text_128 = "Getting Started";
Constant alphabetised_text_129 = "Graffiti";
Constant alphabetised_text_130 = "Grues love the dark.";
Constant alphabetised_text_131 = "Guillotine Room";
Constant alphabetised_text_132 = "Happy";
Constant alphabetised_text_133 = "Have you looked at it?";
Constant alphabetised_text_134 = "Have you looked for one?";
Constant alphabetised_text_135 = "Have you mapped the area?";
Constant alphabetised_text_136 = "Have you put a fuse in a socket?";
Constant alphabetised_text_137 = "Have you ridden Hell Ride?";
Constant alphabetised_text_138 = "Have you seen these colors before?";
Constant alphabetised_text_139 = "Have you seen those colors before?";
Constant alphabetised_text_140 = "Have you tried turning it off?";
Constant alphabetised_text_141 = "Have you tried unlocking it?";
Constant alphabetised_text_142 = "He wonders how is he supposed to look cool dressed in this awful uniform.";
Constant alphabetised_text_143 = "Head of the Line";
Constant alphabetised_text_144 = "Heart Of Glass";
Constant alphabetised_text_145 = "Hell Ride";
Constant alphabetised_text_146 = "Hell Ride attendant";
Constant alphabetised_text_147 = "Hell Ride car";
Constant alphabetised_text_148 = "Hell Ride ticket";
Constant alphabetised_text_149 = "HellRide";
Constant alphabetised_text_150 = "Here is a man dressed in black pants, a white shirt,a striped vest, a fez, and a dazzling smile.";
Constant alphabetised_text_151 = "Hey! Is that a two dollar bill on the ground?";
Constant alphabetised_text_152 = "High Striker";
Constant alphabetised_text_153 = "His mind is completely blank.";
Constant alphabetised_text_154 = "His thoughts are entirely focused on a cheeseburger for lunch.";
Constant alphabetised_text_155 = "Holding Room";
Constant alphabetised_text_156 = "Horror";
Constant alphabetised_text_157 = "How the World is Assembled";
Constant alphabetised_text_158 = "Hydraulic tubing";
Constant alphabetised_text_159 = "I Hear You Knocking";
Constant alphabetised_text_160 = "I am a room to hold things.";
Constant alphabetised_text_161 = "If You Get Stuck";
Constant alphabetised_text_162 = "In the dimly lit tent, you see that the stage is decorated to resemble an exotic Middle Eastern market or palace, featuring rich, colorful fabrics, brass ornaments, and lanterns casting a warm, flickering glow. Scents of incense waft through the air, enhancing the atmosphere of mystique. The backdrop displays painted scenes of pyramids, desert landscapes, and domed structures evoking a sense of being transported to the ~Middle East~. ";
Constant alphabetised_text_163 = "Instructions";
Constant alphabetised_text_164 = "Instructions for Play";
Constant alphabetised_text_165 = "Is there a number that corresponds to each color?";
Constant alphabetised_text_166 = "Is your car parked legally?";
Constant alphabetised_text_167 = "It has a picture of Thomas Jefferson on it.";
Constant alphabetised_text_168 = "It is glowing red with an infernal heat.";
Constant alphabetised_text_169 = "It looks like you could set something there.";
Constant alphabetised_text_170 = "Jimmy Buffet";
Constant alphabetised_text_171 = "Johnny Cash";
Constant alphabetised_text_172 = "Jolene";
Constant alphabetised_text_173 = "Just be grateful";
Constant alphabetised_text_174 = "Just your typical ride in the dark.";
Constant alphabetised_text_175 = "Kermit the Frog";
Constant alphabetised_text_176 = "King of the Road";
Constant alphabetised_text_177 = "Kodachrome";
Constant alphabetised_text_178 = "Led Zeppelin";
Constant alphabetised_text_179 = "Little Egypt";
Constant alphabetised_text_180 = "Little Egypt emerges draped in flowing silk veils which she skillfully uses as part of the dance. Her attire consists of a sparkling, sequined bodice and a flowing skirt, adorned with jingling coin belts and jewelry that accentuate her movements.";
Constant alphabetised_text_181 = "Little Egypt is an exotic looking, beautiful woman who is draped in flowing silk veils which she skillfully uses as part of the dance. Her attire consists of a sparkling, sequined bodice and a flowing skirt, adorned with jingling coin belts and jewelry that accentuate her movements.";
Constant alphabetised_text_182 = "Little Egypt makes eye contact with you and smiles enigmatically. During her performance she balances a sword on her head and accents her dance with finger cymbals.";
Constant alphabetised_text_183 = "Look under the car seat.";
Constant alphabetised_text_184 = "Looking at the notes all you can see are the illegible scribbles of a child.";
Constant alphabetised_text_185 = "Looks like a fuse will fit in the socket.";
Constant alphabetised_text_186 = "Looks like you need a parking ticket.";
Constant alphabetised_text_187 = "Looks like you need something before heading into the carnival.";
Constant alphabetised_text_188 = "Losing My Religion";
Constant alphabetised_text_189 = "Lou Reed and the Velvet Underground";
Constant alphabetised_text_190 = "Maintenance Office";
Constant alphabetised_text_191 = "Margaritaville";
Constant alphabetised_text_192 = "Mechanical Room North";
Constant alphabetised_text_193 = "Mechanical Room South";
Constant alphabetised_text_194 = "Melt With You";
Constant alphabetised_text_195 = "Midway";
Constant alphabetised_text_196 = "Modern English";
Constant alphabetised_text_197 = "More That A Feeling";
Constant alphabetised_text_198 = "Most IF games are set in a world made up of rooms without internal division. Movement between rooms is possible; movement within a room does not always amount to anything. >WALK OVER TO THE DESK is rarely a useful sort of command. On the other hand, if something is described as being high or out of reach, it is sometimes relevant to stand on an object to increase your height. This kind of activity tends to be important only if prompted by the game text.";
Constant alphabetised_text_199 = "Most of the actions you can perform in the world of IF are brief and specific. >WALK WEST or >OPEN DOOR are likely to be provided. >TAKE A JOURNEY or >BUILD A TABLE are not. Things like >GO TO THE HOTEL are on the borderline: some games allow them, but most do not. In general, abstract, multi-stage behavior usually has to be broken down in order for the game to understand it. ";
Constant alphabetised_text_200 = "Mysterious Woman";
Constant alphabetised_text_201 = "Neil Diamond";
Constant alphabetised_text_202 = "Never Gonna Give You Up";
Constant alphabetised_text_203 = "No Shoes";
Constant alphabetised_text_204 = "No Woman, No Cry";
Constant alphabetised_text_205 = "Objects";
Constant alphabetised_text_206 = "Oh, come now, isn't it obvious?";
Constant alphabetised_text_207 = "One is in the Dark Passage.";
Constant alphabetised_text_208 = "One thing that IF does tend to model thoroughly is containment. Is something in or on something else? The game keeps track of this, and many puzzles have to do with where things are -- in the player's possession, lying on the floor of the room, on a table, in a box, etc.";
Constant alphabetised_text_209 = "Other Characters";
Constant alphabetised_text_210 = "Other characters in IF games are sometimes rather limited. On the other hand, there are also games in which character interaction is the main point of the game. You should be able to get a feel early on for the characters -- if they seem to respond to a lot of questions, remember what they're told, move around on their own, etc., then they may be fairly important. If they have a lot of stock responses and don't seem to have been the game designer's main concern, then they are most likely present either as local color or to provide the solution to a specific puzzle or set of puzzles. Characters in very puzzle-oriented games often have to be bribed, threatened, or cajoled into doing something that the player cannot do -- giving up a piece of information or an object, reaching something high, allowing the player into a restricted area, and so on.";
Constant alphabetised_text_211 = "Over The Rainbow";
Constant alphabetised_text_212 = "Parking Lot";
Constant alphabetised_text_213 = "Paul Simon";
Constant alphabetised_text_214 = "Peace Train";
Constant alphabetised_text_215 = "Pharell";
Constant alphabetised_text_216 = "Piano Man";
Constant alphabetised_text_217 = "Pink Floyd";
Constant alphabetised_text_218 = "Pitcher's Mound";
Constant alphabetised_text_219 = "Pitcher's Mound attendant";
Constant alphabetised_text_220 = "Plastic bones";
Constant alphabetised_text_221 = "Play with someone else. Two heads are often better than one. If that doesn't work, try emailing the author or (better yet) posting a request for hints on the newsgroup rec.games.int-fiction.  For best results, put the name of the game you want help with in the subject line; then leave a page or so of blank spoiler space (so that no one will read about where you got to in the game unless they've already played it), and describe your problem as clearly as possible.  Someone will probably be able to tell you how to get around it.";
Constant alphabetised_text_222 = "Pliers";
Constant alphabetised_text_223 = "Psycho Killer";
Constant alphabetised_text_224 = "Push the indigo button.";
Constant alphabetised_text_225 = "Put the stub on the dashboard.";
Constant alphabetised_text_226 = "QUIT";
Constant alphabetised_text_227 = "Queen";
Constant alphabetised_text_228 = "R.E.M.";
Constant alphabetised_text_229 = "RESTART";
Constant alphabetised_text_230 = "RESTORE a saved game";
Constant alphabetised_text_231 = "Rainbow Connection";
Constant alphabetised_text_232 = "Read carefully";
Constant alphabetised_text_233 = "Remember that you know how to macrame.";
Constant alphabetised_text_234 = "Respect";
Constant alphabetised_text_235 = "Rick Astley";
Constant alphabetised_text_236 = "Ride Entrance";
Constant alphabetised_text_237 = "Ride Exit";
Constant alphabetised_text_238 = "Ripple";
Constant alphabetised_text_239 = "Roger Miller";
Constant alphabetised_text_240 = "Rooms and Travel";
Constant alphabetised_text_241 = "Sailor";
Constant alphabetised_text_242 = "Sample Hint";
Constant alphabetised_text_243 = "Scissors";
Constant alphabetised_text_244 = "Screws, grease jars, and cans of paint are here.";
Constant alphabetised_text_245 = "Second Floor";
Constant alphabetised_text_246 = "Settings";
Constant alphabetised_text_247 = "Shake It Off";
Constant alphabetised_text_248 = "Show Facade";
Constant alphabetised_text_249 = "Show Tent";
Constant alphabetised_text_250 = "Smokey Robinson";
Constant alphabetised_text_251 = "Son Of A Preacher Man";
Constant alphabetised_text_252 = "Space";
Constant alphabetised_text_253 = "Spin the dials to the right number.";
Constant alphabetised_text_254 = "Stage";
Constant alphabetised_text_255 = "Stake Room";
Constant alphabetised_text_256 = "Stakes";
Constant alphabetised_text_257 = "Stand By Me";
Constant alphabetised_text_258 = "Steely Dan";
Constant alphabetised_text_259 = "Stocks Room";
Constant alphabetised_text_260 = "Storage Room";
Constant alphabetised_text_261 = "Strongman attendant";
Constant alphabetised_text_262 = "Surely not ALL the rides are boring.";
Constant alphabetised_text_263 = "Suspicious Minds";
Constant alphabetised_text_264 = "Sweet Caroline";
Constant alphabetised_text_265 = "Sweet Jane";
Constant alphabetised_text_266 = "Swiss Army knife";
Constant alphabetised_text_267 = "Taking the Mercury dime";
Constant alphabetised_text_268 = "Taking the blueberries";
Constant alphabetised_text_269 = "Taking the flashlight";
Constant alphabetised_text_270 = "Taking the lantern";
Constant alphabetised_text_271 = "Taylor Swift";
Constant alphabetised_text_272 = "Tell me about the big switch.";
Constant alphabetised_text_273 = "The Attractions";
Constant alphabetised_text_274 = "The Control Room";
Constant alphabetised_text_275 = "The Cure";
Constant alphabetised_text_276 = "The Electrical Area";
Constant alphabetised_text_277 = "The Games";
Constant alphabetised_text_278 = "The Grateful Dead";
Constant alphabetised_text_279 = "The Mercury dime is a ten-cent coin struck by the United States Mint from late 1916 to 1945. Designed by Adolph Weinman and also referred to as the Winged Liberty Head dime, it gained its common name because the obverse depiction of a young Liberty, identifiable by her winged Phrygian cap, was confused with the Roman god Mercury.";
Constant alphabetised_text_280 = "The Parking Lot";
Constant alphabetised_text_281 = "The Talking Heads";
Constant alphabetised_text_282 = "The Village People";
Constant alphabetised_text_283 = "The blueberries are ripe and juicy.";
Constant alphabetised_text_284 = "The bucket of popcorn looks enormous!";
Constant alphabetised_text_285 = "The bumper cars is a bustling hub of excitement and laughter, set beneath a canopy of flashing lights and colorful decorations. The rectangular arena is surrounded by padded barriers, ensuring a safe yet thrilling experience for riders. The floor, slick and metallic, allows the brightly colored cars - painted in shades of red, blue, yellow, and green - to glide effortlessly in all directions.^^Each car is equipped with a steering wheel and a padded bumper, designed to absorb the impact of playful collisions. As the ride begins, drivers of all ages eagerly maneuver their cars, aiming for friends, family, or strangers with mischievous grins. The air is filled with the sound of bumpers colliding, laughter, and the occasional squeal of surprise.^^Overhead, a web of electric poles connects the cars to the ceiling, sparking faintly as they supply power to the vehicles. The ride operator watches from a booth, ensuring everyone enjoys the chaos safely. Surrounding the bumper cars are cheering onlookers, carnival lights, and the lively hum of the fairground.^^The bumper cars perfectly captures the playful spirit of the carnival, offering a mix of harmless competition, shared laughter, and nostalgic fun for all ages. The Ticket Kiosk is southeast of here.";
Constant alphabetised_text_286 = "The candy apple is your typical caramel covered apple. It looks like it would get stuck in your teeth.";
Constant alphabetised_text_287 = "The carnival likes to maintain a link to days past when games cost only a dime?";
Constant alphabetised_text_288 = "The cars that will take you into the fearsome Hell Ride stop here for you to board and then move forward, the safety bar locked in place, as the entrance to Hell Ride looms ahead - a grotesque facade of twisted metal and carved wood, illuminated by flickering blood-red lights. The air carries a faint sulfuric tang mingled with the sweet aroma of carnival popcorn.^^A towering archway of flames, spikes, and grinning skulls frames the entrance, crowned by flickering letters that read ~HELL RIDE~, pulsing like a heartbeat. Below, crouching demon sculptures extend clawed hands in a sinister invitation. Wooden doors cover the entrance, whispering with faint, menacing chuckles as distorted organ music grows louder, punctuated by shrieks and grinding machinery.^^Inside, near-total darkness is broken by flashes of sickly green light revealing twisted paths and grotesque shapes. Beyond the threshold lies only uncertainty and terror.";
Constant alphabetised_text_289 = "The chains rattle against the walls.";
Constant alphabetised_text_290 = "The concession stand, perched along the midway, is a colorful and bustling hub. Painted in bright reds, blues, and yellows, it features bold lettering announcing treats like ~SODA! POPCORN! CANDY APPLES!~ Strings of twinkling lights frame the stand, making it a glowing beacon amid the carnival excitement.^^Behind the counter, a popcorn machine churns out golden kernels, filling the air with a buttery aroma. Candy apples gleam under the lights, and cotton candy machines spin fluffy clouds of pink and blue. Warm pretzels sit under a heat lamp, their buttery, salted scent mingling with the sugary treats. A cooler holds sodas, their colorful labels visible through the frosted glass.^^The counter is lively with stacks of paper bags, napkins, and cups of cheese and sugar sprinkles. A handwritten chalkboard menu lists prices in playful lettering. Workers in colorful aprons quickly hand out snacks, their movements efficient amid the cheerful chaos.^^In front of the stand, kids tug at their parents, teens share pretzels, and the crowd buzzes with energy. More than just a snack stop, the stand is a sensory delight, adding flavor and charm to the carnival experience.^^There is a menu to the right of the window. You can see the treats inside the stand. There is an exit to the northeast.";
Constant alphabetised_text_291 = "The cotton candy is a mixture of pink and blue floss.";
Constant alphabetised_text_292 = "The cover reads, ~Put The Bump In Your Bumper Cars~.";
Constant alphabetised_text_293 = "The crawl space beneath the carnival ride is a tight, claustrophobic tunnel shrouded in darkness and filled with the hum of machinery above. The air is stale and heavy, carrying the sharp metallic scent of oil and the faint tang of rust. Every sound is amplified in the confined space - the groaning of steel beams, the clanking of chains, and the rhythmic thrum of motors driving the ride above.^^The ground is uneven, a mix of packed dirt and loose gravel scattered with forgotten tools, scraps of metal, and tangled wires. Overhead, a network of pipes and cables crisscross the space, some wrapped in fraying insulation that crackles faintly as you crawl past. Small puddles of murky water collect in dips on the floor, their surfaces rippling with vibrations from the ride's movement.^^The backstage area continues north and south. There is a door to the west.";
Constant alphabetised_text_294 = "The devil horns tie to your head.";
Constant alphabetised_text_295 = "The flames burn ever higher.";
Constant alphabetised_text_296 = "The fortune teller sits in a dimly lit booth, draped in rich fabrics of deep purple and gold, adorned with celestial patterns of stars and moons. Their appearance is enigmatic, with piercing eyes that seem to look right through you and a knowing smile that hints at secrets yet untold. They wear flowing robes embellished with shimmering beads, and a jeweled headpiece catches the flickering light of nearby candles.";
Constant alphabetised_text_297 = "The game you are playing is a work of Interactive Fiction.  In interactive fiction you play the main character of a story.  You type commands which determine the actions of the character and the flow of the plot.  Some IF games include graphics, but most do not: the imagery is provided courtesy of your imagination.  On the other hand, there's a wide range of action available: whereas in other games you may be restricted to shooting, movement, or searching items you can click on with a mouse, IF allows you a wide range of verbs.";
Constant alphabetised_text_298 = "The grue is a sinister, lurking presence in the dark places of the earth. Its favorite diet is humans, but its insatiable appetite is tempered by its fear of light. No grue has ever been seen by the light of day, and few have survived its fearsome jaws to tell the tale.";
Constant alphabetised_text_299 = "The maintenance office, hidden behind the carnival's bright facade, is a dim and cluttered space reeking of grease, sweat, and faint traces of popcorn from the midway. The air hangs heavy with oil and stirred-up dust.^^The walls are lined with shelves holding tools and parts in disarray - screws and mismatched containers with faded labels. Paint cans and grease jars clutter the workbenches, many left half-open. In the center, a battered desk is strewn with wires, gears, and springs, a bent piece of metal held in a vise. Overhead, a single flickering fluorescent light struggles to illuminate the room.^^In one corner, a disassembled ride mechanism lies exposed, chains and pulleys dangling from hooks above, faintly clinking with the vibrations of the rides. A grease-stained manual and a half-drained mug of coffee sit abandoned on a nearby stool.^^The walls display faded safety posters, a cork board with maintenance schedules and notes, and a worn photo of the carnival in its prime. A clock ticks faintly, its hands out of sync with reality. The floor, gritty with dust and scattered nails, adds to the room's chaotic charm.^^Despite the mess, the room buzzes with purpose - a hidden hub where the carnival's magic is sustained through sweat, ingenuity, and the hum of machinery.^^Exits lead north and south. There is a door to the west.";
Constant alphabetised_text_300 = "The mallet is over sized, perhaps to give you an advantage in the Strong Man game.";
Constant alphabetised_text_301 = "The monitor now displays a scene of three women being burned at the stake.";
Constant alphabetised_text_302 = "The monitor now shows a scene of someone waiting to be hanged.";
Constant alphabetised_text_303 = "The monitor now shows a tableau of a guillotine rising and falling over the ride exit.";
Constant alphabetised_text_304 = "The monitor now shows a tableau of poor unfortunate townsfolk locked in stocks.";
Constant alphabetised_text_305 = "The monitor now shows nothing but snow.";
Constant alphabetised_text_306 = "The monitor now shows the implements of torture in the dungeon.";
Constant alphabetised_text_307 = "The monitor shows the gift shop located at the Hell Ride exit.";
Constant alphabetised_text_308 = "The north mechanical room is compact and specialized, housing auxiliary systems that keep the ride running smoothly. A subdued hum of capacitors and relays fills the space, its quiet rhythm broken only by the occasional hiss of hydraulic fluid.^^Electrical panels line the walls, labeled for functions like ~Lighting Controls,~ ~Brake Systems,~ and ~Emergency Shutdown.~ Smaller cables and conduits snake along the walls, linking these systems to the main hub. In one corner, a hydraulic pump and reservoir manage lifting arms and rotating platforms, their gauges flickering as they work.^^A small workbench against the eastern wall is cluttered with tools and coiled wires, while shelves above hold neatly labeled spare parts - cables, and hydraulic tubing. A faded ride diagram pinned nearby is marked with red annotations from past repairs.^^Dimly lit by a single hanging bulb, the room feels cooler and slightly damp, the metallic tang of machinery mixing with a hint of mildew. Though quieter and less prominent than the south mechanical room, this space plays a vital role in supporting the ride's operation and ensuring its emergency systems are always prepared.^^There are exists north and south. There is a wooden door to the west.";
Constant alphabetised_text_309 = "The other is in the Little Egypt tent.";
Constant alphabetised_text_310 = "The parking attendant has a parking ticket.";
Constant alphabetised_text_311 = "The parking attendant knows something about the stub";
Constant alphabetised_text_312 = "The performance begins with slow, undulating movements, drawing you into the rhythm of exotic live music played on traditional instruments like the oud, darbuka, or zurna. As the tempo builds, her hips, torso, and hands move in intricate, mesmerizing patterns, demonstrating remarkable control and fluidity. She incorporates dramatic spins, drops, and shimmies, often accentuating the beat of the music with a quick jingle of her coin belt.";
Constant alphabetised_text_313 = "The performance concludes with a dramatic flourish of a fast-paced shimmy, a bold spin, and Little Egypt dramatically casts off her veils. The dancer takes a bow to enthusiastic applause, leaving you spellbound by the sensual yet artful display.";
Constant alphabetised_text_314 = "The public square is a cobblestone expanse bordered by weathered timber-framed buildings. The air carries the mingling scents of chimney smoke, damp earth, and the faint tang of a nearby smithy. At its center, crude wooden stocks stand as a grim focal point, their beams weathered and stained from years of use. Iron clasps lock captives in degrading postures, their tattered clothing offering little protection from the biting wind.^^The animatronics and wax figures are extremely life like. Hell Ride sure lives up to its name.^^The punished individuals hang their heads in shame, their faces etched with despair. Around them, the crowd revels in cruelty - a wiry man spits insults with gleeful laughter, while a stout woman throws overripe vegetables, each impact sparking jeers. Even children join in, pointing and mocking with mischievous delight.^^The square hums with noise: the crowd's taunts, the crack of objects hitting wood, and the quiet murmurs of the suffering captives. Overhead, a gray sky threatens rain, indifferent to the spectacle below. The jeering mob ignores its ominous weight, too engrossed in their shared cruelty to notice nature's disapproval.";
Constant alphabetised_text_315 = "The public square is steeped in grim silence, broken only by the crackling of flames. At its center, three wooden stakes rise from a pyre of logs and kindling, darkened by smoke from past executions. Bound to the stakes are three women, their faces reflecting defiance, resignation, and terror.^^A crowd encircles the scene, expressions ranging from morbid fascination to righteous fury. Children cling to their mothers, while elders nod solemnly. Some jeer and throw stones; others murmur prayers or avert their gaze.^^The executioner, hooded and clad in a leather apron, steps forward with a blazing torch, igniting the pyre in a sudden roar. Flames climb rapidly as thick smoke coils upward. The condemned cry out, their voices mingling with the crackle of fire. The oppressive heat radiates outward, pressing against the silent, uneasy crowd.^^Gray clouds loom overhead, nature's somber backdrop to the grim spectacle. A raven caws from the bell tower as slow church bells toll, each strike punctuating the tragedy. As the pyre burns, some onlookers remain transfixed while others quietly slip away, the square heavy with ash, smoke, and the echoes of the condemned.";
Constant alphabetised_text_316 = "The public square, slick with morning drizzle, lies under a brooding, overcast sky. At its center looms the gallows, a weathered wooden platform with thick ropes swaying ominously. The crowd stands in somber silence, broken by the shuffle of feet or faint murmurs, their eyes fixed on the grim scene.^^A hooded executioner, cloaked in black, adjusts the frayed noose with practiced precision, his cold presence exuding purpose. In front of him stands the condemned man, pale and trembling, his bound hands behind him. Beads of sweat mix with rain on his haunted face as his darting eyes search the indifferent crowd. Each shallow breath forms a fleeting cloud in the chilly air - a fragile reminder of his fleeting life.^^Vendors hawk bread and cider, while children strain for a better view. An old man clutches a rosary, whispering prayers, as others smirk and place bets. Above, the bell tower tolls, its mournful chime marking the passage of the man's final moments. A raven perches on the gallows~ beam, its unblinking gaze fixed on the scene below.^^As the executioner adjusts the noose around the man's neck, the crowd falls silent, the air thick with dread. Distant thunder rumbles faintly, as if the heavens themselves await the inevitable.";
Constant alphabetised_text_317 = "The rack has a prisoner splayed in four directions.";
Constant alphabetised_text_318 = "The ride of a lifetime...";
Constant alphabetised_text_319 = "The rides are boring.";
Constant alphabetised_text_320 = "The room is electromagnetic.";
Constant alphabetised_text_321 = "The sign reads, ~Little Egypt Show - A Journey Into the Mysterious and Exotic!~";
Constant alphabetised_text_322 = "The soft pretzel is generously sprinkled with salt.";
Constant alphabetised_text_323 = "The south mechanical room is the operational core of the carnival ride, a bustling, noisy space dominated by a massive motor. Its steady hum drives the thick belts, pulleys, and gears that work in perfect unison to power the ride.^^Heavy-duty electrical panels line the walls, adorned with warning labels like ~High Voltage~ and blinking indicator lights in an array of colors. Overhead, labeled conduits and wires snake across the ceiling, connecting systems with meticulous precision.^^A cluttered table holds tools and spare parts - bolts and lubricants - alongside open maintenance logs marked with greasy fingerprints. The air is thick with the smell of oil, metal, and a faint trace of ozone from the electrics.^^A cooling fan spins in the corner, barely cutting through the room's warmth. The hum of machinery is occasionally punctuated by clinking chains and the sharp hiss of hydraulic fluid. The floor, a mix of metal grates and worn concrete, reflects years of use and maintenance.^^Bright fluorescent lights in wire cages illuminate the space, highlighting the intricate systems at work. The south mechanical room is the ride's powerhouse, where every movement is controlled with precision to deliver its thrilling experience.^^You can travel north and south from here. There is a door to the west.";
Constant alphabetised_text_324 = "The stage is decorated to resemble an exotic Middle Eastern market or palace, featuring rich, colorful fabrics, brass ornaments, and lanterns casting a warm, flickering glow. Scents of incense waft through the air, enhancing the atmosphere of mystique. The backdrop displays painted scenes of pyramids, desert landscapes, and domed structures to evoking a sense of being transported to the ~Middle East~.";
Constant alphabetised_text_325 = "The stand is bathed in red light, adding to the ominous mood.";
Constant alphabetised_text_326 = "The titles you see are Introduction to Calculus, Statistics, and Heart of Darkness here.";
Constant alphabetised_text_327 = "The workbench is covered in all manner of things.";
Constant alphabetised_text_328 = "There are a variety of things to eat here.";
Constant alphabetised_text_329 = "There are exits in all directions";
Constant alphabetised_text_330 = "There are five levels marked on the pole: Weakling, Getting There, Average, Almost There, and Muscle Man.";
Constant alphabetised_text_331 = "There are two in the game.";
Constant alphabetised_text_332 = "There is a bullseye on the base of the lever. I guess this is where you have to hit the mallet.";
Constant alphabetised_text_333 = "There's a dial, a button, and a light in each one.";
Constant alphabetised_text_334 = "These are pretty colors.";
Constant alphabetised_text_335 = "They come in pretty colors.";
Constant alphabetised_text_336 = "This is a black t-shirt with the caption ~I Survived Hell Ride!";
Constant alphabetised_text_337 = "This is a collection of plastic bones meant to decorate your yard.";
Constant alphabetised_text_338 = "This is a highly polished brass lantern.";
Constant alphabetised_text_339 = "This is a pad of lined paper.";
Constant alphabetised_text_340 = "This is a photo of the carnival in its heyday! A ragtag bunch of people are featured in the picture. On the back reads a date: ~March, 1962~.";
Constant alphabetised_text_341 = "This is a poorly lit hallway. Ahead to the west you can see the glow of an open door.";
Constant alphabetised_text_342 = "This is a poster of Lourde. You love her singing.";
Constant alphabetised_text_343 = "This is a red stapler.";
Constant alphabetised_text_344 = "This is a sharp pair of office scissors.";
Constant alphabetised_text_345 = "This is a sheer gold veil that Little Egypt wore (and removed) during her show. Your head swims as you smell the scent of her perfume on her veil: patchouli.";
Constant alphabetised_text_346 = "This is a small goldfish in a bowl. A pet is just what you need.";
Constant alphabetised_text_347 = "This is a small pocket mirror. You could use it to check your hair.";
Constant alphabetised_text_348 = "This is a small silver key. I wonder what it unlocks.";
Constant alphabetised_text_349 = "This is a small, flat plate, almost a saucer. You are meant to toss a dime on this plate to win a prize!";
Constant alphabetised_text_350 = "This is a square of Bazooka Joe Bubblegum. Really now, is there any other?";
Constant alphabetised_text_351 = "This is a teddy bear like you had when you were a kid. Right down to the red bow around its neck.";
Constant alphabetised_text_352 = "This is one of many folding chairs in the tent tonight.";
Constant alphabetised_text_353 = "This is one of those air fresheners that are shaped like a pine tree and smell like one too. You bought it the last time you went to the car wash.";
Constant alphabetised_text_354 = "This room is backstage at the Hell Ride attraction. The room is littered with bags of trash, piles of junk, and dust bunnies so large they should be paying rent. West is back the way you came from. There an exit to the south.";
Constant alphabetised_text_355 = "This soda is ice cold.";
Constant alphabetised_text_356 = "Three wooden stakes rise from a pyre. Bound to the stakes are three women.";
Constant alphabetised_text_357 = "Ticket Booth";
Constant alphabetised_text_358 = "Tickets are expensive though.";
Constant alphabetised_text_359 = "To SWITCH ON a switch, try FLIP switch, PUSH switch, or TOGGLE switch.";
Constant alphabetised_text_360 = "To TURN ON a switch, try FLIP switch, PUSH switch, or TOGGLE switch.";
Constant alphabetised_text_361 = "To remind you to spend your money wisely.";
Constant alphabetised_text_362 = "Tracks Of My Tears";
Constant alphabetised_text_363 = "Treats";
Constant alphabetised_text_364 = "Try spinning the dials.";
Constant alphabetised_text_365 = "Try wearing the gloves.";
Constant alphabetised_text_366 = "Turn off the big switch.";
Constant alphabetised_text_367 = "Turning off the big switch";
Constant alphabetised_text_368 = "Types of Action";
Constant alphabetised_text_369 = "UNDO the last command";
Constant alphabetised_text_370 = "Van Morrison";
Constant alphabetised_text_371 = "Very big";
Constant alphabetised_text_372 = "Warren Zevon";
Constant alphabetised_text_373 = "Wearing the sheer veil";
Constant alphabetised_text_374 = "Weezer";
Constant alphabetised_text_375 = "Werewolves Of London";
Constant alphabetised_text_376 = "What about the control panels?";
Constant alphabetised_text_377 = "What about the different rooms";
Constant alphabetised_text_378 = "What about the electrical panels?";
Constant alphabetised_text_379 = "What about the glove box?";
Constant alphabetised_text_380 = "What about the parking stub";
Constant alphabetised_text_381 = "What do I do with the string?";
Constant alphabetised_text_382 = "What? You want them to cost a quarter?";
Constant alphabetised_text_383 = "What? You were expecting wrist bands?";
Constant alphabetised_text_384 = "Why are tickets so expensive?";
Constant alphabetised_text_385 = "Why do I die?";
Constant alphabetised_text_386 = "Why do I get eaten by a grue?";
Constant alphabetised_text_387 = "Why do the games only cost a dime?";
Constant alphabetised_text_388 = "Why does my car get towed?";
Constant alphabetised_text_389 = "Why might your car get towed?";
Constant alphabetised_text_390 = "Winning the Crimson fuse";
Constant alphabetised_text_391 = "Winning the Magenta fuse";
Constant alphabetised_text_392 = "Winning the Orange fuse";
Constant alphabetised_text_393 = "Winning the Swiss Army knife";
Constant alphabetised_text_394 = "Winning the a plush donkey";
Constant alphabetised_text_395 = "Winning the goldfish in a bowl";
Constant alphabetised_text_396 = "Winning the poster of Billie Eilish";
Constant alphabetised_text_397 = "Winning the poster of Lourde";
Constant alphabetised_text_398 = "Winning the poster of Taylor Swift";
Constant alphabetised_text_399 = "Winning the small pocket mirror";
Constant alphabetised_text_400 = "Winning the stuffed monkey";
Constant alphabetised_text_401 = "Winning the teddy bear";
Constant alphabetised_text_402 = "Y";
Constant alphabetised_text_403 = "YMCA";
Constant alphabetised_text_404 = "Yes, the prizes are important.";
Constant alphabetised_text_405 = "Yes.";
Constant alphabetised_text_406 = "You are despondent given that you and your date just had a huge fight and they stormed off. Maybe visiting the attractions at the carnival will make you feel better.";
Constant alphabetised_text_407 = "You can buy tickets at the Ticket Kiosk.";
Constant alphabetised_text_408 = "You could probably put something in the socket.";
Constant alphabetised_text_409 = "You feel rather underwhelmed as you look at the small plush donkey on a key chain.";
Constant alphabetised_text_410 = "You feel rather underwhelmed as you look at the small plush monkey on a key chain.";
Constant alphabetised_text_411 = "You found this in a stack of coupons on the counter of the gas station.";
Constant alphabetised_text_412 = "You have to find it";
Constant alphabetised_text_413 = "You head west through the midway, the bright lights of the carnival fading behind you as you approach a wooden booth. A sign above the entrance reads ~Little Egypt Show - A Journey Into the Mysterious and Exotic!~ A rotund barker, wearing a fez and a dazzling smile, gestures to a small sign beside him that says ~Dime Admission.~  The Ticket Kiosk is back the way you came.^^You are standing in front of a dark and mysterious tent filled with illusions and exotic performers. Perhaps there's a fortune teller inside, offering cryptic clues about your journey or a hidden artifact that can be collected. There is a stage in front of the tent. The Barker is encouraging you to step up, pay for, and enjoy the Little Egypt Show.";
Constant alphabetised_text_414 = "You need a key.";
Constant alphabetised_text_415 = "You see rats scurry in all directions fleeing from the light cast by you.";
Constant alphabetised_text_416 = "You've decided to stay and enjoy the carnival anyway.";
Constant alphabetised_text_417 = "Young Americans";
Constant alphabetised_text_418 = "Your dirty clothes are strewn about. You really meant to do laundry days ago.";
Constant alphabetised_text_419 = "Your standard ballpoint pen. It says Bic on the side.";
Constant alphabetised_text_420 = "Yourself";
Constant alphabetised_text_421 = "a";
Constant alphabetised_text_422 = "a Swiss Army knife";
Constant alphabetised_text_423 = "a crimson fuse";
Constant alphabetised_text_424 = "a goldfish in a bowl";
Constant alphabetised_text_425 = "a magenta fuse";
Constant alphabetised_text_426 = "a plush donkey";
Constant alphabetised_text_427 = "a poster of Billie Eilish";
Constant alphabetised_text_428 = "a poster of Lourde";
Constant alphabetised_text_429 = "a poster of Taylor Swift";
Constant alphabetised_text_430 = "a small pocket mirror";
Constant alphabetised_text_431 = "a stuffed monkey";
Constant alphabetised_text_432 = "a teddy bear";
Constant alphabetised_text_433 = "adjustable wrench";
Constant alphabetised_text_434 = "air freshener";
Constant outcome_allow_access_U1 = "allow access";
Constant outcome_allow_startup_U1 = "allow startup";
Constant alphabetised_text_435 = "an orange fuse";
Constant alphabetised_text_436 = "animals";
Constant alphabetised_text_437 = "attendants";
Constant alphabetised_text_438 = "awl";
Constant alphabetised_text_439 = "backdrops";
Constant alphabetised_text_440 = "bags of trash";
Constant alphabetised_text_441 = "ballpoint pen";
Constant alphabetised_text_442 = "bar";
Constant alphabetised_text_443 = "baseball";
Constant alphabetised_text_444 = "baseballs";
Constant alphabetised_text_445 = "beater car";
Constant alphabetised_text_446 = "bell";
Constant alphabetised_text_447 = "bench";
Constant alphabetised_text_448 = "bent piece of metal";
Constant alphabetised_text_449 = "big switch";
Constant alphabetised_text_450 = "blueberries";
Constant alphabetised_text_451 = "blueberry bush";
Constant alphabetised_text_452 = "bolts";
Constant alphabetised_text_453 = "booths";
Constant alphabetised_text_454 = "boxes of lightbulbs";
Constant alphabetised_text_455 = "brazier";
Constant alphabetised_text_456 = "breaker panel";
Constant alphabetised_text_457 = "bubblegum";
Constant alphabetised_text_458 = "bucket of popcorn";
Constant alphabetised_text_459 = "buttons";
Constant alphabetised_text_460 = "cables";
Constant alphabetised_text_461 = "can opener";
Constant alphabetised_text_462 = "candy apple";
Constant alphabetised_text_463 = "cashier";
Constant alphabetised_text_464 = "chains";
Constant alphabetised_text_465 = "channel locks";
Constant alphabetised_text_466 = "charts";
Constant alphabetised_text_467 = "circuit breakers";
Constant alphabetised_text_468 = "clock";
Constant alphabetised_text_469 = "cluttered desk";
Constant alphabetised_text_470 = "coffee mug";
Constant alphabetised_text_471 = "coins";
Constant alphabetised_text_472 = "containers";
Constant alphabetised_text_473 = "control panels";
Constant alphabetised_text_474 = "cooling fan";
Constant alphabetised_text_475 = "cork board";
Constant alphabetised_text_476 = "corkscrew";
Constant alphabetised_text_477 = "cotton candy";
Constant alphabetised_text_478 = "coupon";
Constant alphabetised_text_479 = "dashboard";
Constant outcome_deny_access_U1 = "deny access";
Constant outcome_deny_startup_U1 = "deny startup";
Constant alphabetised_text_480 = "desk";
Constant alphabetised_text_481 = "devices";
Constant alphabetised_text_482 = "devil horns";
Constant alphabetised_text_483 = "diagram";
Constant alphabetised_text_484 = "dials";
Constant alphabetised_text_485 = "diesel canisters";
Constant alphabetised_text_486 = "dime";
Constant alphabetised_text_487 = "dimes";
Constant alphabetised_text_488 = "directions";
Constant alphabetised_text_489 = "doors";
Constant alphabetised_text_490 = "down";
Constant alphabetised_text_491 = "drawer";
Constant alphabetised_text_492 = "dust bunnies";
Constant alphabetised_text_493 = "east";
Constant alphabetised_text_494 = "electric lamps";
Constant alphabetised_text_495 = "electrical panels";
Constant alphabetised_text_496 = "emergency shutdown panel";
Constant alphabetised_text_497 = "faded safety poster";
Constant alphabetised_text_498 = "filters";
Constant alphabetised_text_499 = "fingernail clippers";
Constant alphabetised_text_500 = "fire extinguisher";
Constant alphabetised_text_501 = "flags";
Constant alphabetised_text_502 = "flashlight";
Constant alphabetised_text_503 = "fluid containers";
Constant alphabetised_text_504 = "folding chair";
Constant alphabetised_text_505 = "foo";
Constant alphabetised_text_506 = "fuses";
Constant alphabetised_text_507 = "gallows platform";
Constant alphabetised_text_508 = "gauges";
Constant alphabetised_text_509 = "gears";
Constant alphabetised_text_510 = "glove box";
Constant alphabetised_text_511 = "goldfish";
Constant alphabetised_text_512 = "graffiti";
Constant alphabetised_text_513 = "grate";
Constant alphabetised_text_514 = "grease canister";
Constant alphabetised_text_515 = "grease jars";
Constant alphabetised_text_516 = "ground";
Constant alphabetised_text_517 = "guillotine platform";
Constant alphabetised_text_518 = "hammer";
Constant alphabetised_text_519 = "horse";
Constant alphabetised_text_520 = "hydraulic pump";
Constant alphabetised_text_521 = "hydraulic tubing";
Constant alphabetised_text_522 = "ignition";
Constant alphabetised_text_523 = "indicators";
Constant alphabetised_text_524 = "inside";
Constant alphabetised_text_525 = "iron chair";
Constant outcome_it_does_U1 = "it does";
Constant outcome_it_does_not_U1 = "it does not";
Constant outcome_it_is_likely_U1 = "it is likely";
Constant outcome_it_is_possible_U1 = "it is possible";
Constant outcome_it_is_unlikely_U1 = "it is unlikely";
Constant outcome_it_is_very_likely_U1 = "it is very likely";
Constant outcome_it_is_very_unlikely_U1 = "it is very unlikely";
Constant alphabetised_text_526 = "junction box";
Constant alphabetised_text_527 = "junction boxes";
Constant alphabetised_text_528 = "keychains";
Constant alphabetised_text_529 = "ladder";
Constant alphabetised_text_530 = "lantern";
Constant alphabetised_text_531 = "large panel";
Constant alphabetised_text_532 = "lever";
Constant alphabetised_text_533 = "lights";
Constant alphabetised_text_534 = "lubricant";
Constant alphabetised_text_535 = "lubricants";
Constant alphabetised_text_536 = "lurking grue";
Constant alphabetised_text_537 = "maintenance manual";
Constant alphabetised_text_538 = "mallet";
Constant alphabetised_text_539 = "manual";
Constant alphabetised_text_540 = "markings";
Constant alphabetised_text_541 = "men";
Constant alphabetised_text_542 = "menu";
Constant alphabetised_text_543 = "merchandise stand";
Constant alphabetised_text_544 = "mercury dime";
Constant alphabetised_text_545 = "milk bottles";
Constant alphabetised_text_546 = "monitor";
Constant alphabetised_text_547 = "nickel";
Constant alphabetised_text_548 = "nickels";
Constant alphabetised_text_549 = "north";
Constant alphabetised_text_550 = "northeast";
Constant alphabetised_text_551 = "northwest";
Constant alphabetised_text_552 = "notes";
Constant alphabetised_text_553 = "outside";
Constant alphabetised_text_554 = "pad of paper";
Constant alphabetised_text_555 = "paint cans";
Constant alphabetised_text_556 = "pair of gloves";
Constant alphabetised_text_557 = "parking attendant";
Constant alphabetised_text_558 = "parking stub";
Constant alphabetised_text_559 = "parking ticket";
Constant alphabetised_text_560 = "passkeys";
Constant alphabetised_text_561 = "people";
Constant outcome_persuasion_fails_U1 = "persuasion fails";
Constant outcome_persuasion_succeeds_U1 = "persuasion succeeds";
Constant alphabetised_text_562 = "pile of junk";
Constant alphabetised_text_563 = "plastic bones";
Constant alphabetised_text_564 = "plate";
Constant alphabetised_text_565 = "player's holdalls";
Constant alphabetised_text_566 = "pliers";
Constant alphabetised_text_567 = "poster of Billie Eilish";
Constant alphabetised_text_568 = "poster of Lourde";
Constant alphabetised_text_569 = "poster of Taylor Swift";
Constant alphabetised_text_570 = "pulleys";
Constant alphabetised_text_571 = "pyre";
Constant alphabetised_text_572 = "quarter";
Constant alphabetised_text_573 = "quarters";
Constant alphabetised_text_574 = "rack";
Constant alphabetised_text_575 = "radio";
Constant alphabetised_text_576 = "rats";
Constant alphabetised_text_577 = "regions";
Constant alphabetised_text_578 = "ride parts";
Constant alphabetised_text_579 = "ride tickets";
Constant alphabetised_text_580 = "riveted iron-bound door";
Constant alphabetised_text_581 = "safety posters";
Constant alphabetised_text_582 = "scissors";
Constant alphabetised_text_583 = "screwdriver";
Constant alphabetised_text_584 = "screws";
Constant alphabetised_text_585 = "seat";
Constant alphabetised_text_586 = "seats";
Constant alphabetised_text_587 = "see some suggestions for AMUSING things to do";
Constant alphabetised_text_588 = "sheer veil";
Constant alphabetised_text_589 = "sign";
Constant alphabetised_text_590 = "signboard";
Constant alphabetised_text_591 = "silver key";
Constant alphabetised_text_592 = "sky";
Constant alphabetised_text_593 = "small fan";
Constant alphabetised_text_594 = "small plush donkey";
Constant alphabetised_text_595 = "small plush monkey";
Constant alphabetised_text_596 = "small pocket mirror";
Constant alphabetised_text_597 = "sockets";
Constant alphabetised_text_598 = "soda can";
Constant alphabetised_text_599 = "soft pretzel";
Constant alphabetised_text_600 = "south";
Constant alphabetised_text_601 = "southeast";
Constant alphabetised_text_602 = "southwest";
Constant alphabetised_text_603 = "spare parts";
Constant alphabetised_text_604 = "spark plugs";
Constant alphabetised_text_605 = "spools of wire";
Constant alphabetised_text_606 = "stakes";
Constant alphabetised_text_607 = "stapler";
Constant alphabetised_text_608 = "stool";
Constant alphabetised_text_609 = "supplies";
Constant alphabetised_text_610 = "supporters";
Constant alphabetised_text_611 = "switches";
Constant alphabetised_text_612 = "t-shirt";
Constant alphabetised_text_613 = "table";
Constant alphabetised_text_614 = "teddy bear";
Constant alphabetised_text_615 = "text books";
Constant alphabetised_text_616 = "the";
Constant outcome_there_is_insufficien_U1 = "there is insufficient light";
Constant outcome_there_is_sufficient__U1 = "there is sufficient light";
Constant alphabetised_text_617 = "thick belts";
Constant alphabetised_text_618 = "ticket kiosk";
Constant alphabetised_text_619 = "toolbox";
Constant alphabetised_text_620 = "tools";
Constant alphabetised_text_621 = "treats";
Constant alphabetised_text_622 = "two dollar bill";
Constant alphabetised_text_623 = "up";
Constant alphabetised_text_624 = "vehicles";
Constant alphabetised_text_625 = "vise";
Constant alphabetised_text_626 = "wall";
Constant alphabetised_text_627 = "wallet";
Constant alphabetised_text_628 = "west";
Constant alphabetised_text_629 = "wire coils";
Constant alphabetised_text_630 = "wire scraps";
Constant alphabetised_text_631 = "wires";
Constant alphabetised_text_632 = "women";
Constant alphabetised_text_633 = "wooden doors";
Constant alphabetised_text_634 = "wooden stocks";
Constant alphabetised_text_635 = "workbench";
Constant alphabetised_text_636 = "worn photo";
Constant alphabetised_text_637 = "wrappers";
Constant alphabetised_text_638 = "your dirty clothes";
Constant alphabetised_text_639 = "your keys";
Constant alphabetised_text_640 = "yourself";
Constant alphabetised_text_641 = "~Admit One~ Have your fortune told.";
Constant alphabetised_text_642 = "~Admit One~ to the Bumper Cars.";
Constant alphabetised_text_643 = "~Admit One~ to the Carousel.";
Constant alphabetised_text_644 = "~Admit One~ to the Ferris Wheel.";
Constant text_U1 = alphabetised_text_495;
Constant text_U2 = alphabetised_text_495;
Constant text_U3 = alphabetised_text_495;
Constant text_U4 = alphabetised_text_495;
Constant text_U5 = alphabetised_text_495;
Constant text_U6 = alphabetised_text_495;
Constant text_U7 = alphabetised_text_597;
Constant text_U8 = alphabetised_text_597;
Constant text_U9 = alphabetised_text_597;
Constant text_U10 = alphabetised_text_597;
Constant text_U11 = alphabetised_text_597;
Constant text_U12 = alphabetised_text_597;
Constant text_U13 = alphabetised_text_523;
Constant text_U14 = alphabetised_text_523;
Constant text_U15 = alphabetised_text_523;
Constant text_U16 = alphabetised_text_523;
Constant text_U17 = alphabetised_text_523;
Constant text_U18 = alphabetised_text_523;
Constant text_U19 = alphabetised_text_611;
Constant text_U20 = alphabetised_text_611;
Constant text_U21 = alphabetised_text_611;
Constant text_U22 = alphabetised_text_611;
Constant text_U23 = alphabetised_text_611;
Constant text_U24 = alphabetised_text_611;
Constant text_U25 = alphabetised_text_459;
Constant text_U26 = alphabetised_text_459;
Constant text_U27 = alphabetised_text_459;
Constant text_U28 = alphabetised_text_459;
Constant text_U29 = alphabetised_text_459;
Constant text_U30 = alphabetised_text_459;
Constant text_U31 = alphabetised_text_484;
Constant text_U32 = alphabetised_text_484;
Constant text_U33 = alphabetised_text_484;
Constant text_U34 = alphabetised_text_484;
Constant text_U35 = alphabetised_text_484;
Constant text_U36 = alphabetised_text_484;
Constant text_U37 = alphabetised_text_533;
Constant text_U38 = alphabetised_text_533;
Constant text_U39 = alphabetised_text_533;
Constant text_U40 = alphabetised_text_533;
Constant text_U41 = alphabetised_text_533;
Constant text_U42 = alphabetised_text_533;
Constant V1_starting_the_virtual_mach = activity_id_U1;
Constant V2_printing_the_name = activity_id_U2;
Constant V3_printing_the_plural_name = activity_id_U3;
Constant text_U43 = alphabetised_text_549;
Constant text_U44 = alphabetised_text_616;
Constant text_U45 = alphabetised_text_488;
Constant text_U46 = alphabetised_text_550;
Constant text_U47 = alphabetised_text_616;
Constant text_U48 = alphabetised_text_488;
Constant text_U49 = alphabetised_text_551;
Constant text_U50 = alphabetised_text_616;
Constant text_U51 = alphabetised_text_488;
Constant text_U52 = alphabetised_text_600;
Constant text_U53 = alphabetised_text_616;
Constant text_U54 = alphabetised_text_488;
Constant text_U55 = alphabetised_text_601;
Constant text_U56 = alphabetised_text_616;
Constant text_U57 = alphabetised_text_488;
Constant text_U58 = alphabetised_text_602;
Constant text_U59 = alphabetised_text_616;
Constant text_U60 = alphabetised_text_488;
Constant text_U61 = alphabetised_text_493;
Constant text_U62 = alphabetised_text_616;
Constant text_U63 = alphabetised_text_488;
Constant text_U64 = alphabetised_text_628;
Constant text_U65 = alphabetised_text_616;
Constant text_U66 = alphabetised_text_488;
Constant text_U67 = alphabetised_text_623;
Constant text_U68 = alphabetised_text_616;
Constant text_U69 = alphabetised_text_488;
Constant text_U70 = alphabetised_text_490;
Constant text_U71 = alphabetised_text_616;
Constant text_U72 = alphabetised_text_488;
Constant text_U73 = alphabetised_text_524;
Constant text_U74 = alphabetised_text_616;
Constant text_U75 = alphabetised_text_488;
Constant text_U76 = alphabetised_text_553;
Constant text_U77 = alphabetised_text_616;
Constant text_U78 = alphabetised_text_488;
Constant text_U79 = alphabetised_text_640;
Constant text_U80 = alphabetised_text_406;
Constant text_U81 = alphabetised_text_420;
Constant text_U82 = alphabetised_text_640;
Constant text_U83 = alphabetised_text_561;
Constant text_U84 = alphabetised_text_636;
Constant text_U85 = alphabetised_text_340;
Constant RBNO0_OUTCOME_U1 = outcome_it_is_very_unlikely_U1;
Constant RBNO4_OUTCOME_U1 = outcome_it_is_very_likely_U1;
Constant RBNO3_OUTCOME_U1 = outcome_it_is_likely_U1;
Constant RBNO2_OUTCOME_U1 = outcome_it_is_possible_U1;
Constant RBNO1_OUTCOME_U1 = outcome_it_is_unlikely_U1;
Constant V4_issuing_the_response_text = activity_id_U4;
Constant V5_printing_a_number = activity_id_U5;
Constant V6_printing_room_description = activity_id_U6;
Constant V7_printing_inventory_detail = activity_id_U7;
Constant V8_listing_contents = activity_id_U8;
Constant V9_grouping_together = activity_id_U9;
Constant V10_writing_a_paragraph_about = activity_id_U10;
Constant V11_listing_nondescript_items = activity_id_U11;
Constant V12_printing_the_name_of_a_da = activity_id_U12;
Constant V13_printing_the_description_ = activity_id_U13;
Constant V14_printing_the_announcement = activity_id_U14;
Constant V15_printing_the_announcement = activity_id_U15;
Constant V16_printing_a_refusal_to_act = activity_id_U16;
Constant V17_constructing_the_status_l = activity_id_U17;
Constant V18_printing_the_banner_text = activity_id_U18;
Constant V19_reading_a_command = activity_id_U19;
Constant V20_deciding_the_scope = activity_id_U20;
Constant V21_deciding_the_concealed_po = activity_id_U21;
Constant V22_deciding_whether_all_incl = activity_id_U22;
Constant V23_clarifying_the_parser_s_c = activity_id_U23;
Constant V24_asking_which_do_you_mean = activity_id_U24;
Constant V25_printing_a_parser_error = activity_id_U25;
Constant V26_supplying_a_missing_noun = activity_id_U26;
Constant V27_supplying_a_missing_secon = activity_id_U27;
Constant V28_implicitly_taking = activity_id_U28;
Constant V29_amusing_a_victorious_play = activity_id_U29;
Constant V30_printing_the_player_s_obi = activity_id_U30;
Constant V31_handling_the_final_questi = activity_id_U31;
Constant V32_printing_the_locale_descr = activity_id_U32;
Constant V33_choosing_notable_locale_o = activity_id_U33;
Constant V34_printing_a_locale_paragra = activity_id_U34;
Constant text_U86 = alphabetised_text_488;
Constant text_U87 = alphabetised_text_489;
Constant text_U88 = alphabetised_text_472;
Constant text_U89 = alphabetised_text_610;
Constant text_U90 = alphabetised_text_439;
Constant text_U91 = alphabetised_text_561;
Constant text_U92 = alphabetised_text_577;
Constant K10_man_First = nothing;
Constant text_U93 = alphabetised_text_541;
Constant text_U94 = alphabetised_text_632;
Constant K12_animal_First = nothing;
Constant text_U95 = alphabetised_text_436;
Constant text_U96 = alphabetised_text_481;
Constant text_U97 = alphabetised_text_624;
Constant K15_player_s_holdall_First = nothing;
Constant text_U98 = alphabetised_text_565;
Constant text_U99 = alphabetised_text_10;
Constant text_U100 = alphabetised_text_203;
Constant text_U101 = alphabetised_text_318;
Constant text_U102 = alphabetised_text_156;
Constant text_U103 = alphabetised_text_416;
Constant column_identity_U1 = table_column_id_U1;
Constant text_U104 = alphabetised_text_229;
Constant text_U105 = alphabetised_text_230;
Constant text_U106 = alphabetised_text_587;
Constant text_U107 = alphabetised_text_226;
Constant text_U108 = alphabetised_text_369;
Constant column_identity_U2 = table_column_id_U2;
Constant column_identity_U3 = table_column_id_U3;
Constant column_identity_U4 = table_column_id_U4;
Constant column_identity_U5 = table_column_id_U5;
Constant column_identity_U6 = table_column_id_U6;
Constant column_identity_U7 = table_column_id_U7;
Constant V35_refusing_keys = activity_id_U35;
Constant K16_passkey_First = nothing;
Constant text_U109 = alphabetised_text_560;
Constant K17_keychain_First = nothing;
Constant text_U110 = alphabetised_text_528;
Constant V36_displaying = activity_id_U36;
Constant text_U111 = alphabetised_text_163;
Constant column_identity_U8 = table_column_id_U8;
Constant text_U112 = alphabetised_text_505;
Constant column_identity_U9 = table_column_id_U9;
Constant column_identity_U10 = table_column_id_U10;
Constant text_U113 = alphabetised_text_442;
Constant column_identity_U11 = table_column_id_U11;
Constant column_identity_U12 = table_column_id_U12;
Constant column_identity_U13 = table_column_id_U13;
Constant column_identity_U14 = table_column_id_U14;
Constant column_identity_U15 = table_column_id_U15;
Constant column_identity_U16 = table_column_id_U16;
Constant column_identity_U17 = table_column_id_U14;
Constant text_U114 = alphabetised_text_1;
Constant text_U115 = alphabetised_text_2;
Constant column_identity_U18 = table_column_id_U15;
Constant column_identity_U19 = table_column_id_U16;
Constant text_U116 = alphabetised_text_0;
Constant text_U117 = alphabetised_text_93;
Constant column_identity_U20 = table_column_id_U17;
Constant text_U118 = alphabetised_text_242;
Constant column_identity_U21 = table_column_id_U18;
Constant column_identity_U22 = table_column_id_U8;
Constant text_U119 = alphabetised_text_145;
Constant text_U120 = alphabetised_text_164;
Constant text_U121 = alphabetised_text_64;
Constant text_U122 = alphabetised_text_280;
Constant text_U123 = alphabetised_text_273;
Constant text_U124 = alphabetised_text_277;
Constant text_U125 = alphabetised_text_31;
Constant text_U126 = alphabetised_text_145;
Constant text_U127 = alphabetised_text_276;
Constant text_U128 = alphabetised_text_274;
Constant text_U129 = alphabetised_text_246;
Constant column_identity_U23 = table_column_id_U9;
Constant column_identity_U24 = table_column_id_U10;
Constant text_U130 = alphabetised_text_156;
Constant text_U131 = alphabetised_text_145;
Constant column_identity_U25 = table_column_id_U11;
Constant column_identity_U26 = table_column_id_U8;
Constant text_U132 = alphabetised_text_15;
Constant text_U133 = alphabetised_text_128;
Constant text_U134 = alphabetised_text_240;
Constant text_U135 = alphabetised_text_205;
Constant text_U136 = alphabetised_text_73;
Constant text_U137 = alphabetised_text_157;
Constant text_U138 = alphabetised_text_161;
Constant column_identity_U27 = table_column_id_U9;
Constant column_identity_U28 = table_column_id_U10;
Constant text_U139 = alphabetised_text_297;
Constant column_identity_U29 = table_column_id_U11;
Constant column_identity_U30 = table_column_id_U8;
Constant column_identity_U31 = table_column_id_U9;
Constant column_identity_U32 = table_column_id_U10;
Constant column_identity_U33 = table_column_id_U11;
Constant column_identity_U34 = table_column_id_U8;
Constant text_U140 = alphabetised_text_252;
Constant text_U141 = alphabetised_text_65;
Constant text_U142 = alphabetised_text_368;
Constant text_U143 = alphabetised_text_209;
Constant column_identity_U35 = table_column_id_U9;
Constant column_identity_U36 = table_column_id_U10;
Constant text_U144 = alphabetised_text_198;
Constant text_U145 = alphabetised_text_208;
Constant text_U146 = alphabetised_text_199;
Constant text_U147 = alphabetised_text_210;
Constant column_identity_U37 = table_column_id_U11;
Constant column_identity_U38 = table_column_id_U8;
Constant text_U148 = alphabetised_text_107;
Constant text_U149 = alphabetised_text_232;
Constant text_U150 = alphabetised_text_33;
Constant text_U151 = alphabetised_text_74;
Constant column_identity_U39 = table_column_id_U9;
Constant column_identity_U40 = table_column_id_U10;
Constant text_U152 = alphabetised_text_221;
Constant column_identity_U41 = table_column_id_U11;
Constant V37_pausing_the_game = activity_id_U37;
Constant column_identity_U42 = table_column_id_U14;
Constant column_identity_U43 = table_column_id_U15;
Constant column_identity_U44 = table_column_id_U16;
Constant text_U153 = alphabetised_text_212;
Constant text_U154 = alphabetised_text_478;
Constant text_U155 = alphabetised_text_411;
Constant text_U156 = alphabetised_text_627;
Constant text_U157 = alphabetised_text_472;
Constant text_U158 = alphabetised_text_536;
Constant text_U159 = alphabetised_text_298;
Constant text_U160 = alphabetised_text_439;
Constant text_U161 = alphabetised_text_241;
Constant text_U162 = alphabetised_text_439;
Constant text_U163 = alphabetised_text_585;
Constant text_U164 = alphabetised_text_421;
Constant text_U165 = alphabetised_text_12;
Constant text_U166 = alphabetised_text_610;
Constant text_U167 = alphabetised_text_572;
Constant text_U168 = alphabetised_text_573;
Constant text_U169 = alphabetised_text_572;
Constant text_U170 = alphabetised_text_573;
Constant text_U171 = alphabetised_text_572;
Constant text_U172 = alphabetised_text_573;
Constant text_U173 = alphabetised_text_547;
Constant text_U174 = alphabetised_text_114;
Constant text_U175 = alphabetised_text_548;
Constant text_U176 = alphabetised_text_592;
Constant text_U177 = alphabetised_text_439;
Constant text_U178 = alphabetised_text_516;
Constant text_U179 = alphabetised_text_439;
Constant text_U180 = alphabetised_text_145;
Constant text_U181 = alphabetised_text_439;
Constant text_U182 = alphabetised_text_486;
Constant text_U183 = alphabetised_text_487;
Constant text_U184 = alphabetised_text_486;
Constant text_U185 = alphabetised_text_487;
Constant text_U186 = alphabetised_text_486;
Constant text_U187 = alphabetised_text_487;
Constant text_U188 = alphabetised_text_486;
Constant text_U189 = alphabetised_text_487;
Constant text_U190 = alphabetised_text_486;
Constant text_U191 = alphabetised_text_487;
Constant text_U192 = alphabetised_text_100;
Constant text_U193 = alphabetised_text_103;
Constant text_U194 = alphabetised_text_102;
Constant text_U195 = alphabetised_text_98;
Constant text_U196 = alphabetised_text_101;
Constant text_U197 = alphabetised_text_99;
Constant text_U198 = alphabetised_text_97;
Constant text_U199 = alphabetised_text_591;
Constant text_U200 = alphabetised_text_348;
Constant text_U201 = alphabetised_text_266;
Constant text_U202 = alphabetised_text_506;
Constant text_U203 = alphabetised_text_543;
Constant text_U204 = alphabetised_text_325;
Constant text_U205 = alphabetised_text_472;
Constant text_U206 = alphabetised_text_506;
Constant text_U207 = alphabetised_text_219;
Constant text_U208 = alphabetised_text_437;
Constant text_U209 = alphabetised_text_506;
Constant text_U210 = alphabetised_text_634;
Constant text_U211 = alphabetised_text_610;
Constant text_U212 = alphabetised_text_506;
Constant text_U213 = alphabetised_text_517;
Constant text_U214 = alphabetised_text_29;
Constant text_U215 = alphabetised_text_610;
Constant text_U216 = alphabetised_text_506;
Constant text_U217 = alphabetised_text_525;
Constant text_U218 = alphabetised_text_13;
Constant text_U219 = alphabetised_text_610;
Constant text_U220 = alphabetised_text_506;
Constant text_U221 = alphabetised_text_507;
Constant text_U222 = alphabetised_text_30;
Constant text_U223 = alphabetised_text_610;
Constant text_U224 = alphabetised_text_506;
Constant text_U225 = alphabetised_text_261;
Constant text_U226 = alphabetised_text_437;
Constant text_U227 = alphabetised_text_506;
Constant text_U228 = alphabetised_text_86;
Constant text_U229 = alphabetised_text_437;
Constant text_U230 = alphabetised_text_506;
Constant text_U231 = alphabetised_text_571;
Constant text_U232 = alphabetised_text_295;
Constant text_U233 = alphabetised_text_472;
Constant text_U234 = alphabetised_text_456;
Constant text_U235 = alphabetised_text_526;
Constant text_U236 = alphabetised_text_635;
Constant text_U237 = alphabetised_text_496;
Constant text_U238 = alphabetised_text_500;
Constant text_U239 = alphabetised_text_497;
Constant text_U240 = alphabetised_text_593;
Constant text_U241 = alphabetised_text_127;
Constant text_U242 = alphabetised_text_3;
Constant text_U243 = alphabetised_text_260;
Constant text_U244 = alphabetised_text_357;
Constant text_U245 = alphabetised_text_557;
Constant text_U246 = alphabetised_text_437;
Constant text_U247 = alphabetised_text_559;
Constant text_U248 = alphabetised_text_558;
Constant text_U249 = alphabetised_text_445;
Constant text_U250 = alphabetised_text_472;
Constant text_U251 = alphabetised_text_637;
Constant text_U252 = alphabetised_text_615;
Constant text_U253 = alphabetised_text_326;
Constant text_U254 = alphabetised_text_638;
Constant text_U255 = alphabetised_text_418;
Constant text_U256 = alphabetised_text_451;
Constant text_U257 = alphabetised_text_472;
Constant text_U258 = alphabetised_text_450;
Constant text_U259 = alphabetised_text_283;
Constant text_U260 = alphabetised_text_37;
Constant text_U261 = alphabetised_text_434;
Constant text_U262 = alphabetised_text_353;
Constant text_U263 = alphabetised_text_522;
Constant text_U264 = alphabetised_text_472;
Constant text_U265 = alphabetised_text_479;
Constant text_U266 = alphabetised_text_169;
Constant text_U267 = alphabetised_text_610;
Constant text_U268 = alphabetised_text_639;
Constant text_U269 = alphabetised_text_510;
Constant text_U270 = alphabetised_text_472;
Constant text_U271 = alphabetised_text_556;
Constant text_U272 = alphabetised_text_123;
Constant text_U273 = alphabetised_text_143;
Constant text_U274 = alphabetised_text_63;
Constant text_U275 = alphabetised_text_290;
Constant text_U276 = alphabetised_text_248;
Constant text_U277 = alphabetised_text_413;
Constant text_U278 = alphabetised_text_56;
Constant text_U279 = alphabetised_text_48;
Constant text_U280 = alphabetised_text_285;
Constant text_U281 = alphabetised_text_152;
Constant text_U282 = alphabetised_text_618;
Constant text_U283 = alphabetised_text_148;
Constant text_U284 = alphabetised_text_579;
Constant text_U285 = alphabetised_text_463;
Constant text_U286 = alphabetised_text_437;
Constant text_U287 = alphabetised_text_124;
Constant text_U288 = alphabetised_text_641;
Constant text_U289 = alphabetised_text_579;
Constant text_U290 = alphabetised_text_110;
Constant text_U291 = alphabetised_text_644;
Constant text_U292 = alphabetised_text_579;
Constant text_U293 = alphabetised_text_50;
Constant text_U294 = alphabetised_text_642;
Constant text_U295 = alphabetised_text_579;
Constant text_U296 = alphabetised_text_58;
Constant text_U297 = alphabetised_text_643;
Constant text_U298 = alphabetised_text_579;
Constant text_U299 = alphabetised_text_590;
Constant text_U300 = alphabetised_text_621;
Constant text_U301 = alphabetised_text_328;
Constant text_U302 = alphabetised_text_363;
Constant text_U303 = alphabetised_text_542;
Constant text_U304 = alphabetised_text_598;
Constant text_U305 = alphabetised_text_355;
Constant text_U306 = alphabetised_text_503;
Constant text_U307 = alphabetised_text_457;
Constant text_U308 = alphabetised_text_350;
Constant text_U309 = alphabetised_text_47;
Constant text_U310 = alphabetised_text_458;
Constant text_U311 = alphabetised_text_284;
Constant text_U312 = alphabetised_text_462;
Constant text_U313 = alphabetised_text_286;
Constant text_U314 = alphabetised_text_477;
Constant text_U315 = alphabetised_text_291;
Constant text_U316 = alphabetised_text_75;
Constant text_U317 = alphabetised_text_599;
Constant text_U318 = alphabetised_text_322;
Constant text_U319 = alphabetised_text_218;
Constant text_U320 = alphabetised_text_616;
Constant text_U321 = alphabetised_text_108;
Constant text_U322 = alphabetised_text_616;
Constant text_U323 = alphabetised_text_85;
Constant text_U324 = alphabetised_text_616;
Constant text_U325 = alphabetised_text_540;
Constant text_U326 = alphabetised_text_330;
Constant text_U327 = alphabetised_text_614;
Constant text_U328 = alphabetised_text_351;
Constant text_U329 = alphabetised_text_583;
Constant text_U330 = alphabetised_text_438;
Constant text_U331 = alphabetised_text_499;
Constant text_U332 = alphabetised_text_461;
Constant text_U333 = alphabetised_text_476;
Constant text_U334 = alphabetised_text_569;
Constant text_U335 = alphabetised_text_532;
Constant text_U336 = alphabetised_text_332;
Constant text_U337 = alphabetised_text_538;
Constant text_U338 = alphabetised_text_300;
Constant text_U339 = alphabetised_text_446;
Constant text_U340 = alphabetised_text_87;
Constant text_U341 = alphabetised_text_544;
Constant text_U342 = alphabetised_text_279;
Constant text_U343 = alphabetised_text_487;
Constant text_U344 = alphabetised_text_595;
Constant text_U345 = alphabetised_text_410;
Constant text_U346 = alphabetised_text_567;
Constant text_U347 = alphabetised_text_596;
Constant text_U348 = alphabetised_text_347;
Constant text_U349 = alphabetised_text_564;
Constant text_U350 = alphabetised_text_349;
Constant text_U351 = alphabetised_text_610;
Constant text_U352 = alphabetised_text_594;
Constant text_U353 = alphabetised_text_409;
Constant text_U354 = alphabetised_text_568;
Constant text_U355 = alphabetised_text_342;
Constant text_U356 = alphabetised_text_511;
Constant text_U357 = alphabetised_text_346;
Constant text_U358 = alphabetised_text_443;
Constant text_U359 = alphabetised_text_444;
Constant text_U360 = alphabetised_text_443;
Constant text_U361 = alphabetised_text_444;
Constant text_U362 = alphabetised_text_443;
Constant text_U363 = alphabetised_text_444;
Constant text_U364 = alphabetised_text_545;
Constant text_U365 = alphabetised_text_249;
Constant text_U366 = alphabetised_text_589;
Constant text_U367 = alphabetised_text_321;
Constant text_U368 = alphabetised_text_32;
Constant text_U369 = alphabetised_text_150;
Constant text_U370 = alphabetised_text_561;
Constant text_U371 = alphabetised_text_179;
Constant text_U372 = alphabetised_text_181;
Constant text_U373 = alphabetised_text_632;
Constant text_U374 = alphabetised_text_588;
Constant text_U375 = alphabetised_text_345;
Constant text_U376 = alphabetised_text_254;
Constant text_U377 = alphabetised_text_324;
Constant text_U378 = alphabetised_text_626;
Constant text_U379 = alphabetised_text_472;
Constant text_U380 = alphabetised_text_530;
Constant text_U381 = alphabetised_text_338;
Constant text_U382 = alphabetised_text_494;
Constant text_U383 = alphabetised_text_504;
Constant text_U384 = alphabetised_text_352;
Constant text_U385 = alphabetised_text_610;
Constant text_U386 = alphabetised_text_109;
Constant text_U387 = alphabetised_text_437;
Constant text_U388 = alphabetised_text_49;
Constant text_U389 = alphabetised_text_437;
Constant text_U390 = alphabetised_text_622;
Constant text_U391 = alphabetised_text_167;
Constant text_U392 = alphabetised_text_151;
Constant text_U393 = alphabetised_text_200;
Constant text_U394 = alphabetised_text_296;
Constant text_U395 = alphabetised_text_632;
Constant text_U396 = alphabetised_text_57;
Constant text_U397 = alphabetised_text_437;
Constant text_U398 = alphabetised_text_236;
Constant text_U399 = alphabetised_text_146;
Constant text_U400 = alphabetised_text_437;
Constant text_U401 = alphabetised_text_78;
Constant text_U402 = alphabetised_text_354;
Constant text_U403 = alphabetised_text_492;
Constant text_U404 = alphabetised_text_440;
Constant text_U405 = alphabetised_text_562;
Constant text_U406 = alphabetised_text_472;
Constant text_U407 = alphabetised_text_502;
Constant text_U408 = alphabetised_text_494;
Constant text_U409 = alphabetised_text_190;
Constant text_U410 = alphabetised_text_299;
Constant text_U411 = alphabetised_text_584;
Constant text_U412 = alphabetised_text_244;
Constant text_U413 = alphabetised_text_555;
Constant text_U414 = alphabetised_text_244;
Constant text_U415 = alphabetised_text_515;
Constant text_U416 = alphabetised_text_244;
Constant text_U417 = alphabetised_text_625;
Constant text_U418 = alphabetised_text_448;
Constant text_U419 = alphabetised_text_581;
Constant text_U420 = alphabetised_text_552;
Constant text_U421 = alphabetised_text_184;
Constant text_U422 = alphabetised_text_468;
Constant text_U423 = alphabetised_text_534;
Constant text_U424 = alphabetised_text_539;
Constant text_U425 = alphabetised_text_608;
Constant text_U426 = alphabetised_text_610;
Constant text_U427 = alphabetised_text_470;
Constant text_U428 = alphabetised_text_480;
Constant text_U429 = alphabetised_text_610;
Constant text_U430 = alphabetised_text_491;
Constant text_U431 = alphabetised_text_472;
Constant text_U432 = alphabetised_text_575;
Constant text_U433 = alphabetised_text_481;
Constant text_U434 = alphabetised_text_582;
Constant text_U435 = alphabetised_text_344;
Constant text_U436 = alphabetised_text_243;
Constant text_U437 = alphabetised_text_607;
Constant text_U438 = alphabetised_text_343;
Constant text_U439 = alphabetised_text_441;
Constant text_U440 = alphabetised_text_419;
Constant text_U441 = alphabetised_text_554;
Constant text_U442 = alphabetised_text_339;
Constant text_U443 = alphabetised_text_633;
Constant text_U444 = alphabetised_text_259;
Constant text_U445 = alphabetised_text_529;
Constant text_U446 = alphabetised_text_489;
Constant text_U447 = alphabetised_text_77;
Constant text_U448 = alphabetised_text_341;
Constant text_U449 = alphabetised_text_76;
Constant text_U450 = alphabetised_text_293;
Constant text_U451 = alphabetised_text_633;
Constant text_U452 = alphabetised_text_126;
Constant text_U453 = alphabetised_text_192;
Constant text_U454 = alphabetised_text_308;
Constant text_U455 = alphabetised_text_619;
Constant text_U456 = alphabetised_text_472;
Constant text_U457 = alphabetised_text_433;
Constant text_U458 = alphabetised_text_465;
Constant text_U459 = alphabetised_text_61;
Constant text_U460 = alphabetised_text_566;
Constant text_U461 = alphabetised_text_222;
Constant text_U462 = alphabetised_text_518;
Constant text_U463 = alphabetised_text_520;
Constant text_U464 = alphabetised_text_508;
Constant text_U465 = alphabetised_text_620;
Constant text_U466 = alphabetised_text_447;
Constant text_U467 = alphabetised_text_327;
Constant text_U468 = alphabetised_text_631;
Constant text_U469 = alphabetised_text_603;
Constant text_U470 = alphabetised_text_521;
Constant text_U471 = alphabetised_text_158;
Constant text_U472 = alphabetised_text_483;
Constant text_U473 = alphabetised_text_633;
Constant text_U474 = alphabetised_text_255;
Constant text_U475 = alphabetised_text_193;
Constant text_U476 = alphabetised_text_323;
Constant text_U477 = alphabetised_text_533;
Constant text_U478 = alphabetised_text_617;
Constant text_U479 = alphabetised_text_570;
Constant text_U480 = alphabetised_text_509;
Constant text_U481 = alphabetised_text_613;
Constant text_U482 = alphabetised_text_452;
Constant text_U483 = alphabetised_text_535;
Constant text_U484 = alphabetised_text_474;
Constant text_U485 = alphabetised_text_513;
Constant text_U486 = alphabetised_text_489;
Constant text_U487 = alphabetised_text_155;
Constant text_U488 = alphabetised_text_160;
Constant text_U489 = alphabetised_text_633;
Constant text_U490 = alphabetised_text_91;
Constant text_U491 = alphabetised_text_512;
Constant text_U492 = alphabetised_text_129;
Constant text_U493 = alphabetised_text_527;
Constant text_U494 = alphabetised_text_460;
Constant text_U495 = alphabetised_text_467;
Constant text_U496 = alphabetised_text_498;
Constant text_U497 = alphabetised_text_604;
Constant text_U498 = alphabetised_text_629;
Constant text_U499 = alphabetised_text_514;
Constant text_U500 = alphabetised_text_485;
Constant text_U501 = alphabetised_text_537;
Constant text_U502 = alphabetised_text_292;
Constant text_U503 = alphabetised_text_531;
Constant text_U504 = alphabetised_text_633;
Constant text_U505 = alphabetised_text_131;
Constant text_U506 = alphabetised_text_609;
Constant text_U507 = alphabetised_text_454;
Constant text_U508 = alphabetised_text_605;
Constant text_U509 = alphabetised_text_578;
Constant text_U510 = alphabetised_text_501;
Constant text_U511 = alphabetised_text_586;
Constant text_U512 = alphabetised_text_453;
Constant text_U513 = alphabetised_text_519;
Constant text_U514 = alphabetised_text_630;
Constant text_U515 = alphabetised_text_576;
Constant text_U516 = alphabetised_text_415;
Constant text_U517 = alphabetised_text_633;
Constant text_U518 = alphabetised_text_237;
Constant text_U519 = alphabetised_text_147;
Constant text_U520 = alphabetised_text_11;
Constant text_U521 = alphabetised_text_624;
Constant text_U522 = alphabetised_text_606;
Constant text_U523 = alphabetised_text_356;
Constant text_U524 = alphabetised_text_256;
Constant text_U525 = alphabetised_text_464;
Constant text_U526 = alphabetised_text_289;
Constant text_U527 = alphabetised_text_60;
Constant text_U528 = alphabetised_text_574;
Constant text_U529 = alphabetised_text_317;
Constant text_U530 = alphabetised_text_455;
Constant text_U531 = alphabetised_text_168;
Constant text_U532 = alphabetised_text_580;
Constant text_U533 = alphabetised_text_563;
Constant text_U534 = alphabetised_text_337;
Constant text_U535 = alphabetised_text_220;
Constant text_U536 = alphabetised_text_482;
Constant text_U537 = alphabetised_text_294;
Constant text_U538 = alphabetised_text_81;
Constant text_U539 = alphabetised_text_612;
Constant text_U540 = alphabetised_text_336;
Constant text_U541 = alphabetised_text_72;
Constant text_U542 = alphabetised_text_449;
Constant text_U543 = alphabetised_text_481;
Constant text_U544 = alphabetised_text_469;
Constant text_U545 = alphabetised_text_475;
Constant text_U546 = alphabetised_text_466;
Constant text_U547 = alphabetised_text_69;
Constant text_U548 = alphabetised_text_473;
Constant text_U549 = alphabetised_text_71;
Constant text_U550 = alphabetised_text_473;
Constant text_U551 = alphabetised_text_67;
Constant text_U552 = alphabetised_text_473;
Constant text_U553 = alphabetised_text_70;
Constant text_U554 = alphabetised_text_473;
Constant text_U555 = alphabetised_text_68;
Constant text_U556 = alphabetised_text_473;
Constant text_U557 = alphabetised_text_66;
Constant text_U558 = alphabetised_text_473;
Constant text_U559 = alphabetised_text_546;
Constant text_U560 = alphabetised_text_195;
Constant text_U561 = alphabetised_text_577;
Constant text_U562 = alphabetised_text_149;
Constant text_U563 = alphabetised_text_577;
Constant text_U564 = alphabetised_text_96;
Constant text_U565 = alphabetised_text_577;
Constant text_U566 = alphabetised_text_31;
Constant text_U567 = alphabetised_text_577;
Constant text_U568 = alphabetised_text_245;
Constant text_U569 = alphabetised_text_577;
Constant abilities_U7 = (RELS_TEST);
Constant abilities_U8 = (RELS_TEST);
Constant abilities_U10 = (RELS_TEST);
Constant abilities_U11 = (RELS_TEST);
Constant V38_showing_action = activity_id_U38;
Constant text_U570 = alphabetised_text_503;
Constant text_U571 = alphabetised_text_494;
Constant text_U572 = alphabetised_text_437;
Constant text_U573 = alphabetised_text_471;
Constant text_U574 = alphabetised_text_548;
Constant text_U575 = alphabetised_text_114;
Constant text_U576 = alphabetised_text_487;
Constant text_U577 = alphabetised_text_573;
Constant text_U578 = alphabetised_text_495;
Constant text_U579 = alphabetised_text_597;
Constant text_U580 = alphabetised_text_523;
Constant text_U581 = alphabetised_text_506;
Constant text_U582 = alphabetised_text_611;
Constant text_U583 = alphabetised_text_579;
Constant text_U584 = alphabetised_text_444;
Constant text_U585 = alphabetised_text_633;
Constant text_U586 = alphabetised_text_473;
Constant text_U587 = alphabetised_text_459;
Constant text_U588 = alphabetised_text_484;
Constant text_U589 = alphabetised_text_533;
Constant text_U590 = alphabetised_text_145;
Constant text_U591 = alphabetised_text_145;
Constant text_U592 = alphabetised_text_145;
Constant text_U593 = alphabetised_text_55;
Constant text_U594 = alphabetised_text_269;
Constant text_U595 = alphabetised_text_270;
Constant text_U596 = alphabetised_text_145;
Constant text_U597 = alphabetised_text_145;
Constant column_identity_U45 = table_column_id_U28;
Constant text_U598 = alphabetised_text_4;
Constant text_U599 = alphabetised_text_5;
Constant text_U600 = alphabetised_text_6;
Constant text_U601 = alphabetised_text_7;
Constant column_identity_U46 = table_column_id_U29;
Constant column_identity_U47 = table_column_id_U10;
Constant text_U602 = alphabetised_text_432;
Constant text_U603 = alphabetised_text_422;
Constant text_U604 = alphabetised_text_429;
Constant text_U605 = alphabetised_text_425;
Constant column_identity_U48 = table_column_id_U28;
Constant text_U606 = alphabetised_text_4;
Constant text_U607 = alphabetised_text_5;
Constant text_U608 = alphabetised_text_6;
Constant text_U609 = alphabetised_text_7;
Constant text_U610 = alphabetised_text_8;
Constant column_identity_U49 = table_column_id_U29;
Constant column_identity_U50 = table_column_id_U30;
Constant column_identity_U51 = table_column_id_U10;
Constant text_U611 = alphabetised_text_162;
Constant text_U612 = alphabetised_text_180;
Constant text_U613 = alphabetised_text_312;
Constant text_U614 = alphabetised_text_182;
Constant text_U615 = alphabetised_text_313;
Constant column_identity_U52 = table_column_id_U31;
Constant column_identity_U53 = table_column_id_U32;
Constant text_U616 = alphabetised_text_236;
Constant text_U617 = alphabetised_text_259;
Constant text_U618 = alphabetised_text_126;
Constant text_U619 = alphabetised_text_255;
Constant text_U620 = alphabetised_text_91;
Constant text_U621 = alphabetised_text_131;
Constant text_U622 = alphabetised_text_237;
Constant column_identity_U54 = table_column_id_U33;
Constant column_identity_U55 = table_column_id_U10;
Constant text_U623 = alphabetised_text_288;
Constant text_U624 = alphabetised_text_314;
Constant text_U625 = alphabetised_text_316;
Constant text_U626 = alphabetised_text_315;
Constant column_identity_U56 = table_column_id_U8;
Constant text_U627 = alphabetised_text_379;
Constant text_U628 = alphabetised_text_381;
Constant text_U629 = alphabetised_text_388;
Constant column_identity_U57 = table_column_id_U9;
Constant column_identity_U58 = table_column_id_U10;
Constant column_identity_U59 = table_column_id_U11;
Constant column_identity_U60 = table_column_id_U8;
Constant text_U630 = alphabetised_text_53;
Constant text_U631 = alphabetised_text_384;
Constant text_U632 = alphabetised_text_319;
Constant column_identity_U61 = table_column_id_U9;
Constant column_identity_U62 = table_column_id_U10;
Constant column_identity_U63 = table_column_id_U11;
Constant column_identity_U64 = table_column_id_U8;
Constant text_U633 = alphabetised_text_26;
Constant text_U634 = alphabetised_text_387;
Constant column_identity_U65 = table_column_id_U9;
Constant column_identity_U66 = table_column_id_U10;
Constant column_identity_U67 = table_column_id_U11;
Constant column_identity_U68 = table_column_id_U8;
Constant text_U635 = alphabetised_text_386;
Constant text_U636 = alphabetised_text_24;
Constant column_identity_U69 = table_column_id_U9;
Constant column_identity_U70 = table_column_id_U10;
Constant column_identity_U71 = table_column_id_U11;
Constant column_identity_U72 = table_column_id_U8;
Constant text_U637 = alphabetised_text_385;
Constant text_U638 = alphabetised_text_377;
Constant column_identity_U73 = table_column_id_U9;
Constant column_identity_U74 = table_column_id_U10;
Constant column_identity_U75 = table_column_id_U11;
Constant column_identity_U76 = table_column_id_U8;
Constant text_U639 = alphabetised_text_378;
Constant text_U640 = alphabetised_text_25;
Constant column_identity_U77 = table_column_id_U9;
Constant column_identity_U78 = table_column_id_U10;
Constant column_identity_U79 = table_column_id_U11;
Constant column_identity_U80 = table_column_id_U8;
Constant text_U641 = alphabetised_text_272;
Constant text_U642 = alphabetised_text_376;
Constant column_identity_U81 = table_column_id_U9;
Constant column_identity_U82 = table_column_id_U10;
Constant column_identity_U83 = table_column_id_U11;
Constant column_identity_U84 = table_column_id_U19;
Constant column_identity_U85 = table_column_id_U20;
Constant column_identity_U86 = table_column_id_U10;
Constant text_U643 = alphabetised_text_268;
Constant text_U644 = alphabetised_text_95;
Constant text_U645 = alphabetised_text_113;
Constant text_U646 = alphabetised_text_52;
Constant text_U647 = alphabetised_text_373;
Constant text_U648 = alphabetised_text_270;
Constant text_U649 = alphabetised_text_269;
Constant text_U650 = alphabetised_text_267;
Constant text_U651 = alphabetised_text_367;
Constant text_U652 = alphabetised_text_111;
Constant text_U653 = alphabetised_text_112;
Constant text_U654 = alphabetised_text_43;
Constant text_U655 = alphabetised_text_16;
Constant text_U656 = alphabetised_text_17;
Constant text_U657 = alphabetised_text_18;
Constant text_U658 = alphabetised_text_19;
Constant text_U659 = alphabetised_text_20;
Constant text_U660 = alphabetised_text_115;
Constant text_U661 = alphabetised_text_116;
Constant text_U662 = alphabetised_text_117;
Constant text_U663 = alphabetised_text_118;
Constant text_U664 = alphabetised_text_119;
Constant text_U665 = alphabetised_text_120;
Constant text_U666 = alphabetised_text_401;
Constant text_U667 = alphabetised_text_393;
Constant text_U668 = alphabetised_text_398;
Constant text_U669 = alphabetised_text_391;
Constant text_U670 = alphabetised_text_400;
Constant text_U671 = alphabetised_text_392;
Constant text_U672 = alphabetised_text_396;
Constant text_U673 = alphabetised_text_399;
Constant text_U674 = alphabetised_text_390;
Constant text_U675 = alphabetised_text_394;
Constant text_U676 = alphabetised_text_395;
Constant text_U677 = alphabetised_text_397;
Constant column_identity_U87 = table_column_id_U21;
Constant column_identity_U88 = table_column_id_U22;
Constant text_U678 = alphabetised_text_153;
Constant text_U679 = alphabetised_text_154;
Constant text_U680 = alphabetised_text_142;
Constant column_identity_U89 = table_column_id_U23;
Constant text_U681 = alphabetised_text_178;
Constant text_U682 = alphabetised_text_217;
Constant text_U683 = alphabetised_text_28;
Constant text_U684 = alphabetised_text_258;
Constant text_U685 = alphabetised_text_271;
Constant text_U686 = alphabetised_text_215;
Constant text_U687 = alphabetised_text_89;
Constant text_U688 = alphabetised_text_370;
Constant text_U689 = alphabetised_text_374;
Constant text_U690 = alphabetised_text_171;
Constant text_U691 = alphabetised_text_59;
Constant text_U692 = alphabetised_text_189;
Constant text_U693 = alphabetised_text_227;
Constant text_U694 = alphabetised_text_39;
Constant text_U695 = alphabetised_text_42;
Constant text_U696 = alphabetised_text_239;
Constant text_U697 = alphabetised_text_104;
Constant text_U698 = alphabetised_text_170;
Constant text_U699 = alphabetised_text_275;
Constant text_U700 = alphabetised_text_79;
Constant text_U701 = alphabetised_text_46;
Constant text_U702 = alphabetised_text_21;
Constant text_U703 = alphabetised_text_213;
Constant text_U704 = alphabetised_text_228;
Constant text_U705 = alphabetised_text_196;
Constant text_U706 = alphabetised_text_235;
Constant text_U707 = alphabetised_text_38;
Constant text_U708 = alphabetised_text_250;
Constant text_U709 = alphabetised_text_35;
Constant text_U710 = alphabetised_text_372;
Constant text_U711 = alphabetised_text_92;
Constant text_U712 = alphabetised_text_175;
Constant text_U713 = alphabetised_text_80;
Constant text_U714 = alphabetised_text_34;
Constant text_U715 = alphabetised_text_36;
Constant text_U716 = alphabetised_text_201;
Constant text_U717 = alphabetised_text_278;
Constant text_U718 = alphabetised_text_45;
Constant text_U719 = alphabetised_text_281;
Constant text_U720 = alphabetised_text_282;
Constant column_identity_U90 = table_column_id_U24;
Constant text_U721 = alphabetised_text_122;
Constant text_U722 = alphabetised_text_62;
Constant text_U723 = alphabetised_text_234;
Constant text_U724 = alphabetised_text_23;
Constant text_U725 = alphabetised_text_247;
Constant text_U726 = alphabetised_text_132;
Constant text_U727 = alphabetised_text_172;
Constant text_U728 = alphabetised_text_44;
Constant text_U729 = alphabetised_text_22;
Constant text_U730 = alphabetised_text_121;
Constant text_U731 = alphabetised_text_214;
Constant text_U732 = alphabetised_text_265;
Constant text_U733 = alphabetised_text_40;
Constant text_U734 = alphabetised_text_197;
Constant text_U735 = alphabetised_text_176;
Constant text_U736 = alphabetised_text_263;
Constant text_U737 = alphabetised_text_191;
Constant text_U738 = alphabetised_text_125;
Constant text_U739 = alphabetised_text_159;
Constant text_U740 = alphabetised_text_211;
Constant text_U741 = alphabetised_text_90;
Constant text_U742 = alphabetised_text_177;
Constant text_U743 = alphabetised_text_188;
Constant text_U744 = alphabetised_text_194;
Constant text_U745 = alphabetised_text_202;
Constant text_U746 = alphabetised_text_204;
Constant text_U747 = alphabetised_text_362;
Constant text_U748 = alphabetised_text_216;
Constant text_U749 = alphabetised_text_375;
Constant text_U750 = alphabetised_text_251;
Constant text_U751 = alphabetised_text_231;
Constant text_U752 = alphabetised_text_417;
Constant text_U753 = alphabetised_text_257;
Constant text_U754 = alphabetised_text_144;
Constant text_U755 = alphabetised_text_264;
Constant text_U756 = alphabetised_text_238;
Constant text_U757 = alphabetised_text_41;
Constant text_U758 = alphabetised_text_223;
Constant text_U759 = alphabetised_text_403;
Constant column_identity_U91 = table_column_id_U25;
Constant column_identity_U92 = table_column_id_U26;
Constant column_identity_U93 = table_column_id_U27;
Constant column_identity_U94 = table_column_id_U10;
Constant text_U760 = alphabetised_text_305;
Constant text_U761 = alphabetised_text_304;
Constant text_U762 = alphabetised_text_302;
Constant text_U763 = alphabetised_text_301;
Constant text_U764 = alphabetised_text_306;
Constant text_U765 = alphabetised_text_303;
Constant text_U766 = alphabetised_text_307;
Constant column_identity_U95 = table_column_id_U28;
Constant text_U767 = alphabetised_text_4;
Constant text_U768 = alphabetised_text_5;
Constant text_U769 = alphabetised_text_6;
Constant text_U770 = alphabetised_text_7;
Constant column_identity_U96 = table_column_id_U29;
Constant column_identity_U97 = table_column_id_U10;
Constant text_U771 = alphabetised_text_431;
Constant text_U772 = alphabetised_text_435;
Constant text_U773 = alphabetised_text_427;
Constant text_U774 = alphabetised_text_430;
Constant column_identity_U98 = table_column_id_U28;
Constant text_U775 = alphabetised_text_4;
Constant text_U776 = alphabetised_text_5;
Constant text_U777 = alphabetised_text_6;
Constant text_U778 = alphabetised_text_7;
Constant column_identity_U99 = table_column_id_U29;
Constant column_identity_U100 = table_column_id_U10;
Constant text_U779 = alphabetised_text_423;
Constant text_U780 = alphabetised_text_426;
Constant text_U781 = alphabetised_text_424;
Constant text_U782 = alphabetised_text_428;
Constant column_identity_U101 = table_column_id_U28;
Constant text_U783 = alphabetised_text_4;
Constant text_U784 = alphabetised_text_5;
Constant text_U785 = alphabetised_text_6;
Constant text_U786 = alphabetised_text_7;
Constant text_U787 = alphabetised_text_8;
Constant text_U788 = alphabetised_text_9;
Constant column_identity_U102 = table_column_id_U29;
Constant column_identity_U103 = table_column_id_U30;
Constant column_identity_U104 = table_column_id_U17;
Constant text_U789 = alphabetised_text_141;
Constant text_U790 = alphabetised_text_414;
Constant text_U791 = alphabetised_text_183;
Constant column_identity_U105 = table_column_id_U18;
Constant column_identity_U106 = table_column_id_U17;
Constant text_U792 = alphabetised_text_187;
Constant text_U793 = alphabetised_text_186;
Constant text_U794 = alphabetised_text_310;
Constant text_U795 = alphabetised_text_51;
Constant column_identity_U107 = table_column_id_U18;
Constant column_identity_U108 = table_column_id_U17;
Constant text_U796 = alphabetised_text_233;
Constant text_U797 = alphabetised_text_206;
Constant column_identity_U109 = table_column_id_U18;
Constant column_identity_U110 = table_column_id_U17;
Constant text_U798 = alphabetised_text_389;
Constant text_U799 = alphabetised_text_166;
Constant text_U800 = alphabetised_text_27;
Constant text_U801 = alphabetised_text_380;
Constant text_U802 = alphabetised_text_311;
Constant text_U803 = alphabetised_text_225;
Constant column_identity_U111 = table_column_id_U18;
Constant column_identity_U112 = table_column_id_U17;
Constant text_U804 = alphabetised_text_358;
Constant text_U805 = alphabetised_text_407;
Constant column_identity_U113 = table_column_id_U18;
Constant column_identity_U114 = table_column_id_U17;
Constant text_U806 = alphabetised_text_383;
Constant text_U807 = alphabetised_text_361;
Constant column_identity_U115 = table_column_id_U18;
Constant column_identity_U116 = table_column_id_U17;
Constant text_U808 = alphabetised_text_262;
Constant text_U809 = alphabetised_text_137;
Constant column_identity_U117 = table_column_id_U18;
Constant column_identity_U118 = table_column_id_U17;
Constant text_U810 = alphabetised_text_14;
Constant text_U811 = alphabetised_text_404;
Constant column_identity_U119 = table_column_id_U18;
Constant column_identity_U120 = table_column_id_U17;
Constant text_U812 = alphabetised_text_382;
Constant text_U813 = alphabetised_text_287;
Constant text_U814 = alphabetised_text_173;
Constant column_identity_U121 = table_column_id_U18;
Constant column_identity_U122 = table_column_id_U17;
Constant text_U815 = alphabetised_text_133;
Constant column_identity_U123 = table_column_id_U18;
Constant column_identity_U124 = table_column_id_U17;
Constant text_U816 = alphabetised_text_130;
Constant text_U817 = alphabetised_text_88;
Constant text_U818 = alphabetised_text_134;
Constant text_U819 = alphabetised_text_331;
Constant text_U820 = alphabetised_text_207;
Constant text_U821 = alphabetised_text_309;
Constant column_identity_U125 = table_column_id_U18;
Constant column_identity_U126 = table_column_id_U17;
Constant text_U822 = alphabetised_text_412;
Constant column_identity_U127 = table_column_id_U18;
Constant column_identity_U128 = table_column_id_U17;
Constant text_U823 = alphabetised_text_105;
Constant text_U824 = alphabetised_text_84;
Constant text_U825 = alphabetised_text_83;
Constant column_identity_U129 = table_column_id_U18;
Constant column_identity_U130 = table_column_id_U17;
Constant text_U826 = alphabetised_text_106;
Constant text_U827 = alphabetised_text_94;
Constant text_U828 = alphabetised_text_174;
Constant column_identity_U131 = table_column_id_U18;
Constant column_identity_U132 = table_column_id_U17;
Constant text_U829 = alphabetised_text_329;
Constant text_U830 = alphabetised_text_135;
Constant text_U831 = alphabetised_text_54;
Constant text_U832 = alphabetised_text_320;
Constant text_U833 = alphabetised_text_366;
Constant column_identity_U133 = table_column_id_U18;
Constant column_identity_U134 = table_column_id_U17;
Constant text_U834 = alphabetised_text_408;
Constant text_U835 = alphabetised_text_185;
Constant column_identity_U135 = table_column_id_U18;
Constant column_identity_U136 = table_column_id_U17;
Constant text_U836 = alphabetised_text_405;
Constant text_U837 = alphabetised_text_335;
Constant text_U838 = alphabetised_text_139;
Constant text_U839 = alphabetised_text_136;
Constant column_identity_U137 = table_column_id_U18;
Constant column_identity_U138 = table_column_id_U17;
Constant text_U840 = alphabetised_text_371;
Constant text_U841 = alphabetised_text_140;
Constant text_U842 = alphabetised_text_82;
Constant text_U843 = alphabetised_text_365;
Constant column_identity_U139 = table_column_id_U18;
Constant column_identity_U140 = table_column_id_U17;
Constant text_U844 = alphabetised_text_333;
Constant text_U845 = alphabetised_text_334;
Constant text_U846 = alphabetised_text_138;
Constant text_U847 = alphabetised_text_364;
Constant text_U848 = alphabetised_text_253;
Constant text_U849 = alphabetised_text_165;
Constant text_U850 = alphabetised_text_224;
Constant column_identity_U141 = table_column_id_U18;
Constant text_U851 = alphabetised_text_402;
Constant text_U852 = alphabetised_text_145;
Constant text_U853 = alphabetised_text_318;
Constant text_U854 = alphabetised_text_203;
Constant text_U855 = alphabetised_text_360;
Constant text_U856 = alphabetised_text_359;
Constant GPR_REPARSE = REPARSE_CODE;
Constant TABLE_NOVALUE = IMPROBABLE_VALUE;
Constant RC_INFINITY = MAX_POSITIVE_NUMBER;
Constant RRVAL_V_TO_O = RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V = RELS_X_UNIQUE;
Constant RRVAL_SYM_V_TO_V = RELS_SYMMETRIC;
Constant NUMBER_SCENES_CREATED = ICOUNT_SCENE;
Constant ActionCount = CCOUNT_ACTION_NAME;
Constant NUM_DOORS = ICOUNT_DOOR;
Constant NUM_ROOMS = ICOUNT_ROOM;
Constant Computed_Constant_Value_2_U1 = (Computed_Constant_Value_0_U1 + Computed_Constant_Value_1_U1);
Constant Computed_Constant_Value_1_U2 = (GPR_NOUN + Computed_Constant_Value_0_U2);
Constant Computed_Constant_Value_3_U1 = (GPR_NOUN + Computed_Constant_Value_2_U2);
Constant Computed_Constant_Value_5_U1 = (GPR_NOUN + Computed_Constant_Value_4_U1);
Constant Computed_Constant_Value_7_U1 = (GPR_NOUN + Computed_Constant_Value_6_U1);
Constant Computed_Constant_Value_9_U1 = (GPR_NOUN + Computed_Constant_Value_8_U1);
Constant Computed_Constant_Value_11_U1 = (GPR_NOUN + Computed_Constant_Value_10_U1);
Constant Computed_Constant_Value_13_U1 = (DynamicMemoryAllocation / Computed_Constant_Value_12_U1);
Constant Computed_Constant_Value_17_U1 = (Computed_Constant_Value_16_U1 + MAX_FRAME_SIZE_NEEDED);
Constant Computed_Constant_Value_20_U1 = (Computed_Constant_Value_19_U1 * WORDSIZE);
Constant Computed_Constant_Value_22_U1 = (Computed_Constant_Value_21_U1 * WORDSIZE);
Constant Computed_Constant_Value_25_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_28_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_32_U1 = (BLK_BVBITMAP_TEXT + Computed_Constant_Value_31_U1);
Constant Computed_Constant_Value_33_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK);
Constant Computed_Constant_Value_36_U1 = (BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT);
Constant Computed_Constant_Value_40_U1 = (WORDSIZE * RE_PACKET_SIZE);
Constant Computed_Constant_Value_43_U1 = (RR_NAME - Computed_Constant_Value_42_U1);
Constant Computed_Constant_Value_45_U1 = (RR_PERMISSIONS - Computed_Constant_Value_44_U1);
Constant Computed_Constant_Value_47_U1 = (RR_STORAGE - Computed_Constant_Value_46_U1);
Constant Computed_Constant_Value_49_U1 = (RR_KIND - Computed_Constant_Value_48_U1);
Constant Computed_Constant_Value_51_U1 = (RR_HANDLER - Computed_Constant_Value_50_U1);
Constant Computed_Constant_Value_53_U1 = (RR_DESCRIPTION - Computed_Constant_Value_52_U1);
Constant Computed_Constant_Value_54_U1 = (RELS_X_UNIQUE + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_55_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_56_U1 = (RELS_SYMMETRIC + RELS_X_UNIQUE);
Constant Computed_Constant_Value_58_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_62_U1 = (ICOUNT_OBJECT + Computed_Constant_Value_61_U1);
Constant Computed_Constant_Value_15_U1 = (GG_ANYTOSTRING_LEN + Computed_Constant_Value_14_U1);
Constant Computed_Constant_Value_41_U1 = (RE_MAX_PACKETS * RE_PACKET_SIZE);
Constant Computed_Constant_Value_3_U2 = (Computed_Constant_Value_2_U3 * ICOUNT_OBJECT);
Constant Computed_Constant_Value_5_U2 = (ICOUNT_FIGURE_NAME + ICOUNT_SOUND_NAME);
Constant Computed_Constant_Value_12_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_11_U2);
Constant Computed_Constant_Value_14_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_13_U2);
Constant Computed_Constant_Value_16_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_15_U2);
Constant Computed_Constant_Value_18_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_17_U2);
Constant Computed_Constant_Value_20_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_19_U2);
Constant Computed_Constant_Value_22_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_21_U2);
Constant Computed_Constant_Value_1_U4 = (MATCH_LIST_WORDS + Computed_Constant_Value_0_U4);
Constant TEXT_TY_BufferSize = Computed_Constant_Value_2_U1;
Constant GPR_HELD = Computed_Constant_Value_1_U2;
Constant GPR_MULTI = Computed_Constant_Value_3_U1;
Constant GPR_MULTIHELD = Computed_Constant_Value_5_U1;
Constant GPR_MULTIEXCEPT = Computed_Constant_Value_7_U1;
Constant GPR_MULTIINSIDE = Computed_Constant_Value_9_U1;
Constant GPR_CREATURE = Computed_Constant_Value_11_U1;
Constant BLOCKV_STACK_SIZE = Computed_Constant_Value_13_U1;
Constant MAX_MSTACK_FRAME = Computed_Constant_Value_17_U1;
Constant BLK_DATA_OFFSET = Computed_Constant_Value_20_U1;
Constant PACKED_TEXT_STORAGE = Computed_Constant_Value_32_U1;
Constant TEXT_TY_Storage_Flags = Computed_Constant_Value_36_U1;
Constant RE_PACKET_SIZE_IN_BYTES = Computed_Constant_Value_40_U1;
Constant RRV_NAME = Computed_Constant_Value_43_U1;
Constant RRV_PERMISSIONS = Computed_Constant_Value_45_U1;
Constant RRV_STORAGE = Computed_Constant_Value_47_U1;
Constant RRV_KIND = Computed_Constant_Value_49_U1;
Constant RRV_HANDLER = Computed_Constant_Value_51_U1;
Constant RRV_DESCRIPTION = Computed_Constant_Value_53_U1;
Constant RRVAL_O_TO_O = Computed_Constant_Value_54_U1;
Constant RRVAL_EQUIV = Computed_Constant_Value_55_U1;
Constant MAX_ROUTE_LENGTH = Computed_Constant_Value_62_U1;
Constant Computed_Constant_Value_1_U3 = (NUMBER_SCENES_CREATED + Computed_Constant_Value_0_U3);
Constant REQUISITION_STACK_SIZE = Computed_Constant_Value_3_U2;
Constant Computed_Constant_Value_9_U2 = (NUM_DOORS + Computed_Constant_Value_8_U2);
Constant strong_id_U4 = DK2_activity_on_objects;
Constant strong_id_U5 = DK3_phrase_real_number____re;
Constant strong_id_U6 = DK4_phrase_real_number____nu;
Constant SCENE_ARRAY_SIZE = Computed_Constant_Value_1_U3;
Constant Computed_Constant_Value_10_U2 = (NUM_ROOMS * NUM_ROOMS);
Constant Computed_Constant_Value_27_U1 = (Computed_Constant_Value_25_U1 + Computed_Constant_Value_26_U1);
Constant Computed_Constant_Value_30_U1 = (Computed_Constant_Value_28_U1 + Computed_Constant_Value_29_U1);
Constant Computed_Constant_Value_35_U1 = (Computed_Constant_Value_33_U1 + Computed_Constant_Value_34_U1);
Constant Computed_Constant_Value_57_U1 = (Computed_Constant_Value_56_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_59_U1 = (Computed_Constant_Value_58_U1 + RELS_X_UNIQUE);
Constant Computed_Constant_Value_7_U2 = (Computed_Constant_Value_5_U2 + Computed_Constant_Value_6_U2);
Constant strong_id_U1 = DK10_relation_of_rooms_to_doo;
Constant strong_id_U2 = DK11_relation_of_passkeys_to_;
Constant strong_id_U3 = DK1_rule;
Constant strong_id_U7 = DK5_relation_of_values;
Constant strong_id_U8 = DK6_relation_of_objects;
Constant strong_id_U9 = DK7_relation_of_supporters_t;
Constant strong_id_U10 = DK8_relation_of_things;
Constant strong_id_U11 = DK9_relation_of_people_to_th;
Constant strong_id_U12 = DK12_relation_of_rooms;
Constant Computed_Constant_Value_18_U1 = (MSTACK_CAPACITY * MAX_MSTACK_FRAME);
Constant CONSTANT_PACKED_TEXT_STORAGE = Computed_Constant_Value_27_U1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = Computed_Constant_Value_30_U1;
Constant UNPACKED_TEXT_STORAGE = Computed_Constant_Value_35_U1;
Constant RRVAL_SYM_O_TO_O = Computed_Constant_Value_57_U1;
Constant Computed_Constant_Value_38_U1 = (TEXT_TY_BufferSize + Computed_Constant_Value_37_U1);
Constant MSTACK_SIZE = Computed_Constant_Value_18_U1;
Constant abilities_U6 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U15 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U19 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U20 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U21 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U22 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant Computed_Constant_Value_60_U1 = (Computed_Constant_Value_59_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_23_U1 = (BLK_DATA_OFFSET + Computed_Constant_Value_22_U1);
Constant VALENCY_MASK = Computed_Constant_Value_60_U1;
Constant Computed_Constant_Value_39_U1 = (Computed_Constant_Value_38_U1 * TEXT_TY_NoBuffers);
Constant BLK_DATA_MULTI_OFFSET = Computed_Constant_Value_23_U1;
Constant Story = bc_U2135;
Constant Headline = bc_U2136;
Constant Story_Author = bc_U2137;
Constant Computed_Constant_Value_24_U1 = (MEMORY_HEAP_SIZE + BLK_DATA_MULTI_OFFSET);
Constant abilities_U9 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U12 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U13 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U14 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U16 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U17 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U18 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U1 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U2 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U3 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U4 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_Y_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U5 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_SYMMETRIC + RELS_X_UNIQUE + RELS_Y_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant MEANINGLESS_RR = Rel_Record22;
Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;
Array A_absent --> [ 2; subterfuge_1; 1; "absent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_animate --> [ 2; subterfuge_2; 1; "animate"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_clothing --> [ 2; subterfuge_3; 1; "wearable"; K2_thing; NULL; ];
Array A_concealed --> [ 2; subterfuge_4; 1; "undescribed"; K2_thing; NULL; ];
Array A_container --> [ 2; subterfuge_5; 1; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door --> [ 2; subterfuge_6; 1; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_edible --> [ 2; subterfuge_7; 1; "edible"; K2_thing; NULL; ];
Array A_enterable --> [ 2; subterfuge_8; 1; "enterable"; K6_supporter; K5_container; NULL; ];
Array A_light --> [ 2; subterfuge_9; 1; "lighted"; K2_thing; K1_room; NULL; ];
Array A_lockable --> [ 2; subterfuge_10; 1; "lockable"; K4_door; K5_container; NULL; ];
Array A_locked --> [ 2; subterfuge_11; 1; "locked"; K4_door; K5_container; NULL; ];
Array A_moved --> [ 2; subterfuge_12; 1; "handled"; K2_thing; NULL; ];
Array A_on --> [ 2; subterfuge_13; 1; "switched on"; K13_device; NULL; ];
Array A_open --> [ 2; subterfuge_14; 1; "open"; K4_door; K5_container; NULL; ];
Array A_openable --> [ 2; subterfuge_15; 1; "openable"; K4_door; K5_container; NULL; ];
Array A_scenery --> [ 2; subterfuge_16; 1; "scenery"; K2_thing; K3_direction; NULL; ];
Array A_static --> [ 2; subterfuge_17; 1; "fixed in place"; K2_thing; NULL; ];
Array A_supporter --> [ 2; subterfuge_18; 1; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_switchable --> [ 2; subterfuge_19; 1; "switchable"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_talkable --> [ 2; subterfuge_20; 1; "<nameless>"; NULL; ];
Array A_transparent --> [ 2; subterfuge_21; 1; "transparent"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_visited --> [ 2; subterfuge_22; 1; "visited"; K1_room; NULL; ];
Array A_worn --> [ 2; subterfuge_23; 1; "<nameless>"; NULL; ];
Array A_male --> [ 2; subterfuge_24; 1; "<nameless>"; NULL; ];
Array A_female --> [ 2; subterfuge_25; 1; "female"; K8_person; NULL; ];
Array A_neuter --> [ 2; subterfuge_26; 1; "neuter"; K8_person; NULL; ];
Array A_pluralname --> [ 2; subterfuge_27; 1; "plural-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_ambigpluralname --> [ 2; subterfuge_28; 1; "ambiguously plural"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_proper --> [ 2; subterfuge_29; 1; "proper-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_remove_proper --> [ 2; subterfuge_30; 1; "<nameless>"; NULL; ];
Array A_privately_named --> [ 2; subterfuge_31; 1; "privately-named"; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mentioned --> [ 2; subterfuge_32; 1; "mentioned"; K2_thing; NULL; ];
Array A_pushable --> [ 2; subterfuge_33; 1; "pushable between rooms"; K2_thing; NULL; ];
Array A_mark_as_room --> [ 2; subterfuge_34; 1; "mark_as_room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mark_as_thing --> [ 2; subterfuge_35; 1; "mark_as_thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_workflag --> [ 2; subterfuge_36; 1; "marked for listing"; K2_thing; K3_direction; NULL; ];
Array A_workflag2 --> [ 2; subterfuge_37; 1; "<nameless>"; NULL; ];
Array A_add_to_scope --> [ 1; subterfuge_38; 0; "<nameless>"; NULL; ];
Array A_article --> [ 1; subterfuge_39; 0; "indefinite article"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_capacity --> [ 1; subterfuge_40; 0; "carrying capacity"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_component_child --> [ 1; subterfuge_41; 0; "component_child"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_parent --> [ 1; subterfuge_42; 0; "component_parent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_sibling --> [ 1; subterfuge_43; 0; "component_sibling"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_description --> [ 1; subterfuge_44; 0; "description"; K1_room; K2_thing; NULL; ];
Array A_door_dir --> [ 1; subterfuge_45; 0; "door_dir"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door_to --> [ 1; subterfuge_46; 0; "leading-through destination"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; K4_door; NULL; ];
Array A_found_in --> [ 1; subterfuge_47; 0; "found_in"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_initial --> [ 1; subterfuge_48; 0; "initial appearance"; K2_thing; NULL; ];
Array A_list_together --> [ 1; subterfuge_49; 0; "list grouping key"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_map_region --> [ 1; subterfuge_50; 0; "map region"; K1_room; NULL; ];
Array A_parse_name --> [ 1; subterfuge_51; 0; "parse_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_plural --> [ 1; subterfuge_52; 0; "printed plural name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_regional_found_in --> [ 1; subterfuge_53; 0; "regional_found_in"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_room_index --> [ 1; subterfuge_54; 0; "room_index"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_short_name --> [ 1; subterfuge_55; 0; "printed name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_saved_short_name --> [ 1; subterfuge_56; 0; "saved_short_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_vector --> [ 1; subterfuge_57; 0; "vector"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_with_key --> [ 1; subterfuge_58; 0; "matching key"; K2_thing; K4_door; K5_container; NULL; ];
Array A_KD_Count --> [ 1; subterfuge_59; 0; "KD_Count"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_Count --> [ 1; subterfuge_60; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK2_Count --> [ 1; subterfuge_61; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK4_Count --> [ 1; subterfuge_62; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK5_Count --> [ 1; subterfuge_63; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK6_Count --> [ 1; subterfuge_64; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK8_Count --> [ 1; subterfuge_65; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK3_Count --> [ 1; subterfuge_66; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_link --> [ 1; subterfuge_67; 0; "<nameless>"; NULL; ];
Array A_IK2_link --> [ 1; subterfuge_68; 0; "<nameless>"; NULL; ];
Array A_IK5_link --> [ 1; subterfuge_69; 0; "<nameless>"; NULL; ];
Array A_IK6_link --> [ 1; subterfuge_70; 0; "<nameless>"; NULL; ];
Array A_IK8_link --> [ 1; subterfuge_71; 0; "<nameless>"; NULL; ];
Array A_articles --> [ 1; subterfuge_72; 0; "<nameless>"; NULL; ];
Array A_grammar --> [ 1; subterfuge_73; 0; "<nameless>"; NULL; ];
Array A_inside_description --> [ 1; subterfuge_74; 0; "<nameless>"; NULL; ];
Array A_short_name_indef --> [ 1; subterfuge_75; 0; "<nameless>"; NULL; ];
Array A_cap_short_name --> [ 1; subterfuge_76; 0; "object"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_before --> [ 1; subterfuge_77; 0; "before"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_action_bitmap --> [ 1; subterfuge_78; 0; "action_bitmap"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_name --> [ 1; subterfuge_79; 0; "name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_variable_initial_value --> [ 1; subterfuge_80; 0; "variable initial value"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_specification --> [ 1; subterfuge_81; 0; "specification"; NULL; ];
Array A_P_indefinite_appearance_text --> [ 1; subterfuge_82; 0; "indefinite appearance text"; NULL; ];
Array A_P_adaptive_text_viewpoint --> [ 1; subterfuge_83; 0; "adaptive text viewpoint"; NULL; ];
Array A_P_opposite --> [ 1; subterfuge_84; 0; "opposite"; K3_direction; NULL; ];
Array A_P_recurring --> [ 1; subterfuge_85; 1; "recurring"; NULL; ];
Array A_K1_room_Next --> [ 1; subterfuge_86; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K2_thing_Next --> [ 1; subterfuge_87; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K3_direction_Next --> [ 1; subterfuge_88; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K4_door_Next --> [ 1; subterfuge_89; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K5_container_Next --> [ 1; subterfuge_90; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K6_supporter_Next --> [ 1; subterfuge_91; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK7_Count --> [ 1; subterfuge_92; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K7_backdrop_Next --> [ 1; subterfuge_93; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K8_person_Next --> [ 1; subterfuge_94; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK9_Count --> [ 1; subterfuge_95; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K9_region_Next --> [ 1; subterfuge_96; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK10_Count --> [ 1; subterfuge_97; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K10_man_Next --> [ 1; subterfuge_98; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Count --> [ 1; subterfuge_99; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Next --> [ 1; subterfuge_100; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Count --> [ 1; subterfuge_101; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Next --> [ 1; subterfuge_102; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Count --> [ 1; subterfuge_103; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Next --> [ 1; subterfuge_104; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Count --> [ 1; subterfuge_105; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Next --> [ 1; subterfuge_106; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Count --> [ 1; subterfuge_107; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Next --> [ 1; subterfuge_108; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_passkey_Count --> [ 1; subterfuge_109; 0; "passkey"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_passkey_Next --> [ 1; subterfuge_110; 0; "passkey"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K17_keychain_Count --> [ 1; subterfuge_111; 0; "keychain"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K17_keychain_Next --> [ 1; subterfuge_112; 0; "keychain"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_unbolting_relation_storage --> [ 1; subterfuge_113; 0; "unbolting relation storage"; K2_thing; NULL; ];
Array A_K18_fluid_container_Count --> [ 1; subterfuge_114; 0; "fluid container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K18_fluid_container_Next --> [ 1; subterfuge_115; 0; "fluid container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K19_electric_lamp_Count --> [ 1; subterfuge_116; 0; "electric lamp"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K19_electric_lamp_Next --> [ 1; subterfuge_117; 0; "electric lamp"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K20_attendant_Count --> [ 1; subterfuge_118; 0; "attendant"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K20_attendant_Next --> [ 1; subterfuge_119; 0; "attendant"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K21_coin_Count --> [ 1; subterfuge_120; 0; "coin"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K21_coin_Next --> [ 1; subterfuge_121; 0; "coin"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K22_nickel_Count --> [ 1; subterfuge_122; 0; "nickel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K22_nickel_Next --> [ 1; subterfuge_123; 0; "nickel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K23_dime_Count --> [ 1; subterfuge_124; 0; "dime"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K23_dime_Next --> [ 1; subterfuge_125; 0; "dime"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K24_quarter_Count --> [ 1; subterfuge_126; 0; "quarter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K24_quarter_Next --> [ 1; subterfuge_127; 0; "quarter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K25_electrical_closet_Count --> [ 1; subterfuge_128; 0; "electrical closet"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K25_electrical_closet_Next --> [ 1; subterfuge_129; 0; "electrical closet"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K26_electrical_panel_Count --> [ 1; subterfuge_130; 0; "electrical panel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K26_electrical_panel_Next --> [ 1; subterfuge_131; 0; "electrical panel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K27_socket_Count --> [ 1; subterfuge_132; 0; "socket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K27_socket_Next --> [ 1; subterfuge_133; 0; "socket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K28_indicator_Count --> [ 1; subterfuge_134; 0; "indicator"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K28_indicator_Next --> [ 1; subterfuge_135; 0; "indicator"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K29_fuse_Count --> [ 1; subterfuge_136; 0; "fuse"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K29_fuse_Next --> [ 1; subterfuge_137; 0; "fuse"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K30_switch_Count --> [ 1; subterfuge_138; 0; "switch"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K30_switch_Next --> [ 1; subterfuge_139; 0; "switch"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K31_ride_ticket_Count --> [ 1; subterfuge_140; 0; "ride ticket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K31_ride_ticket_Next --> [ 1; subterfuge_141; 0; "ride ticket"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K32_baseball_Count --> [ 1; subterfuge_142; 0; "baseball"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K32_baseball_Next --> [ 1; subterfuge_143; 0; "baseball"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K33_wooden_door_Count --> [ 1; subterfuge_144; 0; "wooden door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K33_wooden_door_Next --> [ 1; subterfuge_145; 0; "wooden door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K34_control_panel_Count --> [ 1; subterfuge_146; 0; "control panel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K34_control_panel_Next --> [ 1; subterfuge_147; 0; "control panel"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K35_button_Count --> [ 1; subterfuge_148; 0; "button"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K35_button_Next --> [ 1; subterfuge_149; 0; "button"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K36_dial_Count --> [ 1; subterfuge_150; 0; "dial"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K36_dial_Next --> [ 1; subterfuge_151; 0; "dial"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K37_light_Count --> [ 1; subterfuge_152; 0; "light"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K37_light_Next --> [ 1; subterfuge_153; 0; "light"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_indoors --> [ 2; subterfuge_154; 1; "indoors"; K1_room; NULL; ];
Array A_P_price --> [ 1; subterfuge_155; 0; "price"; K2_thing; NULL; ];
Array A_P_fluid_capacity --> [ 1; subterfuge_156; 0; "fluid capacity"; K18_fluid_container; NULL; ];
Array A_P_current_volume --> [ 1; subterfuge_157; 0; "current volume"; K18_fluid_container; NULL; ];
Array A_P_liquid --> [ 1; subterfuge_158; 0; "liquid"; K18_fluid_container; NULL; ];
Array A_P_panel_id --> [ 1; subterfuge_159; 0; "panel id"; K26_electrical_panel; K34_control_panel; NULL; ];
Array A_P_color --> [ 1; subterfuge_160; 0; "color"; K33_wooden_door; K26_electrical_panel; K34_control_panel; K29_fuse; NULL; ];
Array A_P_fuse_id --> [ 1; subterfuge_161; 0; "fuse id"; K29_fuse; NULL; ];
Array A_P_dial_setting --> [ 1; subterfuge_162; 0; "dial setting"; K36_dial; NULL; ];
Array A_P_figure_id --> [ 1; subterfuge_163; 0; "figure id"; I_monitor_U1; NULL; ];
Array A_P_underlying_relation_storag --> [ 1; subterfuge_164; 0; "underlying relation storage"; K2_thing; NULL; ];
Array A_P_electromagnetic --> [ 2; subterfuge_165; 1; "electromagnetic"; I_electrical_room_U1; NULL; ];
Array A_P_consumed --> [ 2; subterfuge_166; 1; "consumed"; I_blueberries_U1; NULL; ];
Array A_P_tossing_relation_storage --> [ 1; subterfuge_167; 0; "tossing relation storage"; K2_thing; NULL; ];
Array bc_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U1 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U43; ];
Array bc_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U44; ];
Array bc_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U1; ];
Array bc_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U2 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U45; ];
Array bc_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U46; ];
Array bc_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U2; ];
Array bc_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U3 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U47; ];
Array bc_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U48; ];
Array bc_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U3; ];
Array bc_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U4 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U49; ];
Array bc_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U50; ];
Array bc_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U4; ];
Array bc_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U5 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U51; ];
Array bc_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U52; ];
Array bc_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U5; ];
Array bc_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U6 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U53; ];
Array bc_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U54; ];
Array bc_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U6; ];
Array bc_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U7 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U55; ];
Array bc_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U56; ];
Array bc_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U7; ];
Array bc_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U8 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U57; ];
Array bc_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U58; ];
Array bc_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U8; ];
Array bc_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U9 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U59; ];
Array bc_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U60; ];
Array bc_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U9; ];
Array bc_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U10 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U61; ];
Array bc_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U62; ];
Array bc_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U10; ];
Array bc_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U11 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U63; ];
Array bc_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U64; ];
Array bc_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U11; ];
Array bc_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U12 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U65; ];
Array bc_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U66; ];
Array bc_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U12; ];
Array bc_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U13 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U67; ];
Array bc_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U68; ];
Array bc_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U13; ];
Array bc_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U14 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U69; ];
Array bc_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U70; ];
Array bc_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U14; ];
Array bc_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U15 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U71; ];
Array bc_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U72; ];
Array bc_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U15; ];
Array bc_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U16 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U73; ];
Array bc_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U74; ];
Array bc_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U16; ];
Array bc_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U17 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U75; ];
Array bc_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U76; ];
Array bc_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U17; ];
Array bc_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U18 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U77; ];
Array bc_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U78; ];
Array bc_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U18; ];
Array bc_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A1 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R1; ];
Array SN_R_A2 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R2; ];
Array inline_U19 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U79; ];
Array bc_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U19; ];
Array bc_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A3 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R3; ];
Array SN_R_A4 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R4; ];
Array inline_U20 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U80; ];
Array bc_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U20; ];
Array bc_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A5 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R5; ];
Array SN_R_A6 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R6; ];
Array inline_U21 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U81; ];
Array bc_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U21; ];
Array bc_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A7 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R7; ];
Array SN_R_A8 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R8; ];
Array inline_U22 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U82; ];
Array bc_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U22; ];
Array bc_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A9 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R9; ];
Array SN_R_A10 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R10; ];
Array inline_U23 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U83; ];
Array bc_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U23; ];
Array bc_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array SN_R_A11 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R11; ];
Array SN_R_A12 --> [ CONSTANT_PACKED_TEXT_STORAGE; SN_R12; ];
Array inline_U24 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U84; ];
Array bc_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U24; ];
Array bc_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U25 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U85; ];
Array bc_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U86; ];
Array bc_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U25; ];
Array bc_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U26 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U87; ];
Array bc_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U88; ];
Array bc_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U26; ];
Array bc_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U27 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U89; ];
Array bc_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U90; ];
Array bc_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U27; ];
Array bc_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U28 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U91; ];
Array bc_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U92; ];
Array bc_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U28; ];
Array bc_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U29 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U93; ];
Array bc_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U94; ];
Array bc_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U29; ];
Array bc_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U30 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U95; ];
Array bc_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U96; ];
Array bc_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U30; ];
Array bc_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U31 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U97; ];
Array bc_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U98; ];
Array bc_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U31; ];
Array bc_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U32 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U99; ];
Array bc_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U100; ];
Array bc_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U32; ];
Array bc_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U33 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U101; ];
Array bc_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U102; ];
Array bc_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U33; ];
Array bc_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U34 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U103; ];
Array bc_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U104; ];
Array bc_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U34; ];
Array bc_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U35 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U105; ];
Array bc_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U106; ];
Array bc_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U35; ];
Array bc_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U36 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U107; ];
Array bc_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U108; ];
Array bc_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U36; ];
Array bc_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U37 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U109; ];
Array bc_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U110; ];
Array bc_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U37; ];
Array bc_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U38 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U111; ];
Array bc_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U112; ];
Array bc_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U38; ];
Array bc_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U39 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U113; ];
Array bc_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U114; ];
Array bc_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U39; ];
Array bc_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U40 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U115; ];
Array bc_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U116; ];
Array bc_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U40; ];
Array bc_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U41 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U117; ];
Array bc_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U118; ];
Array bc_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U41; ];
Array bc_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U42 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U119; ];
Array bc_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U120; ];
Array bc_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U42; ];
Array bc_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ActionHappened --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array ActionCoding --> [ ##Inv; ##Take; ##Remove; ##Drop; ##PutOn; ##Insert; ##Eat; ##Go; ##Enter; ##Exit; ##GetOff; ##Look; ##Examine; ##LookUnder; ##Search; ##Consult; ##Lock; ##Unlock; ##SwitchOn; ##SwitchOff; ##Open; ##Close; ##Wear; ##Disrobe; ##Give; ##Show; ##WakeOther; ##ThrowAt; ##Attack; ##Kiss; ##Answer; ##Tell; ##Ask; ##AskFor; ##Wait; ##Touch; ##Wave; ##Pull; ##Push; ##Turn; ##PushDir; ##Squeeze; ##Yes; ##No; ##Burn; ##Wake; ##Think; ##Smell; ##Listen; ##Taste; ##Cut; ##Jump; ##Tie; ##Drink; ##Sorry; ##Swing; ##Rub; ##SetTo; ##WaveHands; ##Buy; ##Climb; ##Sleep; ##Quit; ##Save; ##Restore; ##Restart; ##Verify; ##ScriptOn; ##ScriptOff; ##Version; ##Score; ##LMode3; ##LMode2; ##LMode1; ##NotifyOn; ##NotifyOff; ##Pronouns; ##A_standing; ##A_unlocking_keylessly; ##A_locking_keylessly; ##A_universal_unlocking; ##A_asking_for_help; ##Sing; ##A_pouring_it_into; ##A_hiding_it_under; ##A_hi_speaking; ##A_casting_xyzzy; ##A_casting_plugh; ##A_talking_randomly_abou; ##A_talking_about; ##A_requesting_the_comple; ##Mild; ##A_fucking; ##Strong; ##A_toggling; ##A_flipping; ##A_reading; ##A_hitting; ##A_tossing; ##A_throwing; ##A_spinning_it_to; ##A_crediting; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array ActionData table [ ##Inv; 0; OBJECT_TY; OBJECT_TY; 0; 20000; ##Take; 9; OBJECT_TY; OBJECT_TY; call_U570; 20001; ##Remove; 27; OBJECT_TY; OBJECT_TY; 0; 20002; ##Drop; 9; OBJECT_TY; OBJECT_TY; 0; 20003; ##PutOn; 27; OBJECT_TY; OBJECT_TY; 0; 20004; ##Insert; 27; OBJECT_TY; OBJECT_TY; 0; 20005; ##Eat; 9; OBJECT_TY; OBJECT_TY; 0; 20006; ##Go; 8; OBJECT_TY; OBJECT_TY; call_U589; 20007; ##Enter; 9; OBJECT_TY; OBJECT_TY; 0; 20008; ##Exit; 0; OBJECT_TY; OBJECT_TY; call_U596; 20009; ##GetOff; 9; OBJECT_TY; OBJECT_TY; 0; 20010; ##Look; 0; OBJECT_TY; OBJECT_TY; call_U603; 20011; ##Examine; 12; OBJECT_TY; OBJECT_TY; call_U607; 20012; ##LookUnder; 12; OBJECT_TY; OBJECT_TY; 0; 20013; ##Search; 13; OBJECT_TY; OBJECT_TY; 0; 20014; ##Consult; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20015; ##Lock; 155; OBJECT_TY; OBJECT_TY; 0; 20016; ##Unlock; 155; OBJECT_TY; OBJECT_TY; 0; 20017; ##SwitchOn; 9; OBJECT_TY; OBJECT_TY; 0; 20018; ##SwitchOff; 9; OBJECT_TY; OBJECT_TY; 0; 20019; ##Open; 9; OBJECT_TY; OBJECT_TY; 0; 20020; ##Close; 9; OBJECT_TY; OBJECT_TY; 0; 20021; ##Wear; 73; OBJECT_TY; OBJECT_TY; 0; 20022; ##Disrobe; 9; OBJECT_TY; OBJECT_TY; 0; 20023; ##Give; 91; OBJECT_TY; OBJECT_TY; 0; 20024; ##Show; 89; OBJECT_TY; OBJECT_TY; 0; 20025; ##WakeOther; 9; OBJECT_TY; OBJECT_TY; 0; 20026; ##ThrowAt; 89; OBJECT_TY; OBJECT_TY; 0; 20027; ##Attack; 9; OBJECT_TY; OBJECT_TY; 0; 20028; ##Kiss; 9; OBJECT_TY; OBJECT_TY; 0; 20029; ##Answer; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20030; ##Tell; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20031; ##Ask; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20032; ##AskFor; 27; OBJECT_TY; OBJECT_TY; 0; 20033; ##Wait; 0; OBJECT_TY; OBJECT_TY; 0; 20034; ##Touch; 9; OBJECT_TY; OBJECT_TY; 0; 20035; ##Wave; 9; OBJECT_TY; OBJECT_TY; 0; 20036; ##Pull; 9; OBJECT_TY; OBJECT_TY; 0; 20037; ##Push; 9; OBJECT_TY; OBJECT_TY; 0; 20038; ##Turn; 9; OBJECT_TY; OBJECT_TY; 0; 20039; ##PushDir; 25; OBJECT_TY; OBJECT_TY; 0; 20040; ##Squeeze; 9; OBJECT_TY; OBJECT_TY; 0; 20041; ##Yes; 0; OBJECT_TY; OBJECT_TY; 0; 20042; ##No; 0; OBJECT_TY; OBJECT_TY; 0; 20043; ##Burn; 9; OBJECT_TY; OBJECT_TY; 0; 20044; ##Wake; 0; OBJECT_TY; OBJECT_TY; 0; 20045; ##Think; 0; OBJECT_TY; OBJECT_TY; 0; 20046; ##Smell; 9; OBJECT_TY; OBJECT_TY; 0; 20047; ##Listen; 9; OBJECT_TY; OBJECT_TY; 0; 20048; ##Taste; 9; OBJECT_TY; OBJECT_TY; 0; 20049; ##Cut; 9; OBJECT_TY; OBJECT_TY; 0; 20050; ##Jump; 0; OBJECT_TY; OBJECT_TY; 0; 20051; ##Tie; 27; OBJECT_TY; OBJECT_TY; 0; 20052; ##Drink; 9; OBJECT_TY; OBJECT_TY; 0; 20053; ##Sorry; 0; OBJECT_TY; OBJECT_TY; 0; 20054; ##Swing; 9; OBJECT_TY; OBJECT_TY; 0; 20055; ##Rub; 9; OBJECT_TY; OBJECT_TY; 0; 20056; ##SetTo; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20057; ##WaveHands; 0; OBJECT_TY; OBJECT_TY; 0; 20058; ##Buy; 9; OBJECT_TY; OBJECT_TY; 0; 20059; ##Climb; 9; OBJECT_TY; OBJECT_TY; 0; 20060; ##Sleep; 0; OBJECT_TY; OBJECT_TY; 0; 20061; ##Quit; 32; OBJECT_TY; OBJECT_TY; 0; 20062; ##Save; 32; OBJECT_TY; OBJECT_TY; 0; 20063; ##Restore; 32; OBJECT_TY; OBJECT_TY; 0; 20064; ##Restart; 32; OBJECT_TY; OBJECT_TY; 0; 20065; ##Verify; 32; OBJECT_TY; OBJECT_TY; 0; 20066; ##ScriptOn; 32; OBJECT_TY; OBJECT_TY; 0; 20067; ##ScriptOff; 32; OBJECT_TY; OBJECT_TY; 0; 20068; ##Version; 32; OBJECT_TY; OBJECT_TY; 0; 20069; ##Score; 32; OBJECT_TY; OBJECT_TY; 0; 20070; ##LMode3; 32; OBJECT_TY; OBJECT_TY; 0; 20071; ##LMode2; 32; OBJECT_TY; OBJECT_TY; 0; 20072; ##LMode1; 32; OBJECT_TY; OBJECT_TY; 0; 20073; ##NotifyOn; 32; OBJECT_TY; OBJECT_TY; 0; 20074; ##NotifyOff; 32; OBJECT_TY; OBJECT_TY; 0; 20075; ##Pronouns; 32; OBJECT_TY; OBJECT_TY; 0; 20076; ##A_standing; 0; OBJECT_TY; OBJECT_TY; 0; 20077; ##A_unlocking_keylessly; 9; OBJECT_TY; OBJECT_TY; call_U2030; 20078; ##A_locking_keylessly; 9; OBJECT_TY; OBJECT_TY; call_U2034; 20079; ##A_universal_unlocking; 0; OBJECT_TY; OBJECT_TY; 0; 20080; ##A_asking_for_help; 32; OBJECT_TY; OBJECT_TY; 0; 20081; ##Sing; 0; OBJECT_TY; OBJECT_TY; 0; 20082; ##A_pouring_it_into; 27; OBJECT_TY; OBJECT_TY; 0; 20083; ##A_hiding_it_under; 91; OBJECT_TY; OBJECT_TY; 0; 20084; ##A_hi_speaking; 8; OBJECT_TY; OBJECT_TY; 0; 20085; ##A_casting_xyzzy; 0; OBJECT_TY; OBJECT_TY; 0; 20086; ##A_casting_plugh; 0; OBJECT_TY; OBJECT_TY; 0; 20087; ##A_talking_randomly_abou; 8; UNDERSTANDING_TY; OBJECT_TY; 0; 20088; ##A_talking_about; 8; OBJECT_TY; OBJECT_TY; 0; 20089; ##A_requesting_the_comple; 32; OBJECT_TY; OBJECT_TY; 0; 20090; ##Mild; 0; OBJECT_TY; OBJECT_TY; 0; 20091; ##A_fucking; 9; OBJECT_TY; OBJECT_TY; 0; 20092; ##Strong; 0; OBJECT_TY; OBJECT_TY; 0; 20093; ##A_toggling; 9; OBJECT_TY; OBJECT_TY; 0; 20094; ##A_flipping; 9; OBJECT_TY; OBJECT_TY; 0; 20095; ##A_reading; 9; OBJECT_TY; OBJECT_TY; 0; 20096; ##A_hitting; 24; OBJECT_TY; OBJECT_TY; 0; 20097; ##A_tossing; 27; OBJECT_TY; OBJECT_TY; 0; 20098; ##A_throwing; 27; OBJECT_TY; OBJECT_TY; 0; 20099; ##A_spinning_it_to; 25; OBJECT_TY; NUMBER_TY; 0; 20100; ##A_crediting; 0; OBJECT_TY; OBJECT_TY; 0; 20101; 0; 0; 0; 0; 0; 20102; 0; 0; 0; 0; 0; 20103; 0; 0; 0; 0; 0; 20104; 0; 0; 0; 0; 0; 20105; 0; 0; 0; 0; 0; 20106; 0; 0; 0; 0; 0; 20107; 0; 0; 0; 0; 0; 20108; 0; 0; 0; 0; 0; 20109; 0; 0; 0; 0; 0; 20110; 0; 0; 0; 0; 0; 20111; 0; 0; 0; 0; 0; 20112; 0; 0; 0; 0; 0; 20113; 0; 0; 0; 0; 0; 20114; 0; 0; 0; 0; 0; 20115; 0; 0; 0; 0; 0; 20116; 0; 0; 0; 0; 0; 20117; 0; 0; 0; 0; 0; 20118; 0; 0; 0; 0; 0; 20119; 0; 0; 0; 0; 0; 20120; 0; 0; 0; 0; 0; 20121; 0; 0; 0; 0; 0; 20122; 0; 0; 0; 0; 0; 20123; 0; 0; 0; 0; 0; 20124; 0; ];
Array Activity_after_rulebooks --> [ rulebook_id_U5; rulebook_id_U8; rulebook_id_U11; rulebook_id_U41; rulebook_id_U44; rulebook_id_U47; rulebook_id_U50; rulebook_id_U53; rulebook_id_U56; rulebook_id_U59; rulebook_id_U62; rulebook_id_U65; rulebook_id_U68; rulebook_id_U71; rulebook_id_U74; rulebook_id_U77; rulebook_id_U80; rulebook_id_U83; rulebook_id_U86; rulebook_id_U89; rulebook_id_U92; rulebook_id_U95; rulebook_id_U98; rulebook_id_U101; rulebook_id_U104; rulebook_id_U107; rulebook_id_U110; rulebook_id_U113; rulebook_id_U116; rulebook_id_U119; rulebook_id_U122; rulebook_id_U125; rulebook_id_U128; rulebook_id_U131; rulebook_id_U368; rulebook_id_U380; rulebook_id_U386; rulebook_id_U449; ];
Array Activity_atb_rulebooks -> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 1; 1; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array Activity_before_rulebooks --> [ rulebook_id_U3; rulebook_id_U6; rulebook_id_U9; rulebook_id_U39; rulebook_id_U42; rulebook_id_U45; rulebook_id_U48; rulebook_id_U51; rulebook_id_U54; rulebook_id_U57; rulebook_id_U60; rulebook_id_U63; rulebook_id_U66; rulebook_id_U69; rulebook_id_U72; rulebook_id_U75; rulebook_id_U78; rulebook_id_U81; rulebook_id_U84; rulebook_id_U87; rulebook_id_U90; rulebook_id_U93; rulebook_id_U96; rulebook_id_U99; rulebook_id_U102; rulebook_id_U105; rulebook_id_U108; rulebook_id_U111; rulebook_id_U114; rulebook_id_U117; rulebook_id_U120; rulebook_id_U123; rulebook_id_U126; rulebook_id_U129; rulebook_id_U366; rulebook_id_U378; rulebook_id_U384; rulebook_id_U447; ];
Array Activity_for_rulebooks --> [ rulebook_id_U4; rulebook_id_U7; rulebook_id_U10; rulebook_id_U40; rulebook_id_U43; rulebook_id_U46; rulebook_id_U49; rulebook_id_U52; rulebook_id_U55; rulebook_id_U58; rulebook_id_U61; rulebook_id_U64; rulebook_id_U67; rulebook_id_U70; rulebook_id_U73; rulebook_id_U76; rulebook_id_U79; rulebook_id_U82; rulebook_id_U85; rulebook_id_U88; rulebook_id_U91; rulebook_id_U94; rulebook_id_U97; rulebook_id_U100; rulebook_id_U103; rulebook_id_U106; rulebook_id_U109; rulebook_id_U112; rulebook_id_U115; rulebook_id_U118; rulebook_id_U121; rulebook_id_U124; rulebook_id_U127; rulebook_id_U130; rulebook_id_U367; rulebook_id_U379; rulebook_id_U385; rulebook_id_U448; ];
Array activity_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array TimedEventsTable table [ 0; 0; ];
Array TimedEventTimesTable table [ 0; 0; ];
Array PastActionsI6Routines --> [ PAPR1; PAPR2; PAPR3; PAPR4; PAPR5; PAPR6; 0; 0; ];
Array TableOfVerbs --> [ call_U213; call_U214; call_U215; call_U216; call_U217; call_U218; call_U219; call_U220; call_U221; call_U222; call_U223; call_U224; call_U225; call_U226; call_U227; call_U228; call_U229; call_U230; call_U231; call_U1933; call_U1934; call_U1935; call_U1936; call_U1937; call_U1938; call_U1939; call_U1940; call_U1941; call_U1942; call_U1943; call_U1944; call_U1945; call_U1946; call_U1947; call_U1948; call_U1949; call_U1950; call_U1951; call_U1952; call_U1953; call_U1954; call_U1955; call_U1956; call_U1957; call_U1958; call_U1959; call_U1960; call_U1961; call_U1962; call_U1963; call_U1964; call_U1965; call_U1966; call_U1967; call_U1968; call_U1969; call_U1970; call_U1971; call_U1972; call_U1973; call_U1974; call_U1975; call_U1976; call_U1977; call_U1978; call_U1979; call_U1980; call_U1981; call_U1982; call_U1983; call_U1984; call_U1985; call_U1986; call_U1987; call_U1988; call_U1989; call_U1990; call_U1991; call_U1992; call_U1993; call_U1994; call_U1995; call_U1996; call_U1997; call_U1998; call_U1999; call_U2000; call_U2001; call_U2002; call_U2003; call_U284; call_U285; call_U286; call_U287; call_U288; call_U289; call_U2110; call_U2111; call_U2893; call_U2894; call_U2895; call_U2896; call_U2897; call_U2898; call_U2899; call_U2900; 0; ];
Array KindHierarchy --> [ K0_kind; 0; K1_room; 0; K2_thing; 0; K3_direction; 0; K4_door; 2; K5_container; 2; K6_supporter; 2; K7_backdrop; 2; K8_person; 2; K9_region; 0; K10_man; 8; K11_woman; 8; K12_animal; 8; K13_device; 2; K14_vehicle; 5; K15_player_s_holdall; 5; K16_passkey; 2; K17_keychain; 6; K18_fluid_container; 5; K19_electric_lamp; 13; K20_attendant; 8; K21_coin; 2; K22_nickel; 21; K23_dime; 21; K24_quarter; 21; K25_electrical_closet; 1; K26_electrical_panel; 5; K27_socket; 5; K28_indicator; 2; K29_fuse; 2; K30_switch; 13; K31_ride_ticket; 2; K32_baseball; 2; K33_wooden_door; 4; K34_control_panel; 5; K35_button; 13; K36_dial; 2; K37_light; 2; ];
Array ResourceIDsOfFigures --> [ 0; 1; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 0; ];
Array ResourceIDsOfSounds --> [ 0; 31; 0; ];
Array TableOfExternalFiles --> [ 0; 0; ];
Array RulebookNames --> [ "Startup rulebook"; "Shutdown rulebook"; "before starting the virtual machine rulebook"; "for starting the virtual machine rulebook"; "after starting the virtual machine rulebook"; "before printing the name rulebook"; "for printing the name rulebook"; "after printing the name rulebook"; "before printing the plural name rulebook"; "for printing the plural name rulebook"; "after printing the plural name rulebook"; "Turn sequence rulebook"; "Scene changing rulebook"; "When play begins rulebook"; "When play ends rulebook"; "When scene begins rulebook"; "When scene ends rulebook"; "Every turn rulebook"; "Action-processing rulebook"; "Setting action variables rulebook"; "specific action-processing rulebook"; "player's action awareness rulebook"; "Accessibility rulebook"; "Reaching inside rulebook"; "Reaching outside rulebook"; "Visibility rulebook"; "Persuasion rulebook"; "Unsuccessful attempt by rulebook"; "Before rulebook"; "Instead rulebook"; "Check rulebook"; "Carry out rulebook"; "After rulebook"; "Report rulebook"; "does the player mean rulebook"; "multiple action processing rulebook"; "when Entire Game begins rulebook"; "when Entire Game ends rulebook"; "before issuing the response text rulebook"; "for issuing the response text rulebook"; "after issuing the response text rulebook"; "before printing a number rulebook"; "for printing a number rulebook"; "after printing a number rulebook"; "before printing room description details rulebook"; "for printing room description details rulebook"; "after printing room description details rulebook"; "before printing inventory details rulebook"; "for printing inventory details rulebook"; "after printing inventory details rulebook"; "before listing contents rulebook"; "for listing contents rulebook"; "after listing contents rulebook"; "before grouping together rulebook"; "for grouping together rulebook"; "after grouping together rulebook"; "before writing a paragraph about rulebook"; "for writing a paragraph about rulebook"; "after writing a paragraph about rulebook"; "before listing nondescript items rulebook"; "for listing nondescript items rulebook"; "after listing nondescript items rulebook"; "before printing the name of a dark room rulebook"; "for printing the name of a dark room rulebook"; "after printing the name of a dark room rulebook"; "before printing the description of a dark room rulebook"; "for printing the description of a dark room rulebook"; "after printing the description of a dark room rulebook"; "before printing the announcement of darkness rulebook"; "for printing the announcement of darkness rulebook"; "after printing the announcement of darkness rulebook"; "before printing the announcement of light rulebook"; "for printing the announcement of light rulebook"; "after printing the announcement of light rulebook"; "before printing a refusal to act in the dark rulebook"; "for printing a refusal to act in the dark rulebook"; "after printing a refusal to act in the dark rulebook"; "before constructing the status line rulebook"; "for constructing the status line rulebook"; "after constructing the status line rulebook"; "before printing the banner text rulebook"; "for printing the banner text rulebook"; "after printing the banner text rulebook"; "before reading a command rulebook"; "for reading a command rulebook"; "after reading a command rulebook"; "before deciding the scope rulebook"; "for deciding the scope rulebook"; "after deciding the scope rulebook"; "before deciding the concealed possessions rulebook"; "for deciding the concealed possessions rulebook"; "after deciding the concealed possessions rulebook"; "before deciding whether all includes rulebook"; "for deciding whether all includes rulebook"; "after deciding whether all includes rulebook"; "before clarifying the parser's choice rulebook"; "for clarifying the parser's choice rulebook"; "after clarifying the parser's choice rulebook"; "before asking which do you mean rulebook"; "for asking which do you mean rulebook"; "after asking which do you mean rulebook"; "before printing a parser error rulebook"; "for printing a parser error rulebook"; "after printing a parser error rulebook"; "before supplying a missing noun rulebook"; "for supplying a missing noun rulebook"; "after supplying a missing noun rulebook"; "before supplying a missing second noun rulebook"; "for supplying a missing second noun rulebook"; "after supplying a missing second noun rulebook"; "before implicitly taking rulebook"; "for implicitly taking rulebook"; "after implicitly taking rulebook"; "before amusing a victorious player rulebook"; "for amusing a victorious player rulebook"; "after amusing a victorious player rulebook"; "before printing the player's obituary rulebook"; "for printing the player's obituary rulebook"; "after printing the player's obituary rulebook"; "before handling the final question rulebook"; "for handling the final question rulebook"; "after handling the final question rulebook"; "before printing the locale description rulebook"; "for printing the locale description rulebook"; "after printing the locale description rulebook"; "before choosing notable locale objects rulebook"; "for choosing notable locale objects rulebook"; "after choosing notable locale objects rulebook"; "before printing a locale paragraph about rulebook"; "for printing a locale paragraph about rulebook"; "after printing a locale paragraph about rulebook"; "check taking inventory rulebook"; "carry out taking inventory rulebook"; "report taking inventory rulebook"; "check taking rulebook"; "carry out taking rulebook"; "report taking rulebook"; "check removing it from rulebook"; "carry out removing it from rulebook"; "report removing it from rulebook"; "check dropping rulebook"; "carry out dropping rulebook"; "report dropping rulebook"; "check putting it on rulebook"; "carry out putting it on rulebook"; "report putting it on rulebook"; "check inserting it into rulebook"; "carry out inserting it into rulebook"; "report inserting it into rulebook"; "check eating rulebook"; "carry out eating rulebook"; "report eating rulebook"; "check going rulebook"; "carry out going rulebook"; "report going rulebook"; "check entering rulebook"; "carry out entering rulebook"; "report entering rulebook"; "check exiting rulebook"; "carry out exiting rulebook"; "report exiting rulebook"; "check getting off rulebook"; "carry out getting off rulebook"; "report getting off rulebook"; "check looking rulebook"; "carry out looking rulebook"; "report looking rulebook"; "check examining rulebook"; "carry out examining rulebook"; "report examining rulebook"; "check looking under rulebook"; "carry out looking under rulebook"; "report looking under rulebook"; "check searching rulebook"; "carry out searching rulebook"; "report searching rulebook"; "check consulting it about rulebook"; "carry out consulting it about rulebook"; "report consulting it about rulebook"; "check locking it with rulebook"; "carry out locking it with rulebook"; "report locking it with rulebook"; "check unlocking it with rulebook"; "carry out unlocking it with rulebook"; "report unlocking it with rulebook"; "check switching on rulebook"; "carry out switching on rulebook"; "report switching on rulebook"; "check switching off rulebook"; "carry out switching off rulebook"; "report switching off rulebook"; "check opening rulebook"; "carry out opening rulebook"; "report opening rulebook"; "check closing rulebook"; "carry out closing rulebook"; "report closing rulebook"; "check wearing rulebook"; "carry out wearing rulebook"; "report wearing rulebook"; "check taking off rulebook"; "carry out taking off rulebook"; "report taking off rulebook"; "check giving it to rulebook"; "carry out giving it to rulebook"; "report giving it to rulebook"; "check showing it to rulebook"; "carry out showing it to rulebook"; "report showing it to rulebook"; "check waking rulebook"; "carry out waking rulebook"; "report waking rulebook"; "check throwing it at rulebook"; "carry out throwing it at rulebook"; "report throwing it at rulebook"; "check attacking rulebook"; "carry out attacking rulebook"; "report attacking rulebook"; "check kissing rulebook"; "carry out kissing rulebook"; "report kissing rulebook"; "check answering it that rulebook"; "carry out answering it that rulebook"; "report answering it that rulebook"; "check telling it about rulebook"; "carry out telling it about rulebook"; "report telling it about rulebook"; "check asking it about rulebook"; "carry out asking it about rulebook"; "report asking it about rulebook"; "check asking it for rulebook"; "carry out asking it for rulebook"; "report asking it for rulebook"; "check waiting rulebook"; "carry out waiting rulebook"; "report waiting rulebook"; "check touching rulebook"; "carry out touching rulebook"; "report touching rulebook"; "check waving rulebook"; "carry out waving rulebook"; "report waving rulebook"; "check pulling rulebook"; "carry out pulling rulebook"; "report pulling rulebook"; "check pushing rulebook"; "carry out pushing rulebook"; "report pushing rulebook"; "check turning rulebook"; "carry out turning rulebook"; "report turning rulebook"; "check pushing it to rulebook"; "carry out pushing it to rulebook"; "report pushing it to rulebook"; "check squeezing rulebook"; "carry out squeezing rulebook"; "report squeezing rulebook"; "check saying yes rulebook"; "carry out saying yes rulebook"; "report saying yes rulebook"; "check saying no rulebook"; "carry out saying no rulebook"; "report saying no rulebook"; "check burning rulebook"; "carry out burning rulebook"; "report burning rulebook"; "check waking up rulebook"; "carry out waking up rulebook"; "report waking up rulebook"; "check thinking rulebook"; "carry out thinking rulebook"; "report thinking rulebook"; "check smelling rulebook"; "carry out smelling rulebook"; "report smelling rulebook"; "check listening to rulebook"; "carry out listening to rulebook"; "report listening to rulebook"; "check tasting rulebook"; "carry out tasting rulebook"; "report tasting rulebook"; "check cutting rulebook"; "carry out cutting rulebook"; "report cutting rulebook"; "check jumping rulebook"; "carry out jumping rulebook"; "report jumping rulebook"; "check tying it to rulebook"; "carry out tying it to rulebook"; "report tying it to rulebook"; "check drinking rulebook"; "carry out drinking rulebook"; "report drinking rulebook"; "check saying sorry rulebook"; "carry out saying sorry rulebook"; "report saying sorry rulebook"; "check swinging rulebook"; "carry out swinging rulebook"; "report swinging rulebook"; "check rubbing rulebook"; "carry out rubbing rulebook"; "report rubbing rulebook"; "check setting it to rulebook"; "carry out setting it to rulebook"; "report setting it to rulebook"; "check waving hands rulebook"; "carry out waving hands rulebook"; "report waving hands rulebook"; "check buying rulebook"; "carry out buying rulebook"; "report buying rulebook"; "check climbing rulebook"; "carry out climbing rulebook"; "report climbing rulebook"; "check sleeping rulebook"; "carry out sleeping rulebook"; "report sleeping rulebook"; "check quitting the game rulebook"; "carry out quitting the game rulebook"; "report quitting the game rulebook"; "check saving the game rulebook"; "carry out saving the game rulebook"; "report saving the game rulebook"; "check restoring the game rulebook"; "carry out restoring the game rulebook"; "report restoring the game rulebook"; "check restarting the game rulebook"; "carry out restarting the game rulebook"; "report restarting the game rulebook"; "check verifying the story file rulebook"; "carry out verifying the story file rulebook"; "report verifying the story file rulebook"; "check switching the story transcript on rulebook"; "carry out switching the story transcript on rulebook"; "report switching the story transcript on rulebook"; "check switching the story transcript off rulebook"; "carry out switching the story transcript off rulebook"; "report switching the story transcript off rulebook"; "check requesting the story file version rulebook"; "carry out requesting the story file version rulebook"; "report requesting the story file version rulebook"; "check requesting the score rulebook"; "carry out requesting the score rulebook"; "report requesting the score rulebook"; "check preferring abbreviated room descriptions rulebook"; "carry out preferring abbreviated room descriptions rulebook"; "report preferring abbreviated room descriptions rulebook"; "check preferring unabbreviated room descriptions rulebook"; "carry out preferring unabbreviated room descriptions rulebook"; "report preferring unabbreviated room descriptions rulebook"; "check preferring sometimes abbreviated room descriptions rulebook"; "carry out preferring sometimes abbreviated room descriptions rulebook"; "report preferring sometimes abbreviated room descriptions rulebook"; "check switching score notification on rulebook"; "carry out switching score notification on rulebook"; "report switching score notification on rulebook"; "check switching score notification off rulebook"; "carry out switching score notification off rulebook"; "report switching score notification off rulebook"; "check requesting the pronoun meanings rulebook"; "carry out requesting the pronoun meanings rulebook"; "report requesting the pronoun meanings rulebook"; "check standing rulebook"; "carry out standing rulebook"; "report standing rulebook"; "before refusing keys rulebook"; "for refusing keys rulebook"; "after refusing keys rulebook"; "check unlocking keylessly rulebook"; "carry out unlocking keylessly rulebook"; "report unlocking keylessly rulebook"; "check locking keylessly rulebook"; "carry out locking keylessly rulebook"; "report locking keylessly rulebook"; "check universal unlocking rulebook"; "carry out universal unlocking rulebook"; "report universal unlocking rulebook"; "before displaying rulebook"; "for displaying rulebook"; "after displaying rulebook"; "check asking for help rulebook"; "carry out asking for help rulebook"; "report asking for help rulebook"; "before pausing the game rulebook"; "for pausing the game rulebook"; "after pausing the game rulebook"; "check singing rulebook"; "carry out singing rulebook"; "report singing rulebook"; "check pouring it into rulebook"; "carry out pouring it into rulebook"; "report pouring it into rulebook"; "check hiding it under rulebook"; "carry out hiding it under rulebook"; "report hiding it under rulebook"; "check hi-speaking rulebook"; "carry out hi-speaking rulebook"; "report hi-speaking rulebook"; "check casting xyzzy rulebook"; "carry out casting xyzzy rulebook"; "report casting xyzzy rulebook"; "check casting plugh rulebook"; "carry out casting plugh rulebook"; "report casting plugh rulebook"; "check talking randomly about rulebook"; "carry out talking randomly about rulebook"; "report talking randomly about rulebook"; "check talking about rulebook"; "carry out talking about rulebook"; "report talking about rulebook"; "check requesting the complete score rulebook"; "carry out requesting the complete score rulebook"; "report requesting the complete score rulebook"; "check swearing mildly rulebook"; "carry out swearing mildly rulebook"; "report swearing mildly rulebook"; "check fucking rulebook"; "carry out fucking rulebook"; "report fucking rulebook"; "check swearing obscenely rulebook"; "carry out swearing obscenely rulebook"; "report swearing obscenely rulebook"; "check toggling rulebook"; "carry out toggling rulebook"; "report toggling rulebook"; "check flipping rulebook"; "carry out flipping rulebook"; "report flipping rulebook"; "check reading rulebook"; "carry out reading rulebook"; "report reading rulebook"; "check hitting rulebook"; "carry out hitting rulebook"; "report hitting rulebook"; "check tossing rulebook"; "carry out tossing rulebook"; "report tossing rulebook"; "check throwing rulebook"; "carry out throwing rulebook"; "report throwing rulebook"; "check spinning it to rulebook"; "carry out spinning it to rulebook"; "report spinning it to rulebook"; "check crediting rulebook"; "carry out crediting rulebook"; "report crediting rulebook"; "before showing action rulebook"; "for showing action rulebook"; "after showing action rulebook"; "when Little Egypt AutoPlay begins rulebook"; "when Little Egypt AutoPlay ends rulebook"; "when Hell Ride AutoPlay begins rulebook"; "when Hell Ride AutoPlay ends rulebook"; ];
Array rulebook_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; call_U450; 0; call_U453; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array rulebooks_array --> [ call_U193; call_U194; call_U195; call_U196; call_U197; call_U198; call_U199; call_U200; call_U201; call_U202; call_U203; call_U442; call_U443; call_U444; call_U445; call_U446; call_U447; call_U448; call_U449; call_U451; call_U452; call_U454; call_U455; call_U456; call_U457; call_U458; call_U459; call_U460; call_U461; call_U462; call_U463; call_U464; call_U465; call_U466; call_U467; call_U468; call_U469; call_U470; call_U471; call_U472; call_U473; call_U474; call_U475; call_U476; call_U477; call_U478; call_U479; call_U480; call_U481; call_U482; call_U483; call_U484; call_U485; call_U486; call_U487; call_U488; call_U489; call_U490; call_U491; call_U492; call_U493; call_U494; call_U495; call_U496; call_U497; call_U498; call_U499; call_U500; call_U501; call_U502; call_U503; call_U504; call_U505; call_U506; call_U507; call_U508; call_U509; call_U510; call_U511; call_U512; call_U513; call_U514; call_U515; call_U516; call_U517; call_U518; call_U519; call_U520; call_U521; call_U522; call_U523; call_U524; call_U525; call_U526; call_U527; call_U528; call_U529; call_U530; call_U531; call_U532; call_U533; call_U534; call_U535; call_U536; call_U537; call_U538; call_U539; call_U540; call_U541; call_U542; call_U543; call_U544; call_U545; call_U546; call_U547; call_U548; call_U549; call_U550; call_U551; call_U552; call_U553; call_U554; call_U555; call_U556; call_U557; call_U558; call_U559; call_U560; call_U561; call_U562; call_U563; call_U564; call_U565; call_U566; call_U567; call_U568; call_U569; call_U571; call_U572; call_U573; call_U574; call_U575; call_U576; call_U577; call_U578; call_U579; call_U580; call_U581; call_U582; call_U583; call_U584; call_U585; call_U586; call_U587; call_U588; call_U590; call_U591; call_U592; call_U593; call_U594; call_U595; call_U597; call_U598; call_U599; call_U600; call_U601; call_U602; call_U604; call_U605; call_U606; call_U608; call_U609; call_U610; call_U611; call_U612; call_U613; call_U614; call_U615; call_U616; call_U617; call_U618; call_U619; call_U620; call_U621; call_U622; call_U623; call_U624; call_U625; call_U626; call_U627; call_U628; call_U629; call_U630; call_U631; call_U632; call_U633; call_U634; call_U635; call_U636; call_U637; call_U638; call_U639; call_U640; call_U641; call_U642; call_U643; call_U644; call_U645; call_U646; call_U647; call_U648; call_U649; call_U650; call_U651; call_U652; call_U653; call_U654; call_U655; call_U656; call_U657; call_U658; call_U659; call_U660; call_U661; call_U662; call_U663; call_U664; call_U665; call_U666; call_U667; call_U668; call_U669; call_U670; call_U671; call_U672; call_U673; call_U674; call_U675; call_U676; call_U677; call_U678; call_U679; call_U680; call_U681; call_U682; call_U683; call_U684; call_U685; call_U686; call_U687; call_U688; call_U689; call_U690; call_U691; call_U692; call_U693; call_U694; call_U695; call_U696; call_U697; call_U698; call_U699; call_U700; call_U701; call_U702; call_U703; call_U704; call_U705; call_U706; call_U707; call_U708; call_U709; call_U710; call_U711; call_U712; call_U713; call_U714; call_U715; call_U716; call_U717; call_U718; call_U719; call_U720; call_U721; call_U722; call_U723; call_U724; call_U725; call_U726; call_U727; call_U728; call_U729; call_U730; call_U731; call_U732; call_U733; call_U734; call_U735; call_U736; call_U737; call_U738; call_U739; call_U740; call_U741; call_U742; call_U743; call_U744; call_U745; call_U746; call_U747; call_U748; call_U749; call_U750; call_U751; call_U752; call_U753; call_U754; call_U755; call_U756; call_U757; call_U758; call_U759; call_U760; call_U761; call_U762; call_U763; call_U764; call_U765; call_U766; call_U767; call_U768; call_U769; call_U770; call_U771; call_U772; call_U773; call_U774; call_U775; call_U776; call_U777; call_U778; call_U779; call_U780; call_U781; call_U782; call_U783; call_U784; call_U785; call_U786; call_U787; call_U788; call_U789; call_U790; call_U791; call_U792; call_U793; call_U794; call_U795; call_U796; call_U797; call_U798; call_U799; call_U2004; call_U2005; call_U2006; call_U2024; call_U2025; call_U2026; call_U2027; call_U2028; call_U2029; call_U2031; call_U2032; call_U2033; call_U2035; call_U2036; call_U2037; call_U2112; call_U2113; call_U2114; call_U2129; call_U2130; call_U2131; call_U2154; call_U2155; call_U2156; call_U2164; call_U2165; call_U2166; call_U2355; call_U2356; call_U2357; call_U2358; call_U2359; call_U2360; call_U2361; call_U2362; call_U2363; call_U2364; call_U2365; call_U2366; call_U2367; call_U2368; call_U2369; call_U2370; call_U2371; call_U2372; call_U2373; call_U2374; call_U2375; call_U2376; call_U2377; call_U2378; call_U2379; call_U2380; call_U2381; call_U2382; call_U2383; call_U2384; call_U2385; call_U2386; call_U2387; call_U2388; call_U2389; call_U2390; call_U2391; call_U2392; call_U2393; call_U2394; call_U2395; call_U2396; call_U2397; call_U2398; call_U2399; call_U2400; call_U2401; call_U2402; call_U2403; call_U2404; call_U2405; call_U2406; call_U2407; call_U2408; call_U2409; call_U2410; call_U2411; call_U2439; call_U2440; call_U2441; call_U2442; call_U2443; call_U2444; call_U2445; 0; ];
Array ResponseTexts --> [ ts_array_U79; ts_array_U80; ts_array_U81; ts_array_U82; ts_array_U83; ts_array_U84; ts_array_U85; ts_array_U86; ts_array_U87; ts_array_U88; ts_array_U89; ts_array_U90; ts_array_U91; ts_array_U92; ts_array_U93; ts_array_U94; ts_array_U95; ts_array_U96; ts_array_U97; ts_array_U98; ts_array_U99; ts_array_U100; ts_array_U101; ts_array_U102; ts_array_U103; ts_array_U104; ts_array_U105; ts_array_U106; ts_array_U107; ts_array_U108; ts_array_U109; ts_array_U110; ts_array_U111; ts_array_U112; ts_array_U113; ts_array_U114; ts_array_U115; ts_array_U116; ts_array_U117; ts_array_U118; ts_array_U119; ts_array_U120; ts_array_U121; ts_array_U122; ts_array_U123; ts_array_U124; ts_array_U125; ts_array_U126; ts_array_U127; ts_array_U128; ts_array_U129; ts_array_U130; ts_array_U131; ts_array_U132; ts_array_U133; ts_array_U134; ts_array_U135; ts_array_U136; ts_array_U137; ts_array_U138; ts_array_U139; ts_array_U140; ts_array_U141; ts_array_U142; ts_array_U143; ts_array_U144; ts_array_U145; ts_array_U146; ts_array_U147; ts_array_U148; ts_array_U149; ts_array_U150; ts_array_U151; ts_array_U152; ts_array_U153; ts_array_U154; ts_array_U155; ts_array_U156; ts_array_U157; ts_array_U158; ts_array_U159; ts_array_U160; ts_array_U161; ts_array_U162; ts_array_U163; ts_array_U164; ts_array_U165; ts_array_U166; ts_array_U167; ts_array_U168; ts_array_U169; ts_array_U170; ts_array_U171; ts_array_U172; ts_array_U173; ts_array_U174; ts_array_U175; ts_array_U176; ts_array_U177; ts_array_U178; ts_array_U179; ts_array_U180; ts_array_U181; ts_array_U182; ts_array_U183; ts_array_U184; ts_array_U185; ts_array_U186; ts_array_U187; ts_array_U188; ts_array_U189; ts_array_U190; ts_array_U191; ts_array_U192; ts_array_U193; ts_array_U194; ts_array_U195; ts_array_U196; ts_array_U197; ts_array_U198; ts_array_U199; ts_array_U200; ts_array_U201; ts_array_U202; ts_array_U203; ts_array_U204; ts_array_U205; ts_array_U206; ts_array_U207; ts_array_U208; ts_array_U209; ts_array_U210; ts_array_U211; ts_array_U212; ts_array_U213; ts_array_U214; ts_array_U215; ts_array_U216; ts_array_U217; ts_array_U218; ts_array_U219; ts_array_U220; ts_array_U221; ts_array_U222; ts_array_U223; ts_array_U224; ts_array_U225; ts_array_U226; ts_array_U227; ts_array_U228; ts_array_U229; ts_array_U230; ts_array_U231; ts_array_U232; ts_array_U233; ts_array_U234; ts_array_U235; ts_array_U236; ts_array_U237; ts_array_U238; ts_array_U239; ts_array_U240; ts_array_U241; ts_array_U242; ts_array_U243; ts_array_U244; ts_array_U245; ts_array_U246; ts_array_U247; ts_array_U248; ts_array_U249; ts_array_U250; ts_array_U251; ts_array_U252; ts_array_U253; ts_array_U254; ts_array_U255; ts_array_U256; ts_array_U257; ts_array_U258; ts_array_U259; ts_array_U260; ts_array_U261; ts_array_U262; ts_array_U263; ts_array_U264; ts_array_U265; ts_array_U266; ts_array_U267; ts_array_U268; ts_array_U269; ts_array_U270; ts_array_U271; ts_array_U272; ts_array_U273; ts_array_U274; ts_array_U275; ts_array_U276; ts_array_U277; ts_array_U278; ts_array_U279; ts_array_U280; ts_array_U281; ts_array_U282; ts_array_U283; ts_array_U284; ts_array_U285; ts_array_U286; ts_array_U287; ts_array_U288; ts_array_U289; ts_array_U290; ts_array_U291; ts_array_U292; ts_array_U293; ts_array_U294; ts_array_U295; ts_array_U296; ts_array_U297; ts_array_U298; ts_array_U299; ts_array_U300; ts_array_U301; ts_array_U302; ts_array_U303; ts_array_U304; ts_array_U305; ts_array_U306; ts_array_U307; ts_array_U308; ts_array_U309; ts_array_U310; ts_array_U311; ts_array_U312; ts_array_U313; ts_array_U314; ts_array_U315; ts_array_U316; ts_array_U317; ts_array_U318; ts_array_U319; ts_array_U320; ts_array_U321; ts_array_U322; ts_array_U323; ts_array_U324; ts_array_U325; ts_array_U326; ts_array_U327; ts_array_U328; ts_array_U329; ts_array_U330; ts_array_U331; ts_array_U332; ts_array_U333; ts_array_U334; ts_array_U335; ts_array_U336; ts_array_U337; ts_array_U338; ts_array_U339; ts_array_U340; ts_array_U341; ts_array_U342; ts_array_U343; ts_array_U344; ts_array_U345; ts_array_U346; ts_array_U347; ts_array_U348; ts_array_U349; ts_array_U350; ts_array_U351; ts_array_U352; ts_array_U353; ts_array_U354; ts_array_U355; ts_array_U356; ts_array_U357; ts_array_U358; ts_array_U359; ts_array_U360; ts_array_U361; ts_array_U362; ts_array_U363; ts_array_U364; ts_array_U365; ts_array_U366; ts_array_U367; ts_array_U368; ts_array_U369; ts_array_U370; ts_array_U371; ts_array_U372; ts_array_U373; ts_array_U374; ts_array_U375; ts_array_U376; ts_array_U377; ts_array_U378; ts_array_U379; ts_array_U380; ts_array_U381; ts_array_U382; ts_array_U383; ts_array_U384; ts_array_U385; ts_array_U386; ts_array_U387; ts_array_U388; ts_array_U389; ts_array_U390; ts_array_U391; ts_array_U392; ts_array_U393; ts_array_U394; ts_array_U395; ts_array_U396; ts_array_U397; ts_array_U398; ts_array_U399; ts_array_U400; ts_array_U401; ts_array_U402; ts_array_U403; ts_array_U404; ts_array_U405; ts_array_U406; ts_array_U407; ts_array_U408; ts_array_U409; ts_array_U410; ts_array_U411; ts_array_U412; ts_array_U413; ts_array_U414; ts_array_U415; ts_array_U416; ts_array_U417; ts_array_U418; ts_array_U419; ts_array_U420; ts_array_U421; ts_array_U422; ts_array_U423; ts_array_U424; ts_array_U425; ts_array_U426; ts_array_U427; ts_array_U428; ts_array_U429; ts_array_U430; ts_array_U431; ts_array_U432; ts_array_U433; ts_array_U434; ts_array_U435; ts_array_U436; ts_array_U437; ts_array_U438; ts_array_U439; ts_array_U440; ts_array_U441; ts_array_U442; ts_array_U443; ts_array_U444; ts_array_U445; ts_array_U446; ts_array_U447; ts_array_U448; ts_array_U449; ts_array_U450; ts_array_U451; ts_array_U452; ts_array_U453; ts_array_U454; ts_array_U455; ts_array_U456; ts_array_U457; ts_array_U458; ts_array_U459; ts_array_U460; ts_array_U461; ts_array_U462; ts_array_U463; ts_array_U464; ts_array_U465; ts_array_U466; ts_array_U467; ts_array_U468; ts_array_U469; ts_array_U470; ts_array_U471; ts_array_U473; ts_array_U474; ts_array_U475; ts_array_U476; ts_array_U477; ts_array_U478; ts_array_U479; ts_array_U480; ts_array_U481; ts_array_U482; ts_array_U483; ts_array_U484; ts_array_U485; ts_array_U486; ts_array_U487; ts_array_U488; ts_array_U489; ts_array_U507; 0; 0; ];
Array ResponseDivisions --> [ "Standard Rules"; 1; 393; "Modified Exit by Emily Short"; 394; 395; "Locksmith by Emily Short"; 396; 410; "Basic Screen Effects by Emily Short"; 411; 411; 0; 0; 0; ];
Array TableOfTables --> [ TheEmptyTable; table_data_U1; table_data_U2; table_data_U3; table_data_U4; table_data_U5; table_data_U6; table_data_U7; table_data_U8; table_data_U9; table_data_U10; table_data_U11; table_data_U12; table_data_U13; table_data_U14; table_data_U15; table_data_U16; table_data_U17; table_data_U18; table_data_U19; table_data_U20; table_data_U21; table_data_U22; table_data_U23; table_data_U24; table_data_U25; table_data_U26; table_data_U27; table_data_U28; table_data_U29; table_data_U30; table_data_U31; table_data_U32; table_data_U33; table_data_U34; table_data_U35; table_data_U36; table_data_U37; table_data_U38; table_data_U39; table_data_U40; table_data_U41; table_data_U42; table_data_U43; table_data_U44; table_data_U45; table_data_U46; table_data_U47; table_data_U48; table_data_U49; table_data_U50; 0; 0; ];
Array TB_Blanks -> [ 0; 0; 0; 4; 27; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 255; 15; 0; 1; 0; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0; 5; 0; 250; 7; 255; 7; 0; 63; 192; 255; 0; 3; 3; 0; 0; 15; 0; 15; 0; 15; 0; 15; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 15; 0; 15; 0; 7; 0; 63; 0; 7; 0; 3; 0; 7; 0; 15; 0; 7; 0; 15; 0; 63; 0; 31; 0; 31; 0; 31; 0; 127; 0; 15; 0; 15; 0; 63; 0; 127; 0; 0; ];
Array closure_data_U1 --> [ DK3_phrase_real_number____re; call_U209; "rsqr function"; ];
Array closure_data_U2 --> [ DK3_phrase_real_number____re; call_U210; "arcsinh function"; ];
Array closure_data_U3 --> [ DK3_phrase_real_number____re; call_U211; "arccosh function"; ];
Array closure_data_U4 --> [ DK3_phrase_real_number____re; call_U212; "arctanh function"; ];
Array closure_data_U5 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Abs; "abs function"; ];
Array closure_data_U6 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Root; "root function"; ];
Array closure_data_U7 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Ceiling; "ceiling function"; ];
Array closure_data_U8 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Floor; "floor function"; ];
Array closure_data_U9 --> [ DK4_phrase_real_number____nu; REAL_NUMBER_TY_to_NUMBER_TY; "int function"; ];
Array closure_data_U10 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Log; "log function"; ];
Array closure_data_U11 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Exp; "exp function"; ];
Array closure_data_U12 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sin; "sin function"; ];
Array closure_data_U13 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cos; "cos function"; ];
Array closure_data_U14 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tan; "tan function"; ];
Array closure_data_U15 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arcsin; "arcsin function"; ];
Array closure_data_U16 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arccos; "arccos function"; ];
Array closure_data_U17 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arctan; "arctan function"; ];
Array closure_data_U18 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sinh; "sinh function"; ];
Array closure_data_U19 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cosh; "cosh function"; ];
Array closure_data_U20 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tanh; "tanh function"; ];
Array inline_U43 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U43; ];
Array bc_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U44; ];
Array bc_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U45; ];
Array bc_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U44 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U46; ];
Array bc_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U47; ];
Array bc_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U48; ];
Array bc_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U45 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U49; ];
Array bc_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U50; ];
Array bc_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U51; ];
Array bc_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U46 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U52; ];
Array bc_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U53; ];
Array bc_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U54; ];
Array bc_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U47 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U55; ];
Array bc_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U56; ];
Array bc_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U57; ];
Array bc_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U48 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U58; ];
Array bc_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U59; ];
Array bc_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U60; ];
Array bc_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U49 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U61; ];
Array bc_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U62; ];
Array bc_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U63; ];
Array bc_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U50 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U64; ];
Array bc_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U65; ];
Array bc_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U66; ];
Array bc_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U51 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U67; ];
Array bc_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U68; ];
Array bc_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U69; ];
Array bc_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U52 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U70; ];
Array bc_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U71; ];
Array bc_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U72; ];
Array bc_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U53 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U73; ];
Array bc_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U74; ];
Array bc_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U75; ];
Array bc_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U54 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U76; ];
Array bc_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U77; ];
Array bc_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U78; ];
Array bc_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U55 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U79; ];
Array bc_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U80; ];
Array bc_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U81; ];
Array bc_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U82; ];
Array bc_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U83; ];
Array bc_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U56 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U84; ];
Array bc_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U85; ];
Array bc_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array Rel_Record1 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "leading-through relation"; abilities_U1; A_door_to; DK10_relation_of_rooms_to_doo; call_U437; "Leading-through relates one room ( called the leading-through destination ) to various doors"; ];
Array Rel_Record2 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "lock-fitting relation"; abilities_U2; A_with_key; DK8_relation_of_things; call_U441; "Lock-fitting relates one thing ( called the matching key ) to various things"; ];
Array as_block_constant_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U800; ];
Array ts_array_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U801; ];
Array as_block_constant_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U802; ];
Array ts_array_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U803; ];
Array as_block_constant_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U804; ];
Array ts_array_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U805; ];
Array as_block_constant_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U806; ];
Array ts_array_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U807; ];
Array as_block_constant_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U808; ];
Array ts_array_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U809; ];
Array as_block_constant_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U810; ];
Array ts_array_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U811; ];
Array as_block_constant_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U812; ];
Array ts_array_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U813; ];
Array as_block_constant_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U814; ];
Array ts_array_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U815; ];
Array as_block_constant_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U816; ];
Array ts_array_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U817; ];
Array as_block_constant_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U818; ];
Array ts_array_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U819; ];
Array as_block_constant_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U820; ];
Array ts_array_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U821; ];
Array as_block_constant_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U822; ];
Array ts_array_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U823; ];
Array as_block_constant_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U824; ];
Array ts_array_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U825; ];
Array as_block_constant_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U826; ];
Array ts_array_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U827; ];
Array as_block_constant_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U828; ];
Array ts_array_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U829; ];
Array as_block_constant_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U830; ];
Array ts_array_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U831; ];
Array as_block_constant_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U832; ];
Array ts_array_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U833; ];
Array as_block_constant_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U834; ];
Array ts_array_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U835; ];
Array as_block_constant_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U836; ];
Array ts_array_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U837; ];
Array as_block_constant_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U838; ];
Array ts_array_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U839; ];
Array as_block_constant_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U840; ];
Array ts_array_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U841; ];
Array as_block_constant_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U842; ];
Array ts_array_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U843; ];
Array as_block_constant_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U844; ];
Array ts_array_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U845; ];
Array as_block_constant_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U846; ];
Array ts_array_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U847; ];
Array as_block_constant_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U848; ];
Array ts_array_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U849; ];
Array as_block_constant_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U850; ];
Array ts_array_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U851; ];
Array as_block_constant_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U852; ];
Array ts_array_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U853; ];
Array as_block_constant_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U854; ];
Array ts_array_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U855; ];
Array as_block_constant_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U856; ];
Array ts_array_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U857; ];
Array as_block_constant_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U858; ];
Array ts_array_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U859; ];
Array as_block_constant_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U860; ];
Array ts_array_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U861; ];
Array as_block_constant_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U862; ];
Array ts_array_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U863; ];
Array as_block_constant_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U864; ];
Array ts_array_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U865; ];
Array as_block_constant_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U866; ];
Array ts_array_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U867; ];
Array as_block_constant_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U868; ];
Array ts_array_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U869; ];
Array as_block_constant_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U870; ];
Array ts_array_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U871; ];
Array as_block_constant_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U872; ];
Array ts_array_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U873; ];
Array as_block_constant_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U874; ];
Array ts_array_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U875; ];
Array as_block_constant_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U876; ];
Array ts_array_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U877; ];
Array as_block_constant_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U878; ];
Array ts_array_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U879; ];
Array as_block_constant_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U880; ];
Array ts_array_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U881; ];
Array as_block_constant_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U882; ];
Array ts_array_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U883; ];
Array as_block_constant_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U884; ];
Array ts_array_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U885; ];
Array as_block_constant_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U886; ];
Array ts_array_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U887; ];
Array as_block_constant_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U888; ];
Array ts_array_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U889; ];
Array as_block_constant_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U890; ];
Array ts_array_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U891; ];
Array as_block_constant_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U892; ];
Array ts_array_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U893; ];
Array as_block_constant_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U894; ];
Array ts_array_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U895; ];
Array as_block_constant_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U896; ];
Array ts_array_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U897; ];
Array as_block_constant_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U898; ];
Array ts_array_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U899; ];
Array as_block_constant_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U900; ];
Array ts_array_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U901; ];
Array as_block_constant_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U902; ];
Array ts_array_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U903; ];
Array as_block_constant_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U904; ];
Array ts_array_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U905; ];
Array as_block_constant_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U906; ];
Array ts_array_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U907; ];
Array as_block_constant_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U908; ];
Array ts_array_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U909; ];
Array as_block_constant_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U910; ];
Array ts_array_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U911; ];
Array as_block_constant_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U912; ];
Array ts_array_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U913; ];
Array as_block_constant_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U914; ];
Array ts_array_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U915; ];
Array as_block_constant_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U916; ];
Array ts_array_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U917; ];
Array as_block_constant_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U918; ];
Array ts_array_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U919; ];
Array as_block_constant_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U920; ];
Array ts_array_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U921; ];
Array as_block_constant_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U922; ];
Array ts_array_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U923; ];
Array as_block_constant_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U924; ];
Array ts_array_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U925; ];
Array as_block_constant_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U926; ];
Array ts_array_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U927; ];
Array as_block_constant_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U928; ];
Array ts_array_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U929; ];
Array as_block_constant_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U930; ];
Array ts_array_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U931; ];
Array as_block_constant_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U932; ];
Array ts_array_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U933; ];
Array as_block_constant_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U934; ];
Array ts_array_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U935; ];
Array as_block_constant_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U936; ];
Array ts_array_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U937; ];
Array as_block_constant_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U938; ];
Array ts_array_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U939; ];
Array as_block_constant_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U940; ];
Array ts_array_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U941; ];
Array as_block_constant_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U942; ];
Array ts_array_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U943; ];
Array as_block_constant_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U944; ];
Array ts_array_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U945; ];
Array as_block_constant_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U946; ];
Array ts_array_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U947; ];
Array as_block_constant_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U948; ];
Array ts_array_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U949; ];
Array as_block_constant_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U950; ];
Array ts_array_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U951; ];
Array as_block_constant_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U952; ];
Array ts_array_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U953; ];
Array as_block_constant_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U954; ];
Array ts_array_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U955; ];
Array as_block_constant_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U956; ];
Array ts_array_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U957; ];
Array as_block_constant_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U958; ];
Array ts_array_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U959; ];
Array as_block_constant_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U960; ];
Array ts_array_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U961; ];
Array as_block_constant_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U962; ];
Array ts_array_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U963; ];
Array as_block_constant_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U964; ];
Array ts_array_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U965; ];
Array as_block_constant_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U966; ];
Array ts_array_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U967; ];
Array as_block_constant_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U968; ];
Array ts_array_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U969; ];
Array as_block_constant_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U970; ];
Array ts_array_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U971; ];
Array as_block_constant_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U972; ];
Array ts_array_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U973; ];
Array as_block_constant_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U974; ];
Array ts_array_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U975; ];
Array as_block_constant_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U976; ];
Array ts_array_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U977; ];
Array as_block_constant_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U978; ];
Array ts_array_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U979; ];
Array as_block_constant_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U980; ];
Array ts_array_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U981; ];
Array as_block_constant_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U982; ];
Array ts_array_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U983; ];
Array as_block_constant_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U984; ];
Array ts_array_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U985; ];
Array as_block_constant_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U986; ];
Array ts_array_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U987; ];
Array as_block_constant_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U988; ];
Array ts_array_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U989; ];
Array as_block_constant_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U990; ];
Array ts_array_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U991; ];
Array as_block_constant_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U992; ];
Array ts_array_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U993; ];
Array as_block_constant_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U994; ];
Array ts_array_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U995; ];
Array as_block_constant_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U996; ];
Array ts_array_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U997; ];
Array as_block_constant_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U998; ];
Array ts_array_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U999; ];
Array as_block_constant_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1000; ];
Array ts_array_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1001; ];
Array as_block_constant_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1002; ];
Array ts_array_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1003; ];
Array as_block_constant_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1004; ];
Array ts_array_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1005; ];
Array as_block_constant_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1006; ];
Array ts_array_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1007; ];
Array as_block_constant_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1008; ];
Array ts_array_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1009; ];
Array as_block_constant_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1010; ];
Array ts_array_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1011; ];
Array as_block_constant_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1012; ];
Array ts_array_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1013; ];
Array as_block_constant_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1014; ];
Array ts_array_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1015; ];
Array as_block_constant_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1016; ];
Array ts_array_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1017; ];
Array as_block_constant_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1018; ];
Array ts_array_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1019; ];
Array as_block_constant_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1020; ];
Array ts_array_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1021; ];
Array as_block_constant_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1022; ];
Array ts_array_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1023; ];
Array as_block_constant_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1024; ];
Array ts_array_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1025; ];
Array as_block_constant_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1026; ];
Array ts_array_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1027; ];
Array as_block_constant_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1028; ];
Array ts_array_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1029; ];
Array as_block_constant_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1030; ];
Array ts_array_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1031; ];
Array as_block_constant_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1032; ];
Array ts_array_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1033; ];
Array as_block_constant_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1034; ];
Array ts_array_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1035; ];
Array as_block_constant_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1036; ];
Array ts_array_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1037; ];
Array as_block_constant_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1038; ];
Array ts_array_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1039; ];
Array as_block_constant_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1040; ];
Array ts_array_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1041; ];
Array as_block_constant_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1042; ];
Array ts_array_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1043; ];
Array as_block_constant_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1044; ];
Array ts_array_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1045; ];
Array as_block_constant_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1046; ];
Array ts_array_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1047; ];
Array as_block_constant_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1048; ];
Array ts_array_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1049; ];
Array as_block_constant_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1050; ];
Array ts_array_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1051; ];
Array as_block_constant_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1052; ];
Array ts_array_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1053; ];
Array as_block_constant_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1054; ];
Array ts_array_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1055; ];
Array as_block_constant_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1056; ];
Array ts_array_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1057; ];
Array as_block_constant_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1058; ];
Array ts_array_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1059; ];
Array as_block_constant_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1060; ];
Array ts_array_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1061; ];
Array as_block_constant_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1062; ];
Array ts_array_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1063; ];
Array as_block_constant_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1064; ];
Array ts_array_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1065; ];
Array as_block_constant_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1066; ];
Array ts_array_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1067; ];
Array as_block_constant_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1083; ];
Array ts_array_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1084; ];
Array bc_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1113; ];
Array ts_array_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1114; ];
Array as_block_constant_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1116; ];
Array ts_array_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1117; ];
Array as_block_constant_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1119; ];
Array ts_array_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1120; ];
Array as_block_constant_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1121; ];
Array ts_array_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1122; ];
Array as_block_constant_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1124; ];
Array ts_array_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1125; ];
Array as_block_constant_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1135; ];
Array ts_array_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1136; ];
Array as_block_constant_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1137; ];
Array ts_array_U220 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1138; ];
Array as_block_constant_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1139; ];
Array ts_array_U221 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1140; ];
Array as_block_constant_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1141; ];
Array ts_array_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1142; ];
Array as_block_constant_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1143; ];
Array ts_array_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1144; ];
Array as_block_constant_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1145; ];
Array ts_array_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1146; ];
Array bc_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1156; ];
Array ts_array_U225 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1157; ];
Array bc_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1163; ];
Array ts_array_U226 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1164; ];
Array as_block_constant_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1168; ];
Array ts_array_U227 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1169; ];
Array as_block_constant_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1171; ];
Array ts_array_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1172; ];
Array as_block_constant_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1174; ];
Array ts_array_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1175; ];
Array as_block_constant_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1177; ];
Array ts_array_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1178; ];
Array as_block_constant_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1180; ];
Array ts_array_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1181; ];
Array as_block_constant_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1183; ];
Array ts_array_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1184; ];
Array as_block_constant_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1186; ];
Array ts_array_U233 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1187; ];
Array as_block_constant_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1189; ];
Array ts_array_U234 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1190; ];
Array as_block_constant_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1192; ];
Array ts_array_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1193; ];
Array as_block_constant_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1195; ];
Array ts_array_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1196; ];
Array as_block_constant_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1198; ];
Array ts_array_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1199; ];
Array as_block_constant_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1201; ];
Array ts_array_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1202; ];
Array as_block_constant_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1204; ];
Array ts_array_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1205; ];
Array as_block_constant_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1207; ];
Array ts_array_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1208; ];
Array as_block_constant_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1213; ];
Array ts_array_U241 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1214; ];
Array as_block_constant_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1217; ];
Array ts_array_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1218; ];
Array as_block_constant_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1221; ];
Array ts_array_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1222; ];
Array as_block_constant_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1223; ];
Array ts_array_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1224; ];
Array as_block_constant_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1226; ];
Array ts_array_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1227; ];
Array as_block_constant_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1229; ];
Array ts_array_U246 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1230; ];
Array as_block_constant_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1233; ];
Array ts_array_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1234; ];
Array as_block_constant_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1236; ];
Array ts_array_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1237; ];
Array as_block_constant_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1239; ];
Array ts_array_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1240; ];
Array as_block_constant_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1242; ];
Array ts_array_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1243; ];
Array as_block_constant_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1245; ];
Array ts_array_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1246; ];
Array as_block_constant_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1250; ];
Array ts_array_U252 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1251; ];
Array as_block_constant_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1252; ];
Array ts_array_U253 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1253; ];
Array as_block_constant_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1256; ];
Array ts_array_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1257; ];
Array as_block_constant_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1258; ];
Array ts_array_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1259; ];
Array as_block_constant_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1263; ];
Array ts_array_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1264; ];
Array as_block_constant_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1266; ];
Array ts_array_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1267; ];
Array as_block_constant_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1269; ];
Array ts_array_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1270; ];
Array as_block_constant_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1273; ];
Array ts_array_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1274; ];
Array as_block_constant_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1277; ];
Array ts_array_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1278; ];
Array as_block_constant_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1280; ];
Array ts_array_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1281; ];
Array as_block_constant_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1284; ];
Array ts_array_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1285; ];
Array as_block_constant_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1287; ];
Array ts_array_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1288; ];
Array as_block_constant_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1291; ];
Array ts_array_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1292; ];
Array as_block_constant_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1294; ];
Array ts_array_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1295; ];
Array as_block_constant_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1297; ];
Array ts_array_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1298; ];
Array as_block_constant_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1301; ];
Array ts_array_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1302; ];
Array as_block_constant_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1305; ];
Array ts_array_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1306; ];
Array as_block_constant_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1308; ];
Array ts_array_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1309; ];
Array as_block_constant_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1311; ];
Array ts_array_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1312; ];
Array as_block_constant_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1314; ];
Array ts_array_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1315; ];
Array as_block_constant_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1318; ];
Array ts_array_U272 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1319; ];
Array as_block_constant_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1323; ];
Array ts_array_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1324; ];
Array as_block_constant_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1325; ];
Array ts_array_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1326; ];
Array as_block_constant_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1329; ];
Array ts_array_U275 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1330; ];
Array as_block_constant_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1332; ];
Array ts_array_U276 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1333; ];
Array as_block_constant_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1334; ];
Array ts_array_U277 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1335; ];
Array as_block_constant_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1337; ];
Array ts_array_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1338; ];
Array as_block_constant_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1340; ];
Array ts_array_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1341; ];
Array as_block_constant_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1344; ];
Array ts_array_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1345; ];
Array as_block_constant_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1346; ];
Array ts_array_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1347; ];
Array as_block_constant_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1352; ];
Array ts_array_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1353; ];
Array as_block_constant_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1354; ];
Array ts_array_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1355; ];
Array as_block_constant_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1356; ];
Array ts_array_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1357; ];
Array as_block_constant_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1358; ];
Array ts_array_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1359; ];
Array as_block_constant_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1360; ];
Array ts_array_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1361; ];
Array as_block_constant_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1362; ];
Array ts_array_U287 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1363; ];
Array as_block_constant_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1364; ];
Array ts_array_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1365; ];
Array as_block_constant_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1366; ];
Array ts_array_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1367; ];
Array as_block_constant_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1368; ];
Array ts_array_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1369; ];
Array as_block_constant_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1370; ];
Array ts_array_U291 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1371; ];
Array as_block_constant_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1372; ];
Array ts_array_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1373; ];
Array as_block_constant_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1374; ];
Array ts_array_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1375; ];
Array as_block_constant_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1376; ];
Array ts_array_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1377; ];
Array as_block_constant_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1378; ];
Array ts_array_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1379; ];
Array as_block_constant_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1380; ];
Array ts_array_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1381; ];
Array as_block_constant_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1382; ];
Array ts_array_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1383; ];
Array as_block_constant_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1384; ];
Array ts_array_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1385; ];
Array as_block_constant_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1386; ];
Array ts_array_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1387; ];
Array as_block_constant_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1388; ];
Array ts_array_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1389; ];
Array as_block_constant_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1395; ];
Array ts_array_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1396; ];
Array as_block_constant_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1397; ];
Array ts_array_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1398; ];
Array as_block_constant_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1400; ];
Array ts_array_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1401; ];
Array as_block_constant_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1402; ];
Array ts_array_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1403; ];
Array as_block_constant_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1404; ];
Array ts_array_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1405; ];
Array as_block_constant_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1406; ];
Array ts_array_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1407; ];
Array as_block_constant_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1409; ];
Array ts_array_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1410; ];
Array as_block_constant_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1414; ];
Array ts_array_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1415; ];
Array as_block_constant_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1416; ];
Array ts_array_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1417; ];
Array as_block_constant_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1419; ];
Array ts_array_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1420; ];
Array as_block_constant_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1422; ];
Array ts_array_U311 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1423; ];
Array as_block_constant_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1424; ];
Array ts_array_U312 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1425; ];
Array as_block_constant_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1426; ];
Array ts_array_U313 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1427; ];
Array as_block_constant_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1428; ];
Array ts_array_U314 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1429; ];
Array as_block_constant_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1430; ];
Array ts_array_U315 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1431; ];
Array as_block_constant_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1434; ];
Array ts_array_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1435; ];
Array as_block_constant_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1436; ];
Array ts_array_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1437; ];
Array as_block_constant_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1438; ];
Array ts_array_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1439; ];
Array as_block_constant_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1440; ];
Array ts_array_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1441; ];
Array as_block_constant_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1446; ];
Array ts_array_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1447; ];
Array as_block_constant_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1449; ];
Array ts_array_U321 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1450; ];
Array as_block_constant_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1454; ];
Array ts_array_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1455; ];
Array as_block_constant_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1456; ];
Array ts_array_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1457; ];
Array as_block_constant_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1458; ];
Array ts_array_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1459; ];
Array as_block_constant_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1462; ];
Array ts_array_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1463; ];
Array as_block_constant_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1466; ];
Array ts_array_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1467; ];
Array as_block_constant_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1473; ];
Array ts_array_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1474; ];
Array as_block_constant_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1475; ];
Array ts_array_U328 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1476; ];
Array as_block_constant_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1477; ];
Array ts_array_U329 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1478; ];
Array as_block_constant_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1480; ];
Array ts_array_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1481; ];
Array as_block_constant_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1485; ];
Array ts_array_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1486; ];
Array bc_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1489; ];
Array ts_array_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1490; ];
Array as_block_constant_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1494; ];
Array ts_array_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1495; ];
Array as_block_constant_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1496; ];
Array ts_array_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1497; ];
Array as_block_constant_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1501; ];
Array ts_array_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1502; ];
Array as_block_constant_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1504; ];
Array ts_array_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1505; ];
Array as_block_constant_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1507; ];
Array ts_array_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1508; ];
Array as_block_constant_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1510; ];
Array ts_array_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1511; ];
Array as_block_constant_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1513; ];
Array ts_array_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1514; ];
Array as_block_constant_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1516; ];
Array ts_array_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1517; ];
Array as_block_constant_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1519; ];
Array ts_array_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1520; ];
Array as_block_constant_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1522; ];
Array ts_array_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1523; ];
Array as_block_constant_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1526; ];
Array ts_array_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1527; ];
Array as_block_constant_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1528; ];
Array ts_array_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1529; ];
Array as_block_constant_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1532; ];
Array ts_array_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1533; ];
Array as_block_constant_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1534; ];
Array ts_array_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1535; ];
Array as_block_constant_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1537; ];
Array ts_array_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1538; ];
Array as_block_constant_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1540; ];
Array ts_array_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1541; ];
Array as_block_constant_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1542; ];
Array ts_array_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1543; ];
Array as_block_constant_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1545; ];
Array ts_array_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1546; ];
Array as_block_constant_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1548; ];
Array ts_array_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1549; ];
Array as_block_constant_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1551; ];
Array ts_array_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1552; ];
Array as_block_constant_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1554; ];
Array ts_array_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1555; ];
Array as_block_constant_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1558; ];
Array ts_array_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1559; ];
Array as_block_constant_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1560; ];
Array ts_array_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1561; ];
Array as_block_constant_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1563; ];
Array ts_array_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1564; ];
Array as_block_constant_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1566; ];
Array ts_array_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1567; ];
Array as_block_constant_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1569; ];
Array ts_array_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1570; ];
Array as_block_constant_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1573; ];
Array ts_array_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1574; ];
Array as_block_constant_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1575; ];
Array ts_array_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1576; ];
Array as_block_constant_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1578; ];
Array ts_array_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1579; ];
Array as_block_constant_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1581; ];
Array ts_array_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1582; ];
Array as_block_constant_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1585; ];
Array ts_array_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1586; ];
Array as_block_constant_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1588; ];
Array ts_array_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1589; ];
Array as_block_constant_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1591; ];
Array ts_array_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1592; ];
Array as_block_constant_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1595; ];
Array ts_array_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1596; ];
Array as_block_constant_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1598; ];
Array ts_array_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1599; ];
Array as_block_constant_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1601; ];
Array ts_array_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1602; ];
Array as_block_constant_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1604; ];
Array ts_array_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1605; ];
Array as_block_constant_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1608; ];
Array ts_array_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1609; ];
Array as_block_constant_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1611; ];
Array ts_array_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1612; ];
Array as_block_constant_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1613; ];
Array ts_array_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1614; ];
Array as_block_constant_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1615; ];
Array ts_array_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1616; ];
Array as_block_constant_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1618; ];
Array ts_array_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1619; ];
Array as_block_constant_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1621; ];
Array ts_array_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1622; ];
Array as_block_constant_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1625; ];
Array ts_array_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1626; ];
Array as_block_constant_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1627; ];
Array ts_array_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1628; ];
Array as_block_constant_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1629; ];
Array ts_array_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1630; ];
Array as_block_constant_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1632; ];
Array ts_array_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1633; ];
Array as_block_constant_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1635; ];
Array ts_array_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1636; ];
Array as_block_constant_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1638; ];
Array ts_array_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1639; ];
Array as_block_constant_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1642; ];
Array ts_array_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1643; ];
Array as_block_constant_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1644; ];
Array ts_array_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1645; ];
Array as_block_constant_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1648; ];
Array ts_array_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1649; ];
Array as_block_constant_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1652; ];
Array ts_array_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1653; ];
Array as_block_constant_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1656; ];
Array ts_array_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1657; ];
Array as_block_constant_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1658; ];
Array ts_array_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1659; ];
Array as_block_constant_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1661; ];
Array ts_array_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1662; ];
Array as_block_constant_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1664; ];
Array ts_array_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1665; ];
Array as_block_constant_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1667; ];
Array ts_array_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1668; ];
Array as_block_constant_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1670; ];
Array ts_array_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1671; ];
Array as_block_constant_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1673; ];
Array ts_array_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1674; ];
Array as_block_constant_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1677; ];
Array ts_array_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1678; ];
Array as_block_constant_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1681; ];
Array ts_array_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1682; ];
Array as_block_constant_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1683; ];
Array ts_array_U395 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1684; ];
Array as_block_constant_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1685; ];
Array ts_array_U396 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1686; ];
Array as_block_constant_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1688; ];
Array ts_array_U397 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1689; ];
Array as_block_constant_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1692; ];
Array ts_array_U398 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1693; ];
Array as_block_constant_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1695; ];
Array ts_array_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1696; ];
Array as_block_constant_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1698; ];
Array ts_array_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1699; ];
Array as_block_constant_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1701; ];
Array ts_array_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1702; ];
Array as_block_constant_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1704; ];
Array ts_array_U402 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1705; ];
Array as_block_constant_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1707; ];
Array ts_array_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1708; ];
Array as_block_constant_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1710; ];
Array ts_array_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1711; ];
Array as_block_constant_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1713; ];
Array ts_array_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1714; ];
Array as_block_constant_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1716; ];
Array ts_array_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1717; ];
Array as_block_constant_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1719; ];
Array ts_array_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1720; ];
Array as_block_constant_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1722; ];
Array ts_array_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1723; ];
Array as_block_constant_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1725; ];
Array ts_array_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1726; ];
Array as_block_constant_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1730; ];
Array ts_array_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1731; ];
Array as_block_constant_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1732; ];
Array ts_array_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1733; ];
Array as_block_constant_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1735; ];
Array ts_array_U412 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1736; ];
Array as_block_constant_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1737; ];
Array ts_array_U413 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1738; ];
Array as_block_constant_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1740; ];
Array ts_array_U414 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1741; ];
Array as_block_constant_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1742; ];
Array ts_array_U415 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1743; ];
Array as_block_constant_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1744; ];
Array ts_array_U416 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1745; ];
Array as_block_constant_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1747; ];
Array ts_array_U417 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1748; ];
Array as_block_constant_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1749; ];
Array ts_array_U418 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1750; ];
Array as_block_constant_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1752; ];
Array ts_array_U419 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1753; ];
Array as_block_constant_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1755; ];
Array ts_array_U420 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1756; ];
Array as_block_constant_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1757; ];
Array ts_array_U421 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1758; ];
Array as_block_constant_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1760; ];
Array ts_array_U422 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1761; ];
Array as_block_constant_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1763; ];
Array ts_array_U423 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1764; ];
Array as_block_constant_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1766; ];
Array ts_array_U424 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1767; ];
Array as_block_constant_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1769; ];
Array ts_array_U425 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1770; ];
Array as_block_constant_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1771; ];
Array ts_array_U426 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1772; ];
Array as_block_constant_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1774; ];
Array ts_array_U427 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1775; ];
Array as_block_constant_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1777; ];
Array ts_array_U428 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1778; ];
Array as_block_constant_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1780; ];
Array ts_array_U429 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1781; ];
Array as_block_constant_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1783; ];
Array ts_array_U430 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1784; ];
Array as_block_constant_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1785; ];
Array ts_array_U431 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1786; ];
Array as_block_constant_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1788; ];
Array ts_array_U432 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1789; ];
Array as_block_constant_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1791; ];
Array ts_array_U433 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1792; ];
Array as_block_constant_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1794; ];
Array ts_array_U434 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1795; ];
Array as_block_constant_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1797; ];
Array ts_array_U435 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1798; ];
Array as_block_constant_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1799; ];
Array ts_array_U436 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1800; ];
Array as_block_constant_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1802; ];
Array ts_array_U437 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1803; ];
Array as_block_constant_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1805; ];
Array ts_array_U438 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1806; ];
Array as_block_constant_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1808; ];
Array ts_array_U439 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1809; ];
Array as_block_constant_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1811; ];
Array ts_array_U440 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1812; ];
Array as_block_constant_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1815; ];
Array ts_array_U441 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1816; ];
Array as_block_constant_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1818; ];
Array ts_array_U442 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1819; ];
Array as_block_constant_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1821; ];
Array ts_array_U443 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1822; ];
Array as_block_constant_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1823; ];
Array ts_array_U444 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1824; ];
Array as_block_constant_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1826; ];
Array ts_array_U445 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1827; ];
Array as_block_constant_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1829; ];
Array ts_array_U446 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1830; ];
Array as_block_constant_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1832; ];
Array ts_array_U447 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1833; ];
Array as_block_constant_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1835; ];
Array ts_array_U448 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1836; ];
Array as_block_constant_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1838; ];
Array ts_array_U449 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1839; ];
Array as_block_constant_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1841; ];
Array ts_array_U450 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1842; ];
Array as_block_constant_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1843; ];
Array ts_array_U451 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1844; ];
Array as_block_constant_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1846; ];
Array ts_array_U452 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1847; ];
Array as_block_constant_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1848; ];
Array ts_array_U453 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1849; ];
Array as_block_constant_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1851; ];
Array ts_array_U454 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1852; ];
Array as_block_constant_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1853; ];
Array ts_array_U455 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1854; ];
Array as_block_constant_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1856; ];
Array ts_array_U456 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1857; ];
Array as_block_constant_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1859; ];
Array ts_array_U457 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1860; ];
Array as_block_constant_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1861; ];
Array ts_array_U458 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1862; ];
Array as_block_constant_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1864; ];
Array ts_array_U459 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1865; ];
Array as_block_constant_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1867; ];
Array ts_array_U460 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1868; ];
Array as_block_constant_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1870; ];
Array ts_array_U461 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1871; ];
Array as_block_constant_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1873; ];
Array ts_array_U462 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1874; ];
Array as_block_constant_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1876; ];
Array ts_array_U463 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1877; ];
Array as_block_constant_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1879; ];
Array ts_array_U464 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1880; ];
Array as_block_constant_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1881; ];
Array ts_array_U465 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1882; ];
Array as_block_constant_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1884; ];
Array ts_array_U466 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1885; ];
Array as_block_constant_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1887; ];
Array ts_array_U467 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1888; ];
Array as_block_constant_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1889; ];
Array ts_array_U468 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1890; ];
Array as_block_constant_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1892; ];
Array ts_array_U469 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1893; ];
Array as_block_constant_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1895; ];
Array ts_array_U470 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1896; ];
Array as_block_constant_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1898; ];
Array ts_array_U471 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1899; ];
Array bc_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U57 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U86; ];
Array bc_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U87; ];
Array ts_array_U472 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1908; ];
Array bc_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U88; ];
Array bc_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U89; ];
Array bc_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U90; ];
Array bc_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U91; ];
Array bc_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U92; ];
Array bc_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U93; ];
Array bc_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U94; ];
Array bc_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U95; ];
Array bc_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U96; ];
Array bc_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U97; ];
Array bc_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U98; ];
Array bc_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK10_relation_of_rooms_to_doo --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array bc_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U99; ];
Array bc_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U100; ];
Array bc_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U101; ];
Array bc_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U102; ];
Array bc_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U103; ];
Array column_data_U1 table [ column_bits_U1; column_blanks_U1; bc_U330; bc_U331; bc_U332; bc_U333; bc_U334; ];
Array bc_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U104; ];
Array bc_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U105; ];
Array bc_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U106; ];
Array bc_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U107; ];
Array bc_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U108; ];
Array column_data_U2 table [ column_bits_U2; column_blanks_U2; 0; 0; 1; 0; 0; ];
Array column_data_U3 table [ column_bits_U3; column_blanks_U3; Consult_Grammar1; Consult_Grammar2; Consult_Grammar3; Consult_Grammar4; Consult_Grammar5; ];
Array column_data_U4 table [ column_bits_U4; column_blanks_U4; IMMEDIATELY_RESTART_VM_R; IMMEDIATELY_RESTORE_SAVED_R; TABLE_NOVALUE; IMMEDIATELY_QUIT_R; IMMEDIATELY_UNDO_R; ];
Array column_data_U5 table [ column_bits_U5; column_blanks_U5; TABLE_NOVALUE; TABLE_NOVALUE; V29_amusing_a_victorious_play; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U1 table [ column_data_U1; column_data_U2; column_data_U3; column_data_U4; column_data_U5; ];
Array column_data_U6 table [ column_bits_U6; NULL; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U7 table [ column_bits_U7; column_blanks_U6; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U2 table [ column_data_U6; column_data_U7; ];
Array as_block_constant_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2012; ];
Array ts_array_U473 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2013; ];
Array as_block_constant_U395 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2016; ];
Array ts_array_U474 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2017; ];
Array Rel_Record3 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "unbolting relation"; abilities_U3; A_P_unbolting_relation_storage; DK11_relation_of_passkeys_to_; call_U2041; "Unbolting relates one passkey to various things"; ];
Array bc_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U109; ];
Array bc_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U110; ];
Array bc_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK11_relation_of_passkeys_to_ --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array as_block_constant_U396 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2045; ];
Array ts_array_U475 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2046; ];
Array as_block_constant_U397 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2048; ];
Array ts_array_U476 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2049; ];
Array as_block_constant_U398 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2051; ];
Array ts_array_U477 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2052; ];
Array as_block_constant_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2054; ];
Array ts_array_U478 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2055; ];
Array as_block_constant_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2062; ];
Array ts_array_U479 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2063; ];
Array as_block_constant_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2066; ];
Array ts_array_U480 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2067; ];
Array as_block_constant_U402 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2070; ];
Array ts_array_U481 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2071; ];
Array as_block_constant_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2075; ];
Array ts_array_U482 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2076; ];
Array as_block_constant_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2078; ];
Array ts_array_U483 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2079; ];
Array as_block_constant_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2081; ];
Array ts_array_U484 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2082; ];
Array as_block_constant_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2088; ];
Array ts_array_U485 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2089; ];
Array as_block_constant_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2097; ];
Array ts_array_U486 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2098; ];
Array as_block_constant_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2100; ];
Array ts_array_U487 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2101; ];
Array as_block_constant_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2104; ];
Array ts_array_U488 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U2105; ];
Array as_block_constant_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2107; ];
Array ts_array_U489 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2108; ];
Array bc_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U111; ];
Array column_data_U8 table [ column_bits_U8; column_blanks_U7; bc_U348; ];
Array bc_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U112; ];
Array column_data_U9 table [ column_bits_U9; column_blanks_U8; TABLE_NOVALUE; ];
Array column_data_U10 table [ column_bits_U10; column_blanks_U9; bc_U349; ];
Array bc_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U113; ];
Array column_data_U11 table [ column_bits_U11; column_blanks_U10; TABLE_NOVALUE; ];
Array table_data_U3 table [ column_data_U8; column_data_U9; column_data_U10; column_data_U11; ];
Array column_data_U12 table [ column_bits_U12; column_blanks_U11; 78; 110; 80; 112; 81; 113; 13; 32; 130; 129; 27; -8; -6; -5; -4; ];
Array column_data_U13 table [ column_bits_U13; column_blanks_U12; call_U2116; call_U2116; call_U2117; call_U2117; call_U2115; call_U2115; call_U2118; call_U2118; call_U2116; call_U2117; call_U2115; call_U2115; call_U2118; call_U2116; call_U2117; ];
Array table_data_U4 table [ column_data_U12; column_data_U13; ];
Array column_data_U14 table [ column_bits_U14; column_blanks_U13; bc_U350; ];
Array bc_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U15 table [ column_bits_U15; column_blanks_U14; ts_array_U490; ];
Array ts_array_U490 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2122; ];
Array column_data_U16 table [ column_bits_U16; column_blanks_U15; bc_U351; ];
Array bc_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array table_data_U5 table [ column_data_U14; column_data_U15; column_data_U16; ];
Array column_data_U17 table [ column_bits_U17; column_blanks_U16; bc_U352; bc_U353; bc_U354; bc_U355; ];
Array bc_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U114; ];
Array bc_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U115; ];
Array column_data_U18 table [ column_bits_U18; column_blanks_U17; ts_array_U491; bc_U356; bc_U357; bc_U358; ];
Array ts_array_U491 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2123; ];
Array bc_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U19 table [ column_bits_U19; column_blanks_U18; bc_U359; bc_U360; ts_array_U492; bc_U361; ];
Array bc_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U116; ];
Array ts_array_U492 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2124; ];
Array bc_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U117; ];
Array table_data_U6 table [ column_data_U17; column_data_U18; column_data_U19; ];
Array column_data_U20 table [ column_bits_U20; column_blanks_U19; bc_U362; ];
Array bc_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U118; ];
Array column_data_U21 table [ column_bits_U21; column_blanks_U20; TABLE_NOVALUE; ];
Array table_data_U7 table [ column_data_U20; column_data_U21; ];
Array column_data_U22 table [ column_bits_U22; column_blanks_U21; ts_array_U493; bc_U364; bc_U365; bc_U366; bc_U367; bc_U368; bc_U369; bc_U370; bc_U371; bc_U372; bc_U373; ];
Array bc_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U119; ];
Array ts_array_U493 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2140; ];
Array bc_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U120; ];
Array bc_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U121; ];
Array bc_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U122; ];
Array bc_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U123; ];
Array bc_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U124; ];
Array bc_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U125; ];
Array bc_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U126; ];
Array bc_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U127; ];
Array bc_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U128; ];
Array bc_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U129; ];
Array column_data_U23 table [ column_bits_U23; column_blanks_U22; TABLE_NOVALUE; table_data_U9; TABLE_NOVALUE; table_data_U18; table_data_U19; table_data_U20; table_data_U21; table_data_U22; table_data_U23; table_data_U24; table_data_U10; ];
Array column_data_U24 table [ column_bits_U24; column_blanks_U23; ts_array_U494; TABLE_NOVALUE; ts_array_U495; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array bc_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U130; ];
Array ts_array_U494 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2141; ];
Array bc_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U131; ];
Array ts_array_U495 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2142; ];
Array column_data_U25 table [ column_bits_U25; column_blanks_U24; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U8 table [ column_data_U22; column_data_U23; column_data_U24; column_data_U25; ];
Array column_data_U26 table [ column_bits_U26; column_blanks_U25; bc_U376; ts_array_U496; bc_U377; bc_U378; bc_U379; bc_U380; bc_U381; bc_U382; ];
Array bc_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U132; ];
Array ts_array_U496 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2143; ];
Array bc_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U133; ];
Array bc_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U134; ];
Array bc_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U135; ];
Array bc_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U136; ];
Array bc_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U137; ];
Array bc_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U138; ];
Array column_data_U27 table [ column_bits_U27; column_blanks_U26; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; table_data_U11; table_data_U12; ];
Array column_data_U28 table [ column_bits_U28; column_blanks_U27; bc_U383; ts_array_U497; ts_array_U498; ts_array_U499; ts_array_U500; ts_array_U501; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array bc_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U139; ];
Array ts_array_U497 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2144; ];
Array ts_array_U498 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2145; ];
Array ts_array_U499 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2146; ];
Array ts_array_U500 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2147; ];
Array ts_array_U501 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2148; ];
Array column_data_U29 table [ column_bits_U29; column_blanks_U28; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U9 table [ column_data_U26; column_data_U27; column_data_U28; column_data_U29; ];
Array column_data_U30 table [ column_bits_U30; column_blanks_U29; ts_array_U502; ts_array_U503; ];
Array ts_array_U502 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2149; ];
Array ts_array_U503 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2150; ];
Array column_data_U31 table [ column_bits_U31; column_blanks_U30; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U32 table [ column_bits_U32; column_blanks_U31; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U33 table [ column_bits_U33; column_blanks_U32; call_U2137; call_U2136; ];
Array table_data_U10 table [ column_data_U30; column_data_U31; column_data_U32; column_data_U33; ];
Array column_data_U34 table [ column_bits_U34; column_blanks_U33; bc_U384; bc_U385; bc_U386; bc_U387; ];
Array bc_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U140; ];
Array bc_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U141; ];
Array bc_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U142; ];
Array bc_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U143; ];
Array column_data_U35 table [ column_bits_U35; column_blanks_U34; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U36 table [ column_bits_U36; column_blanks_U35; bc_U388; bc_U389; bc_U390; bc_U391; ];
Array bc_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U144; ];
Array bc_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U145; ];
Array bc_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U146; ];
Array bc_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U147; ];
Array column_data_U37 table [ column_bits_U37; column_blanks_U36; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U11 table [ column_data_U34; column_data_U35; column_data_U36; column_data_U37; ];
Array column_data_U38 table [ column_bits_U38; column_blanks_U37; bc_U392; bc_U393; bc_U394; bc_U395; ];
Array bc_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U148; ];
Array bc_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U149; ];
Array bc_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U150; ];
Array bc_U395 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U151; ];
Array column_data_U39 table [ column_bits_U39; column_blanks_U38; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U40 table [ column_bits_U40; column_blanks_U39; ts_array_U504; ts_array_U505; ts_array_U506; bc_U396; ];
Array ts_array_U504 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2151; ];
Array ts_array_U505 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2152; ];
Array ts_array_U506 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2153; ];
Array bc_U396 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U152; ];
Array column_data_U41 table [ column_bits_U41; column_blanks_U40; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U12 table [ column_data_U38; column_data_U39; column_data_U40; column_data_U41; ];
Array as_block_constant_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2158; ];
Array ts_array_U507 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2159; ];
Array column_data_U42 table [ column_bits_U42; column_blanks_U41; ts_array_U508; ];
Array ts_array_U508 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2160; ];
Array column_data_U43 table [ column_bits_U43; column_blanks_U42; bc_U397; ];
Array bc_U397 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U44 table [ column_bits_U44; column_blanks_U43; ts_array_U509; ];
Array ts_array_U509 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2161; ];
Array table_data_U13 table [ column_data_U42; column_data_U43; column_data_U44; ];
Array bc_U398 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U153; ];
Array ts_array_U510 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2241; ];
Array bc_U399 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U400 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U401 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U58 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U402 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U154; ];
Array bc_U403 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U155; ];
Array bc_U404 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U405 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U406 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U407 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U59 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U408 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U156; ];
Array bc_U409 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U410 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U411 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U157; ];
Array bc_U412 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U413 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U60 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U511 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2242; ];
Array bc_U414 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U415 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U416 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U417 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U418 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U61 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U419 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U158; ];
Array bc_U420 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U159; ];
Array bc_U421 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U422 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U160; ];
Array bc_U423 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U424 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U62 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U425 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U161; ];
Array bc_U426 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U427 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U428 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U162; ];
Array bc_U429 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U430 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U63 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U431 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U163; ];
Array bc_U432 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U164; ];
Array bc_U433 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U165; ];
Array bc_U434 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U435 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U166; ];
Array bc_U436 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U64 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U437 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U167; ];
Array ts_array_U512 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2243; ];
Array bc_U438 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U439 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U168; ];
Array bc_U440 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U441 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U65 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U442 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U169; ];
Array ts_array_U513 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2244; ];
Array bc_U443 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U444 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U170; ];
Array bc_U445 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U446 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U66 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U447 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U171; ];
Array ts_array_U514 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2245; ];
Array bc_U448 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U449 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U172; ];
Array bc_U450 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U451 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U67 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U452 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U173; ];
Array bc_U453 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U174; ];
Array bc_U454 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U455 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U175; ];
Array bc_U456 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U457 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U68 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U458 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U176; ];
Array ts_array_U515 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2246; ];
Array bc_U459 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U460 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U177; ];
Array bc_U461 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U462 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U69 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U463 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U178; ];
Array bc_U464 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U465 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U466 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U179; ];
Array bc_U467 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U468 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U70 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U469 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U180; ];
Array bc_U470 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U471 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U472 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U181; ];
Array bc_U473 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U474 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U71 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U475 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U182; ];
Array ts_array_U516 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2247; ];
Array bc_U476 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U477 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U183; ];
Array bc_U478 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U479 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U72 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U480 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U184; ];
Array ts_array_U517 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2248; ];
Array bc_U481 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U482 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U185; ];
Array bc_U483 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U484 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U73 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U485 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U186; ];
Array ts_array_U518 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2249; ];
Array bc_U486 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U487 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U187; ];
Array bc_U488 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U489 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U74 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U490 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U188; ];
Array ts_array_U519 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2250; ];
Array bc_U491 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U492 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U189; ];
Array bc_U493 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U494 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U75 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U495 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U190; ];
Array ts_array_U520 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2251; ];
Array bc_U496 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U497 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U191; ];
Array bc_U498 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U499 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U500 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U192; ];
Array ts_array_U521 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2252; ];
Array bc_U501 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U502 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U503 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U504 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U193; ];
Array ts_array_U522 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2254; ];
Array bc_U505 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U506 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U507 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U508 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U194; ];
Array ts_array_U523 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2255; ];
Array bc_U509 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U510 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U511 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U512 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U195; ];
Array ts_array_U524 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2256; ];
Array bc_U513 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U514 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U515 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U516 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U196; ];
Array ts_array_U525 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2257; ];
Array bc_U517 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U518 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U519 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U520 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U197; ];
Array ts_array_U526 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2258; ];
Array bc_U521 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U522 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U523 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U524 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U198; ];
Array ts_array_U527 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2259; ];
Array bc_U525 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U526 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U527 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U76 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U528 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U199; ];
Array bc_U529 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U200; ];
Array bc_U530 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U531 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U532 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U533 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U77 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U534 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U201; ];
Array ts_array_U528 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2260; ];
Array bc_U535 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U536 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U537 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U538 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U78 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U529 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2261; ];
Array bc_U539 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U530 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2262; ];
Array bc_U540 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U202; ];
Array bc_U541 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U542 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U79 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U543 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U203; ];
Array bc_U544 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U204; ];
Array bc_U545 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U546 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U205; ];
Array bc_U547 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U548 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U80 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U531 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2263; ];
Array bc_U549 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U532 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2264; ];
Array bc_U550 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U206; ];
Array bc_U551 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U552 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U81 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U553 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U207; ];
Array bc_U554 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U555 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U556 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U208; ];
Array bc_U557 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U558 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U82 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U533 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2265; ];
Array bc_U559 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U534 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2266; ];
Array bc_U560 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U209; ];
Array bc_U561 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U562 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U83 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U563 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U210; ];
Array ts_array_U535 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2267; ];
Array bc_U564 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U565 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U211; ];
Array bc_U566 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U567 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U84 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U536 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2268; ];
Array bc_U568 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U537 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2269; ];
Array bc_U569 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U212; ];
Array bc_U570 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U571 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U85 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U572 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U213; ];
Array bc_U573 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U214; ];
Array bc_U574 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U575 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U215; ];
Array bc_U576 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U577 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U86 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U538 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2270; ];
Array bc_U578 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U539 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2271; ];
Array bc_U579 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U216; ];
Array bc_U580 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U581 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U87 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U582 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U217; ];
Array bc_U583 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U218; ];
Array bc_U584 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U585 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U219; ];
Array bc_U586 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U587 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U88 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U540 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2272; ];
Array bc_U588 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U541 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2273; ];
Array bc_U589 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U220; ];
Array bc_U590 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U591 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U89 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U592 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U221; ];
Array bc_U593 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U222; ];
Array bc_U594 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U595 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U223; ];
Array bc_U596 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U597 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U90 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U542 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2274; ];
Array bc_U598 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U543 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2275; ];
Array bc_U599 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U224; ];
Array bc_U600 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U601 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U91 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U602 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U225; ];
Array bc_U603 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U604 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U605 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U226; ];
Array bc_U606 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U607 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U92 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U544 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2276; ];
Array bc_U608 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U545 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2277; ];
Array bc_U609 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U227; ];
Array bc_U610 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U611 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U93 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U612 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U228; ];
Array bc_U613 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U614 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U615 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U229; ];
Array bc_U616 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U617 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U94 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U546 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2278; ];
Array bc_U618 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U547 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2279; ];
Array bc_U619 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U230; ];
Array bc_U620 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U621 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U95 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U622 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U231; ];
Array bc_U623 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U232; ];
Array bc_U624 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U625 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U233; ];
Array bc_U626 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U627 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U96 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U628 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U234; ];
Array bc_U629 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U630 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U631 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U632 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U633 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U97 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U634 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U235; ];
Array bc_U635 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U636 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U637 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U638 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U639 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U98 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U640 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U236; ];
Array bc_U641 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U642 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U643 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U644 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U645 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U99 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U646 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U237; ];
Array bc_U647 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U648 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U649 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U650 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U651 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U100 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U652 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U238; ];
Array bc_U653 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U654 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U655 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U656 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U657 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U101 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U658 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U239; ];
Array ts_array_U548 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2280; ];
Array bc_U659 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U660 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U661 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U662 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U102 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U663 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U240; ];
Array bc_U664 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U665 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U666 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U667 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U668 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U669 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U241; ];
Array bc_U670 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U242; ];
Array bc_U671 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U672 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U673 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U674 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U243; ];
Array ts_array_U549 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2281; ];
Array bc_U675 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U676 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U677 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U678 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U244; ];
Array ts_array_U550 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2282; ];
Array bc_U679 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U680 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U681 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U103 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U682 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U245; ];
Array bc_U683 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U684 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U685 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U246; ];
Array bc_U686 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U687 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U104 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U688 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U247; ];
Array bc_U689 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U690 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U691 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U692 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U693 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U105 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U694 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U248; ];
Array bc_U695 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U696 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U697 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U698 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U699 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U106 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U700 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U249; ];
Array ts_array_U551 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2283; ];
Array bc_U701 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U702 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U250; ];
Array bc_U703 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U704 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U107 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U705 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U251; ];
Array ts_array_U552 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2284; ];
Array bc_U706 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U707 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U708 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U709 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U108 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U710 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U252; ];
Array bc_U711 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U253; ];
Array bc_U712 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U713 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U714 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U715 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U109 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U716 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U254; ];
Array bc_U717 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U255; ];
Array bc_U718 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U719 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U720 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U721 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U110 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U722 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U256; ];
Array bc_U723 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U724 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U725 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U257; ];
Array bc_U726 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U727 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U111 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U728 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U258; ];
Array bc_U729 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U259; ];
Array bc_U730 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U260; ];
Array bc_U731 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U732 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U733 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U734 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U112 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U735 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U261; ];
Array bc_U736 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U262; ];
Array bc_U737 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U738 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U739 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U740 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U113 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U741 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U263; ];
Array bc_U742 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U743 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U744 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U264; ];
Array bc_U745 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U746 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U114 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U747 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U265; ];
Array bc_U748 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U266; ];
Array bc_U749 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U750 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U267; ];
Array bc_U751 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U752 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U115 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U753 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U268; ];
Array ts_array_U553 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2286; ];
Array bc_U754 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U755 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U756 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U757 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U116 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U758 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U269; ];
Array bc_U759 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U760 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U761 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U270; ];
Array bc_U762 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U763 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U117 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U764 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U271; ];
Array ts_array_U554 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2287; ];
Array bc_U765 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U766 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U767 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U768 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U769 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U272; ];
Array ts_array_U555 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2288; ];
Array bc_U770 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U771 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U772 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U773 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U273; ];
Array ts_array_U556 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2289; ];
Array bc_U774 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U775 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U776 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U777 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U274; ];
Array bc_U778 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U275; ];
Array bc_U779 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U780 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U781 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U782 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U276; ];
Array bc_U783 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U277; ];
Array bc_U784 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U785 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U786 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U787 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U278; ];
Array ts_array_U557 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2290; ];
Array bc_U788 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U789 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U790 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U791 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U279; ];
Array bc_U792 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U280; ];
Array bc_U793 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U794 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U795 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U796 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U281; ];
Array ts_array_U558 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2291; ];
Array bc_U797 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U798 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U799 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U118 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U800 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U282; ];
Array ts_array_U559 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2292; ];
Array bc_U801 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U802 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U803 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U804 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U119 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U805 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U283; ];
Array ts_array_U560 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2293; ];
Array bc_U806 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U807 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U284; ];
Array bc_U808 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U809 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U120 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U810 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U285; ];
Array bc_U811 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U812 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U813 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U286; ];
Array bc_U814 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U815 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U121 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U816 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U287; ];
Array bc_U817 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U288; ];
Array bc_U818 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U819 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U289; ];
Array bc_U820 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U821 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U122 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U822 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U290; ];
Array bc_U823 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U291; ];
Array bc_U824 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U825 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U292; ];
Array bc_U826 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U827 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U123 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U828 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U293; ];
Array bc_U829 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U294; ];
Array bc_U830 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U831 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U295; ];
Array bc_U832 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U833 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U124 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U834 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U296; ];
Array bc_U835 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U297; ];
Array bc_U836 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U837 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U298; ];
Array bc_U838 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U839 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U125 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U840 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U299; ];
Array ts_array_U561 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2294; ];
Array bc_U841 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U842 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U843 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U844 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U126 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U845 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U300; ];
Array bc_U846 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U301; ];
Array bc_U847 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U302; ];
Array bc_U848 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U849 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U850 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U851 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U127 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U852 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U303; ];
Array ts_array_U562 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2295; ];
Array bc_U853 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U854 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U855 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U856 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U128 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U857 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U304; ];
Array bc_U858 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U305; ];
Array bc_U859 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U860 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U306; ];
Array bc_U861 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U862 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U129 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U863 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U307; ];
Array bc_U864 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U308; ];
Array bc_U865 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U309; ];
Array bc_U866 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U867 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U868 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U869 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U130 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U870 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U310; ];
Array bc_U871 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U311; ];
Array bc_U872 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U873 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U874 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U875 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U131 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U876 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U312; ];
Array bc_U877 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U313; ];
Array bc_U878 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U879 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U880 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U881 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U132 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U882 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U314; ];
Array bc_U883 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U315; ];
Array bc_U884 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U316; ];
Array bc_U885 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U886 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U887 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U888 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U133 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U889 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U317; ];
Array bc_U890 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U318; ];
Array bc_U891 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U892 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U893 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U894 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U895 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U319; ];
Array bc_U896 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U320; ];
Array ts_array_U563 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2296; ];
Array bc_U897 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U898 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U899 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U321; ];
Array bc_U900 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U322; ];
Array ts_array_U564 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2297; ];
Array bc_U901 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U902 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U903 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U323; ];
Array bc_U904 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U324; ];
Array ts_array_U565 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2298; ];
Array bc_U905 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U906 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U134 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U907 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U325; ];
Array bc_U908 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U326; ];
Array bc_U909 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U910 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U911 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U912 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U135 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U913 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U327; ];
Array bc_U914 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U328; ];
Array bc_U915 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U916 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U917 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U918 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U136 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U919 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U329; ];
Array ts_array_U566 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2300; ];
Array bc_U920 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U921 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U922 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U923 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U137 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U924 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U330; ];
Array ts_array_U567 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2301; ];
Array bc_U925 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U926 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U927 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U928 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U138 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U929 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U331; ];
Array ts_array_U568 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2302; ];
Array bc_U930 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U931 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U932 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U933 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U139 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U934 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U332; ];
Array ts_array_U569 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2303; ];
Array bc_U935 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U936 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U937 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U938 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U140 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U939 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U333; ];
Array ts_array_U570 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2304; ];
Array bc_U940 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U941 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U942 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U943 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U141 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U944 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U334; ];
Array ts_array_U571 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2305; ];
Array bc_U945 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U946 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U947 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U948 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U142 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U949 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U335; ];
Array bc_U950 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U336; ];
Array bc_U951 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U952 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U953 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U954 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U143 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U955 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U337; ];
Array bc_U956 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U338; ];
Array bc_U957 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U958 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U959 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U960 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U144 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U961 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U339; ];
Array ts_array_U572 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2306; ];
Array bc_U962 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U963 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U964 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U965 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U145 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U966 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U340; ];
Array ts_array_U573 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2307; ];
Array bc_U967 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U968 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U969 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U970 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U146 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U971 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U341; ];
Array bc_U972 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U342; ];
Array bc_U973 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U974 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U343; ];
Array bc_U975 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U976 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U147 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U977 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U344; ];
Array bc_U978 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U345; ];
Array bc_U979 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U980 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U981 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U982 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U148 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U983 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U346; ];
Array bc_U984 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U985 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U986 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U987 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U988 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U149 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U989 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U347; ];
Array bc_U990 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U348; ];
Array bc_U991 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U992 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U993 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U994 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U150 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U995 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U349; ];
Array bc_U996 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U350; ];
Array bc_U997 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U998 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U351; ];
Array bc_U999 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1000 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U151 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1001 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U352; ];
Array bc_U1002 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U353; ];
Array bc_U1003 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1004 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1005 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1006 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U152 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1007 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U354; ];
Array bc_U1008 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U355; ];
Array bc_U1009 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1010 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1011 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1012 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U153 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1013 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U356; ];
Array bc_U1014 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U357; ];
Array bc_U1015 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1016 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1017 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1018 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U154 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1019 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U358; ];
Array bc_U1020 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1021 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1022 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U359; ];
Array bc_U1023 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1024 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U155 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1025 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U360; ];
Array bc_U1026 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1027 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1028 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U361; ];
Array bc_U1029 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1030 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U156 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1031 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U362; ];
Array bc_U1032 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1033 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1034 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U363; ];
Array bc_U1035 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1036 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U157 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1037 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U364; ];
Array bc_U1038 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1039 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1040 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1041 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1042 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1043 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U365; ];
Array ts_array_U574 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2309; ];
Array bc_U1044 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1045 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1046 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U158 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1047 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U366; ];
Array bc_U1048 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U367; ];
Array bc_U1049 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1050 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1051 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1052 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U159 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1053 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U368; ];
Array bc_U1054 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U369; ];
Array bc_U1055 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1056 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U370; ];
Array bc_U1057 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1058 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U160 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1059 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U371; ];
Array bc_U1060 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U372; ];
Array bc_U1061 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1062 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U373; ];
Array bc_U1063 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1064 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U161 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1065 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U374; ];
Array bc_U1066 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U375; ];
Array bc_U1067 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1068 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1069 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1070 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U162 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1071 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U376; ];
Array bc_U1072 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U377; ];
Array bc_U1073 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1074 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1075 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1076 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U163 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1077 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U378; ];
Array bc_U1078 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1079 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1080 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U379; ];
Array bc_U1081 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1082 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U164 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1083 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U380; ];
Array bc_U1084 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U381; ];
Array bc_U1085 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1086 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U382; ];
Array bc_U1087 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1088 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U165 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1089 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U383; ];
Array bc_U1090 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U384; ];
Array bc_U1091 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1092 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U385; ];
Array bc_U1093 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1094 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1095 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U166 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1096 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U386; ];
Array bc_U1097 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1098 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1099 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U387; ];
Array bc_U1100 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1101 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U167 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1102 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U388; ];
Array bc_U1103 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1104 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1105 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U389; ];
Array bc_U1106 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1107 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U168 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1108 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U390; ];
Array bc_U1109 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U391; ];
Array bc_U1110 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U392; ];
Array bc_U1111 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1112 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1113 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U169 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1114 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U393; ];
Array bc_U1115 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U394; ];
Array bc_U1116 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1117 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U395; ];
Array bc_U1118 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1119 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U170 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1120 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U396; ];
Array bc_U1121 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1122 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1123 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U397; ];
Array bc_U1124 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1125 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1126 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U398; ];
Array ts_array_U575 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2312; ];
Array bc_U1127 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1128 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1129 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U171 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1130 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U399; ];
Array bc_U1131 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1132 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1133 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U400; ];
Array bc_U1134 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1135 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1136 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U401; ];
Array bc_U1137 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U402; ];
Array bc_U1138 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1139 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1140 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U172 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1141 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U403; ];
Array bc_U1142 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1143 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1144 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1145 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1146 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U173 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1147 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U404; ];
Array bc_U1148 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1149 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1150 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1151 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1152 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U174 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1153 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U405; ];
Array bc_U1154 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1155 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1156 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U406; ];
Array bc_U1157 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1158 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U175 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1159 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U407; ];
Array ts_array_U576 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2313; ];
Array bc_U1160 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1161 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U408; ];
Array bc_U1162 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1163 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1164 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U409; ];
Array bc_U1165 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U410; ];
Array bc_U1166 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1167 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1168 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U176 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1169 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U411; ];
Array bc_U1170 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U412; ];
Array bc_U1171 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1172 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1173 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1174 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U177 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1175 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U413; ];
Array bc_U1176 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U414; ];
Array bc_U1177 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1178 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1179 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1180 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U178 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1181 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U415; ];
Array bc_U1182 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U416; ];
Array bc_U1183 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1184 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1185 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1186 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U179 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1187 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U417; ];
Array bc_U1188 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1189 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1190 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1191 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1192 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U180 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1193 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U418; ];
Array bc_U1194 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1195 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1196 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1197 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1198 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U181 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1199 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U419; ];
Array ts_array_U577 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2314; ];
Array bc_U1200 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1201 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1202 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1203 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U182 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1204 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U420; ];
Array bc_U1205 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U421; ];
Array bc_U1206 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1207 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1208 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1209 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U183 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1210 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U422; ];
Array ts_array_U578 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2315; ];
Array bc_U1211 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1212 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1213 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1214 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U184 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1215 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U423; ];
Array ts_array_U579 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2316; ];
Array bc_U1216 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1217 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1218 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1219 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U185 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1220 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U424; ];
Array ts_array_U580 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2317; ];
Array bc_U1221 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1222 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1223 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1224 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U186 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1225 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U425; ];
Array bc_U1226 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1227 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1228 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U426; ];
Array bc_U1229 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1230 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U187 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1231 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U427; ];
Array ts_array_U581 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2318; ];
Array bc_U1232 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1233 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1234 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1235 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U188 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1236 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U428; ];
Array ts_array_U582 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2319; ];
Array bc_U1237 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1238 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U429; ];
Array bc_U1239 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1240 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U189 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1241 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U430; ];
Array bc_U1242 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1243 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1244 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U431; ];
Array bc_U1245 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1246 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U190 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1247 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U432; ];
Array ts_array_U583 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2320; ];
Array bc_U1248 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1249 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U433; ];
Array bc_U1250 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1251 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U191 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1252 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U434; ];
Array bc_U1253 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U435; ];
Array bc_U1254 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U436; ];
Array bc_U1255 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1256 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1257 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1258 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U192 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1259 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U437; ];
Array bc_U1260 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U438; ];
Array bc_U1261 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1262 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1263 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1264 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U193 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1265 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U439; ];
Array bc_U1266 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U440; ];
Array bc_U1267 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1268 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1269 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1270 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U194 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1271 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U441; ];
Array bc_U1272 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U442; ];
Array bc_U1273 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1274 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1275 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1276 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U195 --> [ I_maintenance_office_U1; I_stocks_room_U1; ];
Array inline_U196 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U584 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2321; ];
Array ts_array_U585 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2322; ];
Array ts_array_U586 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2323; ];
Array bc_U1277 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U443; ];
Array bc_U1278 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1279 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1280 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U444; ];
Array ts_array_U587 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2324; ];
Array bc_U1281 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1282 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1283 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U197 --> [ I_maintenance_office_U1; I_dark_hallway_U1; ];
Array inline_U198 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1284 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U445; ];
Array ts_array_U588 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2325; ];
Array ts_array_U589 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2326; ];
Array bc_U1285 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U446; ];
Array bc_U1286 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1287 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1288 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U447; ];
Array bc_U1289 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U448; ];
Array bc_U1290 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1291 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1292 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1293 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U449; ];
Array bc_U1294 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U450; ];
Array bc_U1295 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1296 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1297 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U199 --> [ I_crawl_space_U1; I_gallows_room_U1; ];
Array inline_U200 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U590 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2327; ];
Array ts_array_U591 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2328; ];
Array ts_array_U592 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2329; ];
Array bc_U1298 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U451; ];
Array bc_U1299 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1300 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1301 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U452; ];
Array ts_array_U593 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2330; ];
Array bc_U1302 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1303 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1304 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1305 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U453; ];
Array bc_U1306 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U454; ];
Array bc_U1307 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1308 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1309 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U201 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1310 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U455; ];
Array bc_U1311 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1312 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1313 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U456; ];
Array bc_U1314 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1315 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U202 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1316 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U457; ];
Array ts_array_U594 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2331; ];
Array bc_U1317 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1318 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1319 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1320 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U203 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1321 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U458; ];
Array bc_U1322 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U459; ];
Array bc_U1323 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1324 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1325 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1326 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1327 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U204 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1328 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U460; ];
Array bc_U1329 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U461; ];
Array bc_U1330 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1331 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1332 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1333 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1334 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U205 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1335 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U462; ];
Array bc_U1336 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1337 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1338 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1339 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1340 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U206 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1341 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U463; ];
Array bc_U1342 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1343 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1344 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1345 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1346 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U207 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1347 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U464; ];
Array bc_U1348 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1349 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1350 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1351 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1352 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U208 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1353 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U465; ];
Array bc_U1354 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1355 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1356 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1357 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1358 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U209 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1359 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U466; ];
Array bc_U1360 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U467; ];
Array bc_U1361 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1362 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1363 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1364 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U210 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1365 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U468; ];
Array bc_U1366 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1367 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1368 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1369 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1370 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U211 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1371 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U469; ];
Array bc_U1372 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1373 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1374 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1375 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1376 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U212 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1377 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U470; ];
Array bc_U1378 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U471; ];
Array bc_U1379 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1380 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1381 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1382 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1383 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U213 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1384 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U472; ];
Array bc_U1385 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1386 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1387 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1388 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1389 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U214 --> [ I_mechanical_room_north_U1; I_stake_room_U1; ];
Array inline_U215 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U595 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2332; ];
Array ts_array_U596 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2333; ];
Array ts_array_U597 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2334; ];
Array bc_U1390 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U473; ];
Array bc_U1391 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1392 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1393 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U474; ];
Array ts_array_U598 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2335; ];
Array bc_U1394 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1395 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1396 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1397 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U475; ];
Array bc_U1398 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U476; ];
Array bc_U1399 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1400 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1401 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U216 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1402 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U477; ];
Array bc_U1403 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1404 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1405 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1406 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1407 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U217 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1408 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U478; ];
Array bc_U1409 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1410 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1411 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1412 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1413 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U218 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1414 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U479; ];
Array bc_U1415 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1416 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1417 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1418 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1419 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U219 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1420 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U480; ];
Array bc_U1421 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1422 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1423 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1424 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1425 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U220 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1426 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U481; ];
Array bc_U1427 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1428 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1429 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1430 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1431 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U221 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1432 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U482; ];
Array bc_U1433 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1434 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1435 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1436 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1437 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U222 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1438 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U483; ];
Array bc_U1439 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1440 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1441 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1442 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1443 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U223 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1444 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U484; ];
Array bc_U1445 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1446 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1447 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1448 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1449 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U224 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1450 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U485; ];
Array ts_array_U599 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2336; ];
Array ts_array_U600 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2337; ];
Array bc_U1451 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U486; ];
Array bc_U1452 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1453 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1454 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U487; ];
Array bc_U1455 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U488; ];
Array bc_U1456 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1457 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1458 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U225 --> [ I_mechanical_room_south_U1; I_dungeon_U1; ];
Array inline_U226 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U601 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2338; ];
Array ts_array_U602 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2339; ];
Array ts_array_U603 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2340; ];
Array bc_U1459 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U489; ];
Array bc_U1460 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1461 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1462 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U490; ];
Array ts_array_U604 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2341; ];
Array bc_U1463 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1464 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1465 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U227 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1466 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U491; ];
Array bc_U1467 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U492; ];
Array bc_U1468 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1469 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1470 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1471 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1472 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U228 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1473 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U493; ];
Array bc_U1474 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1475 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1476 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1477 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1478 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U229 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1479 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U494; ];
Array bc_U1480 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1481 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1482 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1483 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1484 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U230 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1485 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U495; ];
Array bc_U1486 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1487 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1488 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1489 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1490 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U231 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1491 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U496; ];
Array bc_U1492 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1493 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1494 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1495 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1496 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U232 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1497 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U497; ];
Array bc_U1498 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1499 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1500 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1501 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1502 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U233 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1503 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U498; ];
Array bc_U1504 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1505 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1506 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1507 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1508 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U234 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1509 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U499; ];
Array bc_U1510 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1511 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1512 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1513 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1514 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U235 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1515 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U500; ];
Array bc_U1516 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1517 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1518 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1519 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1520 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U236 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1521 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U501; ];
Array bc_U1522 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U502; ];
Array bc_U1523 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1524 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1525 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1526 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U237 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1527 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U503; ];
Array bc_U1528 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1529 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1530 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1531 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1532 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U238 --> [ I_generator_room_U1; I_guillotine_room_U1; ];
Array inline_U239 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U605 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2342; ];
Array ts_array_U606 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2343; ];
Array ts_array_U607 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2344; ];
Array bc_U1533 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U504; ];
Array bc_U1534 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1535 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1536 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U505; ];
Array ts_array_U608 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2345; ];
Array bc_U1537 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1538 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1539 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U240 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1540 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U506; ];
Array bc_U1541 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1542 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1543 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1544 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1545 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U241 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1546 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U507; ];
Array bc_U1547 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1548 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1549 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1550 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1551 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U242 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1552 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U508; ];
Array bc_U1553 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1554 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1555 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1556 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1557 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U243 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1558 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U509; ];
Array bc_U1559 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1560 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1561 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1562 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1563 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U244 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1564 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U510; ];
Array bc_U1565 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1566 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1567 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1568 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1569 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U245 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1570 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U511; ];
Array bc_U1571 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1572 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1573 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1574 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1575 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U246 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1576 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U512; ];
Array bc_U1577 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1578 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1579 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1580 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1581 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U247 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1582 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U513; ];
Array bc_U1583 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1584 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1585 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1586 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1587 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U248 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1588 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U514; ];
Array bc_U1589 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1590 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1591 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1592 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1593 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U249 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1594 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U515; ];
Array bc_U1595 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U516; ];
Array bc_U1596 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1597 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1598 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1599 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U250 --> [ I_storage_room_U1; I_ride_exit_U1; ];
Array inline_U251 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array ts_array_U609 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2346; ];
Array ts_array_U610 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2347; ];
Array ts_array_U611 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2348; ];
Array bc_U1600 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U517; ];
Array bc_U1601 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1602 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1603 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U518; ];
Array ts_array_U612 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2349; ];
Array bc_U1604 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1605 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1606 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1607 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U252 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1608 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U519; ];
Array bc_U1609 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U520; ];
Array bc_U1610 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1611 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U521; ];
Array bc_U1612 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1613 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U253 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1614 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U522; ];
Array bc_U1615 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U523; ];
Array bc_U1616 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U524; ];
Array bc_U1617 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1618 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1619 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1620 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U254 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1621 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U525; ];
Array bc_U1622 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U526; ];
Array bc_U1623 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U527; ];
Array bc_U1624 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1625 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1626 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1627 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U255 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1628 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U528; ];
Array bc_U1629 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U529; ];
Array bc_U1630 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1631 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1632 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1633 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U256 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1634 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U530; ];
Array bc_U1635 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U531; ];
Array bc_U1636 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1637 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1638 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1639 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U257 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1640 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U532; ];
Array bc_U1641 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1642 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1643 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1644 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1645 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U258 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1646 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U533; ];
Array bc_U1647 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U534; ];
Array bc_U1648 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U535; ];
Array bc_U1649 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1650 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1651 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1652 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U259 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1653 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U536; ];
Array bc_U1654 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U537; ];
Array bc_U1655 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U538; ];
Array bc_U1656 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1657 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1658 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1659 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U260 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1660 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U539; ];
Array bc_U1661 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U540; ];
Array bc_U1662 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1663 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1664 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1665 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1666 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U541; ];
Array ts_array_U613 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2352; ];
Array bc_U1667 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1668 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1669 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U261 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1670 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U542; ];
Array ts_array_U614 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2353; ];
Array bc_U1671 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1672 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U543; ];
Array bc_U1673 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1674 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U262 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1675 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U544; ];
Array bc_U1676 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1677 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1678 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1679 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1680 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U263 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1681 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U545; ];
Array bc_U1682 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1683 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1684 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1685 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1686 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U264 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1687 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U546; ];
Array bc_U1688 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1689 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1690 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1691 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1692 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U265 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1693 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U547; ];
Array bc_U1694 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1695 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1696 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U548; ];
Array bc_U1697 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1698 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U266 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1699 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U549; ];
Array bc_U1700 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1701 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1702 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U550; ];
Array bc_U1703 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1704 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U267 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1705 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U551; ];
Array bc_U1706 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1707 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1708 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U552; ];
Array bc_U1709 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1710 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U268 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1711 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U553; ];
Array bc_U1712 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1713 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1714 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U554; ];
Array bc_U1715 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1716 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U269 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1717 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U555; ];
Array bc_U1718 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1719 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1720 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U556; ];
Array bc_U1721 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1722 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U270 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1723 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U557; ];
Array bc_U1724 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1725 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1726 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U558; ];
Array bc_U1727 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1728 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U271 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1729 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U559; ];
Array bc_U1730 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1731 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1732 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1733 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1734 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U272 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1735 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U560; ];
Array bc_U1736 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U561; ];
Array bc_U1737 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1738 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U273 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1739 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U562; ];
Array bc_U1740 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U563; ];
Array bc_U1741 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1742 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U274 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1743 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U564; ];
Array bc_U1744 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U565; ];
Array bc_U1745 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1746 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U275 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1747 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U566; ];
Array bc_U1748 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U567; ];
Array bc_U1749 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1750 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U276 --> [ 0; 0; 0; 0; 0; 0; 0; ];
Array bc_U1751 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U568; ];
Array bc_U1752 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U569; ];
Array bc_U1753 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1754 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array Rel_Record4 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "underlying relation"; abilities_U4; A_P_underlying_relation_storag; DK8_relation_of_things; call_U2415; "Underlying relates various things to one thing"; ];
Array Rel_Record5 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "tossing relation"; abilities_U5; A_P_tossing_relation_storage; DK8_relation_of_things; call_U2419; "Tossing relates one thing to another"; ];
Array Rel_Record6 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "nearness relation"; abilities_U6; call_U2420; DK12_relation_of_rooms; call_U2422; "nearness"; ];
Array Rel_Record7 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "equality relation"; abilities_U7; 0; DK5_relation_of_values; call_U2423; "is"; ];
Array Rel_Record8 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "meaning relation"; abilities_U8; 0; DK6_relation_of_objects; call_U2424; "means"; ];
Array Rel_Record9 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "possession relation"; abilities_U9; 0; DK6_relation_of_objects; call_U2425; "has"; ];
Array Rel_Record10 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "universal relation"; abilities_U10; 0; DK6_relation_of_objects; call_U2426; "relates"; ];
Array Rel_Record11 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "provision relation"; abilities_U11; 0; DK6_relation_of_objects; call_U2427; "provides"; ];
Array Rel_Record12 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "containment relation"; abilities_U12; 0; DK6_relation_of_objects; call_U2428; "contains"; ];
Array Rel_Record13 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "support relation"; abilities_U13; 0; DK7_relation_of_supporters_t; call_U2429; "supports"; ];
Array Rel_Record14 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "incorporation relation"; abilities_U14; 0; DK8_relation_of_things; call_U2430; "incorporates"; ];
Array Rel_Record15 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "enclosure relation"; abilities_U15; 0; DK6_relation_of_objects; call_U2431; "encloses"; ];
Array Rel_Record16 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "carrying relation"; abilities_U16; 0; DK9_relation_of_people_to_th; call_U2432; "carries"; ];
Array Rel_Record17 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "holding relation"; abilities_U17; 0; DK9_relation_of_people_to_th; call_U2433; "holds"; ];
Array Rel_Record18 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "wearing relation"; abilities_U18; 0; DK9_relation_of_people_to_th; call_U2434; "wears"; ];
Array Rel_Record19 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "visibility relation"; abilities_U19; 0; DK8_relation_of_things; call_U2435; "can-see"; ];
Array Rel_Record20 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "touchability relation"; abilities_U20; 0; DK8_relation_of_things; call_U2436; "can-touch"; ];
Array Rel_Record21 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "concealment relation"; abilities_U21; 0; DK8_relation_of_things; call_U2437; "conceals"; ];
Array Rel_Record22 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "never-holding relation"; abilities_U22; 0; DK5_relation_of_values; call_U2438; "is"; ];
Array bc_U1755 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U570; ];
Array bc_U1756 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1757 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1758 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1759 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1760 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1761 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U571; ];
Array bc_U1762 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1763 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1764 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1765 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1766 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1767 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U572; ];
Array bc_U1768 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1769 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1770 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1771 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1772 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1773 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U573; ];
Array bc_U1774 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1775 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1776 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1777 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1778 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1779 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U574; ];
Array bc_U1780 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U575; ];
Array bc_U1781 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1782 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1783 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1784 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1785 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U576; ];
Array ts_array_U615 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2463; ];
Array bc_U1786 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1787 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1788 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1789 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1790 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U577; ];
Array ts_array_U616 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2465; ];
Array bc_U1791 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1792 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1793 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1794 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1795 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1796 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1797 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1798 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1799 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U617 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2475; ];
Array bc_U1800 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U578; ];
Array ts_array_U618 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2476; ];
Array bc_U1801 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1802 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1803 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U619 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2478; ];
Array bc_U1804 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U579; ];
Array ts_array_U620 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2479; ];
Array bc_U1805 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1806 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1807 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U621 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2481; ];
Array bc_U1808 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U580; ];
Array ts_array_U622 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2482; ];
Array bc_U1809 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1810 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1811 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U623 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2485; ];
Array bc_U1812 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U581; ];
Array ts_array_U624 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2486; ];
Array bc_U1813 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1814 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1815 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1816 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U582; ];
Array ts_array_U625 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2488; ];
Array bc_U1817 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1818 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1819 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1820 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1821 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U583; ];
Array bc_U1822 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1823 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1824 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1825 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1826 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1827 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U584; ];
Array bc_U1828 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1829 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1830 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1831 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1832 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U626 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2497; ];
Array bc_U1833 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U585; ];
Array ts_array_U627 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2498; ];
Array ts_array_U628 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2499; ];
Array bc_U1834 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1835 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1836 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U586; ];
Array bc_U1837 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1838 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1839 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1840 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1841 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U629 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2503; ];
Array bc_U1842 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U587; ];
Array ts_array_U630 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2504; ];
Array bc_U1843 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1844 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1845 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U631 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2507; ];
Array bc_U1846 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U588; ];
Array ts_array_U632 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2508; ];
Array bc_U1847 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1848 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1849 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U633 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2510; ];
Array bc_U1850 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U589; ];
Array ts_array_U634 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2511; ];
Array bc_U1851 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1852 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1853 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK1_rule --> [ RULE_TY; 2; ACTION_NAME_TY; VOID_TY; ];
Array DK2_activity_on_objects --> [ ACTIVITY_TY; 1; OBJECT_TY; ];
Array DK3_phrase_real_number____re --> [ PHRASE_TY; 2; REAL_NUMBER_TY; ];
Array DK4_phrase_real_number____nu --> [ PHRASE_TY; 2; NUMBER_TY; ];
Array DK5_relation_of_values --> [ RELATION_TY; 2; VALUE_TY; VALUE_TY; ];
Array DK6_relation_of_objects --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK7_relation_of_supporters_t --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK8_relation_of_things --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK9_relation_of_people_to_th --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK12_relation_of_rooms --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array label_associated_storage_U1863 --> [ 0; 0; 0; ];
Array label_associated_storage_U1864 --> [ 0; 0; 0; ];
Array label_associated_storage_U1867 --> [ 0; 0; 0; ];
Array label_associated_storage_U1868 --> [ 0; 0; 0; ];
Array label_associated_storage_U1875 --> [ 0; 0; ];
Array label_associated_storage_U1876 --> [ 0; 0; ];
Array bc_U1854 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U590; ];
Array label_associated_storage_U1897 --> [ 0; 0; ];
Array label_associated_storage_U1898 --> [ 0; 0; ];
Array bc_U1855 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U591; ];
Array bc_U1856 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U592; ];
Array ts_array_U635 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2624; ];
Array bc_U1857 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U593; ];
Array bc_U1858 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U594; ];
Array bc_U1859 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U595; ];
Array label_associated_storage_U2019 --> [ 0; 0; ];
Array label_associated_storage_U2020 --> [ 0; 0; ];
Array ts_array_U636 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2746; ];
Array bc_U1860 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U596; ];
Array bc_U1861 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U597; ];
Array column_data_U45 table [ column_bits_U45; column_blanks_U44; bc_U1862; bc_U1863; bc_U1864; bc_U1865; ];
Array bc_U1862 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U598; ];
Array bc_U1863 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U599; ];
Array bc_U1864 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U600; ];
Array bc_U1865 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U601; ];
Array column_data_U46 table [ column_bits_U46; NULL; I_teddy_bear_U1; I_swiss_army_knife_U1; I_poster_of_taylor_swift_U1; I_fuse13_U1; ];
Array column_data_U47 table [ column_bits_U47; column_blanks_U45; bc_U1866; bc_U1867; bc_U1868; bc_U1869; ];
Array bc_U1866 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U602; ];
Array bc_U1867 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U603; ];
Array bc_U1868 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U604; ];
Array bc_U1869 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U605; ];
Array table_data_U14 table [ column_data_U45; column_data_U46; column_data_U47; ];
Array column_data_U48 table [ column_bits_U48; column_blanks_U46; bc_U1870; bc_U1871; bc_U1872; bc_U1873; bc_U1874; ];
Array bc_U1870 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U606; ];
Array bc_U1871 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U607; ];
Array bc_U1872 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U608; ];
Array bc_U1873 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U609; ];
Array bc_U1874 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U610; ];
Array column_data_U49 table [ column_bits_U49; NULL; I_hell_ride_ticket_U1; I_fortune_teller_ticket_U1; I_ferris_wheel_ticket_U1; I_bumper_cars_ticket_U1; I_carousel_ticket_U1; ];
Array column_data_U50 table [ column_bits_U50; column_blanks_U47; 300; 300; 200; 200; 100; ];
Array table_data_U15 table [ column_data_U48; column_data_U49; column_data_U50; ];
Array column_data_U51 table [ column_bits_U51; column_blanks_U48; bc_U1875; bc_U1876; bc_U1877; bc_U1878; ts_array_U637; bc_U1879; ];
Array bc_U1875 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U611; ];
Array bc_U1876 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U612; ];
Array bc_U1877 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U613; ];
Array bc_U1878 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U614; ];
Array ts_array_U637 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2754; ];
Array bc_U1879 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U615; ];
Array table_data_U16 table [ column_data_U51; ];
Array column_data_U52 table [ column_bits_U52; NULL; I_ride_entrance_U1; I_stocks_room_U1; I_gallows_room_U1; I_stake_room_U1; I_dungeon_U1; I_guillotine_room_U1; I_ride_exit_U1; ];
Array column_data_U53 table [ column_bits_U53; column_blanks_U49; bc_U1880; bc_U1881; bc_U1882; bc_U1883; bc_U1884; bc_U1885; bc_U1886; ];
Array bc_U1880 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U616; ];
Array bc_U1881 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U617; ];
Array bc_U1882 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U618; ];
Array bc_U1883 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U619; ];
Array bc_U1884 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U620; ];
Array bc_U1885 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U621; ];
Array bc_U1886 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U622; ];
Array column_data_U54 table [ column_bits_U54; NULL; I_figure_of_hell_ride_U1; I_figure_of_ridestocks_U1; I_figure_of_ridegallows_U1; I_figure_of_ridestake_U1; I_figure_of_ridedungeon_U1; I_figure_of_rideguillotine_U1; I_figure_of_rideexit_U1; ];
Array column_data_U55 table [ column_bits_U55; column_blanks_U50; bc_U1887; bc_U1888; bc_U1889; bc_U1890; ts_array_U638; ts_array_U639; ts_array_U640; ];
Array bc_U1887 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U623; ];
Array bc_U1888 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U624; ];
Array bc_U1889 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U625; ];
Array bc_U1890 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U626; ];
Array ts_array_U638 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2755; ];
Array ts_array_U639 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2756; ];
Array ts_array_U640 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2757; ];
Array table_data_U17 table [ column_data_U52; column_data_U53; column_data_U54; column_data_U55; ];
Array column_data_U56 table [ column_bits_U56; column_blanks_U51; bc_U1891; ts_array_U641; bc_U1892; bc_U1893; ];
Array bc_U1891 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U627; ];
Array ts_array_U641 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2758; ];
Array bc_U1892 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U628; ];
Array bc_U1893 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U629; ];
Array column_data_U57 table [ column_bits_U57; column_blanks_U52; table_data_U32; table_data_U33; table_data_U34; table_data_U35; ];
Array column_data_U58 table [ column_bits_U58; column_blanks_U53; bc_U1894; bc_U1895; bc_U1896; bc_U1897; ];
Array bc_U1894 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1895 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1896 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1897 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U59 table [ column_bits_U59; column_blanks_U54; call_U2121; call_U2121; call_U2121; call_U2121; ];
Array table_data_U18 table [ column_data_U56; column_data_U57; column_data_U58; column_data_U59; ];
Array column_data_U60 table [ column_bits_U60; column_blanks_U55; bc_U1898; bc_U1899; bc_U1900; ];
Array bc_U1898 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U630; ];
Array bc_U1899 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U631; ];
Array bc_U1900 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U632; ];
Array column_data_U61 table [ column_bits_U61; column_blanks_U56; table_data_U36; table_data_U37; table_data_U38; ];
Array column_data_U62 table [ column_bits_U62; column_blanks_U57; bc_U1901; bc_U1902; bc_U1903; ];
Array bc_U1901 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1902 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1903 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U63 table [ column_bits_U63; column_blanks_U58; call_U2121; call_U2121; call_U2121; ];
Array table_data_U19 table [ column_data_U60; column_data_U61; column_data_U62; column_data_U63; ];
Array column_data_U64 table [ column_bits_U64; column_blanks_U59; bc_U1904; bc_U1905; ts_array_U642; ];
Array bc_U1904 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U633; ];
Array bc_U1905 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U634; ];
Array ts_array_U642 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2759; ];
Array column_data_U65 table [ column_bits_U65; column_blanks_U60; table_data_U39; table_data_U40; table_data_U41; ];
Array column_data_U66 table [ column_bits_U66; column_blanks_U61; bc_U1906; bc_U1907; bc_U1908; ];
Array bc_U1906 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1907 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1908 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U67 table [ column_bits_U67; column_blanks_U62; call_U2121; call_U2121; call_U2121; ];
Array table_data_U20 table [ column_data_U64; column_data_U65; column_data_U66; column_data_U67; ];
Array column_data_U68 table [ column_bits_U68; column_blanks_U63; bc_U1909; bc_U1910; ];
Array bc_U1909 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U635; ];
Array bc_U1910 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U636; ];
Array column_data_U69 table [ column_bits_U69; column_blanks_U64; table_data_U42; table_data_U43; ];
Array column_data_U70 table [ column_bits_U70; column_blanks_U65; bc_U1911; bc_U1912; ];
Array bc_U1911 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1912 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U71 table [ column_bits_U71; column_blanks_U66; call_U2121; call_U2121; ];
Array table_data_U21 table [ column_data_U68; column_data_U69; column_data_U70; column_data_U71; ];
Array column_data_U72 table [ column_bits_U72; column_blanks_U67; bc_U1913; bc_U1914; ];
Array bc_U1913 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U637; ];
Array bc_U1914 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U638; ];
Array column_data_U73 table [ column_bits_U73; column_blanks_U68; table_data_U44; table_data_U45; ];
Array column_data_U74 table [ column_bits_U74; column_blanks_U69; bc_U1915; bc_U1916; ];
Array bc_U1915 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1916 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U75 table [ column_bits_U75; column_blanks_U70; call_U2121; call_U2121; ];
Array table_data_U22 table [ column_data_U72; column_data_U73; column_data_U74; column_data_U75; ];
Array column_data_U76 table [ column_bits_U76; column_blanks_U71; ts_array_U643; bc_U1917; bc_U1918; ];
Array ts_array_U643 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2760; ];
Array bc_U1917 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U639; ];
Array bc_U1918 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U640; ];
Array column_data_U77 table [ column_bits_U77; column_blanks_U72; table_data_U46; table_data_U47; table_data_U48; ];
Array column_data_U78 table [ column_bits_U78; column_blanks_U73; bc_U1919; bc_U1920; bc_U1921; ];
Array bc_U1919 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1920 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1921 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U79 table [ column_bits_U79; column_blanks_U74; call_U2121; call_U2121; call_U2121; ];
Array table_data_U23 table [ column_data_U76; column_data_U77; column_data_U78; column_data_U79; ];
Array column_data_U80 table [ column_bits_U80; column_blanks_U75; bc_U1922; bc_U1923; ];
Array bc_U1922 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U641; ];
Array bc_U1923 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U642; ];
Array column_data_U81 table [ column_bits_U81; column_blanks_U76; table_data_U49; table_data_U50; ];
Array column_data_U82 table [ column_bits_U82; column_blanks_U77; bc_U1924; bc_U1925; ];
Array bc_U1924 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U1925 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U83 table [ column_bits_U83; column_blanks_U78; call_U2121; call_U2121; ];
Array table_data_U24 table [ column_data_U80; column_data_U81; column_data_U82; column_data_U83; ];
Array column_data_U84 table [ column_bits_U84; column_blanks_U79; ts_array_U644; ts_array_U645; ts_array_U646; ts_array_U647; ts_array_U648; ts_array_U649; ts_array_U650; ts_array_U651; ts_array_U652; ts_array_U653; ts_array_U654; ts_array_U655; ts_array_U656; ts_array_U657; ts_array_U658; ts_array_U659; ts_array_U660; ts_array_U661; ts_array_U662; ts_array_U663; ts_array_U664; ts_array_U665; ts_array_U666; ts_array_U667; ts_array_U668; ts_array_U669; ts_array_U670; ts_array_U671; ts_array_U672; ts_array_U673; ts_array_U674; ts_array_U675; ts_array_U676; ts_array_U677; ts_array_U678; ];
Array ts_array_U644 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2761; ];
Array ts_array_U645 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2762; ];
Array ts_array_U646 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2763; ];
Array ts_array_U647 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2764; ];
Array ts_array_U648 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2765; ];
Array ts_array_U649 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2766; ];
Array ts_array_U650 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2767; ];
Array ts_array_U651 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2768; ];
Array ts_array_U652 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2769; ];
Array ts_array_U653 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2770; ];
Array ts_array_U654 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2771; ];
Array ts_array_U655 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2772; ];
Array ts_array_U656 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2773; ];
Array ts_array_U657 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2775; ];
Array ts_array_U658 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2777; ];
Array ts_array_U659 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2779; ];
Array ts_array_U660 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2781; ];
Array ts_array_U661 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2783; ];
Array ts_array_U662 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2784; ];
Array ts_array_U663 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2785; ];
Array ts_array_U664 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2786; ];
Array ts_array_U665 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2787; ];
Array ts_array_U666 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2788; ];
Array ts_array_U667 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2789; ];
Array ts_array_U668 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2790; ];
Array ts_array_U669 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2791; ];
Array ts_array_U670 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2792; ];
Array ts_array_U671 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2794; ];
Array ts_array_U672 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2795; ];
Array ts_array_U673 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2797; ];
Array ts_array_U674 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2798; ];
Array ts_array_U675 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2799; ];
Array ts_array_U676 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2801; ];
Array ts_array_U677 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2802; ];
Array ts_array_U678 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2803; ];
Array column_data_U85 table [ column_bits_U85; column_blanks_U80; 5; 5; 5; 10; 5; 10; 10; 5; 10; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 5; 10; 5; 5; 5; 5; 5; 5; 10; 5; 5; 5; ];
Array column_data_U86 table [ column_bits_U86; column_blanks_U81; bc_U1926; bc_U1927; bc_U1928; bc_U1929; bc_U1930; bc_U1931; bc_U1932; bc_U1933; bc_U1934; bc_U1935; bc_U1936; bc_U1937; bc_U1938; bc_U1939; bc_U1940; bc_U1941; bc_U1942; bc_U1943; bc_U1944; bc_U1945; bc_U1946; bc_U1947; bc_U1948; bc_U1949; bc_U1950; bc_U1951; bc_U1952; bc_U1953; bc_U1954; bc_U1955; bc_U1956; bc_U1957; bc_U1958; bc_U1959; bc_U1960; ];
Array bc_U1926 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U643; ];
Array bc_U1927 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U644; ];
Array bc_U1928 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U645; ];
Array bc_U1929 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U646; ];
Array bc_U1930 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U647; ];
Array bc_U1931 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U648; ];
Array bc_U1932 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U649; ];
Array bc_U1933 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U650; ];
Array bc_U1934 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U651; ];
Array bc_U1935 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U652; ];
Array bc_U1936 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U653; ];
Array bc_U1937 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U654; ];
Array bc_U1938 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U655; ];
Array bc_U1939 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U656; ];
Array bc_U1940 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U657; ];
Array bc_U1941 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U658; ];
Array bc_U1942 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U659; ];
Array bc_U1943 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U660; ];
Array bc_U1944 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U661; ];
Array bc_U1945 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U662; ];
Array bc_U1946 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U663; ];
Array bc_U1947 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U664; ];
Array bc_U1948 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U665; ];
Array bc_U1949 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U666; ];
Array bc_U1950 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U667; ];
Array bc_U1951 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U668; ];
Array bc_U1952 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U669; ];
Array bc_U1953 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U670; ];
Array bc_U1954 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U671; ];
Array bc_U1955 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U672; ];
Array bc_U1956 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U673; ];
Array bc_U1957 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U674; ];
Array bc_U1958 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U675; ];
Array bc_U1959 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U676; ];
Array bc_U1960 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U677; ];
Array column_data_U87 table [ column_bits_U87; column_blanks_U82; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; -1; ];
Array table_data_U25 table [ column_data_U84; column_data_U85; column_data_U86; column_data_U87; ];
Array column_data_U88 table [ column_bits_U88; column_blanks_U83; ts_array_U679; ts_array_U680; bc_U1961; ts_array_U681; ts_array_U682; ts_array_U683; bc_U1962; bc_U1963; ];
Array ts_array_U679 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2804; ];
Array ts_array_U680 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2805; ];
Array bc_U1961 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U678; ];
Array ts_array_U681 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2806; ];
Array ts_array_U682 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2807; ];
Array ts_array_U683 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2808; ];
Array bc_U1962 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U679; ];
Array bc_U1963 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U680; ];
Array table_data_U26 table [ column_data_U88; ];
Array column_data_U89 table [ column_bits_U89; column_blanks_U84; bc_U1964; bc_U1965; bc_U1966; bc_U1967; bc_U1968; bc_U1969; bc_U1970; bc_U1971; bc_U1972; bc_U1973; bc_U1974; bc_U1975; bc_U1976; bc_U1977; bc_U1978; bc_U1979; bc_U1980; bc_U1981; bc_U1982; bc_U1983; bc_U1984; bc_U1985; bc_U1986; bc_U1987; bc_U1988; bc_U1989; bc_U1990; bc_U1991; bc_U1992; bc_U1993; bc_U1994; bc_U1995; bc_U1996; bc_U1997; bc_U1998; bc_U1999; bc_U2000; bc_U2001; bc_U2002; bc_U2003; ];
Array bc_U1964 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U681; ];
Array bc_U1965 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U682; ];
Array bc_U1966 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U683; ];
Array bc_U1967 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U684; ];
Array bc_U1968 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U685; ];
Array bc_U1969 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U686; ];
Array bc_U1970 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U687; ];
Array bc_U1971 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U688; ];
Array bc_U1972 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U689; ];
Array bc_U1973 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U690; ];
Array bc_U1974 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U691; ];
Array bc_U1975 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U692; ];
Array bc_U1976 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U693; ];
Array bc_U1977 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U694; ];
Array bc_U1978 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U695; ];
Array bc_U1979 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U696; ];
Array bc_U1980 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U697; ];
Array bc_U1981 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U698; ];
Array bc_U1982 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U699; ];
Array bc_U1983 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U700; ];
Array bc_U1984 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U701; ];
Array bc_U1985 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U702; ];
Array bc_U1986 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U703; ];
Array bc_U1987 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U704; ];
Array bc_U1988 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U705; ];
Array bc_U1989 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U706; ];
Array bc_U1990 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U707; ];
Array bc_U1991 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U708; ];
Array bc_U1992 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U709; ];
Array bc_U1993 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U710; ];
Array bc_U1994 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U711; ];
Array bc_U1995 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U712; ];
Array bc_U1996 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U713; ];
Array bc_U1997 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U714; ];
Array bc_U1998 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U715; ];
Array bc_U1999 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U716; ];
Array bc_U2000 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U717; ];
Array bc_U2001 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U718; ];
Array bc_U2002 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U719; ];
Array bc_U2003 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U720; ];
Array column_data_U90 table [ column_bits_U90; column_blanks_U85; bc_U2004; bc_U2005; bc_U2006; bc_U2007; bc_U2008; bc_U2009; bc_U2010; bc_U2011; bc_U2012; bc_U2013; bc_U2014; bc_U2015; bc_U2016; ts_array_U684; bc_U2017; bc_U2018; bc_U2019; bc_U2020; bc_U2021; bc_U2022; bc_U2023; bc_U2024; bc_U2025; bc_U2026; bc_U2027; bc_U2028; bc_U2029; bc_U2030; bc_U2031; bc_U2032; bc_U2033; bc_U2034; bc_U2035; bc_U2036; bc_U2037; bc_U2038; bc_U2039; bc_U2040; bc_U2041; bc_U2042; ];
Array bc_U2004 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U721; ];
Array bc_U2005 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U722; ];
Array bc_U2006 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U723; ];
Array bc_U2007 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U724; ];
Array bc_U2008 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U725; ];
Array bc_U2009 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U726; ];
Array bc_U2010 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U727; ];
Array bc_U2011 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U728; ];
Array bc_U2012 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U729; ];
Array bc_U2013 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U730; ];
Array bc_U2014 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U731; ];
Array bc_U2015 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U732; ];
Array bc_U2016 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U733; ];
Array ts_array_U684 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2809; ];
Array bc_U2017 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U734; ];
Array bc_U2018 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U735; ];
Array bc_U2019 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U736; ];
Array bc_U2020 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U737; ];
Array bc_U2021 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U738; ];
Array bc_U2022 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U739; ];
Array bc_U2023 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U740; ];
Array bc_U2024 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U741; ];
Array bc_U2025 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U742; ];
Array bc_U2026 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U743; ];
Array bc_U2027 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U744; ];
Array bc_U2028 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U745; ];
Array bc_U2029 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U746; ];
Array bc_U2030 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U747; ];
Array bc_U2031 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U748; ];
Array bc_U2032 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U749; ];
Array bc_U2033 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U750; ];
Array bc_U2034 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U751; ];
Array bc_U2035 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U752; ];
Array bc_U2036 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U753; ];
Array bc_U2037 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U754; ];
Array bc_U2038 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U755; ];
Array bc_U2039 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U756; ];
Array bc_U2040 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U757; ];
Array bc_U2041 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U758; ];
Array bc_U2042 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U759; ];
Array column_data_U91 table [ column_bits_U91; column_blanks_U86; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array table_data_U27 table [ column_data_U89; column_data_U90; column_data_U91; ];
Array column_data_U92 table [ column_bits_U92; column_blanks_U87; 0; 1; 3; 5; 7; 9; 11; ];
Array column_data_U93 table [ column_bits_U93; NULL; I_figure_of_controlpanel_U1; I_figure_of_controlpanelstoc_U1; I_figure_of_controlpanelgall_U1; I_figure_of_controlpanelstak_U1; I_figure_of_controlpaneldung_U1; I_figure_of_controlpanelguil_U1; I_figure_of_controlpanelexit_U1; ];
Array column_data_U94 table [ column_bits_U94; column_blanks_U88; bc_U2043; bc_U2044; bc_U2045; bc_U2046; bc_U2047; bc_U2048; bc_U2049; ];
Array bc_U2043 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U760; ];
Array bc_U2044 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U761; ];
Array bc_U2045 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U762; ];
Array bc_U2046 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U763; ];
Array bc_U2047 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U764; ];
Array bc_U2048 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U765; ];
Array bc_U2049 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U766; ];
Array table_data_U28 table [ column_data_U92; column_data_U93; column_data_U94; ];
Array column_data_U95 table [ column_bits_U95; column_blanks_U89; bc_U2050; bc_U2051; bc_U2052; bc_U2053; ];
Array bc_U2050 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U767; ];
Array bc_U2051 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U768; ];
Array bc_U2052 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U769; ];
Array bc_U2053 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U770; ];
Array column_data_U96 table [ column_bits_U96; NULL; I_small_plush_monkey_U1; I_fuse15_U1; I_poster_of_billie_eilish_U1; I_small_pocket_mirror_U1; ];
Array column_data_U97 table [ column_bits_U97; column_blanks_U90; bc_U2054; bc_U2055; bc_U2056; bc_U2057; ];
Array bc_U2054 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U771; ];
Array bc_U2055 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U772; ];
Array bc_U2056 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U773; ];
Array bc_U2057 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U774; ];
Array table_data_U29 table [ column_data_U95; column_data_U96; column_data_U97; ];
Array column_data_U98 table [ column_bits_U98; column_blanks_U91; bc_U2058; bc_U2059; bc_U2060; bc_U2061; ];
Array bc_U2058 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U775; ];
Array bc_U2059 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U776; ];
Array bc_U2060 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U777; ];
Array bc_U2061 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U778; ];
Array column_data_U99 table [ column_bits_U99; NULL; I_fuse3_U1; I_small_plush_donkey_U1; I_goldfish_U1; I_poster_of_lourde_U1; ];
Array column_data_U100 table [ column_bits_U100; column_blanks_U92; bc_U2062; bc_U2063; bc_U2064; bc_U2065; ];
Array bc_U2062 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U779; ];
Array bc_U2063 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U780; ];
Array bc_U2064 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U781; ];
Array bc_U2065 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U782; ];
Array table_data_U30 table [ column_data_U98; column_data_U99; column_data_U100; ];
Array column_data_U101 table [ column_bits_U101; column_blanks_U93; bc_U2066; bc_U2067; bc_U2068; bc_U2069; bc_U2070; bc_U2071; ];
Array bc_U2066 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U783; ];
Array bc_U2067 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U784; ];
Array bc_U2068 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U785; ];
Array bc_U2069 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U786; ];
Array bc_U2070 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U787; ];
Array bc_U2071 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U788; ];
Array column_data_U102 table [ column_bits_U102; NULL; I_soda_can_U1; I_bucket_of_popcorn_U1; I_candy_apple_U1; I_cotton_candy_U1; I_soft_pretzel_U1; I_bubblegum_U1; ];
Array column_data_U103 table [ column_bits_U103; column_blanks_U94; 200; 250; 150; 150; 150; 100; ];
Array table_data_U31 table [ column_data_U101; column_data_U102; column_data_U103; ];
Array column_data_U104 table [ column_bits_U104; column_blanks_U95; ts_array_U685; bc_U2072; bc_U2073; bc_U2074; ];
Array ts_array_U685 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2810; ];
Array bc_U2072 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U789; ];
Array bc_U2073 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U790; ];
Array bc_U2074 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U791; ];
Array column_data_U105 table [ column_bits_U105; column_blanks_U96; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U32 table [ column_data_U104; column_data_U105; ];
Array column_data_U106 table [ column_bits_U106; column_blanks_U97; bc_U2075; bc_U2076; bc_U2077; bc_U2078; ];
Array bc_U2075 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U792; ];
Array bc_U2076 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U793; ];
Array bc_U2077 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U794; ];
Array bc_U2078 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U795; ];
Array column_data_U107 table [ column_bits_U107; column_blanks_U98; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U33 table [ column_data_U106; column_data_U107; ];
Array column_data_U108 table [ column_bits_U108; column_blanks_U99; bc_U2079; ts_array_U686; bc_U2080; ];
Array bc_U2079 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U796; ];
Array ts_array_U686 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2811; ];
Array bc_U2080 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U797; ];
Array column_data_U109 table [ column_bits_U109; column_blanks_U100; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U34 table [ column_data_U108; column_data_U109; ];
Array column_data_U110 table [ column_bits_U110; column_blanks_U101; bc_U2081; bc_U2082; bc_U2083; bc_U2084; bc_U2085; bc_U2086; ];
Array bc_U2081 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U798; ];
Array bc_U2082 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U799; ];
Array bc_U2083 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U800; ];
Array bc_U2084 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U801; ];
Array bc_U2085 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U802; ];
Array bc_U2086 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U803; ];
Array column_data_U111 table [ column_bits_U111; column_blanks_U102; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U35 table [ column_data_U110; column_data_U111; ];
Array column_data_U112 table [ column_bits_U112; column_blanks_U103; ts_array_U687; bc_U2087; bc_U2088; ];
Array ts_array_U687 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2812; ];
Array bc_U2087 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U804; ];
Array bc_U2088 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U805; ];
Array column_data_U113 table [ column_bits_U113; column_blanks_U104; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U36 table [ column_data_U112; column_data_U113; ];
Array column_data_U114 table [ column_bits_U114; column_blanks_U105; bc_U2089; bc_U2090; ];
Array bc_U2089 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U806; ];
Array bc_U2090 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U807; ];
Array column_data_U115 table [ column_bits_U115; column_blanks_U106; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U37 table [ column_data_U114; column_data_U115; ];
Array column_data_U116 table [ column_bits_U116; column_blanks_U107; bc_U2091; ts_array_U688; bc_U2092; ];
Array bc_U2091 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U808; ];
Array ts_array_U688 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2813; ];
Array bc_U2092 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U809; ];
Array column_data_U117 table [ column_bits_U117; column_blanks_U108; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U38 table [ column_data_U116; column_data_U117; ];
Array column_data_U118 table [ column_bits_U118; column_blanks_U109; ts_array_U689; bc_U2093; ts_array_U690; bc_U2094; ];
Array ts_array_U689 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2814; ];
Array bc_U2093 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U810; ];
Array ts_array_U690 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2815; ];
Array bc_U2094 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U811; ];
Array column_data_U119 table [ column_bits_U119; column_blanks_U110; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U39 table [ column_data_U118; column_data_U119; ];
Array column_data_U120 table [ column_bits_U120; column_blanks_U111; bc_U2095; bc_U2096; bc_U2097; ];
Array bc_U2095 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U812; ];
Array bc_U2096 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U813; ];
Array bc_U2097 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U814; ];
Array column_data_U121 table [ column_bits_U121; column_blanks_U112; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U40 table [ column_data_U120; column_data_U121; ];
Array column_data_U122 table [ column_bits_U122; column_blanks_U113; ts_array_U691; ts_array_U692; bc_U2098; ts_array_U693; ];
Array ts_array_U691 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2816; ];
Array ts_array_U692 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2817; ];
Array bc_U2098 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U815; ];
Array ts_array_U693 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2818; ];
Array column_data_U123 table [ column_bits_U123; column_blanks_U114; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U41 table [ column_data_U122; column_data_U123; ];
Array column_data_U124 table [ column_bits_U124; column_blanks_U115; bc_U2099; bc_U2100; bc_U2101; bc_U2102; bc_U2103; bc_U2104; ];
Array bc_U2099 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U816; ];
Array bc_U2100 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U817; ];
Array bc_U2101 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U818; ];
Array bc_U2102 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U819; ];
Array bc_U2103 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U820; ];
Array bc_U2104 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U821; ];
Array column_data_U125 table [ column_bits_U125; column_blanks_U116; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U42 table [ column_data_U124; column_data_U125; ];
Array column_data_U126 table [ column_bits_U126; column_blanks_U117; ts_array_U694; ts_array_U695; ts_array_U696; bc_U2105; ts_array_U697; ];
Array ts_array_U694 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2819; ];
Array ts_array_U695 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2820; ];
Array ts_array_U696 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2821; ];
Array bc_U2105 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U822; ];
Array ts_array_U697 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2822; ];
Array column_data_U127 table [ column_bits_U127; column_blanks_U118; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U43 table [ column_data_U126; column_data_U127; ];
Array column_data_U128 table [ column_bits_U128; column_blanks_U119; bc_U2106; ts_array_U698; ts_array_U699; bc_U2107; bc_U2108; ];
Array bc_U2106 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U823; ];
Array ts_array_U698 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2823; ];
Array ts_array_U699 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2824; ];
Array bc_U2107 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U824; ];
Array bc_U2108 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U825; ];
Array column_data_U129 table [ column_bits_U129; column_blanks_U120; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U44 table [ column_data_U128; column_data_U129; ];
Array column_data_U130 table [ column_bits_U130; column_blanks_U121; bc_U2109; ts_array_U700; bc_U2110; ts_array_U701; bc_U2111; ];
Array bc_U2109 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U826; ];
Array ts_array_U700 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2825; ];
Array bc_U2110 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U827; ];
Array ts_array_U701 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2826; ];
Array bc_U2111 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U828; ];
Array column_data_U131 table [ column_bits_U131; column_blanks_U122; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U45 table [ column_data_U130; column_data_U131; ];
Array column_data_U132 table [ column_bits_U132; column_blanks_U123; bc_U2112; bc_U2113; bc_U2114; bc_U2115; ts_array_U702; ts_array_U703; bc_U2116; ];
Array bc_U2112 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U829; ];
Array bc_U2113 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U830; ];
Array bc_U2114 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U831; ];
Array bc_U2115 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U832; ];
Array ts_array_U702 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2827; ];
Array ts_array_U703 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2828; ];
Array bc_U2116 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U833; ];
Array column_data_U133 table [ column_bits_U133; column_blanks_U124; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U46 table [ column_data_U132; column_data_U133; ];
Array column_data_U134 table [ column_bits_U134; column_blanks_U125; ts_array_U704; bc_U2117; bc_U2118; ts_array_U705; ];
Array ts_array_U704 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2829; ];
Array bc_U2117 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U834; ];
Array bc_U2118 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U835; ];
Array ts_array_U705 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2830; ];
Array column_data_U135 table [ column_bits_U135; column_blanks_U126; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U47 table [ column_data_U134; column_data_U135; ];
Array column_data_U136 table [ column_bits_U136; column_blanks_U127; bc_U2119; bc_U2120; bc_U2121; bc_U2122; ];
Array bc_U2119 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U836; ];
Array bc_U2120 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U837; ];
Array bc_U2121 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U838; ];
Array bc_U2122 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U839; ];
Array column_data_U137 table [ column_bits_U137; column_blanks_U128; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U48 table [ column_data_U136; column_data_U137; ];
Array column_data_U138 table [ column_bits_U138; column_blanks_U129; ts_array_U706; bc_U2123; ts_array_U707; bc_U2124; bc_U2125; bc_U2126; ];
Array ts_array_U706 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2831; ];
Array bc_U2123 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U840; ];
Array ts_array_U707 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2832; ];
Array bc_U2124 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U841; ];
Array bc_U2125 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U842; ];
Array bc_U2126 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U843; ];
Array column_data_U139 table [ column_bits_U139; column_blanks_U130; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U49 table [ column_data_U138; column_data_U139; ];
Array column_data_U140 table [ column_bits_U140; column_blanks_U131; bc_U2127; bc_U2128; bc_U2129; bc_U2130; bc_U2131; bc_U2132; bc_U2133; ];
Array bc_U2127 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U844; ];
Array bc_U2128 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U845; ];
Array bc_U2129 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U846; ];
Array bc_U2130 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U847; ];
Array bc_U2131 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U848; ];
Array bc_U2132 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U849; ];
Array bc_U2133 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U850; ];
Array column_data_U141 table [ column_bits_U141; column_blanks_U132; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U50 table [ column_data_U140; column_data_U141; ];
Array label_associated_storage_U2199 --> [ 0; 0; ];
Array label_associated_storage_U2200 --> [ 0; 0; ];
Array bc_U2134 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U851; ];
Array ts_array_U708 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2837; ];
Array script_U1 -> [ 98; 114; 105; 101; 102; 47; 116; 101; 115; 116; 32; 112; 97; 114; 107; 105; 110; 103; 47; 116; 101; 115; 116; 32; 103; 97; 109; 101; 115; 47; 116; 101; 115; 116; 32; 97; 116; 116; 114; 97; 99; 116; 105; 111; 110; 115; 47; 116; 101; 115; 116; 32; 99; 111; 110; 99; 101; 115; 115; 105; 111; 110; 47; 116; 101; 115; 116; 32; 109; 105; 115; 99; 47; 116; 101; 115; 116; 32; 98; 97; 99; 107; 115; 116; 97; 103; 101; 124; 124; 124; 124; ];
Array requirements_U1 --> [ 0; 0; ];
Array script_U2 -> [ 98; 114; 105; 101; 102; 47; 116; 101; 115; 116; 32; 112; 97; 114; 107; 105; 110; 103; 47; 116; 101; 115; 116; 32; 103; 97; 109; 101; 115; 47; 116; 101; 115; 116; 32; 97; 116; 116; 114; 97; 99; 116; 105; 111; 110; 115; 47; 116; 101; 115; 116; 32; 99; 111; 110; 99; 101; 115; 115; 105; 111; 110; 47; 116; 101; 115; 116; 32; 109; 105; 115; 99; 47; 116; 101; 115; 116; 32; 114; 105; 100; 101; 124; 124; 124; 124; ];
Array requirements_U2 --> [ 0; 0; ];
Array script_U3 -> [ 98; 114; 105; 101; 102; 47; 103; 101; 116; 32; 98; 108; 117; 101; 98; 101; 114; 114; 105; 101; 115; 47; 101; 97; 116; 32; 98; 108; 117; 101; 98; 101; 114; 114; 105; 101; 115; 47; 103; 105; 118; 101; 32; 99; 111; 117; 112; 111; 110; 32; 116; 111; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 98; 117; 121; 32; 116; 105; 99; 107; 101; 116; 47; 97; 115; 107; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 32; 97; 98; 111; 117; 116; 32; 116; 104; 101; 32; 116; 105; 99; 107; 101; 116; 32; 115; 116; 117; 98; 47; 116; 101; 108; 108; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 32; 97; 98; 111; 117; 116; 32; 115; 116; 117; 98; 47; 115; 104; 111; 119; 32; 116; 104; 101; 32; 115; 116; 117; 98; 32; 116; 111; 32; 116; 104; 101; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 116; 97; 108; 107; 32; 116; 111; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 108; 32; 97; 116; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 107; 105; 115; 115; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 115; 109; 101; 108; 108; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 108; 105; 115; 116; 101; 110; 32; 116; 111; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 116; 111; 117; 99; 104; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 116; 97; 115; 116; 101; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 102; 117; 99; 107; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 100; 97; 114; 110; 47; 100; 97; 109; 110; 47; 103; 101; 116; 32; 105; 110; 32; 99; 97; 114; 47; 108; 111; 111; 107; 47; 108; 32; 97; 116; 32; 115; 101; 97; 116; 47; 108; 32; 117; 110; 100; 101; 114; 32; 115; 101; 97; 116; 47; 103; 101; 116; 32; 97; 108; 108; 32; 100; 105; 109; 101; 115; 47; 103; 101; 116; 32; 97; 108; 108; 32; 113; 117; 97; 114; 116; 101; 114; 115; 47; 103; 101; 116; 32; 110; 105; 99; 107; 101; 108; 47; 103; 101; 116; 32; 107; 101; 121; 115; 47; 111; 112; 101; 110; 32; 103; 108; 111; 118; 101; 32; 98; 111; 120; 47; 103; 101; 116; 32; 103; 108; 111; 118; 101; 115; 47; 119; 101; 97; 114; 32; 103; 108; 111; 118; 101; 115; 47; 115; 101; 116; 32; 115; 116; 117; 98; 32; 111; 110; 32; 116; 104; 101; 32; 100; 97; 115; 104; 98; 111; 97; 114; 100; 47; 108; 32; 97; 116; 32; 116; 104; 101; 32; 100; 97; 115; 104; 98; 111; 97; 114; 100; 47; 103; 101; 116; 32; 97; 105; 114; 32; 102; 114; 101; 115; 104; 101; 110; 101; 114; 47; 108; 111; 111; 107; 32; 97; 116; 32; 105; 116; 47; 112; 117; 116; 32; 107; 101; 121; 115; 32; 105; 110; 32; 105; 103; 110; 105; 116; 105; 111; 110; 47; 116; 117; 114; 110; 32; 107; 101; 121; 115; 47; 101; 120; 105; 116; 124; 124; 124; 124; ];
Array requirements_U3 --> [ 0; 0; ];
Array script_U4 -> [ 98; 114; 105; 101; 102; 47; 116; 101; 115; 116; 32; 112; 97; 114; 107; 105; 110; 103; 47; 103; 101; 116; 32; 105; 110; 32; 99; 97; 114; 47; 103; 101; 116; 32; 112; 97; 114; 107; 105; 110; 103; 32; 115; 116; 117; 98; 47; 101; 120; 105; 116; 32; 99; 97; 114; 47; 116; 101; 115; 116; 32; 103; 97; 109; 101; 115; 47; 116; 101; 115; 116; 32; 97; 116; 116; 114; 97; 99; 116; 105; 111; 110; 115; 124; 124; 124; 124; ];
Array requirements_U4 --> [ 0; 0; ];
Array script_U5 -> [ 98; 114; 105; 101; 102; 47; 115; 47; 119; 47; 103; 105; 118; 101; 32; 100; 105; 109; 101; 32; 116; 111; 32; 98; 97; 114; 107; 101; 114; 47; 119; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 47; 103; 101; 116; 32; 108; 97; 109; 112; 47; 116; 117; 114; 110; 32; 105; 116; 32; 111; 110; 47; 119; 101; 97; 114; 32; 118; 101; 105; 108; 47; 101; 47; 101; 47; 110; 124; 124; 124; 124; ];
Array requirements_U5 --> [ 0; 0; ];
Array script_U6 -> [ 115; 47; 101; 47; 98; 117; 121; 32; 109; 97; 108; 108; 101; 116; 47; 104; 105; 116; 32; 108; 101; 118; 101; 114; 32; 119; 105; 116; 104; 32; 109; 97; 108; 108; 101; 116; 47; 103; 47; 103; 47; 103; 47; 103; 47; 50; 47; 119; 47; 110; 124; 124; 124; 124; ];
Array requirements_U6 --> [ 0; 0; ];
Array script_U7 -> [ 115; 47; 101; 47; 110; 101; 47; 108; 32; 97; 116; 32; 98; 111; 111; 116; 104; 47; 108; 32; 117; 110; 100; 101; 114; 32; 98; 111; 111; 116; 104; 47; 102; 108; 105; 112; 32; 100; 105; 109; 101; 32; 111; 110; 32; 112; 108; 97; 116; 101; 47; 116; 111; 115; 115; 32; 100; 105; 109; 101; 32; 111; 110; 32; 112; 108; 97; 116; 101; 47; 116; 111; 115; 115; 32; 100; 105; 109; 101; 32; 111; 110; 32; 112; 108; 97; 116; 101; 47; 49; 47; 103; 101; 116; 32; 109; 101; 114; 99; 117; 114; 121; 32; 100; 105; 109; 101; 47; 115; 119; 47; 115; 101; 47; 103; 105; 118; 101; 32; 109; 101; 114; 99; 117; 114; 121; 32; 100; 105; 109; 101; 32; 116; 111; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 116; 104; 114; 111; 119; 32; 98; 97; 115; 101; 98; 97; 108; 108; 32; 97; 116; 32; 98; 111; 116; 116; 108; 101; 115; 47; 49; 47; 110; 119; 47; 119; 47; 110; 124; 124; 124; 124; ];
Array requirements_U7 --> [ 0; 0; ];
Array script_U8 -> [ 116; 101; 115; 116; 32; 103; 49; 47; 116; 101; 115; 116; 32; 103; 50; 47; 116; 101; 115; 116; 32; 103; 51; 124; 124; 124; 124; ];
Array requirements_U8 --> [ 0; 0; ];
Array script_U9 -> [ 115; 47; 98; 117; 121; 32; 97; 108; 108; 32; 116; 105; 99; 107; 101; 116; 115; 47; 101; 47; 101; 47; 101; 47; 103; 105; 118; 101; 32; 102; 101; 114; 114; 105; 115; 32; 119; 104; 101; 101; 108; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 102; 101; 114; 114; 105; 115; 32; 119; 104; 101; 101; 108; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 119; 47; 119; 47; 110; 101; 47; 103; 105; 118; 101; 32; 99; 97; 114; 111; 117; 115; 101; 108; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 99; 97; 114; 111; 117; 115; 101; 108; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 115; 119; 47; 115; 101; 47; 103; 105; 118; 101; 32; 102; 111; 114; 116; 117; 110; 101; 32; 116; 101; 108; 108; 101; 114; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 109; 121; 115; 116; 101; 114; 105; 111; 117; 115; 32; 119; 111; 109; 97; 110; 47; 110; 119; 47; 110; 119; 47; 108; 32; 97; 116; 32; 116; 119; 111; 32; 100; 111; 108; 108; 97; 114; 32; 98; 105; 108; 108; 47; 103; 101; 116; 32; 116; 119; 111; 32; 100; 111; 108; 108; 97; 114; 32; 98; 105; 108; 108; 47; 103; 105; 118; 101; 32; 98; 117; 109; 112; 101; 114; 32; 99; 97; 114; 115; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 98; 117; 109; 112; 101; 114; 32; 99; 97; 114; 115; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 115; 101; 47; 110; 124; 124; 124; 124; ];
Array requirements_U9 --> [ 0; 0; ];
Array script_U10 -> [ 98; 114; 105; 101; 102; 47; 115; 47; 98; 117; 121; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 47; 115; 47; 103; 105; 118; 101; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 115; 47; 101; 47; 108; 32; 97; 116; 32; 112; 105; 108; 101; 115; 47; 103; 101; 116; 32; 102; 108; 97; 115; 104; 108; 105; 103; 104; 116; 47; 116; 117; 114; 110; 32; 105; 116; 32; 111; 110; 47; 115; 47; 116; 117; 114; 110; 32; 111; 110; 32; 114; 97; 100; 105; 111; 47; 117; 47; 119; 47; 102; 108; 105; 112; 32; 115; 119; 105; 116; 99; 104; 47; 112; 117; 115; 104; 32; 115; 119; 105; 116; 99; 104; 47; 112; 117; 115; 104; 32; 115; 119; 105; 116; 99; 104; 47; 101; 47; 100; 47; 108; 32; 97; 116; 32; 100; 101; 115; 107; 47; 111; 112; 101; 110; 32; 100; 114; 97; 119; 101; 114; 47; 103; 101; 116; 32; 97; 108; 108; 32; 102; 114; 111; 109; 32; 116; 104; 101; 32; 100; 114; 97; 119; 101; 114; 47; 115; 47; 115; 47; 111; 112; 101; 110; 32; 116; 111; 111; 108; 98; 111; 120; 47; 103; 101; 116; 32; 97; 108; 108; 32; 102; 114; 111; 109; 32; 116; 111; 111; 108; 98; 111; 120; 47; 115; 47; 115; 47; 115; 47; 110; 101; 47; 103; 101; 116; 32; 115; 105; 108; 118; 101; 114; 32; 107; 101; 121; 47; 108; 32; 97; 116; 32; 112; 97; 110; 101; 108; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 108; 32; 97; 116; 32; 115; 111; 99; 107; 101; 116; 47; 115; 119; 47; 110; 47; 110; 47; 110; 47; 110; 47; 110; 124; 124; 124; 124; ];
Array requirements_U10 --> [ 0; 0; ];
Array script_U11 -> [ 110; 47; 119; 47; 110; 47; 110; 47; 110; 119; 47; 103; 105; 118; 101; 32; 116; 104; 101; 32; 97; 100; 106; 117; 115; 116; 97; 98; 108; 101; 32; 119; 114; 101; 110; 99; 104; 32; 116; 111; 32; 116; 104; 101; 32; 97; 116; 116; 101; 110; 100; 97; 110; 116; 47; 115; 101; 47; 115; 47; 115; 47; 101; 47; 115; 124; 124; 124; 124; ];
Array requirements_U11 --> [ 0; 0; ];
Array script_U12 -> [ 119; 47; 108; 32; 117; 110; 100; 101; 114; 32; 115; 116; 111; 99; 107; 115; 47; 116; 97; 107; 101; 32; 101; 109; 101; 114; 97; 108; 100; 47; 101; 47; 115; 47; 119; 47; 108; 32; 117; 110; 100; 101; 114; 32; 112; 108; 97; 116; 102; 111; 114; 109; 47; 116; 97; 107; 101; 32; 107; 104; 97; 107; 105; 32; 102; 117; 115; 101; 47; 101; 47; 115; 47; 119; 47; 108; 32; 105; 110; 32; 112; 121; 114; 101; 47; 103; 101; 116; 32; 102; 117; 115; 101; 47; 101; 47; 115; 47; 119; 47; 108; 32; 117; 110; 100; 101; 114; 32; 115; 101; 97; 116; 47; 116; 97; 107; 101; 32; 105; 110; 100; 105; 103; 111; 32; 102; 117; 115; 101; 47; 101; 47; 115; 47; 119; 47; 108; 32; 117; 110; 100; 101; 114; 32; 112; 108; 97; 116; 102; 111; 114; 109; 47; 116; 97; 107; 101; 32; 103; 114; 97; 121; 32; 102; 117; 115; 101; 47; 101; 47; 115; 47; 115; 47; 119; 47; 108; 32; 105; 110; 32; 115; 116; 97; 110; 100; 47; 98; 117; 121; 32; 97; 113; 117; 97; 32; 102; 117; 115; 101; 47; 101; 47; 110; 124; 124; 124; 124; ];
Array requirements_U12 --> [ 0; 0; ];
Array script_U13 -> [ 110; 101; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 112; 117; 116; 32; 97; 113; 117; 97; 32; 102; 117; 115; 101; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 102; 108; 105; 112; 32; 115; 119; 105; 116; 99; 104; 47; 115; 119; 47; 101; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 112; 117; 116; 32; 99; 114; 105; 109; 115; 111; 110; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 102; 108; 105; 112; 32; 115; 119; 105; 116; 99; 104; 47; 119; 47; 115; 101; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 112; 117; 116; 32; 101; 109; 101; 114; 97; 108; 100; 32; 102; 117; 115; 101; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 116; 111; 103; 103; 108; 101; 32; 115; 119; 105; 116; 99; 104; 47; 110; 119; 47; 115; 119; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 112; 117; 116; 32; 103; 114; 97; 121; 32; 102; 117; 115; 101; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 116; 111; 103; 103; 108; 101; 32; 115; 119; 105; 116; 99; 104; 47; 110; 101; 47; 119; 47; 111; 112; 101; 110; 32; 112; 97; 110; 101; 108; 47; 112; 117; 116; 32; 105; 110; 100; 105; 103; 111; 32; 102; 117; 115; 101; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 112; 117; 115; 104; 32; 115; 119; 105; 116; 99; 104; 47; 101; 47; 110; 119; 47; 108; 32; 97; 116; 32; 112; 97; 110; 101; 108; 47; 117; 110; 108; 111; 99; 107; 32; 112; 97; 110; 101; 108; 32; 119; 105; 116; 104; 32; 107; 110; 105; 102; 101; 47; 108; 32; 97; 116; 32; 112; 97; 110; 101; 108; 47; 111; 112; 101; 110; 32; 32; 112; 97; 110; 101; 108; 47; 108; 32; 97; 116; 32; 112; 97; 110; 101; 108; 47; 108; 32; 97; 116; 32; 115; 119; 105; 116; 99; 104; 46; 47; 108; 32; 97; 116; 32; 105; 110; 100; 105; 99; 97; 116; 111; 114; 47; 108; 32; 97; 116; 32; 115; 111; 99; 107; 101; 116; 47; 112; 117; 116; 32; 107; 104; 97; 107; 105; 32; 102; 117; 115; 101; 32; 105; 110; 32; 115; 111; 99; 107; 101; 116; 47; 112; 117; 115; 104; 32; 115; 119; 105; 116; 99; 104; 47; 108; 32; 97; 116; 32; 115; 111; 99; 107; 101; 116; 47; 115; 101; 124; 124; 124; 124; ];
Array requirements_U13 --> [ 0; 0; ];
Array script_U14 -> [ 110; 47; 110; 47; 110; 47; 110; 47; 110; 47; 99; 108; 105; 109; 98; 32; 108; 97; 100; 100; 101; 114; 47; 119; 47; 108; 32; 97; 116; 32; 99; 111; 110; 116; 114; 111; 108; 32; 112; 97; 110; 101; 108; 32; 49; 47; 116; 117; 114; 110; 32; 97; 113; 117; 97; 32; 100; 105; 97; 108; 32; 116; 111; 32; 49; 47; 116; 117; 114; 110; 32; 99; 114; 105; 109; 115; 111; 110; 32; 100; 105; 97; 108; 32; 116; 111; 32; 116; 104; 114; 101; 101; 47; 116; 117; 114; 110; 32; 101; 109; 101; 114; 97; 108; 100; 32; 100; 105; 97; 108; 32; 116; 111; 32; 53; 47; 116; 117; 114; 110; 32; 103; 114; 97; 121; 32; 100; 105; 97; 108; 32; 116; 111; 32; 115; 101; 118; 101; 110; 47; 116; 117; 114; 110; 32; 105; 110; 100; 105; 103; 111; 32; 100; 105; 97; 108; 32; 116; 111; 32; 57; 47; 116; 117; 114; 110; 32; 107; 104; 97; 107; 105; 32; 100; 105; 97; 108; 32; 116; 111; 32; 101; 108; 101; 118; 101; 110; 47; 112; 117; 115; 104; 32; 97; 113; 117; 97; 32; 98; 117; 116; 116; 111; 110; 47; 108; 32; 97; 116; 32; 99; 111; 110; 116; 114; 111; 108; 32; 112; 97; 110; 101; 108; 32; 49; 47; 112; 117; 115; 104; 32; 99; 114; 105; 109; 115; 111; 110; 32; 98; 117; 116; 116; 111; 110; 47; 108; 32; 97; 116; 32; 99; 111; 110; 116; 114; 111; 108; 32; 112; 97; 110; 101; 108; 32; 32; 51; 47; 112; 117; 115; 104; 32; 101; 109; 101; 114; 97; 108; 100; 32; 98; 117; 116; 116; 111; 110; 47; 108; 32; 97; 116; 32; 99; 111; 110; 116; 114; 111; 108; 32; 112; 97; 110; 101; 108; 32; 53; 47; 112; 117; 115; 104; 32; 103; 114; 97; 121; 32; 98; 117; 116; 116; 111; 110; 47; 108; 32; 97; 116; 32; 99; 111; 110; 116; 114; 111; 108; 32; 112; 97; 110; 101; 108; 32; 49; 49; 47; 112; 117; 115; 104; 32; 107; 104; 97; 107; 105; 32; 98; 117; 116; 116; 111; 110; 124; 124; 124; 124; ];
Array requirements_U14 --> [ 0; 0; ];
Array script_U15 -> [ 116; 101; 115; 116; 32; 98; 49; 47; 116; 101; 115; 116; 32; 98; 49; 97; 47; 116; 101; 115; 116; 32; 98; 50; 47; 116; 101; 115; 116; 32; 98; 51; 47; 116; 101; 115; 116; 32; 98; 52; 124; 124; 124; 124; ];
Array requirements_U15 --> [ 0; 0; ];
Array script_U16 -> [ 98; 114; 105; 101; 102; 47; 115; 47; 115; 119; 47; 108; 32; 97; 116; 32; 116; 114; 101; 97; 116; 115; 47; 114; 101; 97; 100; 32; 109; 101; 110; 117; 47; 98; 117; 121; 32; 99; 111; 108; 97; 47; 98; 117; 121; 32; 112; 111; 112; 99; 111; 114; 110; 47; 98; 117; 121; 32; 99; 97; 110; 100; 121; 32; 97; 112; 112; 108; 101; 47; 98; 117; 121; 32; 99; 111; 116; 116; 111; 110; 32; 99; 97; 110; 100; 121; 47; 98; 117; 121; 32; 112; 114; 101; 116; 122; 101; 108; 47; 105; 110; 118; 101; 110; 116; 111; 114; 121; 47; 100; 114; 105; 110; 107; 32; 115; 111; 100; 97; 47; 103; 47; 103; 47; 103; 47; 103; 47; 105; 47; 110; 101; 47; 110; 47; 105; 47; 115; 99; 111; 114; 101; 124; 124; 124; 124; ];
Array requirements_U16 --> [ 0; 0; ];
Array script_U17 -> [ 98; 114; 105; 101; 102; 47; 115; 47; 98; 117; 121; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 47; 115; 47; 103; 105; 118; 101; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 115; 47; 101; 110; 116; 101; 114; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 99; 97; 114; 47; 119; 97; 105; 116; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 47; 122; 124; 124; 124; 124; ];
Array requirements_U17 --> [ 0; 0; ];
Array script_U18 -> [ 115; 47; 98; 117; 121; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 47; 115; 47; 103; 105; 118; 101; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 47; 115; 47; 101; 47; 108; 32; 117; 110; 100; 101; 114; 32; 106; 117; 110; 107; 47; 103; 101; 116; 32; 102; 108; 97; 115; 104; 108; 105; 103; 104; 116; 47; 116; 117; 114; 110; 32; 105; 116; 32; 111; 110; 47; 115; 47; 117; 47; 119; 47; 114; 101; 109; 111; 118; 101; 32; 103; 108; 111; 118; 101; 115; 47; 115; 119; 105; 116; 99; 104; 32; 116; 104; 101; 32; 98; 105; 103; 32; 115; 119; 105; 116; 99; 104; 32; 111; 102; 102; 124; 124; 124; 124; ];
Array requirements_U18 --> [ 0; 0; ];
Array script_U19 -> [ 115; 47; 98; 117; 121; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 47; 115; 47; 103; 105; 118; 101; 32; 104; 101; 108; 108; 32; 114; 105; 100; 101; 32; 116; 105; 99; 107; 101; 116; 32; 116; 111; 32; 114; 105; 100; 101; 32; 111; 112; 101; 114; 97; 116; 111; 114; 47; 115; 47; 101; 47; 115; 47; 115; 47; 115; 124; 124; 124; 124; ];
Array requirements_U19 --> [ 0; 0; ];
Array script_U20 -> [ 98; 114; 105; 101; 102; 47; 120; 121; 122; 122; 121; 47; 112; 108; 117; 103; 104; 47; 104; 101; 108; 108; 111; 32; 115; 97; 105; 108; 111; 114; 47; 112; 108; 101; 97; 115; 101; 32; 103; 101; 116; 32; 116; 104; 101; 32; 100; 105; 109; 101; 47; 105; 47; 115; 99; 111; 114; 101; 124; 124; 124; 124; ];
Array requirements_U20 --> [ 0; 0; ];
Array bc_U2135 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U852; ];
Array bc_U2136 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U853; ];
Array bc_U2137 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U854; ];
Array UUID_ARRAY -> [ 45; 'U'; 'U'; 'I'; 'D'; ':'; '/'; '/'; 'E'; '0'; 'A'; '5'; 'A'; 'F'; 'B'; '9'; '-'; '1'; '8'; 'B'; 'F'; '-'; '4'; '4'; '8'; '5'; '-'; 'B'; '0'; '8'; '3'; '-'; '4'; '2'; '6'; 'C'; 'A'; '5'; '1'; 'C'; 'C'; 'E'; '7'; '0'; '/'; '/'; ];
Array InitialSituation --> [ selfobj; I_parking_lot_U1; I_parking_lot_U1; 540; 0; ];
Array Map_Storage --> [ 0; 0; 0; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_generator_room_U1; I_electrical_closet_one_U1; I_electrical_closet_eleven_U1; I_storage_room_U1; I_electrical_closet_five_U1; I_electrical_closet_seven_U1; I_electrical_closet_three_U1; I_electrical_closet_nine_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; 0; I_mechanical_room_south_U1; 0; 0; I_electrical_room_U1; 0; 0; 0; I_door9_U1; 0; 0; 0; 0; I_electrical_room_U1; 0; 0; 0; 0; 0; 0; I_door11_U1; 0; 0; 0; 0; I_parking_lot_U1; I_carousel_ride_U1; I_bumper_cars_ride_U1; I_head_of_the_line_U1; I_fortune_teller_booth_U1; I_concession_stand_U1; I_high_striker_U1; I_show_facade_U1; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; 0; 0; I_ride_entrance_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; I_show_tent_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; 0; 0; I_dime_toss_game_U1; 0; 0; I_pitcher_s_mound_U1; 0; I_ferris_wheel_ride_U1; I_ticket_booth_U1; 0; 0; 0; 0; 0; 0; I_high_striker_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_high_striker_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_high_striker_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_show_facade_U1; 0; 0; 0; 0; 0; I_head_of_the_line_U1; 0; 0; I_stocks_room_U1; 0; 0; I_dark_passage_U1; 0; 0; 0; 0; 0; 0; 0; 0; I_maintenance_office_U1; 0; 0; 0; I_ride_entrance_U1; 0; 0; 0; 0; I_dark_passage_U1; 0; 0; I_crawl_space_U1; 0; 0; 0; I_door1_U1; I_ladder_U1; 0; 0; 0; I_ride_entrance_U1; 0; 0; I_gallows_room_U1; 0; 0; I_door1_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_control_room_U1; 0; I_ladder_U1; 0; 0; I_maintenance_office_U1; 0; 0; I_mechanical_room_north_U1; 0; 0; 0; I_door3_U1; 0; 0; 0; 0; I_stocks_room_U1; 0; 0; I_stake_room_U1; 0; 0; I_door3_U1; 0; 0; 0; 0; 0; I_crawl_space_U1; 0; 0; I_mechanical_room_south_U1; 0; 0; 0; I_door5_U1; 0; 0; 0; 0; I_gallows_room_U1; 0; 0; I_dungeon_U1; 0; 0; I_door5_U1; 0; 0; 0; 0; 0; I_mechanical_room_north_U1; 0; 0; I_generator_room_U1; 0; 0; 0; I_door7_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_grate_U1; 0; 0; 0; I_stake_room_U1; 0; 0; I_guillotine_room_U1; 0; 0; I_door7_U1; 0; 0; 0; 0; 0; I_dungeon_U1; 0; 0; I_ride_exit_U1; 0; 0; I_door9_U1; 0; 0; 0; 0; 0; I_guillotine_room_U1; 0; 0; 0; 0; 0; I_door11_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_dark_hallway_U1; 0; 0; 0; 0; 0; ];
Array name_array1 --> [ 'north'; 'directions//p'; 'n//'; ];
Array name_array2 --> [ 'northeast'; 'directions//p'; 'ne'; ];
Array name_array3 --> [ 'northwest'; 'directions//p'; 'nw'; ];
Array name_array4 --> [ 'south'; 'directions//p'; 's//'; ];
Array name_array5 --> [ 'southeast'; 'directions//p'; 'se'; ];
Array name_array6 --> [ 'southwest'; 'directions//p'; 'sw'; ];
Array name_array7 --> [ 'east'; 'directions//p'; 'e//'; ];
Array name_array8 --> [ 'west'; 'directions//p'; 'w//'; ];
Array name_array9 --> [ 'up'; 'directions//p'; 'u//'; ];
Array name_array10 --> [ 'down'; 'directions//p'; 'd//'; ];
Array name_array11 --> [ 'inside'; 'directions//p'; 'in'; ];
Array name_array12 --> [ 'outside'; 'directions//p'; 'out'; ];
Array name_array13 --> [ 'parking'; 'lot'; 'rooms//p'; ];
Array name_array14 --> [ 'coupon'; 'things//p'; ];
Array name_array15 --> [ 'wallet'; 'containers//p'; ];
Array name_array16 --> [ 'money'; 'things//p'; 'cash'; ];
Array name_array17 --> [ 'lurking'; 'grue'; 'backdrops//p'; ];
Array name_array18 --> [ 'sailor'; 'backdrops//p'; ];
Array name_array19 --> [ 'seat'; 'supporters//p'; ];
Array name_array20 --> [ 'quarter'; 'quarters//p'; 'shiny'; ];
Array name_array21 --> [ 'quarter'; 'quarters//p'; 'shiny'; ];
Array name_array22 --> [ 'quarter'; 'quarters//p'; 'shiny'; ];
Array name_array23 --> [ 'nickel'; 'nickels//p'; 'shiny'; ];
Array name_array24 --> [ 'sky'; 'backdrops//p'; ];
Array name_array25 --> [ 'ground'; 'backdrops//p'; 'floor'; ];
Array name_array26 --> [ 'hell'; 'ride'; 'backdrops//p'; ];
Array name_array27 --> [ 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array28 --> [ 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array29 --> [ 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array30 --> [ 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array31 --> [ 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array32 --> [ 'electrical'; 'closet'; 'one'; 'closets//p'; ];
Array name_array33 --> [ 'electrical'; 'room'; 'rooms//p'; ];
Array name_array34 --> [ 'electrical'; 'closet'; 'three'; 'closets//p'; ];
Array name_array35 --> [ 'electrical'; 'closet'; 'five'; 'closets//p'; ];
Array name_array36 --> [ 'electrical'; 'closet'; 'seven'; 'closets//p'; ];
Array name_array37 --> [ 'electrical'; 'closet'; 'nine'; 'closets//p'; ];
Array name_array38 --> [ 'electrical'; 'closet'; 'eleven'; 'closets//p'; ];
Array name_array39 --> [ 'silver'; 'key'; 'things//p'; ];
Array name_array40 --> [ 'swiss'; 'army'; 'knife'; 'things//p'; 'screwdriver'; ];
Array name_array41 --> [ 'electrical'; 'closet'; 'one^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array42 --> [ 'electrical'; 'closet'; 'three^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array43 --> [ 'electrical'; 'closet'; 'five^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array44 --> [ 'electrical'; 'closet'; 'seven^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array45 --> [ 'electrical'; 'closet'; 'nine^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array46 --> [ 'electrical'; 'closet'; 'eleven^s'; 'electrical'; 'panel'; 'panels//p'; 'panel'; 'screws'; ];
Array name_array47 --> [ 'electrical'; 'closet'; 'one^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array48 --> [ 'electrical'; 'closet'; 'three^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array49 --> [ 'electrical'; 'closet'; 'five^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array50 --> [ 'electrical'; 'closet'; 'seven^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array51 --> [ 'electrical'; 'closet'; 'nine^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array52 --> [ 'electrical'; 'closet'; 'eleven^s'; 'electrical'; 'panel^s'; 'socket'; 'sockets//p'; ];
Array name_array53 --> [ 'electrical'; 'closet'; 'one^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array54 --> [ 'electrical'; 'closet'; 'three^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array55 --> [ 'electrical'; 'closet'; 'five^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array56 --> [ 'electrical'; 'closet'; 'seven^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array57 --> [ 'electrical'; 'closet'; 'nine^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array58 --> [ 'electrical'; 'closet'; 'eleven^s'; 'electrical'; 'panel^s'; 'indicator'; 'indicators//p'; 'light'; ];
Array name_array59 --> [ 'fuse1'; 'fuses//p'; 'fuse'; ];
Array name_array60 --> [ 'merchandise'; 'stand'; 'containers//p'; 'stand'; ];
Array name_array61 --> [ 'fuse3'; 'fuses//p'; 'fuse'; ];
Array name_array62 --> [ 'pitcher^s'; 'mound'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array63 --> [ 'fuse5'; 'fuses//p'; 'fuse'; ];
Array name_array64 --> [ 'wooden'; 'stocks'; 'supporters//p'; ];
Array name_array65 --> [ 'fuse7'; 'fuses//p'; 'fuse'; ];
Array name_array66 --> [ 'guillotine'; 'platform'; 'supporters//p'; 'scaffold'; ];
Array name_array67 --> [ 'fuse9'; 'fuses//p'; 'fuse'; ];
Array name_array68 --> [ 'iron'; 'chair'; 'supporters//p'; 'spiked'; 'seat'; ];
Array name_array69 --> [ 'fuse11'; 'fuses//p'; 'fuse'; ];
Array name_array70 --> [ 'gallows'; 'platform'; 'supporters//p'; 'gallows'; ];
Array name_array71 --> [ 'fuse13'; 'fuses//p'; 'fuse'; ];
Array name_array72 --> [ 'strongman'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array73 --> [ 'fuse15'; 'fuses//p'; 'fuse'; ];
Array name_array74 --> [ 'dime'; 'toss'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array75 --> [ 'fuse17'; 'fuses//p'; 'fuse'; ];
Array name_array76 --> [ 'pyre'; 'containers//p'; 'fire'; ];
Array name_array77 --> [ 'electrical'; 'closet'; 'one^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array78 --> [ 'electrical'; 'closet'; 'three^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array79 --> [ 'electrical'; 'closet'; 'five^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array80 --> [ 'electrical'; 'closet'; 'seven^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array81 --> [ 'electrical'; 'closet'; 'nine^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array82 --> [ 'electrical'; 'closet'; 'eleven^s'; 'electrical'; 'panel^s'; 'switch'; 'switches//p'; ];
Array name_array83 --> [ 'breaker'; 'panel'; 'things//p'; ];
Array name_array84 --> [ 'junction'; 'box'; 'things//p'; ];
Array name_array85 --> [ 'workbench'; 'things//p'; ];
Array name_array86 --> [ 'emergency'; 'shutdown'; 'panel'; 'things//p'; ];
Array name_array87 --> [ 'fire'; 'extinguisher'; 'things//p'; ];
Array name_array88 --> [ 'faded'; 'safety'; 'poster'; 'things//p'; ];
Array name_array89 --> [ 'small'; 'fan'; 'things//p'; ];
Array name_array90 --> [ 'generator'; 'room'; 'rooms//p'; ];
Array name_array91 --> [ 'storage'; 'room'; 'rooms//p'; ];
Array name_array92 --> [ 'ticket'; 'booth'; 'rooms//p'; ];
Array name_array93 --> [ 'parking'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array94 --> [ 'parking'; 'ticket'; 'things//p'; ];
Array name_array95 --> [ 'parking'; 'stub'; 'things//p'; ];
Array name_array96 --> [ 'beater'; 'car'; 'containers//p'; 'vehicle'; 'car'; ];
Array name_array97 --> [ 'wrappers'; 'things//p'; ];
Array name_array98 --> [ 'text'; 'books'; 'things//p'; 'books'; ];
Array name_array99 --> [ 'my'; 'dirty'; 'clothes'; 'things//p'; ];
Array name_array100 --> [ 'blueberry'; 'bush'; 'containers//p'; ];
Array name_array101 --> [ 'blueberries'; 'things//p'; 'berries'; ];
Array name_array102 --> [ 'air'; 'freshener'; 'things//p'; ];
Array name_array103 --> [ 'ignition'; 'containers//p'; ];
Array name_array104 --> [ 'dashboard'; 'supporters//p'; 'dash'; ];
Array name_array105 --> [ 'my'; 'keys'; 'things//p'; 'key'; ];
Array name_array106 --> [ 'glove'; 'box'; 'containers//p'; 'compartment'; ];
Array name_array107 --> [ 'pair'; 'of'; 'gloves'; 'things//p'; ];
Array name_array108 --> [ 'fortune'; 'teller'; 'booth'; 'rooms//p'; ];
Array name_array109 --> [ 'head'; 'of'; 'the'; 'line'; 'rooms//p'; ];
Array name_array110 --> [ 'concession'; 'stand'; 'rooms//p'; ];
Array name_array111 --> [ 'show'; 'facade'; 'rooms//p'; ];
Array name_array112 --> [ 'carousel'; 'ride'; 'rooms//p'; ];
Array name_array113 --> [ 'bumper'; 'cars'; 'ride'; 'rooms//p'; ];
Array name_array114 --> [ 'high'; 'striker'; 'rooms//p'; ];
Array name_array115 --> [ 'ticket'; 'kiosk'; 'things//p'; 'booth'; ];
Array name_array116 --> [ 'hell'; 'ride'; 'ticket'; 'tickets//p'; ];
Array name_array117 --> [ 'cashier'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array118 --> [ 'fortune'; 'teller'; 'ticket'; 'ride//p'; 'tickets//p'; ];
Array name_array119 --> [ 'ferris'; 'wheel'; 'ticket'; 'ride//p'; 'tickets//p'; ];
Array name_array120 --> [ 'bumper'; 'cars'; 'ticket'; 'ride//p'; 'tickets//p'; ];
Array name_array121 --> [ 'carousel'; 'ticket'; 'ride//p'; 'tickets//p'; ];
Array name_array122 --> [ 'signboard'; 'things//p'; 'sign'; ];
Array name_array123 --> [ 'treats'; 'things//p'; 'treat'; ];
Array name_array124 --> [ 'menu'; 'things//p'; 'sign'; ];
Array name_array125 --> [ 'soda'; 'can'; 'fluid//p'; 'containers//p'; 'soda'; 'cola'; 'coke'; 'of'; ];
Array name_array126 --> [ 'bubblegum'; 'things//p'; ];
Array name_array127 --> [ 'bucket'; 'of'; 'popcorn'; 'things//p'; ];
Array name_array128 --> [ 'candy'; 'apple'; 'things//p'; ];
Array name_array129 --> [ 'cotton'; 'candy'; 'things//p'; ];
Array name_array130 --> [ 'soft'; 'pretzel'; 'things//p'; ];
Array name_array131 --> [ 'pitcher^s'; 'mound'; 'rooms//p'; ];
Array name_array132 --> [ 'ferris'; 'wheel'; 'ride'; 'rooms//p'; ];
Array name_array133 --> [ 'dime'; 'toss'; 'game'; 'rooms//p'; ];
Array name_array134 --> [ 'markings'; 'things//p'; 'marking'; 'sign'; 'signs'; ];
Array name_array135 --> [ 'teddy'; 'bear'; 'things//p'; ];
Array name_array136 --> [ 'screwdriver'; 'things//p'; ];
Array name_array137 --> [ 'awl'; 'things//p'; ];
Array name_array138 --> [ 'fingernail'; 'clippers'; 'things//p'; ];
Array name_array139 --> [ 'can'; 'opener'; 'things//p'; ];
Array name_array140 --> [ 'corkscrew'; 'things//p'; ];
Array name_array141 --> [ 'poster'; 'of'; 'taylor'; 'swift'; 'things//p'; ];
Array name_array142 --> [ 'lever'; 'things//p'; 'bullseye'; 'striker'; 'target'; ];
Array name_array143 --> [ 'mallet'; 'things//p'; 'hammer'; ];
Array name_array144 --> [ 'bell'; 'things//p'; ];
Array name_array145 --> [ 'dime'; 'toss'; 'booth'; 'things//p'; ];
Array name_array146 --> [ 'mercury'; 'dime'; 'dimes//p'; 'shiny'; ];
Array name_array147 --> [ 'small'; 'plush'; 'monkey'; 'things//p'; 'stuffie'; 'stuffed'; ];
Array name_array148 --> [ 'poster'; 'of'; 'billie'; 'eilish'; 'things//p'; ];
Array name_array149 --> [ 'small'; 'pocket'; 'mirror'; 'things//p'; ];
Array name_array150 --> [ 'plate'; 'supporters//p'; 'plates'; ];
Array name_array151 --> [ 'small'; 'plush'; 'donkey'; 'things//p'; 'stuffie'; 'stuffed'; ];
Array name_array152 --> [ 'poster'; 'of'; 'lourde'; 'things//p'; ];
Array name_array153 --> [ 'goldfish'; 'things//p'; 'bowl'; ];
Array name_array154 --> [ 'baseball'; 'baseballs//p'; 'ball'; ];
Array name_array155 --> [ 'baseball'; 'baseballs//p'; 'ball'; ];
Array name_array156 --> [ 'baseball'; 'baseballs//p'; 'ball'; ];
Array name_array157 --> [ 'milk'; 'bottles'; 'things//p'; 'bottle'; ];
Array name_array158 --> [ 'show'; 'tent'; 'rooms//p'; ];
Array name_array159 --> [ 'sign'; 'things//p'; ];
Array name_array160 --> [ 'barker'; 'people//p'; 'attendant'; 'attendent'; 'operator'; ];
Array name_array161 --> [ 'little'; 'egypt'; 'women//p'; ];
Array name_array162 --> [ 'sheer'; 'veil'; 'things//p'; ];
Array name_array163 --> [ 'stage'; 'things//p'; ];
Array name_array164 --> [ 'wall'; 'containers//p'; ];
Array name_array165 --> [ 'lantern'; 'electric//p'; 'lamps//p'; 'lamp'; ];
Array name_array166 --> [ 'folding'; 'chair'; 'supporters//p'; ];
Array name_array167 --> [ 'ferris'; 'wheel'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array168 --> [ 'bumper'; 'cars'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array169 --> [ 'two'; 'dollar'; 'bill'; 'things//p'; 'bill'; ];
Array name_array170 --> [ 'mysterious'; 'woman'; 'women//p'; ];
Array name_array171 --> [ 'carousel'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array172 --> [ 'ride'; 'entrance'; 'rooms//p'; ];
Array name_array173 --> [ 'hell'; 'ride'; 'attendant'; 'attendants//p'; 'attendent'; 'operator'; 'teen'; 'teenager'; 'bored'; ];
Array name_array174 --> [ 'dark'; 'passage'; 'rooms//p'; ];
Array name_array175 --> [ 'dust'; 'bunnies'; 'things//p'; 'bunnies'; ];
Array name_array176 --> [ 'bags'; 'of'; 'trash'; 'things//p'; 'bags'; 'trash'; ];
Array name_array177 --> [ 'pile'; 'of'; 'junk'; 'containers//p'; 'piles'; 'junk'; ];
Array name_array178 --> [ 'flashlight'; 'electric//p'; 'lamps//p'; ];
Array name_array179 --> [ 'maintenance'; 'office'; 'rooms//p'; ];
Array name_array180 --> [ 'screws'; 'things//p'; ];
Array name_array181 --> [ 'paint'; 'cans'; 'things//p'; ];
Array name_array182 --> [ 'grease'; 'jars'; 'things//p'; ];
Array name_array183 --> [ 'vise'; 'things//p'; ];
Array name_array184 --> [ 'bent'; 'piece'; 'of'; 'metal'; 'things//p'; ];
Array name_array185 --> [ 'safety'; 'posters'; 'things//p'; ];
Array name_array186 --> [ 'notes'; 'things//p'; ];
Array name_array187 --> [ 'clock'; 'things//p'; ];
Array name_array188 --> [ 'lubricant'; 'things//p'; ];
Array name_array189 --> [ 'manual'; 'things//p'; ];
Array name_array190 --> [ 'stool'; 'supporters//p'; ];
Array name_array191 --> [ 'worn'; 'photo'; 'things//p'; 'picture'; ];
Array name_array192 --> [ 'coffee'; 'mug'; 'things//p'; 'coffee'; ];
Array name_array193 --> [ 'desk'; 'supporters//p'; ];
Array name_array194 --> [ 'drawer'; 'containers//p'; ];
Array name_array195 --> [ 'radio'; 'devices//p'; ];
Array name_array196 --> [ 'scissors'; 'things//p'; ];
Array name_array197 --> [ 'stapler'; 'things//p'; ];
Array name_array198 --> [ 'ballpoint'; 'pen'; 'things//p'; ];
Array name_array199 --> [ 'pad'; 'of'; 'paper'; 'things//p'; ];
Array name_array200 --> [ 'door1'; 'wooden//p'; 'doors//p'; ];
Array name_array201 --> [ 'stocks'; 'room'; 'rooms//p'; ];
Array name_array202 --> [ 'ladder'; 'doors//p'; ];
Array name_array203 --> [ 'dark'; 'hallway'; 'rooms//p'; ];
Array name_array204 --> [ 'crawl'; 'space'; 'rooms//p'; ];
Array name_array205 --> [ 'door3'; 'wooden//p'; 'doors//p'; ];
Array name_array206 --> [ 'gallows'; 'room'; 'rooms//p'; ];
Array name_array207 --> [ 'mechanical'; 'room'; 'north'; 'rooms//p'; ];
Array name_array208 --> [ 'toolbox'; 'containers//p'; 'tool'; 'box'; ];
Array name_array209 --> [ 'adjustable'; 'wrench'; 'things//p'; ];
Array name_array210 --> [ 'channel'; 'locks'; 'things//p'; ];
Array name_array211 --> [ 'pliers'; 'things//p'; ];
Array name_array212 --> [ 'hammer'; 'things//p'; ];
Array name_array213 --> [ 'hydraulic'; 'pump'; 'things//p'; ];
Array name_array214 --> [ 'gauges'; 'things//p'; ];
Array name_array215 --> [ 'tools'; 'things//p'; ];
Array name_array216 --> [ 'bench'; 'things//p'; 'workbench'; ];
Array name_array217 --> [ 'wires'; 'things//p'; ];
Array name_array218 --> [ 'spare'; 'parts'; 'things//p'; ];
Array name_array219 --> [ 'hydraulic'; 'tubing'; 'things//p'; ];
Array name_array220 --> [ 'diagram'; 'things//p'; ];
Array name_array221 --> [ 'door5'; 'wooden//p'; 'doors//p'; ];
Array name_array222 --> [ 'stake'; 'room'; 'rooms//p'; ];
Array name_array223 --> [ 'mechanical'; 'room'; 'south'; 'rooms//p'; ];
Array name_array224 --> [ 'lights'; 'things//p'; ];
Array name_array225 --> [ 'thick'; 'belts'; 'things//p'; ];
Array name_array226 --> [ 'pulleys'; 'things//p'; ];
Array name_array227 --> [ 'gears'; 'things//p'; ];
Array name_array228 --> [ 'table'; 'things//p'; ];
Array name_array229 --> [ 'bolts'; 'things//p'; ];
Array name_array230 --> [ 'lubricants'; 'things//p'; ];
Array name_array231 --> [ 'cooling'; 'fan'; 'things//p'; ];
Array name_array232 --> [ 'grate'; 'doors//p'; ];
Array name_array233 --> [ 'holding'; 'room'; 'rooms//p'; ];
Array name_array234 --> [ 'door7'; 'wooden//p'; 'doors//p'; ];
Array name_array235 --> [ 'dungeon'; 'rooms//p'; ];
Array name_array236 --> [ 'graffiti'; 'things//p'; ];
Array name_array237 --> [ 'junction'; 'boxes'; 'things//p'; ];
Array name_array238 --> [ 'cables'; 'things//p'; ];
Array name_array239 --> [ 'circuit'; 'breakers'; 'things//p'; ];
Array name_array240 --> [ 'filters'; 'things//p'; ];
Array name_array241 --> [ 'spark'; 'plugs'; 'things//p'; ];
Array name_array242 --> [ 'wire'; 'coils'; 'things//p'; ];
Array name_array243 --> [ 'grease'; 'canister'; 'things//p'; ];
Array name_array244 --> [ 'diesel'; 'canisters'; 'things//p'; ];
Array name_array245 --> [ 'maintenance'; 'manual'; 'things//p'; ];
Array name_array246 --> [ 'large'; 'panel'; 'things//p'; ];
Array name_array247 --> [ 'door9'; 'wooden//p'; 'doors//p'; ];
Array name_array248 --> [ 'guillotine'; 'room'; 'rooms//p'; ];
Array name_array249 --> [ 'supplies'; 'things//p'; ];
Array name_array250 --> [ 'boxes'; 'of'; 'lightbulbs'; 'things//p'; ];
Array name_array251 --> [ 'spools'; 'of'; 'wire'; 'things//p'; ];
Array name_array252 --> [ 'ride'; 'parts'; 'things//p'; ];
Array name_array253 --> [ 'flags'; 'things//p'; ];
Array name_array254 --> [ 'seats'; 'things//p'; ];
Array name_array255 --> [ 'booths'; 'things//p'; ];
Array name_array256 --> [ 'horse'; 'things//p'; ];
Array name_array257 --> [ 'wire'; 'scraps'; 'things//p'; ];
Array name_array258 --> [ 'rats'; 'things//p'; ];
Array name_array259 --> [ 'door11'; 'wooden//p'; 'doors//p'; ];
Array name_array260 --> [ 'ride'; 'exit'; 'rooms//p'; ];
Array name_array261 --> [ 'hell'; 'ride'; 'car'; 'vehicles//p'; ];
Array name_array262 --> [ 'stakes'; 'things//p'; ];
Array name_array263 --> [ 'chains'; 'things//p'; ];
Array name_array264 --> [ 'rack'; 'things//p'; ];
Array name_array265 --> [ 'brazier'; 'things//p'; ];
Array name_array266 --> [ 'riveted'; 'iron-bound'; 'door'; 'things//p'; ];
Array name_array267 --> [ 'plastic'; 'bones'; 'things//p'; ];
Array name_array268 --> [ 'devil'; 'horns'; 'things//p'; ];
Array name_array269 --> [ 't-shirt'; 'things//p'; 't-shirts'; ];
Array name_array270 --> [ 'control'; 'room'; 'rooms//p'; ];
Array name_array271 --> [ 'big'; 'switch'; 'devices//p'; ];
Array name_array272 --> [ 'cluttered'; 'desk'; 'things//p'; ];
Array name_array273 --> [ 'cork'; 'board'; 'things//p'; ];
Array name_array274 --> [ 'charts'; 'things//p'; ];
Array name_array275 --> [ 'control'; 'panel'; 'one'; 'panels//p'; 'control'; 'panel'; ];
Array name_array276 --> [ 'control'; 'panel'; 'three'; 'panels//p'; 'control'; 'panel'; ];
Array name_array277 --> [ 'control'; 'panel'; 'five'; 'panels//p'; 'control'; 'panel'; ];
Array name_array278 --> [ 'control'; 'panel'; 'seven'; 'panels//p'; 'control'; 'panel'; ];
Array name_array279 --> [ 'control'; 'panel'; 'nine'; 'panels//p'; 'control'; 'panel'; ];
Array name_array280 --> [ 'control'; 'panel'; 'eleven'; 'panels//p'; 'control'; 'panel'; ];
Array name_array281 --> [ 'control'; 'panel'; 'one^s'; 'button'; 'buttons//p'; ];
Array name_array282 --> [ 'control'; 'panel'; 'three^s'; 'button'; 'buttons//p'; ];
Array name_array283 --> [ 'control'; 'panel'; 'five^s'; 'button'; 'buttons//p'; ];
Array name_array284 --> [ 'control'; 'panel'; 'seven^s'; 'button'; 'buttons//p'; ];
Array name_array285 --> [ 'control'; 'panel'; 'nine^s'; 'button'; 'buttons//p'; ];
Array name_array286 --> [ 'control'; 'panel'; 'eleven^s'; 'button'; 'buttons//p'; ];
Array name_array287 --> [ 'control'; 'panel'; 'one^s'; 'dial'; 'dials//p'; ];
Array name_array288 --> [ 'control'; 'panel'; 'three^s'; 'dial'; 'dials//p'; ];
Array name_array289 --> [ 'control'; 'panel'; 'five^s'; 'dial'; 'dials//p'; ];
Array name_array290 --> [ 'control'; 'panel'; 'seven^s'; 'dial'; 'dials//p'; ];
Array name_array291 --> [ 'control'; 'panel'; 'nine^s'; 'dial'; 'dials//p'; ];
Array name_array292 --> [ 'control'; 'panel'; 'eleven^s'; 'dial'; 'dials//p'; ];
Array name_array293 --> [ 'control'; 'panel'; 'one^s'; 'light'; 'lights//p'; ];
Array name_array294 --> [ 'control'; 'panel'; 'three^s'; 'light'; 'lights//p'; ];
Array name_array295 --> [ 'control'; 'panel'; 'five^s'; 'light'; 'lights//p'; ];
Array name_array296 --> [ 'control'; 'panel'; 'seven^s'; 'light'; 'lights//p'; ];
Array name_array297 --> [ 'control'; 'panel'; 'nine^s'; 'light'; 'lights//p'; ];
Array name_array298 --> [ 'control'; 'panel'; 'eleven^s'; 'light'; 'lights//p'; ];
Array name_array299 --> [ 'monitor'; 'things//p'; 'screen'; ];
Array name_array300 --> [ 'midway'; 'regions//p'; ];
Array name_array301 --> [ 'hellride'; 'regions//p'; ];
Array name_array302 --> [ 'electrical'; 'area'; 'regions//p'; ];
Array name_array303 --> [ 'back'; 'stage'; 'regions//p'; ];
Array name_array304 --> [ 'second'; 'floor'; 'regions//p'; ];
Array ts_array_U709 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2901; ];
Array ts_array_U710 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2902; ];
Array bc_U2138 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U855; ];
Array bc_U2139 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U856; ];
Array ts_array_U711 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U2903; ];
Array LocalParking --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array PowersOfTwo_TB --> [ 2048; 1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1; ];
Array IncreasingPowersOfTwo_TB --> [ 1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768; ];
Array EMPTY_TEXT_VALUE --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array TheEmptyTable --> [ 0; 0; ];
Array blockv_stack --> 32768; ! blank with extent 32768
Array Protect_I7_Arrays --> [ 16339; 12345; ];
Array I7_SOO_SHUF -> 32; ! blank with extent 32
Array gg_event --> 4; ! blank with extent 4
Array gg_arguments buffer 28; ! blank with extent 28
Array buffer buffer 260; ! blank with extent 260
Array buffer2 buffer 260; ! blank with extent 260
Array buffer3 buffer 260; ! blank with extent 260
Array parse --> 61; ! blank with extent 61
Array parse2 --> 61; ! blank with extent 61
Array gg_tokenbuf -> 25; ! blank with extent 25
Array AnyToStrArr -> 67; ! blank with extent 67
Array PowersOfTen --> [ 1; 10; 100; 1000; 10000; 100000; 1000000; 10000000; 100000000; 1000000000; ];
Array CheckTableEntryIsBlank_LU -> [ 1; 2; 4; 8; 16; 32; 64; 128; ];
Array CheckTableEntryIsNonBlank_LU -> [ 254; 253; 251; 247; 239; 223; 191; 127; ];
Array MStack --> 160; ! blank with extent 160
Array latest_rule_result --> 3; ! blank with extent 3
Array Flex_Heap -> 524308; ! blank with extent 524308
Array TEXT_TY_Buffers --> 8202; ! blank with extent 8202
Array CharCasingChart0 --> [ 97; 26; -32; 170; 1; UNIC_NCT; 181; 1; 743; 186; 1; UNIC_NCT; 223; 1; UNIC_NCT; 224; 23; -32; 248; 7; -32; 255; 1; 121; 257; -47; -1; 305; 1; -232; 307; -5; -1; 312; 1; UNIC_NCT; 314; -15; -1; 329; 1; UNIC_NCT; 331; -45; -1; 378; -5; -1; 383; 1; -300; 384; 1; UNIC_NCT; 387; -3; -1; 392; 1; -1; 396; 1; -1; 397; 1; UNIC_NCT; 402; 1; -1; 405; 1; 97; 409; 1; -1; 410; 2; UNIC_NCT; 414; 1; 130; 417; -5; -1; 424; 1; -1; 426; 2; UNIC_NCT; 429; 1; -1; 432; 1; -1; 436; -3; -1; 441; 1; -1; 442; 1; UNIC_NCT; 445; 1; -1; 446; 1; UNIC_NCT; 447; 1; 56; 454; 1; -2; 457; 1; -2; 460; 1; -2; 462; -15; -1; 477; 1; -79; 479; -17; -1; 496; 1; UNIC_NCT; 499; 1; -2; 501; 1; -1; 505; -39; -1; 545; 1; UNIC_NCT; 547; -17; -1; 564; 3; UNIC_NCT; 592; 3; UNIC_NCT; 595; 1; -210; 596; 1; -206; 597; 1; UNIC_NCT; 598; 2; -205; 600; 1; UNIC_NCT; 601; 1; -202; 602; 1; UNIC_NCT; 603; 1; -203; 604; 4; UNIC_NCT; 608; 1; -205; 609; 2; UNIC_NCT; 611; 1; -207; 612; 4; UNIC_NCT; 616; 1; -209; 617; 1; -211; 618; 5; UNIC_NCT; 623; 1; -211; 624; 2; UNIC_NCT; 626; 1; -213; 627; 2; UNIC_NCT; 629; 1; -214; 630; 10; UNIC_NCT; 640; 1; -218; 641; 2; UNIC_NCT; 643; 1; -218; 644; 4; UNIC_NCT; 648; 1; -218; 649; 1; UNIC_NCT; 650; 2; -217; 652; 6; UNIC_NCT; 658; 1; -219; 659; 29; UNIC_NCT; 912; 1; UNIC_NCT; 940; 1; -38; 941; 3; -37; 944; 1; UNIC_NCT; 945; 17; -32; 962; 1; -31; 963; 9; -32; 972; 1; -64; 973; 2; -63; 976; 1; -62; 977; 1; -57; 981; 1; -47; 982; 1; -54; 983; 1; UNIC_NCT; 985; -23; -1; 1008; 1; -86; 1009; 1; -80; 1010; 1; 7; 1011; 1; UNIC_NCT; 1013; 1; -96; 1016; 1; -1; 1019; 1; -1; 1072; 32; -32; 1104; 16; -80; 1121; -33; -1; 1163; -53; -1; 1218; -13; -1; 1233; -37; -1; 1273; 1; -1; 1281; -15; -1; 1377; 38; -48; 1415; 1; UNIC_NCT; 7424; 44; UNIC_NCT; 7522; 10; UNIC_NCT; 7681; -149; -1; 7830; 5; UNIC_NCT; 7835; 1; -59; 7841; -89; -1; 7936; 8; 8; 7952; 6; 8; 7968; 8; 8; 7984; 8; 8; 8000; 6; 8; 8016; 1; UNIC_NCT; 8017; 1; 8; 8018; 1; UNIC_NCT; 8019; 1; 8; 8020; 1; UNIC_NCT; 8021; 1; 8; 8022; 1; UNIC_NCT; 8023; 1; 8; 8032; 8; 8; 8048; 2; 74; 8050; 4; 86; 8054; 2; 100; 8056; 2; 128; 8058; 2; 112; 8060; 2; 126; 8064; 8; 8; 8080; 8; 8; 8096; 8; 8; 8112; 2; 8; 8114; 1; UNIC_NCT; 8115; 1; 9; 8116; -3; UNIC_NCT; 8119; 1; UNIC_NCT; 8126; 1; -7205; 8130; 1; UNIC_NCT; 8131; 1; 9; 8132; -3; UNIC_NCT; 8135; 1; UNIC_NCT; 8144; 2; 8; 8146; 2; UNIC_NCT; 8150; 2; UNIC_NCT; 8160; 2; 8; 8162; 3; UNIC_NCT; 8165; 1; 7; 8166; 2; UNIC_NCT; 8178; 1; UNIC_NCT; 8179; 1; 9; 8180; -3; UNIC_NCT; 8183; 1; UNIC_NCT; 8305; 1; UNIC_NCT; 8319; 1; UNIC_NCT; 8458; 1; UNIC_NCT; 8462; 2; UNIC_NCT; 8467; 1; UNIC_NCT; 8495; 1; UNIC_NCT; 8500; 1; UNIC_NCT; 8505; 1; UNIC_NCT; 8509; 1; UNIC_NCT; 8518; 4; UNIC_NCT; 64256; 7; UNIC_NCT; 64275; 5; UNIC_NCT; 65345; 26; -32; 0; ];
Array CharCasingChart1 --> [ 65; 26; 32; 192; 23; 32; 216; 7; 32; 256; -47; 1; 304; 1; -199; 306; -5; 1; 313; -15; 1; 330; -45; 1; 376; 1; -121; 377; -5; 1; 385; 1; 210; 386; -3; 1; 390; 1; 206; 391; 1; 1; 393; 2; 205; 395; 1; 1; 398; 1; 79; 399; 1; 202; 400; 1; 203; 401; 1; 1; 403; 1; 205; 404; 1; 207; 406; 1; 211; 407; 1; 209; 408; 1; 1; 412; 1; 211; 413; 1; 213; 415; 1; 214; 416; -5; 1; 422; 1; 218; 423; 1; 1; 425; 1; 218; 428; 1; 1; 430; 1; 218; 431; 1; 1; 433; 2; 217; 435; -3; 1; 439; 1; 219; 440; 1; 1; 444; 1; 1; 452; 1; 2; 455; 1; 2; 458; 1; 2; 461; -15; 1; 478; -17; 1; 497; 1; 2; 500; 1; 1; 502; 1; -97; 503; 1; -56; 504; -39; 1; 544; 1; -130; 546; -17; 1; 902; 1; 38; 904; 3; 37; 908; 1; 64; 910; 2; 63; 913; 17; 32; 931; 9; 32; 978; 3; UNIC_NCT; 984; -23; 1; 1012; 1; -60; 1015; 1; 1; 1017; 1; -7; 1018; 1; 1; 1024; 16; 80; 1040; 32; 32; 1120; -33; 1; 1162; -53; 1; 1216; 1; UNIC_NCT; 1217; -13; 1; 1232; -37; 1; 1272; 1; 1; 1280; -15; 1; 1329; 38; 48; 4256; 38; UNIC_NCT; 7680; -149; 1; 7840; -89; 1; 7944; 8; -8; 7960; 6; -8; 7976; 8; -8; 7992; 8; -8; 8008; 6; -8; 8025; -7; -8; 8040; 8; -8; 8120; 2; -8; 8122; 2; -74; 8136; 4; -86; 8152; 2; -8; 8154; 2; -100; 8168; 2; -8; 8170; 2; -112; 8172; 1; -7; 8184; 2; -128; 8186; 2; -126; 8450; 1; UNIC_NCT; 8455; 1; UNIC_NCT; 8459; 3; UNIC_NCT; 8464; 3; UNIC_NCT; 8469; 1; UNIC_NCT; 8473; 5; UNIC_NCT; 8484; 1; UNIC_NCT; 8486; 1; -7517; 8488; 1; UNIC_NCT; 8490; 1; -8383; 8491; 1; -8262; 8492; 2; UNIC_NCT; 8496; 2; UNIC_NCT; 8499; 1; UNIC_NCT; 8510; 2; UNIC_NCT; 8517; 1; UNIC_NCT; 65313; 26; 32; 0; ];
Array RE_PACKET_space --> 448; ! blank with extent 448
Array RE_Subexpressions --> 11; ! blank with extent 11
Array Allocated_Match_Vars --> 10; ! blank with extent 10
Array Subexp_Posns --> 20; ! blank with extent 20
Array RTP_Buffer --> [ -1; 0; 0; 0; 0; 0; 0; ];
Array LanguagePronouns table [ 'it'; 568; NULL; 'him'; 2048; NULL; 'her'; 1024; NULL; 'them'; 455; NULL; ];
Array LanguageDescriptors table [ 'my'; 4095; POSSESS_PK; 0; 'this'; 4095; POSSESS_PK; 0; 'these'; 455; POSSESS_PK; 0; 'that'; 4095; POSSESS_PK; 1; 'those'; 455; POSSESS_PK; 1; 'his'; 4095; POSSESS_PK; 'him'; 'her'; 4095; POSSESS_PK; 'her'; 'their'; 4095; POSSESS_PK; 'them'; 'its'; 4095; POSSESS_PK; 'it'; 'the'; 4095; DEFART_PK; NULL; 'a//'; 3640; INDEFART_PK; NULL; 'an'; 3640; INDEFART_PK; NULL; 'some'; 455; INDEFART_PK; NULL; 'lit'; 4095; LIGHTED_PK; NULL; 'lighted'; 4095; LIGHTED_PK; NULL; 'unlit'; 4095; UNLIGHTED_PK; NULL; ];
Array LanguageNumbers table [ 'one'; 1; 'two'; 2; 'three'; 3; 'four'; 4; 'five'; 5; 'six'; 6; 'seven'; 7; 'eight'; 8; 'nine'; 9; 'ten'; 10; 'eleven'; 11; 'twelve'; 12; 'thirteen'; 13; 'fourteen'; 14; 'fifteen'; 15; 'sixteen'; 16; 'seventeen'; 17; 'eighteen'; 18; 'nineteen'; 19; 'twenty'; 20; 'twenty-one'; 21; 'twenty-two'; 22; 'twenty-three'; 23; 'twenty-four'; 24; 'twenty-five'; 25; 'twenty-six'; 26; 'twenty-seven'; 27; 'twenty-eight'; 28; 'twenty-nine'; 29; 'thirty'; 30; ];
Array LanguageArticles --> [ "The "; "the "; "a "; "The "; "the "; "an "; "The "; "the "; "some "; "The "; "the "; "some "; ];
Array LanguageGNAsToArticles --> [ 0; 0; 0; 1; 1; 1; 0; 0; 0; 1; 1; 1; ];
Array scene_started --> 5; ! blank with extent 5
Array scene_ended --> 5; ! blank with extent 5
Array scene_status --> 5; ! blank with extent 5
Array scene_endings --> 5; ! blank with extent 5
Array scene_latest_ending --> 5; ! blank with extent 5
Array multiple_object --> 300; ! blank with extent 300
Array parser_results --> 16; ! blank with extent 16
Array requisition_stack --> 915; ! blank with extent 915
Array LWI_Storage --> [ 1; -1; Computed_Constant_Value_4_U2; ];
Array Details_of_Specific_Action --> 5; ! blank with extent 5
Array activities_stack --> 20; ! blank with extent 20
Array activity_parameters_stack --> 20; ! blank with extent 20
Array ResourceUsageFlags -> 35; ! blank with extent 35
Array T_SL_Score_Moves --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Score_Moves; ];
Array T_SL_Location --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Location; ];
Array StorageForShortName buffer 250; ! blank with extent 250
Array DoorRoutingViable -> 9; ! blank with extent 9
Array FWMatrix --> 1369; ! blank with extent 1369
Array test_stack --> 128; ! blank with extent 128
Array TimesActionHasHappened --> 7; ! blank with extent 7
Array TurnsActionHasBeenHappening --> 7; ! blank with extent 7
Array LastTurnActionHappenedOn --> 7; ! blank with extent 7
Array ActionCurrentlyHappeningFlag -> 7; ! blank with extent 7
Array past_chronological_record --> 4; ! blank with extent 4
Array present_chronological_record --> 4; ! blank with extent 4
Array SAT_Tmp --> 7; ! blank with extent 7
Array pattern --> 32; ! blank with extent 32
Array pattern2 --> 32; ! blank with extent 32
Array line_ttype --> 32; ! blank with extent 32
Array line_tdata --> 32; ! blank with extent 32
Array line_token --> 32; ! blank with extent 32
Array oops_workspace -> 64; ! blank with extent 64
Array match_list --> 300; ! blank with extent 300
Array match_classes --> 300; ! blank with extent 300
Array match_scores --> 300; ! blank with extent 300
Array alt_match_list --> 301; ! blank with extent 301
Array KOVP_0 table [ 0; 0; 1; 0; 0; ];
Array KOVP_1 table [ 0; 0; bc_U230; bc_U1095; bc_U1607; ];
Array KOVP_2 table [ 0; 0; I_first_person_plural_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; ];
Array value_ranges --> 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Array value_property_holders --> 0 0 VPH_2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 VPH_53 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Class K0_kind
    has ~pluralname
    has ~proper
    with short_name bc_U1
    with plural bc_U2
    with article bc_U3
    has ~ambigpluralname
    with list_together bc_U4
;
Class K1_room
  class K0_kind
    with description bc_U241
    with map_region 0
    has ~privately_named
    has light
    has ~visited
    has P_indoors
    with short_name bc_U242
    with plural bc_U243
    with article bc_U244
    with list_together bc_U245
;
Class K25_electrical_closet
  class K1_room
    with description bc_U1795
    with short_name bc_U1796
    with plural bc_U1797
    with article bc_U1798
    with list_together bc_U1799
;
Class K2_thing
  class K0_kind
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    with P_price 0
    with component_parent 0
    with component_child 0
    with component_sibling 0
    with action_bitmap 0 0 0 0 0 0 0
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description bc_U246
    with initial bc_U247
    with with_key 0
    with P_unbolting_relation_storage 0
    with P_underlying_relation_storag 0
    with P_tossing_relation_storage 0
    with short_name bc_U248
    with plural bc_U249
    with article bc_U250
    with list_together bc_U251
;
Class K6_supporter
  class K2_thing
    with plural bc_U267
    with capacity 100
    has static
    has transparent
    has ~enterable
    with description bc_U268
    with initial bc_U269
    with short_name bc_U270
    with article bc_U271
    with list_together bc_U272
;
Class K17_keychain
  class K6_supporter
    with plural bc_U341
    has ~static
    with description bc_U342
    with initial bc_U343
    with short_name bc_U344
    with article bc_U345
    with list_together bc_U346
;
Class K8_person
  class K2_thing
    with plural bc_U279
    with capacity 100
    has transparent
    has ~female
    has ~neuter
    with description bc_U280
    with initial bc_U281
    with short_name bc_U282
    with article bc_U283
    with list_together bc_U284
;
Class K10_man
  class K8_person
    with plural bc_U289
    has ~female
    has ~neuter
    with description bc_U290
    with initial bc_U291
    with short_name bc_U292
    with article bc_U293
    with list_together bc_U294
;
Class K11_woman
  class K8_person
    with plural bc_U295
    has female
    has ~neuter
    with description bc_U296
    with initial bc_U297
    with short_name bc_U298
    with article bc_U299
    with list_together bc_U300
;
Class K12_animal
  class K8_person
    with plural bc_U301
    with description bc_U302
    with initial bc_U303
    with short_name bc_U304
    with article bc_U305
    with list_together bc_U306
;
Class K20_attendant
  class K8_person
    with plural bc_U1767
    has ~female
    with parse_name parse_name325
    with description bc_U1768
    with initial bc_U1769
    with short_name bc_U1770
    with article bc_U1771
    with list_together bc_U1772
;
Class K4_door
  class K2_thing
    with plural bc_U256
    with initial ts_array_U472
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to 0
    with with_key 0
    with description bc_U257
    with short_name bc_U258
    with article bc_U259
    with list_together bc_U260
;
Class K33_wooden_door
  class K4_door
    with short_name ts_array_U626
    with plural bc_U1833
    with description ts_array_U627
    has ~open
    has openable
    has lockable
    has locked
    with P_color I_nondescript_U1
    with initial ts_array_U628
    with article bc_U1834
    with list_together bc_U1835
;
Class K5_container
  class K2_thing
    with plural bc_U261
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key 0
    with description bc_U262
    with initial bc_U263
    with short_name bc_U264
    with article bc_U265
    with list_together bc_U266
;
Class K14_vehicle
  class K5_container
    with plural bc_U313
    has static
    has enterable
    with description bc_U314
    with initial bc_U315
    with short_name bc_U316
    with article bc_U317
    with list_together bc_U318
;
Class K15_player_s_holdall
  class K5_container
    with plural bc_U319
    has ~static
    has openable
    with description bc_U320
    with initial bc_U321
    with short_name bc_U322
    with article bc_U323
    with list_together bc_U324
;
Class K18_fluid_container
  class K5_container
    with plural bc_U1755
    with P_fluid_capacity 120
    with P_current_volume 0
    with parse_name parse_name323
    with P_liquid I_water_U1
    with description bc_U1756
    with initial bc_U1757
    with short_name bc_U1758
    with article bc_U1759
    with list_together bc_U1760
;
Class K26_electrical_panel
  class K5_container
    with short_name ts_array_U617
    with plural bc_U1800
    with description ts_array_U618
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with parse_name parse_name331
    with P_color I_nondescript_U1
    with P_panel_id 0
    with initial bc_U1801
    with article bc_U1802
    with list_together bc_U1803
;
Class K27_socket
  class K5_container
    with short_name ts_array_U619
    with plural bc_U1804
    with description ts_array_U620
    with capacity 1
    has static
    has open
    with parse_name parse_name332
    with initial bc_U1805
    with article bc_U1806
    with list_together bc_U1807
;
Class K34_control_panel
  class K5_container
    with plural bc_U1836
    has scenery
    has open
    with parse_name parse_name339
    with P_color I_nondescript_U1
    with P_panel_id 0
    with description bc_U1837
    with initial bc_U1838
    with short_name bc_U1839
    with article bc_U1840
    with list_together bc_U1841
;
Class K7_backdrop
  class K2_thing
    with plural bc_U273
    has static
    has scenery
    has ~pushable
    with description bc_U274
    with initial bc_U275
    with short_name bc_U276
    with article bc_U277
    with list_together bc_U278
;
Class K13_device
  class K2_thing
    with plural bc_U307
    has ~on
    with description bc_U308
    with initial bc_U309
    with short_name bc_U310
    with article bc_U311
    with list_together bc_U312
;
Class K19_electric_lamp
  class K13_device
    with plural bc_U1761
    with description bc_U1762
    with initial bc_U1763
    with short_name bc_U1764
    with article bc_U1765
    with list_together bc_U1766
;
Class K30_switch
  class K13_device
    with plural bc_U1816
    with description ts_array_U625
    has static
    has ~on
    with parse_name parse_name335
    with initial bc_U1817
    with short_name bc_U1818
    with article bc_U1819
    with list_together bc_U1820
;
Class K35_button
  class K13_device
    with short_name ts_array_U629
    with plural bc_U1842
    with description ts_array_U630
    has static
    has ~on
    with parse_name parse_name340
    with initial bc_U1843
    with article bc_U1844
    with list_together bc_U1845
;
Class K16_passkey
  class K2_thing
    with plural bc_U335
    with description bc_U336
    with initial bc_U337
    with short_name bc_U338
    with article bc_U339
    with list_together bc_U340
;
Class K21_coin
  class K2_thing
    with plural bc_U1773
    with parse_name parse_name326
    with description bc_U1774
    with initial bc_U1775
    with short_name bc_U1776
    with article bc_U1777
    with list_together bc_U1778
;
Class K22_nickel
  class K21_coin
    with plural bc_U1779
    with description bc_U1780
    with initial bc_U1781
    with short_name bc_U1782
    with article bc_U1783
    with list_together bc_U1784
;
Class K23_dime
  class K21_coin
    with plural bc_U1785
    with description ts_array_U615
    with initial bc_U1786
    with short_name bc_U1787
    with article bc_U1788
    with list_together bc_U1789
;
Class K24_quarter
  class K21_coin
    with plural bc_U1790
    with description ts_array_U616
    with initial bc_U1791
    with short_name bc_U1792
    with article bc_U1793
    with list_together bc_U1794
;
Class K28_indicator
  class K2_thing
    with short_name ts_array_U621
    with plural bc_U1808
    with description ts_array_U622
    has static
    with parse_name parse_name333
    with initial bc_U1809
    with article bc_U1810
    with list_together bc_U1811
;
Class K29_fuse
  class K2_thing
    with short_name ts_array_U623
    with plural bc_U1812
    with description ts_array_U624
    with parse_name parse_name334
    with P_color I_nondescript_U1
    with P_fuse_id 0
    with initial bc_U1813
    with article bc_U1814
    with list_together bc_U1815
;
Class K31_ride_ticket
  class K2_thing
    with plural bc_U1821
    with description bc_U1822
    with initial bc_U1823
    with short_name bc_U1824
    with article bc_U1825
    with list_together bc_U1826
;
Class K32_baseball
  class K2_thing
    with plural bc_U1827
    with parse_name parse_name337
    with description bc_U1828
    with initial bc_U1829
    with short_name bc_U1830
    with article bc_U1831
    with list_together bc_U1832
;
Class K36_dial
  class K2_thing
    with short_name ts_array_U631
    with plural bc_U1846
    with description ts_array_U632
    has static
    with parse_name parse_name341
    with P_dial_setting 0
    with initial bc_U1847
    with article bc_U1848
    with list_together bc_U1849
;
Class K37_light
  class K2_thing
    with short_name ts_array_U633
    with plural bc_U1850
    with description ts_array_U634
    has static
    with parse_name parse_name342
    with initial bc_U1851
    with article bc_U1852
    with list_together bc_U1853
;
Class K9_region
  class K0_kind
    with plural bc_U285
    has ~privately_named
    with short_name bc_U286
    with article bc_U287
    with list_together bc_U288
;
Class K3_direction
  class K0_kind
    with plural bc_U252
    has ~privately_named
    has scenery
    has ~workflag
    with P_opposite I_north_U1
    with short_name bc_U253
    with article bc_U254
    with list_together bc_U255
;
Object Compass "(Compass object)"
    has concealed
;
Object thedark "(thedark object)"
    has concealed
;
Object VPH_53    with P_recurring KOVP_0
    with description KOVP_1
;
Object VPH_2    with P_adaptive_text_viewpoint KOVP_2
;
K3_direction I_north_U1 Compass    with short_name bc_U174
    with article bc_U175
    with P_opposite I_south_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 0
    with K3_direction_Next I_northeast_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name1
    with name 'north' 'directions//p' 'n//'
    with plural bc_U176
    with list_together bc_U177
;
K3_direction I_northeast_U1 Compass    with short_name bc_U178
    with article bc_U179
    with P_opposite I_southwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 1
    with K3_direction_Next I_northwest_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name2
    with name 'northeast' 'directions//p' 'ne'
    with plural bc_U180
    with list_together bc_U181
;
K3_direction I_northwest_U1 Compass    with short_name bc_U182
    with article bc_U183
    with P_opposite I_southeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 2
    with K3_direction_Next I_south_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name3
    with name 'northwest' 'directions//p' 'nw'
    with plural bc_U184
    with list_together bc_U185
;
K3_direction I_south_U1 Compass    with short_name bc_U186
    with article bc_U187
    with P_opposite I_north_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 3
    with K3_direction_Next I_southeast_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name4
    with name 'south' 'directions//p' 's//'
    with plural bc_U188
    with list_together bc_U189
;
K3_direction I_southeast_U1 Compass    with short_name bc_U190
    with article bc_U191
    with P_opposite I_northwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 4
    with K3_direction_Next I_southwest_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name5
    with name 'southeast' 'directions//p' 'se'
    with plural bc_U192
    with list_together bc_U193
;
K3_direction I_southwest_U1 Compass    with short_name bc_U194
    with article bc_U195
    with P_opposite I_northeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 5
    with K3_direction_Next I_east_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name6
    with name 'southwest' 'directions//p' 'sw'
    with plural bc_U196
    with list_together bc_U197
;
K3_direction I_east_U1 Compass    with short_name bc_U198
    with article bc_U199
    with P_opposite I_west_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 6
    with K3_direction_Next I_west_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name7
    with name 'east' 'directions//p' 'e//'
    with plural bc_U200
    with list_together bc_U201
;
K3_direction I_west_U1 Compass    with short_name bc_U202
    with article bc_U203
    with P_opposite I_east_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 7
    with K3_direction_Next I_up_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name8
    with name 'west' 'directions//p' 'w//'
    with plural bc_U204
    with list_together bc_U205
;
K3_direction I_up_U1 Compass    with short_name bc_U206
    with article bc_U207
    with P_opposite I_down_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 8
    with K3_direction_Next I_down_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name9
    with name 'up' 'directions//p' 'u//'
    with plural bc_U208
    with list_together bc_U209
;
K3_direction I_down_U1 Compass    with short_name bc_U210
    with article bc_U211
    with P_opposite I_up_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 9
    with K3_direction_Next in_obj
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name10
    with name 'down' 'directions//p' 'd//'
    with plural bc_U212
    with list_together bc_U213
;
K3_direction in_obj Compass    with short_name bc_U214
    with article bc_U215
    with P_opposite out_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 10
    with K3_direction_Next out_obj
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name11
    with name 'inside' 'directions//p' 'in'
    with plural bc_U216
    with list_together bc_U217
;
K3_direction out_obj Compass    with short_name bc_U218
    with article bc_U219
    with P_opposite in_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 11
    with K3_direction_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name12
    with name 'outside' 'directions//p' 'out'
    with plural bc_U220
    with list_together bc_U221
;
K1_room I_parking_lot_U1    with short_name bc_U398
    with description ts_array_U510
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 0
    with K1_room_Next I_electrical_closet_one_U1
    with name 'parking' 'lot' 'rooms//p'
    with plural bc_U399
    with article bc_U400
    with list_together bc_U401
;
K8_person -> selfobj    with short_name bc_U222
    with description bc_U223
    has proper
    has privately_named
    has concealed
    with vector 0
    with cap_short_name bc_U224
    has mark_as_thing
    has animate
    with before NULL
    with saved_short_name bc_U225
    with KD_Count 8
    with IK2_Count 0
    with K2_thing_Next I_wallet_U1
    with IK8_Count 0
    with K8_person_Next I_parking_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name13
    with initial bc_U226
    with plural bc_U227
    with article bc_U228
    with list_together bc_U229
;
K5_container -> -> I_wallet_U1    with short_name bc_U408
    has ~static
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 2
    with K2_thing_Next I_coupon_U1
    with IK5_Count 0
    with K5_container_Next I_beater_car_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wallet' 'containers//p'
    with description bc_U409
    with initial bc_U410
    with plural bc_U411
    with article bc_U412
    with list_together bc_U413
;
K2_thing -> -> -> I_coupon_U1    with short_name bc_U402
    with description bc_U403
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 1
    with K2_thing_Next I_money_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'coupon' 'things//p'
    with initial bc_U404
    with plural bc_U405
    with article bc_U406
    with list_together bc_U407
;
K2_thing -> -> -> I_money_U1    with short_name ts_array_U511
    has proper
    has ~static
    with P_price 3000
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 3
    with K2_thing_Next I_parking_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name17
    with name 'money' 'things//p' 'cash'
    with description bc_U414
    with initial bc_U415
    with plural bc_U416
    with article bc_U417
    with list_together bc_U418
;
K20_attendant -> I_parking_attendant_U1    with short_name bc_U682
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 70
    with K2_thing_Next I_parking_ticket_U1
    with IK8_Count 4
    with K8_person_Next I_cashier_U1
    with K20_attendant_Count 3
    with K20_attendant_Next I_cashier_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'parking' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U683
    with initial bc_U684
    with plural bc_U685
    with article bc_U686
    with list_together bc_U687
;
K2_thing -> -> I_parking_ticket_U1    with short_name bc_U688
    has ~static
    with P_price 500
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 71
    with K2_thing_Next I_parking_stub_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'parking' 'ticket' 'things//p'
    with description bc_U689
    with initial bc_U690
    with plural bc_U691
    with article bc_U692
    with list_together bc_U693
;
K2_thing -> -> I_parking_stub_U1    with short_name bc_U694
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 72
    with K2_thing_Next I_beater_car_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name96
    with name 'parking' 'stub' 'things//p'
    with description bc_U695
    with initial bc_U696
    with plural bc_U697
    with article bc_U698
    with list_together bc_U699
;
K5_container -> I_beater_car_U1    with short_name bc_U700
    with description ts_array_U551
    has static
    has scenery
    has enterable
    has open
    has ~openable
    with vector 0
    has mark_as_thing
    has container
    with component_child I_seat_U1
    with KD_Count 5
    with IK2_Count 73
    with K2_thing_Next I_air_freshener_U1
    with IK5_Count 15
    with K5_container_Next I_blueberry_bush_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name97
    with name 'beater' 'car' 'containers//p' 'vehicle' 'car'
    with initial bc_U701
    with plural bc_U702
    with article bc_U703
    with list_together bc_U704
;
K2_thing -> -> I_air_freshener_U1    with short_name bc_U735
    with description bc_U736
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 79
    with K2_thing_Next I_wrappers_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'air' 'freshener' 'things//p'
    with initial bc_U737
    with plural bc_U738
    with article bc_U739
    with list_together bc_U740
;
K2_thing -> I_wrappers_U1    with short_name bc_U705
    with description ts_array_U552
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 74
    with K2_thing_Next I_text_books_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wrappers' 'things//p'
    with initial bc_U706
    with plural bc_U707
    with article bc_U708
    with list_together bc_U709
;
K2_thing -> I_text_books_U1    with short_name bc_U710
    with description bc_U711
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 75
    with K2_thing_Next I_your_dirty_clothes_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name99
    with name 'text' 'books' 'things//p' 'books'
    with initial bc_U712
    with plural bc_U713
    with article bc_U714
    with list_together bc_U715
;
K2_thing -> I_your_dirty_clothes_U1    with short_name bc_U716
    with description bc_U717
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 76
    with K2_thing_Next I_blueberry_bush_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'my' 'dirty' 'clothes' 'things//p'
    with initial bc_U718
    with plural bc_U719
    with article bc_U720
    with list_together bc_U721
;
K5_container -> I_blueberry_bush_U1    with short_name bc_U722
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 77
    with K2_thing_Next I_blueberries_U1
    with IK5_Count 16
    with K5_container_Next I_electrical_closet_one_s_el_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'blueberry' 'bush' 'containers//p'
    with description bc_U723
    with initial bc_U724
    with plural bc_U725
    with article bc_U726
    with list_together bc_U727
;
K2_thing -> -> I_blueberries_U1    with short_name bc_U728
    with description bc_U729
    has proper
    has edible
    has ~P_consumed
    with vector 0
    with cap_short_name bc_U730
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 78
    with K2_thing_Next I_lurking_grue_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name102
    with name 'blueberries' 'things//p' 'berries'
    with initial bc_U731
    with plural bc_U732
    with article bc_U733
    with list_together bc_U734
;
K7_backdrop I_lurking_grue_U1    with short_name bc_U419
    with description bc_U420
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 4
    with K2_thing_Next I_sailor_U1
    with IK7_Count 0
    with K7_backdrop_Next I_sailor_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'lurking' 'grue' 'backdrops//p'
    with initial bc_U421
    with plural bc_U422
    with article bc_U423
    with list_together bc_U424
;
K7_backdrop I_sailor_U1    with short_name bc_U425
    has scenery
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 5
    with K2_thing_Next I_seat_U1
    with IK7_Count 1
    with K7_backdrop_Next I_sky_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'sailor' 'backdrops//p'
    with description bc_U426
    with initial bc_U427
    with plural bc_U428
    with article bc_U429
    with list_together bc_U430
;
K6_supporter I_seat_U1    with short_name bc_U431
    with article bc_U432
    with description bc_U433
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with component_parent I_beater_car_U1
    with component_sibling I_ignition_U1
    with KD_Count 6
    with IK2_Count 6
    with K2_thing_Next I_U1
    with IK6_Count 0
    with K6_supporter_Next I_dashboard_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name20
    with name 'seat' 'supporters//p'
    with initial bc_U434
    with plural bc_U435
    with list_together bc_U436
;
K24_quarter I_U1    with short_name bc_U437
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 7
    with K2_thing_Next I_U2
    with K21_coin_Count 0
    with K21_coin_Next I_U2
    with K24_quarter_Count 0
    with K24_quarter_Next I_U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'quarter' 'quarters//p' 'shiny'
    with description ts_array_U512
    with initial bc_U438
    with plural bc_U439
    with article bc_U440
    with list_together bc_U441
;
K24_quarter I_U2    with short_name bc_U442
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 8
    with K2_thing_Next I_U3
    with K21_coin_Count 1
    with K21_coin_Next I_U3
    with K24_quarter_Count 1
    with K24_quarter_Next I_U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'quarter' 'quarters//p' 'shiny'
    with description ts_array_U513
    with initial bc_U443
    with plural bc_U444
    with article bc_U445
    with list_together bc_U446
;
K24_quarter I_U3    with short_name bc_U447
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 24
    with IK2_Count 9
    with K2_thing_Next I_U4
    with K21_coin_Count 2
    with K21_coin_Next I_U4
    with K24_quarter_Count 2
    with K24_quarter_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'quarter' 'quarters//p' 'shiny'
    with description ts_array_U514
    with initial bc_U448
    with plural bc_U449
    with article bc_U450
    with list_together bc_U451
;
K22_nickel I_U4    with short_name bc_U452
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 22
    with IK2_Count 10
    with K2_thing_Next I_sky_U1
    with K21_coin_Count 3
    with K21_coin_Next I_U5
    with K22_nickel_Count 0
    with K22_nickel_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'nickel' 'nickels//p' 'shiny'
    with description bc_U453
    with initial bc_U454
    with plural bc_U455
    with article bc_U456
    with list_together bc_U457
;
K7_backdrop I_sky_U1    with short_name bc_U458
    with description ts_array_U515
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 11
    with K2_thing_Next I_ground_U1
    with IK7_Count 2
    with K7_backdrop_Next I_ground_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'sky' 'backdrops//p'
    with initial bc_U459
    with plural bc_U460
    with article bc_U461
    with list_together bc_U462
;
K7_backdrop I_ground_U1    with short_name bc_U463
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 12
    with K2_thing_Next I_hell_ride_U1
    with IK7_Count 3
    with K7_backdrop_Next I_hell_ride_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name26
    with name 'ground' 'backdrops//p' 'floor'
    with description bc_U464
    with initial bc_U465
    with plural bc_U466
    with article bc_U467
    with list_together bc_U468
;
K7_backdrop I_hell_ride_U1    with short_name bc_U469
    has proper
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with KD_Count 7
    with IK2_Count 13
    with K2_thing_Next I_U5
    with IK7_Count 4
    with K7_backdrop_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hell' 'ride' 'backdrops//p'
    with description bc_U470
    with initial bc_U471
    with plural bc_U472
    with article bc_U473
    with list_together bc_U474
;
K23_dime I_U5    with short_name bc_U475
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 14
    with K2_thing_Next I_U6
    with K21_coin_Count 4
    with K21_coin_Next I_U6
    with K23_dime_Count 0
    with K23_dime_Next I_U6
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'dimes//p' 'shiny'
    with description ts_array_U516
    with initial bc_U476
    with plural bc_U477
    with article bc_U478
    with list_together bc_U479
;
K23_dime I_U6    with short_name bc_U480
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 15
    with K2_thing_Next I_U7
    with K21_coin_Count 5
    with K21_coin_Next I_U7
    with K23_dime_Count 1
    with K23_dime_Next I_U7
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'dimes//p' 'shiny'
    with description ts_array_U517
    with initial bc_U481
    with plural bc_U482
    with article bc_U483
    with list_together bc_U484
;
K23_dime I_U7    with short_name bc_U485
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 16
    with K2_thing_Next I_U8
    with K21_coin_Count 6
    with K21_coin_Next I_U8
    with K23_dime_Count 2
    with K23_dime_Next I_U8
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'dimes//p' 'shiny'
    with description ts_array_U518
    with initial bc_U486
    with plural bc_U487
    with article bc_U488
    with list_together bc_U489
;
K23_dime I_U8    with short_name bc_U490
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 17
    with K2_thing_Next I_U9
    with K21_coin_Count 7
    with K21_coin_Next I_U9
    with K23_dime_Count 3
    with K23_dime_Next I_U9
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'dimes//p' 'shiny'
    with description ts_array_U519
    with initial bc_U491
    with plural bc_U492
    with article bc_U493
    with list_together bc_U494
;
K23_dime I_U9    with short_name bc_U495
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 18
    with K2_thing_Next I_silver_key_U1
    with K21_coin_Count 8
    with K21_coin_Next I_mercury_dime_U1
    with K23_dime_Count 4
    with K23_dime_Next I_mercury_dime_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'dimes//p' 'shiny'
    with description ts_array_U520
    with initial bc_U496
    with plural bc_U497
    with article bc_U498
    with list_together bc_U499
;
K25_electrical_closet I_electrical_closet_one_U1    with short_name bc_U500
    with description ts_array_U521
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 1
    with K1_room_Next I_electrical_room_U1
    with K25_electrical_closet_Count 0
    with K25_electrical_closet_Next I_electrical_closet_three_U1
    with name 'electrical' 'closet' 'one' 'closets//p'
    with plural bc_U501
    with article bc_U502
    with list_together bc_U503
;
K2_thing -> I_silver_key_U1    with short_name bc_U528
    with description bc_U529
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 19
    with K2_thing_Next I_electrical_closet_one_s_el_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'silver' 'key' 'things//p'
    with initial bc_U530
    with plural bc_U531
    with article bc_U532
    with list_together bc_U533
;
K26_electrical_panel -> I_electrical_closet_one_s_el_U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 1
    has proper
    has static
    with P_color I_aqua_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_one_s_el_U2
    with KD_Count 26
    with IK2_Count 21
    with K2_thing_Next I_breaker_panel_U1
    with IK5_Count 1
    with K5_container_Next I_electrical_closet_three_s__U1
    with K26_electrical_panel_Count 0
    with K26_electrical_panel_Next I_electrical_closet_three_s__U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'one^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U1
    with initial bc_U6
    with short_name ts_array_U2
    with plural bc_U7
    with article bc_U8
    with list_together bc_U9
;
K1_room I_electrical_room_U1    with short_name bc_U504
    with description ts_array_U522
    with map_region I_electrical_area_U1
    has ~light
    has P_electromagnetic
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 2
    with K1_room_Next I_electrical_closet_three_U1
    with name 'electrical' 'room' 'rooms//p'
    with plural bc_U505
    with article bc_U506
    with list_together bc_U507
;
K2_thing -> I_breaker_panel_U1    with short_name bc_U628
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 63
    with K2_thing_Next I_junction_box_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'breaker' 'panel' 'things//p'
    with description bc_U629
    with initial bc_U630
    with plural bc_U631
    with article bc_U632
    with list_together bc_U633
;
K2_thing -> I_junction_box_U1    with short_name bc_U634
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 64
    with K2_thing_Next I_workbench_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'junction' 'box' 'things//p'
    with description bc_U635
    with initial bc_U636
    with plural bc_U637
    with article bc_U638
    with list_together bc_U639
;
K2_thing -> I_workbench_U1    with short_name bc_U640
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 65
    with K2_thing_Next I_emergency_shutdown_panel_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'workbench' 'things//p'
    with description bc_U641
    with initial bc_U642
    with plural bc_U643
    with article bc_U644
    with list_together bc_U645
;
K2_thing -> I_emergency_shutdown_panel_U1    with short_name bc_U646
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 66
    with K2_thing_Next I_fire_extinguisher_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'emergency' 'shutdown' 'panel' 'things//p'
    with description bc_U647
    with initial bc_U648
    with plural bc_U649
    with article bc_U650
    with list_together bc_U651
;
K2_thing -> I_fire_extinguisher_U1    with short_name bc_U652
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 67
    with K2_thing_Next I_faded_safety_poster_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fire' 'extinguisher' 'things//p'
    with description bc_U653
    with initial bc_U654
    with plural bc_U655
    with article bc_U656
    with list_together bc_U657
;
K2_thing -> I_faded_safety_poster_U1    with short_name bc_U658
    with description ts_array_U548
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 68
    with K2_thing_Next I_small_fan_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'faded' 'safety' 'poster' 'things//p'
    with initial bc_U659
    with plural bc_U660
    with article bc_U661
    with list_together bc_U662
;
K2_thing -> I_small_fan_U1    with short_name bc_U663
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 69
    with K2_thing_Next I_electrical_closet_three_s__U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'small' 'fan' 'things//p'
    with description bc_U664
    with initial bc_U665
    with plural bc_U666
    with article bc_U667
    with list_together bc_U668
;
K25_electrical_closet I_electrical_closet_three_U1    with short_name bc_U508
    with description ts_array_U523
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 3
    with K1_room_Next I_electrical_closet_five_U1
    with K25_electrical_closet_Count 1
    with K25_electrical_closet_Next I_electrical_closet_five_U1
    with name 'electrical' 'closet' 'three' 'closets//p'
    with plural bc_U509
    with article bc_U510
    with list_together bc_U511
;
K26_electrical_panel -> I_electrical_closet_three_s__U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 3
    has proper
    has static
    with P_color I_crimson_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_three_s__U2
    with KD_Count 26
    with IK2_Count 22
    with K2_thing_Next I_electrical_closet_five_s_e_U1
    with IK5_Count 2
    with K5_container_Next I_electrical_closet_five_s_e_U1
    with K26_electrical_panel_Count 1
    with K26_electrical_panel_Next I_electrical_closet_five_s_e_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'three^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U3
    with initial bc_U10
    with short_name ts_array_U4
    with plural bc_U11
    with article bc_U12
    with list_together bc_U13
;
K25_electrical_closet I_electrical_closet_five_U1    with short_name bc_U512
    with description ts_array_U524
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 4
    with K1_room_Next I_electrical_closet_seven_U1
    with K25_electrical_closet_Count 2
    with K25_electrical_closet_Next I_electrical_closet_seven_U1
    with name 'electrical' 'closet' 'five' 'closets//p'
    with plural bc_U513
    with article bc_U514
    with list_together bc_U515
;
K26_electrical_panel -> I_electrical_closet_five_s_e_U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 5
    has proper
    has static
    with P_color I_emerald_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_five_s_e_U2
    with KD_Count 26
    with IK2_Count 23
    with K2_thing_Next I_electrical_closet_seven_s__U1
    with IK5_Count 3
    with K5_container_Next I_electrical_closet_seven_s__U1
    with K26_electrical_panel_Count 2
    with K26_electrical_panel_Next I_electrical_closet_seven_s__U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'five^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U5
    with initial bc_U14
    with short_name ts_array_U6
    with plural bc_U15
    with article bc_U16
    with list_together bc_U17
;
K25_electrical_closet I_electrical_closet_seven_U1    with short_name bc_U516
    with description ts_array_U525
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 5
    with K1_room_Next I_electrical_closet_nine_U1
    with K25_electrical_closet_Count 3
    with K25_electrical_closet_Next I_electrical_closet_nine_U1
    with name 'electrical' 'closet' 'seven' 'closets//p'
    with plural bc_U517
    with article bc_U518
    with list_together bc_U519
;
K26_electrical_panel -> I_electrical_closet_seven_s__U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 7
    has proper
    has static
    with P_color I_gray_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_seven_s__U2
    with KD_Count 26
    with IK2_Count 24
    with K2_thing_Next I_electrical_closet_nine_s_e_U1
    with IK5_Count 4
    with K5_container_Next I_electrical_closet_nine_s_e_U1
    with K26_electrical_panel_Count 3
    with K26_electrical_panel_Next I_electrical_closet_nine_s_e_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'seven^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U7
    with initial bc_U18
    with short_name ts_array_U8
    with plural bc_U19
    with article bc_U20
    with list_together bc_U21
;
K25_electrical_closet I_electrical_closet_nine_U1    with short_name bc_U520
    with description ts_array_U526
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 6
    with K1_room_Next I_electrical_closet_eleven_U1
    with K25_electrical_closet_Count 4
    with K25_electrical_closet_Next I_electrical_closet_eleven_U1
    with name 'electrical' 'closet' 'nine' 'closets//p'
    with plural bc_U521
    with article bc_U522
    with list_together bc_U523
;
K26_electrical_panel -> I_electrical_closet_nine_s_e_U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 9
    has proper
    has static
    with P_color I_indigo_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_nine_s_e_U2
    with KD_Count 26
    with IK2_Count 25
    with K2_thing_Next I_electrical_closet_eleven_s_U1
    with IK5_Count 5
    with K5_container_Next I_electrical_closet_eleven_s_U1
    with K26_electrical_panel_Count 4
    with K26_electrical_panel_Next I_electrical_closet_eleven_s_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'nine^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U9
    with initial bc_U22
    with short_name ts_array_U10
    with plural bc_U23
    with article bc_U24
    with list_together bc_U25
;
K25_electrical_closet I_electrical_closet_eleven_U1    with short_name bc_U524
    with description ts_array_U527
    with map_region I_electrical_area_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 25
    with IK1_Count 7
    with K1_room_Next I_generator_room_U1
    with K25_electrical_closet_Count 5
    with K25_electrical_closet_Next 0
    with name 'electrical' 'closet' 'eleven' 'closets//p'
    with plural bc_U525
    with article bc_U526
    with list_together bc_U527
;
K26_electrical_panel -> I_electrical_closet_eleven_s_U1    with with_key I_swiss_army_knife_U1
    with P_panel_id 11
    has proper
    has static
    with P_color I_khaki_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_electrical_closet_eleven_s_U2
    with KD_Count 26
    with IK2_Count 26
    with K2_thing_Next I_electrical_closet_one_s_el_U2
    with IK5_Count 6
    with K5_container_Next I_electrical_closet_one_s_el_U2
    with K26_electrical_panel_Count 5
    with K26_electrical_panel_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'eleven^s' 'electrical' 'panel' 'panels//p' 'panel' 'screws'
    with description ts_array_U11
    with initial bc_U26
    with short_name ts_array_U12
    with plural bc_U27
    with article bc_U28
    with list_together bc_U29
;
K27_socket I_electrical_closet_one_s_el_U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_one_s_el_U1
    with component_sibling I_electrical_closet_one_s_el_U3
    with KD_Count 27
    with IK2_Count 27
    with K2_thing_Next I_electrical_closet_three_s__U2
    with IK5_Count 7
    with K5_container_Next I_electrical_closet_three_s__U2
    with K27_socket_Count 0
    with K27_socket_Next I_electrical_closet_three_s__U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'one^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U13
    with initial bc_U30
    with short_name ts_array_U14
    with plural bc_U31
    with article bc_U32
    with list_together bc_U33
;
K27_socket I_electrical_closet_three_s__U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_three_s__U1
    with component_sibling I_electrical_closet_three_s__U3
    with KD_Count 27
    with IK2_Count 28
    with K2_thing_Next I_electrical_closet_five_s_e_U2
    with IK5_Count 8
    with K5_container_Next I_electrical_closet_five_s_e_U2
    with K27_socket_Count 1
    with K27_socket_Next I_electrical_closet_five_s_e_U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'three^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U15
    with initial bc_U34
    with short_name ts_array_U16
    with plural bc_U35
    with article bc_U36
    with list_together bc_U37
;
K27_socket I_electrical_closet_five_s_e_U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_five_s_e_U1
    with component_sibling I_electrical_closet_five_s_e_U3
    with KD_Count 27
    with IK2_Count 29
    with K2_thing_Next I_electrical_closet_seven_s__U2
    with IK5_Count 9
    with K5_container_Next I_electrical_closet_seven_s__U2
    with K27_socket_Count 2
    with K27_socket_Next I_electrical_closet_seven_s__U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'five^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U17
    with initial bc_U38
    with short_name ts_array_U18
    with plural bc_U39
    with article bc_U40
    with list_together bc_U41
;
K27_socket I_electrical_closet_seven_s__U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_seven_s__U1
    with component_sibling I_electrical_closet_seven_s__U3
    with KD_Count 27
    with IK2_Count 30
    with K2_thing_Next I_electrical_closet_nine_s_e_U2
    with IK5_Count 10
    with K5_container_Next I_electrical_closet_nine_s_e_U2
    with K27_socket_Count 3
    with K27_socket_Next I_electrical_closet_nine_s_e_U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'seven^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U19
    with initial bc_U42
    with short_name ts_array_U20
    with plural bc_U43
    with article bc_U44
    with list_together bc_U45
;
K27_socket I_electrical_closet_nine_s_e_U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_nine_s_e_U1
    with component_sibling I_electrical_closet_nine_s_e_U3
    with KD_Count 27
    with IK2_Count 31
    with K2_thing_Next I_electrical_closet_eleven_s_U2
    with IK5_Count 11
    with K5_container_Next I_electrical_closet_eleven_s_U2
    with K27_socket_Count 4
    with K27_socket_Next I_electrical_closet_eleven_s_U2
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'nine^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U21
    with initial bc_U46
    with short_name ts_array_U22
    with plural bc_U47
    with article bc_U48
    with list_together bc_U49
;
K27_socket I_electrical_closet_eleven_s_U2    has proper
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_electrical_closet_eleven_s_U1
    with component_sibling I_electrical_closet_eleven_s_U3
    with KD_Count 27
    with IK2_Count 32
    with K2_thing_Next I_electrical_closet_one_s_el_U3
    with IK5_Count 12
    with K5_container_Next I_ignition_U1
    with K27_socket_Count 5
    with K27_socket_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'eleven^s' 'electrical' 'panel^s' 'socket' 'sockets//p'
    with description ts_array_U23
    with initial bc_U50
    with short_name ts_array_U24
    with plural bc_U51
    with article bc_U52
    with list_together bc_U53
;
K28_indicator I_electrical_closet_one_s_el_U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_one_s_el_U1
    with component_sibling I_electrical_closet_one_s_el_U4
    with KD_Count 28
    with IK2_Count 33
    with K2_thing_Next I_electrical_closet_three_s__U3
    with K28_indicator_Count 0
    with K28_indicator_Next I_electrical_closet_three_s__U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'one^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U25
    with initial bc_U54
    with short_name ts_array_U26
    with plural bc_U55
    with article bc_U56
    with list_together bc_U57
;
K28_indicator I_electrical_closet_three_s__U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_three_s__U1
    with component_sibling I_electrical_closet_three_s__U4
    with KD_Count 28
    with IK2_Count 34
    with K2_thing_Next I_electrical_closet_five_s_e_U3
    with K28_indicator_Count 1
    with K28_indicator_Next I_electrical_closet_five_s_e_U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'three^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U27
    with initial bc_U58
    with short_name ts_array_U28
    with plural bc_U59
    with article bc_U60
    with list_together bc_U61
;
K28_indicator I_electrical_closet_five_s_e_U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_five_s_e_U1
    with component_sibling I_electrical_closet_five_s_e_U4
    with KD_Count 28
    with IK2_Count 35
    with K2_thing_Next I_electrical_closet_seven_s__U3
    with K28_indicator_Count 2
    with K28_indicator_Next I_electrical_closet_seven_s__U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'five^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U29
    with initial bc_U62
    with short_name ts_array_U30
    with plural bc_U63
    with article bc_U64
    with list_together bc_U65
;
K28_indicator I_electrical_closet_seven_s__U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_seven_s__U1
    with component_sibling I_electrical_closet_seven_s__U4
    with KD_Count 28
    with IK2_Count 36
    with K2_thing_Next I_electrical_closet_nine_s_e_U3
    with K28_indicator_Count 3
    with K28_indicator_Next I_electrical_closet_nine_s_e_U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'seven^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U31
    with initial bc_U66
    with short_name ts_array_U32
    with plural bc_U67
    with article bc_U68
    with list_together bc_U69
;
K28_indicator I_electrical_closet_nine_s_e_U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_nine_s_e_U1
    with component_sibling I_electrical_closet_nine_s_e_U4
    with KD_Count 28
    with IK2_Count 37
    with K2_thing_Next I_electrical_closet_eleven_s_U3
    with K28_indicator_Count 4
    with K28_indicator_Next I_electrical_closet_eleven_s_U3
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'nine^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U33
    with initial bc_U70
    with short_name ts_array_U34
    with plural bc_U71
    with article bc_U72
    with list_together bc_U73
;
K28_indicator I_electrical_closet_eleven_s_U3    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_electrical_closet_eleven_s_U1
    with component_sibling I_electrical_closet_eleven_s_U4
    with KD_Count 28
    with IK2_Count 38
    with K2_thing_Next I_fuse5_U1
    with K28_indicator_Count 5
    with K28_indicator_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'eleven^s' 'electrical' 'panel^s' 'indicator' 'indicators//p' 'light'
    with description ts_array_U35
    with initial bc_U74
    with short_name ts_array_U36
    with plural bc_U75
    with article bc_U76
    with list_together bc_U77
;
K29_fuse I_fuse5_U1    with P_fuse_id 5
    with P_underlying_relation_storag I_wooden_stocks_U1
    with P_color I_emerald_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 43
    with K2_thing_Next I_fuse7_U1
    with K29_fuse_Count 2
    with K29_fuse_Next I_fuse7_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse5' 'fuses//p' 'fuse'
    with description ts_array_U533
    with initial bc_U559
    with short_name ts_array_U534
    with plural bc_U560
    with article bc_U561
    with list_together bc_U562
;
K29_fuse I_fuse7_U1    with P_fuse_id 7
    with P_underlying_relation_storag I_guillotine_platform_U1
    with P_color I_gray_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 45
    with K2_thing_Next I_fuse9_U1
    with K29_fuse_Count 3
    with K29_fuse_Next I_fuse9_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse7' 'fuses//p' 'fuse'
    with description ts_array_U536
    with initial bc_U568
    with short_name ts_array_U537
    with plural bc_U569
    with article bc_U570
    with list_together bc_U571
;
K29_fuse I_fuse9_U1    with P_fuse_id 9
    with P_underlying_relation_storag I_iron_chair_U1
    with P_color I_indigo_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 47
    with K2_thing_Next I_fuse11_U1
    with K29_fuse_Count 4
    with K29_fuse_Next I_fuse11_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse9' 'fuses//p' 'fuse'
    with description ts_array_U538
    with initial bc_U578
    with short_name ts_array_U539
    with plural bc_U579
    with article bc_U580
    with list_together bc_U581
;
K29_fuse I_fuse11_U1    with P_fuse_id 11
    with P_underlying_relation_storag I_gallows_platform_U1
    with P_color I_khaki_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 49
    with K2_thing_Next I_electrical_closet_one_s_el_U4
    with K29_fuse_Count 5
    with K29_fuse_Next I_fuse13_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse11' 'fuses//p' 'fuse'
    with description ts_array_U540
    with initial bc_U588
    with short_name ts_array_U541
    with plural bc_U589
    with article bc_U590
    with list_together bc_U591
;
K30_switch I_electrical_closet_one_s_el_U4    with short_name SN_R_A1
    has proper
    with vector 0
    with cap_short_name SN_R_A2
    has mark_as_thing
    with component_parent I_electrical_closet_one_s_el_U1
    has switchable
    with KD_Count 30
    with IK2_Count 57
    with K2_thing_Next I_electrical_closet_three_s__U4
    with K13_device_Count 0
    with K13_device_Next I_electrical_closet_three_s__U4
    with K30_switch_Count 0
    with K30_switch_Next I_electrical_closet_three_s__U4
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'one^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U37
    with initial bc_U78
    with plural bc_U79
    with article bc_U80
    with list_together bc_U81
;
K30_switch I_electrical_closet_three_s__U4    with short_name SN_R_A3
    has proper
    with vector 0
    with cap_short_name SN_R_A4
    has mark_as_thing
    with component_parent I_electrical_closet_three_s__U1
    has switchable
    with KD_Count 30
    with IK2_Count 58
    with K2_thing_Next I_electrical_closet_five_s_e_U4
    with K13_device_Count 1
    with K13_device_Next I_electrical_closet_five_s_e_U4
    with K30_switch_Count 1
    with K30_switch_Next I_electrical_closet_five_s_e_U4
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'three^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U38
    with initial bc_U82
    with plural bc_U83
    with article bc_U84
    with list_together bc_U85
;
K30_switch I_electrical_closet_five_s_e_U4    with short_name SN_R_A5
    has proper
    with vector 0
    with cap_short_name SN_R_A6
    has mark_as_thing
    with component_parent I_electrical_closet_five_s_e_U1
    has switchable
    with KD_Count 30
    with IK2_Count 59
    with K2_thing_Next I_electrical_closet_seven_s__U4
    with K13_device_Count 2
    with K13_device_Next I_electrical_closet_seven_s__U4
    with K30_switch_Count 2
    with K30_switch_Next I_electrical_closet_seven_s__U4
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'five^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U39
    with initial bc_U86
    with plural bc_U87
    with article bc_U88
    with list_together bc_U89
;
K30_switch I_electrical_closet_seven_s__U4    with short_name SN_R_A7
    has proper
    with vector 0
    with cap_short_name SN_R_A8
    has mark_as_thing
    with component_parent I_electrical_closet_seven_s__U1
    has switchable
    with KD_Count 30
    with IK2_Count 60
    with K2_thing_Next I_electrical_closet_nine_s_e_U4
    with K13_device_Count 3
    with K13_device_Next I_electrical_closet_nine_s_e_U4
    with K30_switch_Count 3
    with K30_switch_Next I_electrical_closet_nine_s_e_U4
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'seven^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U40
    with initial bc_U90
    with plural bc_U91
    with article bc_U92
    with list_together bc_U93
;
K30_switch I_electrical_closet_nine_s_e_U4    with short_name SN_R_A9
    has proper
    with vector 0
    with cap_short_name SN_R_A10
    has mark_as_thing
    with component_parent I_electrical_closet_nine_s_e_U1
    has switchable
    with KD_Count 30
    with IK2_Count 61
    with K2_thing_Next I_electrical_closet_eleven_s_U4
    with K13_device_Count 4
    with K13_device_Next I_electrical_closet_eleven_s_U4
    with K30_switch_Count 4
    with K30_switch_Next I_electrical_closet_eleven_s_U4
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'nine^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U41
    with initial bc_U94
    with plural bc_U95
    with article bc_U96
    with list_together bc_U97
;
K30_switch I_electrical_closet_eleven_s_U4    with short_name SN_R_A11
    has proper
    with vector 0
    with cap_short_name SN_R_A12
    has mark_as_thing
    with component_parent I_electrical_closet_eleven_s_U1
    has switchable
    with KD_Count 30
    with IK2_Count 62
    with K2_thing_Next I_graffiti_U1
    with K13_device_Count 5
    with K13_device_Next I_lantern_U1
    with K30_switch_Count 5
    with K30_switch_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'closet' 'eleven^s' 'electrical' 'panel^s' 'switch' 'switches//p'
    with description ts_array_U42
    with initial bc_U98
    with plural bc_U99
    with article bc_U100
    with list_together bc_U101
;
K1_room I_generator_room_U1    with short_name bc_U669
    with description bc_U670
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 8
    with K1_room_Next I_storage_room_U1
    with name 'generator' 'room' 'rooms//p'
    with plural bc_U671
    with article bc_U672
    with list_together bc_U673
;
K2_thing -> I_graffiti_U1    with short_name bc_U1466
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U1467
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 190
    with K2_thing_Next I_junction_boxes_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'graffiti' 'things//p'
    with description bc_U1468
    with initial bc_U1469
    with plural bc_U1470
    with article bc_U1471
    with list_together bc_U1472
;
K2_thing -> I_junction_boxes_U1    with short_name bc_U1473
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 191
    with K2_thing_Next I_cables_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'junction' 'boxes' 'things//p'
    with description bc_U1474
    with initial bc_U1475
    with plural bc_U1476
    with article bc_U1477
    with list_together bc_U1478
;
K2_thing -> I_cables_U1    with short_name bc_U1479
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 192
    with K2_thing_Next I_circuit_breakers_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cables' 'things//p'
    with description bc_U1480
    with initial bc_U1481
    with plural bc_U1482
    with article bc_U1483
    with list_together bc_U1484
;
K2_thing -> I_circuit_breakers_U1    with short_name bc_U1485
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 193
    with K2_thing_Next I_filters_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'circuit' 'breakers' 'things//p'
    with description bc_U1486
    with initial bc_U1487
    with plural bc_U1488
    with article bc_U1489
    with list_together bc_U1490
;
K2_thing -> I_filters_U1    with short_name bc_U1491
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 194
    with K2_thing_Next I_spark_plugs_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'filters' 'things//p'
    with description bc_U1492
    with initial bc_U1493
    with plural bc_U1494
    with article bc_U1495
    with list_together bc_U1496
;
K2_thing -> I_spark_plugs_U1    with short_name bc_U1497
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 195
    with K2_thing_Next I_wire_coils_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'spark' 'plugs' 'things//p'
    with description bc_U1498
    with initial bc_U1499
    with plural bc_U1500
    with article bc_U1501
    with list_together bc_U1502
;
K2_thing -> I_wire_coils_U1    with short_name bc_U1503
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 196
    with K2_thing_Next I_grease_canister_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wire' 'coils' 'things//p'
    with description bc_U1504
    with initial bc_U1505
    with plural bc_U1506
    with article bc_U1507
    with list_together bc_U1508
;
K2_thing -> I_grease_canister_U1    with short_name bc_U1509
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 197
    with K2_thing_Next I_diesel_canisters_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'grease' 'canister' 'things//p'
    with description bc_U1510
    with initial bc_U1511
    with plural bc_U1512
    with article bc_U1513
    with list_together bc_U1514
;
K2_thing -> I_diesel_canisters_U1    with short_name bc_U1515
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 198
    with K2_thing_Next I_maintenance_manual_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'diesel' 'canisters' 'things//p'
    with description bc_U1516
    with initial bc_U1517
    with plural bc_U1518
    with article bc_U1519
    with list_together bc_U1520
;
K2_thing -> I_maintenance_manual_U1    with short_name bc_U1521
    with description bc_U1522
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 199
    with K2_thing_Next I_large_panel_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'maintenance' 'manual' 'things//p'
    with initial bc_U1523
    with plural bc_U1524
    with article bc_U1525
    with list_together bc_U1526
;
K2_thing -> I_large_panel_U1    with short_name bc_U1527
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 200
    with K2_thing_Next I_supplies_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'large' 'panel' 'things//p'
    with description bc_U1528
    with initial bc_U1529
    with plural bc_U1530
    with article bc_U1531
    with list_together bc_U1532
;
K1_room I_storage_room_U1    with short_name bc_U674
    with description ts_array_U549
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 9
    with K1_room_Next I_ticket_booth_U1
    with name 'storage' 'room' 'rooms//p'
    with plural bc_U675
    with article bc_U676
    with list_together bc_U677
;
K2_thing -> I_supplies_U1    with short_name bc_U1540
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 202
    with K2_thing_Next I_boxes_of_lightbulbs_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'supplies' 'things//p'
    with description bc_U1541
    with initial bc_U1542
    with plural bc_U1543
    with article bc_U1544
    with list_together bc_U1545
;
K2_thing -> I_boxes_of_lightbulbs_U1    with short_name bc_U1546
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 203
    with K2_thing_Next I_spools_of_wire_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'boxes' 'of' 'lightbulbs' 'things//p'
    with description bc_U1547
    with initial bc_U1548
    with plural bc_U1549
    with article bc_U1550
    with list_together bc_U1551
;
K2_thing -> I_spools_of_wire_U1    with short_name bc_U1552
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 204
    with K2_thing_Next I_ride_parts_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'spools' 'of' 'wire' 'things//p'
    with description bc_U1553
    with initial bc_U1554
    with plural bc_U1555
    with article bc_U1556
    with list_together bc_U1557
;
K2_thing -> I_ride_parts_U1    with short_name bc_U1558
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 205
    with K2_thing_Next I_flags_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ride' 'parts' 'things//p'
    with description bc_U1559
    with initial bc_U1560
    with plural bc_U1561
    with article bc_U1562
    with list_together bc_U1563
;
K2_thing -> I_flags_U1    with short_name bc_U1564
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 206
    with K2_thing_Next I_seats_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'flags' 'things//p'
    with description bc_U1565
    with initial bc_U1566
    with plural bc_U1567
    with article bc_U1568
    with list_together bc_U1569
;
K2_thing -> I_seats_U1    with short_name bc_U1570
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 207
    with K2_thing_Next I_booths_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'seats' 'things//p'
    with description bc_U1571
    with initial bc_U1572
    with plural bc_U1573
    with article bc_U1574
    with list_together bc_U1575
;
K2_thing -> I_booths_U1    with short_name bc_U1576
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 208
    with K2_thing_Next I_horse_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'booths' 'things//p'
    with description bc_U1577
    with initial bc_U1578
    with plural bc_U1579
    with article bc_U1580
    with list_together bc_U1581
;
K2_thing -> I_horse_U1    with short_name bc_U1582
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 209
    with K2_thing_Next I_wire_scraps_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'horse' 'things//p'
    with description bc_U1583
    with initial bc_U1584
    with plural bc_U1585
    with article bc_U1586
    with list_together bc_U1587
;
K2_thing -> I_wire_scraps_U1    with short_name bc_U1588
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 210
    with K2_thing_Next I_rats_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wire' 'scraps' 'things//p'
    with description bc_U1589
    with initial bc_U1590
    with plural bc_U1591
    with article bc_U1592
    with list_together bc_U1593
;
K2_thing -> I_rats_U1    with short_name bc_U1594
    with description bc_U1595
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 211
    with K2_thing_Next I_ticket_kiosk_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'rats' 'things//p'
    with initial bc_U1596
    with plural bc_U1597
    with article bc_U1598
    with list_together bc_U1599
;
K1_room I_ticket_booth_U1    with short_name bc_U678
    with description ts_array_U550
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 10
    with K1_room_Next I_fortune_teller_booth_U1
    with name 'ticket' 'booth' 'rooms//p'
    with plural bc_U679
    with article bc_U680
    with list_together bc_U681
;
K2_thing -> I_ticket_kiosk_U1    with short_name bc_U800
    with description ts_array_U559
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 85
    with K2_thing_Next I_cashier_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name116
    with name 'ticket' 'kiosk' 'things//p' 'booth'
    with initial bc_U801
    with plural bc_U802
    with article bc_U803
    with list_together bc_U804
;
K20_attendant -> I_cashier_U1    with short_name bc_U810
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 87
    with K2_thing_Next I_hell_ride_ticket_U1
    with IK8_Count 5
    with K8_person_Next I_mysterious_woman_U1
    with K20_attendant_Count 4
    with K20_attendant_Next I_hell_ride_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cashier' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U811
    with initial bc_U812
    with plural bc_U813
    with article bc_U814
    with list_together bc_U815
;
K31_ride_ticket -> -> I_hell_ride_ticket_U1    with short_name bc_U805
    with description ts_array_U560
    has ~static
    with P_price 300
    with vector 0
    has mark_as_thing
    with KD_Count 31
    with IK2_Count 86
    with K2_thing_Next I_fortune_teller_ticket_U1
    with K31_ride_ticket_Count 0
    with K31_ride_ticket_Next I_fortune_teller_ticket_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hell' 'ride' 'ticket' 'tickets//p'
    with initial bc_U806
    with plural bc_U807
    with article bc_U808
    with list_together bc_U809
;
K31_ride_ticket -> -> I_fortune_teller_ticket_U1    with short_name bc_U816
    with description bc_U817
    has ~static
    with P_price 300
    with vector 0
    has mark_as_thing
    with KD_Count 31
    with IK2_Count 88
    with K2_thing_Next I_ferris_wheel_ticket_U1
    with K31_ride_ticket_Count 1
    with K31_ride_ticket_Next I_ferris_wheel_ticket_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fortune' 'teller' 'ticket' 'ride//p' 'tickets//p'
    with initial bc_U818
    with plural bc_U819
    with article bc_U820
    with list_together bc_U821
;
K31_ride_ticket -> -> I_ferris_wheel_ticket_U1    with short_name bc_U822
    with description bc_U823
    has ~static
    with P_price 200
    with vector 0
    has mark_as_thing
    with KD_Count 31
    with IK2_Count 89
    with K2_thing_Next I_bumper_cars_ticket_U1
    with K31_ride_ticket_Count 2
    with K31_ride_ticket_Next I_bumper_cars_ticket_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ferris' 'wheel' 'ticket' 'ride//p' 'tickets//p'
    with initial bc_U824
    with plural bc_U825
    with article bc_U826
    with list_together bc_U827
;
K31_ride_ticket -> -> I_bumper_cars_ticket_U1    with short_name bc_U828
    with description bc_U829
    has ~static
    with P_price 200
    with vector 0
    has mark_as_thing
    with KD_Count 31
    with IK2_Count 90
    with K2_thing_Next I_carousel_ticket_U1
    with K31_ride_ticket_Count 3
    with K31_ride_ticket_Next I_carousel_ticket_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name121
    with name 'bumper' 'cars' 'ticket' 'ride//p' 'tickets//p'
    with initial bc_U830
    with plural bc_U831
    with article bc_U832
    with list_together bc_U833
;
K31_ride_ticket -> -> I_carousel_ticket_U1    with short_name bc_U834
    with description bc_U835
    has ~static
    with P_price 100
    with vector 0
    has mark_as_thing
    with KD_Count 31
    with IK2_Count 91
    with K2_thing_Next I_signboard_U1
    with K31_ride_ticket_Count 4
    with K31_ride_ticket_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'carousel' 'ticket' 'ride//p' 'tickets//p'
    with initial bc_U836
    with plural bc_U837
    with article bc_U838
    with list_together bc_U839
;
K2_thing -> I_signboard_U1    with short_name bc_U840
    with description ts_array_U561
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 92
    with K2_thing_Next I_ignition_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name123
    with name 'signboard' 'things//p' 'sign'
    with initial bc_U841
    with plural bc_U842
    with article bc_U843
    with list_together bc_U844
;
K5_container I_ignition_U1    with short_name bc_U741
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_beater_car_U1
    with component_sibling I_dashboard_U1
    with KD_Count 5
    with IK2_Count 80
    with K2_thing_Next I_dashboard_U1
    with IK5_Count 17
    with K5_container_Next I_glove_box_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ignition' 'containers//p'
    with description bc_U742
    with initial bc_U743
    with plural bc_U744
    with article bc_U745
    with list_together bc_U746
;
K6_supporter I_dashboard_U1    with short_name bc_U747
    with description bc_U748
    with vector 0
    has mark_as_thing
    has supporter
    with component_parent I_beater_car_U1
    with component_sibling I_glove_box_U1
    with KD_Count 6
    with IK2_Count 81
    with K2_thing_Next I_your_keys_U1
    with IK6_Count 5
    with K6_supporter_Next I_plate_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name105
    with name 'dashboard' 'supporters//p' 'dash'
    with initial bc_U749
    with plural bc_U750
    with article bc_U751
    with list_together bc_U752
;
K2_thing I_your_keys_U1    with short_name bc_U753
    with description ts_array_U553
    has proper
    with P_underlying_relation_storag I_seat_U1
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 82
    with K2_thing_Next I_glove_box_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name106
    with name 'my' 'keys' 'things//p' 'key'
    with initial bc_U754
    with plural bc_U755
    with article bc_U756
    with list_together bc_U757
;
K5_container I_glove_box_U1    with short_name bc_U758
    with with_key I_your_keys_U1
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_beater_car_U1
    with KD_Count 5
    with IK2_Count 83
    with K2_thing_Next I_pair_of_gloves_U1
    with IK5_Count 18
    with K5_container_Next I_soda_can_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name107
    with name 'glove' 'box' 'containers//p' 'compartment'
    with description bc_U759
    with initial bc_U760
    with plural bc_U761
    with article bc_U762
    with list_together bc_U763
;
K2_thing -> I_pair_of_gloves_U1    with short_name bc_U764
    with description ts_array_U554
    has clothing
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 84
    with K2_thing_Next I_mysterious_woman_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'pair' 'of' 'gloves' 'things//p'
    with initial bc_U765
    with plural bc_U766
    with article bc_U767
    with list_together bc_U768
;
K1_room I_fortune_teller_booth_U1    with short_name bc_U769
    with description ts_array_U555
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 11
    with K1_room_Next I_head_of_the_line_U1
    with name 'fortune' 'teller' 'booth' 'rooms//p'
    with plural bc_U770
    with article bc_U771
    with list_together bc_U772
;
K11_woman -> I_mysterious_woman_U1    with short_name bc_U1114
    with description bc_U1115
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 11
    with IK2_Count 136
    with K2_thing_Next I_hell_ride_attendant_U1
    with IK8_Count 10
    with K8_person_Next I_hell_ride_attendant_U1
    with K11_woman_Count 1
    with K11_woman_Next I_little_egypt_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'mysterious' 'woman' 'women//p'
    with initial bc_U1116
    with plural bc_U1117
    with article bc_U1118
    with list_together bc_U1119
;
K1_room I_head_of_the_line_U1    with short_name bc_U773
    with description ts_array_U556
    with map_region I_midway_U1
    has proper
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 12
    with K1_room_Next I_concession_stand_U1
    with name 'head' 'of' 'the' 'line' 'rooms//p'
    with plural bc_U774
    with article bc_U775
    with list_together bc_U776
;
K20_attendant -> I_hell_ride_attendant_U1    with short_name bc_U1130
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 138
    with K2_thing_Next I_treats_U1
    with IK8_Count 12
    with K8_person_Next I_barker_U1
    with K20_attendant_Count 8
    with K20_attendant_Next I_carousel_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hell' 'ride' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U1131
    with initial bc_U1132
    with plural bc_U1133
    with article bc_U1134
    with list_together bc_U1135
;
K1_room I_concession_stand_U1    with short_name bc_U777
    with description bc_U778
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 13
    with K1_room_Next I_show_facade_U1
    with name 'concession' 'stand' 'rooms//p'
    with plural bc_U779
    with article bc_U780
    with list_together bc_U781
;
K2_thing -> I_treats_U1    with short_name bc_U845
    with description bc_U846
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U847
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 93
    with K2_thing_Next I_menu_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name124
    with name 'treats' 'things//p' 'treat'
    with initial bc_U848
    with plural bc_U849
    with article bc_U850
    with list_together bc_U851
;
K2_thing -> I_menu_U1    with short_name bc_U852
    with description ts_array_U562
    has static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 94
    with K2_thing_Next I_soda_can_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name125
    with name 'menu' 'things//p' 'sign'
    with initial bc_U853
    with plural bc_U854
    with article bc_U855
    with list_together bc_U856
;
K18_fluid_container -> I_soda_can_U1    with short_name bc_U857
    with description bc_U858
    with P_current_volume 80
    with P_price 200
    with P_liquid I_cola_U1
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 18
    with IK2_Count 95
    with K2_thing_Next I_bubblegum_U1
    with IK5_Count 19
    with K5_container_Next I_wall_U1
    with K18_fluid_container_Count 0
    with K18_fluid_container_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name126
    with name 'soda' 'can' 'fluid//p' 'containers//p' 'soda' 'cola' 'coke' 'of'
    with initial bc_U859
    with plural bc_U860
    with article bc_U861
    with list_together bc_U862
;
K2_thing -> I_bubblegum_U1    with short_name bc_U863
    with description bc_U864
    has proper
    has edible
    with P_price 100
    with vector 0
    with cap_short_name bc_U865
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 96
    with K2_thing_Next I_bucket_of_popcorn_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bubblegum' 'things//p'
    with initial bc_U866
    with plural bc_U867
    with article bc_U868
    with list_together bc_U869
;
K2_thing -> I_bucket_of_popcorn_U1    with short_name bc_U870
    with description bc_U871
    has edible
    with P_price 250
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 97
    with K2_thing_Next I_candy_apple_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bucket' 'of' 'popcorn' 'things//p'
    with initial bc_U872
    with plural bc_U873
    with article bc_U874
    with list_together bc_U875
;
K2_thing -> I_candy_apple_U1    with short_name bc_U876
    with description bc_U877
    has edible
    with P_price 150
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 98
    with K2_thing_Next I_cotton_candy_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'candy' 'apple' 'things//p'
    with initial bc_U878
    with plural bc_U879
    with article bc_U880
    with list_together bc_U881
;
K2_thing -> I_cotton_candy_U1    with short_name bc_U882
    with description bc_U883
    has proper
    has edible
    with P_price 150
    with vector 0
    with cap_short_name bc_U884
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 99
    with K2_thing_Next I_soft_pretzel_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cotton' 'candy' 'things//p'
    with initial bc_U885
    with plural bc_U886
    with article bc_U887
    with list_together bc_U888
;
K2_thing -> I_soft_pretzel_U1    with short_name bc_U889
    with description bc_U890
    has edible
    with P_price 150
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 100
    with K2_thing_Next I_sign_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'soft' 'pretzel' 'things//p'
    with initial bc_U891
    with plural bc_U892
    with article bc_U893
    with list_together bc_U894
;
K1_room I_show_facade_U1    with short_name bc_U782
    with description bc_U783
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 14
    with K1_room_Next I_carousel_ride_U1
    with name 'show' 'facade' 'rooms//p'
    with plural bc_U784
    with article bc_U785
    with list_together bc_U786
;
K2_thing -> I_sign_U1    with short_name bc_U1047
    with description bc_U1048
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 125
    with K2_thing_Next I_barker_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'sign' 'things//p'
    with initial bc_U1049
    with plural bc_U1050
    with article bc_U1051
    with list_together bc_U1052
;
K8_person -> I_barker_U1    with short_name bc_U1053
    with description bc_U1054
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 8
    with IK2_Count 126
    with K2_thing_Next I_carousel_attendant_U1
    with IK8_Count 6
    with K8_person_Next I_carousel_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name161
    with name 'barker' 'people//p' 'attendant' 'attendent' 'operator'
    with initial bc_U1055
    with plural bc_U1056
    with article bc_U1057
    with list_together bc_U1058
;
K1_room I_carousel_ride_U1    with short_name bc_U787
    with description ts_array_U557
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 15
    with K1_room_Next I_bumper_cars_ride_U1
    with name 'carousel' 'ride' 'rooms//p'
    with plural bc_U788
    with article bc_U789
    with list_together bc_U790
;
K20_attendant -> I_carousel_attendant_U1    with short_name bc_U1120
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 137
    with K2_thing_Next I_bumper_cars_attendant_U1
    with IK8_Count 11
    with K8_person_Next I_bumper_cars_attendant_U1
    with K20_attendant_Count 7
    with K20_attendant_Next I_bumper_cars_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'carousel' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U1121
    with initial bc_U1122
    with plural bc_U1123
    with article bc_U1124
    with list_together bc_U1125
;
K1_room I_bumper_cars_ride_U1    with short_name bc_U791
    with description bc_U792
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 16
    with K1_room_Next I_high_striker_U1
    with name 'bumper' 'cars' 'ride' 'rooms//p'
    with plural bc_U793
    with article bc_U794
    with list_together bc_U795
;
K20_attendant -> I_bumper_cars_attendant_U1    with short_name bc_U1102
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 134
    with K2_thing_Next I_two_dollar_bill_U1
    with IK8_Count 9
    with K8_person_Next I_strongman_attendant_U1
    with K20_attendant_Count 6
    with K20_attendant_Next I_strongman_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bumper' 'cars' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U1103
    with initial bc_U1104
    with plural bc_U1105
    with article bc_U1106
    with list_together bc_U1107
;
K2_thing -> I_two_dollar_bill_U1    with short_name bc_U1108
    with description bc_U1109
    with initial bc_U1110
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 135
    with K2_thing_Next I_strongman_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name170
    with name 'two' 'dollar' 'bill' 'things//p' 'bill'
    with plural bc_U1111
    with article bc_U1112
    with list_together bc_U1113
;
K1_room I_high_striker_U1    with short_name bc_U796
    with description ts_array_U558
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 17
    with K1_room_Next I_pitcher_s_mound_U1
    with name 'high' 'striker' 'rooms//p'
    with plural bc_U797
    with article bc_U798
    with list_together bc_U799
;
K20_attendant -> I_strongman_attendant_U1    with short_name bc_U602
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 52
    with K2_thing_Next I_swiss_army_knife_U1
    with IK8_Count 2
    with K8_person_Next I_pitcher_s_mound_attendant_U1
    with K20_attendant_Count 1
    with K20_attendant_Next I_pitcher_s_mound_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'strongman' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U603
    with initial bc_U604
    with plural bc_U605
    with article bc_U606
    with list_together bc_U607
;
K2_thing -> -> I_swiss_army_knife_U1    with short_name bc_U534
    with description ts_array_U528
    has ~static
    with vector 0
    has mark_as_thing
    with component_child I_screwdriver_U1
    with KD_Count 2
    with IK2_Count 20
    with K2_thing_Next I_fuse13_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name41
    with name 'swiss' 'army' 'knife' 'things//p' 'screwdriver'
    with initial bc_U535
    with plural bc_U536
    with article bc_U537
    with list_together bc_U538
;
K29_fuse -> -> I_fuse13_U1    with P_fuse_id 13
    has ~static
    with P_color I_magenta_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 51
    with K2_thing_Next I_teddy_bear_U1
    with K29_fuse_Count 6
    with K29_fuse_Next I_fuse3_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse13' 'fuses//p' 'fuse'
    with description ts_array_U542
    with initial bc_U598
    with short_name ts_array_U543
    with plural bc_U599
    with article bc_U600
    with list_together bc_U601
;
K2_thing -> -> I_teddy_bear_U1    with short_name bc_U913
    with description bc_U914
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 102
    with K2_thing_Next I_poster_of_taylor_swift_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'teddy' 'bear' 'things//p'
    with initial bc_U915
    with plural bc_U916
    with article bc_U917
    with list_together bc_U918
;
K2_thing -> -> I_poster_of_taylor_swift_U1    with short_name bc_U944
    with description ts_array_U571
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 108
    with K2_thing_Next I_mallet_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'poster' 'of' 'taylor' 'swift' 'things//p'
    with initial bc_U945
    with plural bc_U946
    with article bc_U947
    with list_together bc_U948
;
K2_thing -> -> I_mallet_U1    with short_name bc_U955
    with description bc_U956
    has ~static
    with P_price 200
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 110
    with K2_thing_Next I_markings_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name144
    with name 'mallet' 'things//p' 'hammer'
    with initial bc_U957
    with plural bc_U958
    with article bc_U959
    with list_together bc_U960
;
K2_thing -> I_markings_U1    with short_name bc_U907
    with description bc_U908
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 101
    with K2_thing_Next I_lever_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name135
    with name 'markings' 'things//p' 'marking' 'sign' 'signs'
    with initial bc_U909
    with plural bc_U910
    with article bc_U911
    with list_together bc_U912
;
K2_thing -> I_lever_U1    with short_name bc_U949
    with description bc_U950
    has static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 109
    with K2_thing_Next I_bell_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name143
    with name 'lever' 'things//p' 'bullseye' 'striker' 'target'
    with initial bc_U951
    with plural bc_U952
    with article bc_U953
    with list_together bc_U954
;
K2_thing -> I_bell_U1    with short_name bc_U961
    with description ts_array_U572
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 111
    with K2_thing_Next I_pitcher_s_mound_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bell' 'things//p'
    with initial bc_U962
    with plural bc_U963
    with article bc_U964
    with list_together bc_U965
;
K1_room I_pitcher_s_mound_U1    with short_name bc_U895
    with article bc_U896
    with description ts_array_U563
    with map_region I_midway_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 18
    with K1_room_Next I_ferris_wheel_ride_U1
    with name 'pitcher^s' 'mound' 'rooms//p'
    with plural bc_U897
    with list_together bc_U898
;
K20_attendant -> I_pitcher_s_mound_attendant_U1    with short_name bc_U553
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 42
    with K2_thing_Next I_fuse3_U1
    with IK8_Count 1
    with K8_person_Next I_ferris_wheel_attendant_U1
    with K20_attendant_Count 0
    with K20_attendant_Next I_ferris_wheel_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'pitcher^s' 'mound' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U554
    with initial bc_U555
    with plural bc_U556
    with article bc_U557
    with list_together bc_U558
;
K29_fuse -> -> I_fuse3_U1    with P_fuse_id 3
    has ~static
    with P_color I_crimson_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 41
    with K2_thing_Next I_small_plush_donkey_U1
    with K29_fuse_Count 1
    with K29_fuse_Next I_fuse15_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse3' 'fuses//p' 'fuse'
    with description ts_array_U531
    with initial bc_U549
    with short_name ts_array_U532
    with plural bc_U550
    with article bc_U551
    with list_together bc_U552
;
K2_thing -> -> I_small_plush_donkey_U1    with short_name bc_U1001
    with description bc_U1002
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 118
    with K2_thing_Next I_poster_of_lourde_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name152
    with name 'small' 'plush' 'donkey' 'things//p' 'stuffie' 'stuffed'
    with initial bc_U1003
    with plural bc_U1004
    with article bc_U1005
    with list_together bc_U1006
;
K2_thing -> -> I_poster_of_lourde_U1    with short_name bc_U1007
    with description bc_U1008
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 119
    with K2_thing_Next I_goldfish_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'poster' 'of' 'lourde' 'things//p'
    with initial bc_U1009
    with plural bc_U1010
    with article bc_U1011
    with list_together bc_U1012
;
K2_thing -> -> I_goldfish_U1    with short_name bc_U1013
    with description bc_U1014
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 120
    with K2_thing_Next I_U10
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name154
    with name 'goldfish' 'things//p' 'bowl'
    with initial bc_U1015
    with plural bc_U1016
    with article bc_U1017
    with list_together bc_U1018
;
K32_baseball -> -> I_U10    with short_name bc_U1019
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 32
    with IK2_Count 121
    with K2_thing_Next I_U11
    with K32_baseball_Count 0
    with K32_baseball_Next I_U11
    with action_bitmap 0 0 0 0 0 0 0
    with name 'baseball' 'baseballs//p' 'ball'
    with description bc_U1020
    with initial bc_U1021
    with plural bc_U1022
    with article bc_U1023
    with list_together bc_U1024
;
K32_baseball -> -> I_U11    with short_name bc_U1025
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 32
    with IK2_Count 122
    with K2_thing_Next I_U12
    with K32_baseball_Count 1
    with K32_baseball_Next I_U12
    with action_bitmap 0 0 0 0 0 0 0
    with name 'baseball' 'baseballs//p' 'ball'
    with description bc_U1026
    with initial bc_U1027
    with plural bc_U1028
    with article bc_U1029
    with list_together bc_U1030
;
K32_baseball -> -> I_U12    with short_name bc_U1031
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 32
    with IK2_Count 123
    with K2_thing_Next I_milk_bottles_U1
    with K32_baseball_Count 2
    with K32_baseball_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'baseball' 'baseballs//p' 'ball'
    with description bc_U1032
    with initial bc_U1033
    with plural bc_U1034
    with article bc_U1035
    with list_together bc_U1036
;
K2_thing -> I_milk_bottles_U1    with short_name bc_U1037
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 124
    with K2_thing_Next I_ferris_wheel_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name158
    with name 'milk' 'bottles' 'things//p' 'bottle'
    with description bc_U1038
    with initial bc_U1039
    with plural bc_U1040
    with article bc_U1041
    with list_together bc_U1042
;
K1_room I_ferris_wheel_ride_U1    with short_name bc_U899
    with article bc_U900
    with description ts_array_U564
    with map_region I_midway_U1
    has ~P_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 19
    with K1_room_Next I_dime_toss_game_U1
    with name 'ferris' 'wheel' 'ride' 'rooms//p'
    with plural bc_U901
    with list_together bc_U902
;
K20_attendant -> I_ferris_wheel_attendant_U1    with short_name bc_U1096
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 133
    with K2_thing_Next I_dime_toss_attendant_U1
    with IK8_Count 8
    with K8_person_Next I_dime_toss_attendant_U1
    with K20_attendant_Count 5
    with K20_attendant_Next I_dime_toss_attendant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ferris' 'wheel' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U1097
    with initial bc_U1098
    with plural bc_U1099
    with article bc_U1100
    with list_together bc_U1101
;
K1_room I_dime_toss_game_U1    with short_name bc_U903
    with article bc_U904
    with description ts_array_U565
    with map_region I_midway_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 20
    with K1_room_Next I_show_tent_U1
    with name 'dime' 'toss' 'game' 'rooms//p'
    with plural bc_U905
    with list_together bc_U906
;
K20_attendant -> I_dime_toss_attendant_U1    with short_name bc_U612
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 20
    with IK2_Count 54
    with K2_thing_Next I_fuse15_U1
    with IK8_Count 3
    with K8_person_Next I_little_egypt_U1
    with K20_attendant_Count 2
    with K20_attendant_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'toss' 'attendant' 'attendants//p' 'attendent' 'operator' 'teen' 'teenager' 'bored'
    with description bc_U613
    with initial bc_U614
    with plural bc_U615
    with article bc_U616
    with list_together bc_U617
;
K29_fuse -> -> I_fuse15_U1    with P_fuse_id 15
    has ~static
    with P_color I_orange_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 53
    with K2_thing_Next I_small_plush_monkey_U1
    with K29_fuse_Count 7
    with K29_fuse_Next I_fuse17_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse15' 'fuses//p' 'fuse'
    with description ts_array_U544
    with initial bc_U608
    with short_name ts_array_U545
    with plural bc_U609
    with article bc_U610
    with list_together bc_U611
;
K2_thing -> -> I_small_plush_monkey_U1    with short_name bc_U977
    with description bc_U978
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 114
    with K2_thing_Next I_poster_of_billie_eilish_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name148
    with name 'small' 'plush' 'monkey' 'things//p' 'stuffie' 'stuffed'
    with initial bc_U979
    with plural bc_U980
    with article bc_U981
    with list_together bc_U982
;
K2_thing -> -> I_poster_of_billie_eilish_U1    with short_name bc_U983
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 115
    with K2_thing_Next I_small_pocket_mirror_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'poster' 'of' 'billie' 'eilish' 'things//p'
    with description bc_U984
    with initial bc_U985
    with plural bc_U986
    with article bc_U987
    with list_together bc_U988
;
K2_thing -> -> I_small_pocket_mirror_U1    with short_name bc_U989
    with description bc_U990
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 116
    with K2_thing_Next I_dime_toss_booth_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'small' 'pocket' 'mirror' 'things//p'
    with initial bc_U991
    with plural bc_U992
    with article bc_U993
    with list_together bc_U994
;
K2_thing -> I_dime_toss_booth_U1    with short_name bc_U966
    with description ts_array_U573
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 112
    with K2_thing_Next I_plate_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'dime' 'toss' 'booth' 'things//p'
    with initial bc_U967
    with plural bc_U968
    with article bc_U969
    with list_together bc_U970
;
K6_supporter -> I_plate_U1    with short_name bc_U995
    with description bc_U996
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 117
    with K2_thing_Next I_screwdriver_U1
    with IK6_Count 6
    with K6_supporter_Next I_folding_chair_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name151
    with name 'plate' 'supporters//p' 'plates'
    with initial bc_U997
    with plural bc_U998
    with article bc_U999
    with list_together bc_U1000
;
K2_thing I_screwdriver_U1    with short_name bc_U919
    with description ts_array_U566
    with vector 0
    has mark_as_thing
    with component_parent I_swiss_army_knife_U1
    with component_sibling I_awl_U1
    with KD_Count 2
    with IK2_Count 103
    with K2_thing_Next I_awl_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'screwdriver' 'things//p'
    with initial bc_U920
    with plural bc_U921
    with article bc_U922
    with list_together bc_U923
;
K2_thing I_awl_U1    with short_name bc_U924
    with description ts_array_U567
    with vector 0
    has mark_as_thing
    with component_parent I_swiss_army_knife_U1
    with component_sibling I_fingernail_clippers_U1
    with KD_Count 2
    with IK2_Count 104
    with K2_thing_Next I_fingernail_clippers_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'awl' 'things//p'
    with initial bc_U925
    with plural bc_U926
    with article bc_U927
    with list_together bc_U928
;
K2_thing I_fingernail_clippers_U1    with short_name bc_U929
    with description ts_array_U568
    with vector 0
    has mark_as_thing
    with component_parent I_swiss_army_knife_U1
    with component_sibling I_can_opener_U1
    with KD_Count 2
    with IK2_Count 105
    with K2_thing_Next I_can_opener_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fingernail' 'clippers' 'things//p'
    with initial bc_U930
    with plural bc_U931
    with article bc_U932
    with list_together bc_U933
;
K2_thing I_can_opener_U1    with short_name bc_U934
    with description ts_array_U569
    with vector 0
    has mark_as_thing
    with component_parent I_swiss_army_knife_U1
    with component_sibling I_corkscrew_U1
    with KD_Count 2
    with IK2_Count 106
    with K2_thing_Next I_corkscrew_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'can' 'opener' 'things//p'
    with initial bc_U935
    with plural bc_U936
    with article bc_U937
    with list_together bc_U938
;
K2_thing I_corkscrew_U1    with short_name bc_U939
    with description ts_array_U570
    with vector 0
    has mark_as_thing
    with component_parent I_swiss_army_knife_U1
    with KD_Count 2
    with IK2_Count 107
    with K2_thing_Next I_mercury_dime_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'corkscrew' 'things//p'
    with initial bc_U940
    with plural bc_U941
    with article bc_U942
    with list_together bc_U943
;
K23_dime I_mercury_dime_U1    with short_name bc_U971
    with description bc_U972
    with P_underlying_relation_storag I_dime_toss_booth_U1
    with vector 0
    has mark_as_thing
    with KD_Count 23
    with IK2_Count 113
    with K2_thing_Next I_little_egypt_U1
    with K21_coin_Count 9
    with K21_coin_Next 0
    with K23_dime_Count 5
    with K23_dime_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'mercury' 'dime' 'dimes//p' 'shiny'
    with initial bc_U973
    with plural bc_U974
    with article bc_U975
    with list_together bc_U976
;
K1_room I_show_tent_U1    with short_name bc_U1043
    with description ts_array_U574
    with map_region I_midway_U1
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 21
    with K1_room_Next I_ride_entrance_U1
    with name 'show' 'tent' 'rooms//p'
    with plural bc_U1044
    with article bc_U1045
    with list_together bc_U1046
;
K11_woman -> I_little_egypt_U1    with short_name bc_U1059
    with description bc_U1060
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 11
    with IK2_Count 127
    with K2_thing_Next I_stage_U1
    with IK8_Count 7
    with K8_person_Next 0
    with K11_woman_Count 0
    with K11_woman_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'little' 'egypt' 'women//p'
    with initial bc_U1061
    with plural bc_U1062
    with article bc_U1063
    with list_together bc_U1064
;
K2_thing -> I_stage_U1    with short_name bc_U1071
    with description bc_U1072
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 129
    with K2_thing_Next I_wall_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'stage' 'things//p'
    with initial bc_U1073
    with plural bc_U1074
    with article bc_U1075
    with list_together bc_U1076
;
K5_container -> I_wall_U1    with short_name bc_U1077
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 130
    with K2_thing_Next I_lantern_U1
    with IK5_Count 20
    with K5_container_Next I_hell_ride_car_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wall' 'containers//p'
    with description bc_U1078
    with initial bc_U1079
    with plural bc_U1080
    with article bc_U1081
    with list_together bc_U1082
;
K19_electric_lamp -> -> I_lantern_U1    with short_name bc_U1083
    with description bc_U1084
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 19
    with IK2_Count 131
    with K2_thing_Next I_folding_chair_U1
    with K13_device_Count 6
    with K13_device_Next I_flashlight_U1
    with K19_electric_lamp_Count 0
    with K19_electric_lamp_Next I_flashlight_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name166
    with name 'lantern' 'electric//p' 'lamps//p' 'lamp'
    with initial bc_U1085
    with plural bc_U1086
    with article bc_U1087
    with list_together bc_U1088
;
K6_supporter -> I_folding_chair_U1    with short_name bc_U1089
    with description bc_U1090
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 132
    with K2_thing_Next I_sheer_veil_U1
    with IK6_Count 7
    with K6_supporter_Next I_stool_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'folding' 'chair' 'supporters//p'
    with initial bc_U1091
    with plural bc_U1092
    with article bc_U1093
    with list_together bc_U1094
;
K2_thing I_sheer_veil_U1    with short_name bc_U1065
    with description bc_U1066
    has clothing
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 128
    with K2_thing_Next I_hell_ride_car_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'sheer' 'veil' 'things//p'
    with initial bc_U1067
    with plural bc_U1068
    with article bc_U1069
    with list_together bc_U1070
;
K1_room I_ride_entrance_U1    with short_name bc_U1126
    with description ts_array_U575
    with map_region I_hellride_U1
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 22
    with K1_room_Next I_dark_passage_U1
    with name 'ride' 'entrance' 'rooms//p'
    with plural bc_U1127
    with article bc_U1128
    with list_together bc_U1129
;
K14_vehicle -> I_hell_ride_car_U1    with short_name bc_U1608
    with description bc_U1609
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 14
    with IK2_Count 213
    with K2_thing_Next I_dust_bunnies_U1
    with IK5_Count 24
    with K5_container_Next I_pile_of_junk_U1
    with K14_vehicle_Count 0
    with K14_vehicle_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hell' 'ride' 'car' 'vehicles//p'
    with initial bc_U1610
    with plural bc_U1611
    with article bc_U1612
    with list_together bc_U1613
;
K1_room I_dark_passage_U1    with short_name bc_U1136
    with description bc_U1137
    with map_region I_back_stage_U1
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 23
    with K1_room_Next I_maintenance_office_U1
    with name 'dark' 'passage' 'rooms//p'
    with plural bc_U1138
    with article bc_U1139
    with list_together bc_U1140
;
K2_thing -> I_dust_bunnies_U1    with short_name bc_U1141
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 139
    with K2_thing_Next I_bags_of_trash_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name176
    with name 'dust' 'bunnies' 'things//p' 'bunnies'
    with description bc_U1142
    with initial bc_U1143
    with plural bc_U1144
    with article bc_U1145
    with list_together bc_U1146
;
K2_thing -> I_bags_of_trash_U1    with short_name bc_U1147
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 140
    with K2_thing_Next I_pile_of_junk_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name177
    with name 'bags' 'of' 'trash' 'things//p' 'bags' 'trash'
    with description bc_U1148
    with initial bc_U1149
    with plural bc_U1150
    with article bc_U1151
    with list_together bc_U1152
;
K5_container -> I_pile_of_junk_U1    with short_name bc_U1153
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 141
    with K2_thing_Next I_flashlight_U1
    with IK5_Count 21
    with K5_container_Next I_drawer_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name178
    with name 'pile' 'of' 'junk' 'containers//p' 'piles' 'junk'
    with description bc_U1154
    with initial bc_U1155
    with plural bc_U1156
    with article bc_U1157
    with list_together bc_U1158
;
K19_electric_lamp -> -> I_flashlight_U1    with short_name bc_U1159
    with description ts_array_U576
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 19
    with IK2_Count 142
    with K2_thing_Next I_screws_U1
    with K13_device_Count 7
    with K13_device_Next I_radio_U1
    with K19_electric_lamp_Count 1
    with K19_electric_lamp_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'flashlight' 'electric//p' 'lamps//p'
    with initial bc_U1160
    with plural bc_U1161
    with article bc_U1162
    with list_together bc_U1163
;
K1_room I_maintenance_office_U1    with short_name bc_U1164
    with description bc_U1165
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 24
    with K1_room_Next I_stocks_room_U1
    with name 'maintenance' 'office' 'rooms//p'
    with plural bc_U1166
    with article bc_U1167
    with list_together bc_U1168
;
K2_thing -> I_screws_U1    with short_name bc_U1169
    with description bc_U1170
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 143
    with K2_thing_Next I_paint_cans_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'screws' 'things//p'
    with initial bc_U1171
    with plural bc_U1172
    with article bc_U1173
    with list_together bc_U1174
;
K2_thing -> I_paint_cans_U1    with short_name bc_U1175
    with description bc_U1176
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 144
    with K2_thing_Next I_grease_jars_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'paint' 'cans' 'things//p'
    with initial bc_U1177
    with plural bc_U1178
    with article bc_U1179
    with list_together bc_U1180
;
K2_thing -> I_grease_jars_U1    with short_name bc_U1181
    with description bc_U1182
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 145
    with K2_thing_Next I_vise_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'grease' 'jars' 'things//p'
    with initial bc_U1183
    with plural bc_U1184
    with article bc_U1185
    with list_together bc_U1186
;
K2_thing -> I_vise_U1    with short_name bc_U1187
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 146
    with K2_thing_Next I_bent_piece_of_metal_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'vise' 'things//p'
    with description bc_U1188
    with initial bc_U1189
    with plural bc_U1190
    with article bc_U1191
    with list_together bc_U1192
;
K2_thing -> I_bent_piece_of_metal_U1    with short_name bc_U1193
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 147
    with K2_thing_Next I_safety_posters_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bent' 'piece' 'of' 'metal' 'things//p'
    with description bc_U1194
    with initial bc_U1195
    with plural bc_U1196
    with article bc_U1197
    with list_together bc_U1198
;
K2_thing -> I_safety_posters_U1    with short_name bc_U1199
    with description ts_array_U577
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 148
    with K2_thing_Next I_notes_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'safety' 'posters' 'things//p'
    with initial bc_U1200
    with plural bc_U1201
    with article bc_U1202
    with list_together bc_U1203
;
K2_thing -> I_notes_U1    with short_name bc_U1204
    with description bc_U1205
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 149
    with K2_thing_Next I_clock_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'notes' 'things//p'
    with initial bc_U1206
    with plural bc_U1207
    with article bc_U1208
    with list_together bc_U1209
;
K2_thing -> I_clock_U1    with short_name bc_U1210
    with description ts_array_U578
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 150
    with K2_thing_Next I_lubricant_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'clock' 'things//p'
    with initial bc_U1211
    with plural bc_U1212
    with article bc_U1213
    with list_together bc_U1214
;
K2_thing -> I_lubricant_U1    with short_name bc_U1215
    with description ts_array_U579
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 151
    with K2_thing_Next I_manual_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'lubricant' 'things//p'
    with initial bc_U1216
    with plural bc_U1217
    with article bc_U1218
    with list_together bc_U1219
;
K2_thing -> I_manual_U1    with short_name bc_U1220
    with description ts_array_U580
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 152
    with K2_thing_Next I_stool_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'manual' 'things//p'
    with initial bc_U1221
    with plural bc_U1222
    with article bc_U1223
    with list_together bc_U1224
;
K6_supporter -> I_stool_U1    with short_name bc_U1225
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 153
    with K2_thing_Next I_worn_photo_U1
    with IK6_Count 8
    with K6_supporter_Next I_desk_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'stool' 'supporters//p'
    with description bc_U1226
    with initial bc_U1227
    with plural bc_U1228
    with article bc_U1229
    with list_together bc_U1230
;
K2_thing -> I_worn_photo_U1    with short_name bc_U231
    with description bc_U232
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 154
    with K2_thing_Next I_desk_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name192
    with name 'worn' 'photo' 'things//p' 'picture'
    with initial bc_U233
    with plural bc_U234
    with article bc_U235
    with list_together bc_U236
;
K6_supporter -> I_desk_U1    with short_name bc_U1236
    with description ts_array_U582
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has supporter
    with component_child I_drawer_U1
    with KD_Count 6
    with IK2_Count 156
    with K2_thing_Next I_coffee_mug_U1
    with IK6_Count 9
    with K6_supporter_Next I_wooden_stocks_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'desk' 'supporters//p'
    with initial bc_U1237
    with plural bc_U1238
    with article bc_U1239
    with list_together bc_U1240
;
K2_thing -> -> I_coffee_mug_U1    with short_name bc_U1231
    with description ts_array_U581
    has edible
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 155
    with K2_thing_Next I_radio_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name193
    with name 'coffee' 'mug' 'things//p' 'coffee'
    with initial bc_U1232
    with plural bc_U1233
    with article bc_U1234
    with list_together bc_U1235
;
K13_device -> -> I_radio_U1    with short_name bc_U1247
    with description ts_array_U583
    has static
    has ~on
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 13
    with IK2_Count 158
    with K2_thing_Next I_drawer_U1
    with K13_device_Count 8
    with K13_device_Next I_big_switch_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'radio' 'devices//p'
    with initial bc_U1248
    with plural bc_U1249
    with article bc_U1250
    with list_together bc_U1251
;
K5_container I_drawer_U1    with short_name bc_U1241
    has static
    has scenery
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    has container
    with component_parent I_desk_U1
    with KD_Count 5
    with IK2_Count 157
    with K2_thing_Next I_scissors_U1
    with IK5_Count 22
    with K5_container_Next I_toolbox_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'drawer' 'containers//p'
    with description bc_U1242
    with initial bc_U1243
    with plural bc_U1244
    with article bc_U1245
    with list_together bc_U1246
;
K2_thing -> I_scissors_U1    with short_name bc_U1252
    with description bc_U1253
    has proper
    with vector 0
    with cap_short_name bc_U1254
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 159
    with K2_thing_Next I_stapler_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'scissors' 'things//p'
    with initial bc_U1255
    with plural bc_U1256
    with article bc_U1257
    with list_together bc_U1258
;
K2_thing -> I_stapler_U1    with short_name bc_U1259
    with description bc_U1260
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 160
    with K2_thing_Next I_ballpoint_pen_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'stapler' 'things//p'
    with initial bc_U1261
    with plural bc_U1262
    with article bc_U1263
    with list_together bc_U1264
;
K2_thing -> I_ballpoint_pen_U1    with short_name bc_U1265
    with description bc_U1266
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 161
    with K2_thing_Next I_pad_of_paper_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ballpoint' 'pen' 'things//p'
    with initial bc_U1267
    with plural bc_U1268
    with article bc_U1269
    with list_together bc_U1270
;
K2_thing -> I_pad_of_paper_U1    with short_name bc_U1271
    with description bc_U1272
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 162
    with K2_thing_Next I_door1_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'pad' 'of' 'paper' 'things//p'
    with initial bc_U1273
    with plural bc_U1274
    with article bc_U1275
    with list_together bc_U1276
;
K33_wooden_door I_door1_U1    with description ts_array_U584
    with with_key I_silver_key_U1
    with P_color I_aqua_U1
    with vector 0
    with found_in I_maintenance_office_U1 I_stocks_room_U1
    has door
    with door_dir TSD_door_dir_value1
    with door_to TSD_door_to_value1
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 163
    with K2_thing_Next I_wooden_stocks_U1
    with IK4_Count 0
    with K4_door_Next I_ladder_U1
    with K33_wooden_door_Count 0
    with K33_wooden_door_Next I_door3_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door1' 'wooden//p' 'doors//p'
    with initial ts_array_U585
    with short_name ts_array_U586
    with plural bc_U1277
    with article bc_U1278
    with list_together bc_U1279
;
K1_room I_stocks_room_U1    with short_name bc_U1280
    with description ts_array_U587
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 25
    with K1_room_Next I_dark_hallway_U1
    with name 'stocks' 'room' 'rooms//p'
    with plural bc_U1281
    with article bc_U1282
    with list_together bc_U1283
;
K6_supporter -> I_wooden_stocks_U1    with short_name bc_U563
    with description ts_array_U535
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 44
    with K2_thing_Next I_ladder_U1
    with IK6_Count 1
    with K6_supporter_Next I_gallows_platform_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wooden' 'stocks' 'supporters//p'
    with initial bc_U564
    with plural bc_U565
    with article bc_U566
    with list_together bc_U567
;
K4_door I_ladder_U1    with short_name bc_U1284
    with description ts_array_U588
    has open
    with vector 0
    with found_in I_maintenance_office_U1 I_dark_hallway_U1
    has door
    with door_dir TSD_door_dir_value2
    with door_to TSD_door_to_value2
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 164
    with K2_thing_Next I_door3_U1
    with IK4_Count 1
    with K4_door_Next I_door3_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'ladder' 'doors//p'
    with initial ts_array_U589
    with plural bc_U1285
    with article bc_U1286
    with list_together bc_U1287
;
K1_room I_dark_hallway_U1    with short_name bc_U1288
    with description bc_U1289
    with map_region I_second_floor_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 26
    with K1_room_Next I_crawl_space_U1
    with name 'dark' 'hallway' 'rooms//p'
    with plural bc_U1290
    with article bc_U1291
    with list_together bc_U1292
;
K1_room I_crawl_space_U1    with short_name bc_U1293
    with description bc_U1294
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 27
    with K1_room_Next I_gallows_room_U1
    with name 'crawl' 'space' 'rooms//p'
    with plural bc_U1295
    with article bc_U1296
    with list_together bc_U1297
;
K33_wooden_door I_door3_U1    with description ts_array_U590
    with with_key I_silver_key_U1
    with P_color I_crimson_U1
    with vector 0
    with found_in I_crawl_space_U1 I_gallows_room_U1
    has door
    with door_dir TSD_door_dir_value3
    with door_to TSD_door_to_value3
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 165
    with K2_thing_Next I_gallows_platform_U1
    with IK4_Count 2
    with K4_door_Next I_door5_U1
    with K33_wooden_door_Count 1
    with K33_wooden_door_Next I_door5_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door3' 'wooden//p' 'doors//p'
    with initial ts_array_U591
    with short_name ts_array_U592
    with plural bc_U1298
    with article bc_U1299
    with list_together bc_U1300
;
K1_room I_gallows_room_U1    with short_name bc_U1301
    with description ts_array_U593
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 28
    with K1_room_Next I_mechanical_room_north_U1
    with name 'gallows' 'room' 'rooms//p'
    with plural bc_U1302
    with article bc_U1303
    with list_together bc_U1304
;
K6_supporter -> I_gallows_platform_U1    with short_name bc_U592
    with description bc_U593
    has static
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 50
    with K2_thing_Next I_toolbox_U1
    with IK6_Count 4
    with K6_supporter_Next I_iron_chair_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name71
    with name 'gallows' 'platform' 'supporters//p' 'gallows'
    with initial bc_U594
    with plural bc_U595
    with article bc_U596
    with list_together bc_U597
;
K1_room I_mechanical_room_north_U1    with short_name bc_U1305
    with description bc_U1306
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 29
    with K1_room_Next I_stake_room_U1
    with name 'mechanical' 'room' 'north' 'rooms//p'
    with plural bc_U1307
    with article bc_U1308
    with list_together bc_U1309
;
K5_container -> I_toolbox_U1    with short_name bc_U1310
    has static
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 166
    with K2_thing_Next I_adjustable_wrench_U1
    with IK5_Count 23
    with K5_container_Next I_pyre_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name209
    with name 'toolbox' 'containers//p' 'tool' 'box'
    with description bc_U1311
    with initial bc_U1312
    with plural bc_U1313
    with article bc_U1314
    with list_together bc_U1315
;
K2_thing -> -> I_adjustable_wrench_U1    with short_name bc_U1316
    with description ts_array_U594
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 167
    with K2_thing_Next I_channel_locks_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'adjustable' 'wrench' 'things//p'
    with initial bc_U1317
    with plural bc_U1318
    with article bc_U1319
    with list_together bc_U1320
;
K2_thing -> -> I_channel_locks_U1    with short_name bc_U1321
    has proper
    with vector 0
    with cap_short_name bc_U1322
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 168
    with K2_thing_Next I_pliers_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'channel' 'locks' 'things//p'
    with description bc_U1323
    with initial bc_U1324
    with plural bc_U1325
    with article bc_U1326
    with list_together bc_U1327
;
K2_thing -> -> I_pliers_U1    with short_name bc_U1328
    has proper
    with vector 0
    with cap_short_name bc_U1329
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 169
    with K2_thing_Next I_hammer_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'pliers' 'things//p'
    with description bc_U1330
    with initial bc_U1331
    with plural bc_U1332
    with article bc_U1333
    with list_together bc_U1334
;
K2_thing -> -> I_hammer_U1    with short_name bc_U1335
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 170
    with K2_thing_Next I_hydraulic_pump_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hammer' 'things//p'
    with description bc_U1336
    with initial bc_U1337
    with plural bc_U1338
    with article bc_U1339
    with list_together bc_U1340
;
K2_thing -> I_hydraulic_pump_U1    with short_name bc_U1341
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 171
    with K2_thing_Next I_gauges_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hydraulic' 'pump' 'things//p'
    with description bc_U1342
    with initial bc_U1343
    with plural bc_U1344
    with article bc_U1345
    with list_together bc_U1346
;
K2_thing -> I_gauges_U1    with short_name bc_U1347
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 172
    with K2_thing_Next I_tools_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'gauges' 'things//p'
    with description bc_U1348
    with initial bc_U1349
    with plural bc_U1350
    with article bc_U1351
    with list_together bc_U1352
;
K2_thing -> I_tools_U1    with short_name bc_U1353
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 173
    with K2_thing_Next I_bench_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'tools' 'things//p'
    with description bc_U1354
    with initial bc_U1355
    with plural bc_U1356
    with article bc_U1357
    with list_together bc_U1358
;
K2_thing -> I_bench_U1    with short_name bc_U1359
    with description bc_U1360
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 174
    with K2_thing_Next I_wires_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name217
    with name 'bench' 'things//p' 'workbench'
    with initial bc_U1361
    with plural bc_U1362
    with article bc_U1363
    with list_together bc_U1364
;
K2_thing -> I_wires_U1    with short_name bc_U1365
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 175
    with K2_thing_Next I_spare_parts_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'wires' 'things//p'
    with description bc_U1366
    with initial bc_U1367
    with plural bc_U1368
    with article bc_U1369
    with list_together bc_U1370
;
K2_thing -> I_spare_parts_U1    with short_name bc_U1371
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 176
    with K2_thing_Next I_hydraulic_tubing_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'spare' 'parts' 'things//p'
    with description bc_U1372
    with initial bc_U1373
    with plural bc_U1374
    with article bc_U1375
    with list_together bc_U1376
;
K2_thing -> I_hydraulic_tubing_U1    with short_name bc_U1377
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U1378
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 177
    with K2_thing_Next I_diagram_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hydraulic' 'tubing' 'things//p'
    with description bc_U1379
    with initial bc_U1380
    with plural bc_U1381
    with article bc_U1382
    with list_together bc_U1383
;
K2_thing -> I_diagram_U1    with short_name bc_U1384
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 178
    with K2_thing_Next I_door5_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'diagram' 'things//p'
    with description bc_U1385
    with initial bc_U1386
    with plural bc_U1387
    with article bc_U1388
    with list_together bc_U1389
;
K33_wooden_door I_door5_U1    with description ts_array_U595
    with with_key I_silver_key_U1
    with P_color I_emerald_U1
    with vector 0
    with found_in I_mechanical_room_north_U1 I_stake_room_U1
    has door
    with door_dir TSD_door_dir_value4
    with door_to TSD_door_to_value4
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 179
    with K2_thing_Next I_pyre_U1
    with IK4_Count 3
    with K4_door_Next I_grate_U1
    with K33_wooden_door_Count 2
    with K33_wooden_door_Next I_door7_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door5' 'wooden//p' 'doors//p'
    with initial ts_array_U596
    with short_name ts_array_U597
    with plural bc_U1390
    with article bc_U1391
    with list_together bc_U1392
;
K1_room I_stake_room_U1    with short_name bc_U1393
    with description ts_array_U598
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 30
    with K1_room_Next I_mechanical_room_south_U1
    with name 'stake' 'room' 'rooms//p'
    with plural bc_U1394
    with article bc_U1395
    with list_together bc_U1396
;
K5_container -> I_pyre_U1    with short_name bc_U622
    with description bc_U623
    has static
    has open
    has ~openable
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 56
    with K2_thing_Next I_fuse17_U1
    with IK5_Count 14
    with K5_container_Next I_merchandise_stand_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name77
    with name 'pyre' 'containers//p' 'fire'
    with initial bc_U624
    with plural bc_U625
    with article bc_U626
    with list_together bc_U627
;
K29_fuse -> -> I_fuse17_U1    with P_fuse_id 17
    with P_color I_quartz_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 55
    with K2_thing_Next I_stakes_U1
    with K29_fuse_Count 8
    with K29_fuse_Next I_fuse1_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse17' 'fuses//p' 'fuse'
    with description ts_array_U546
    with initial bc_U618
    with short_name ts_array_U547
    with plural bc_U619
    with article bc_U620
    with list_together bc_U621
;
K2_thing -> I_stakes_U1    with short_name bc_U1614
    with description bc_U1615
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U1616
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 214
    with K2_thing_Next I_lights_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'stakes' 'things//p'
    with initial bc_U1617
    with plural bc_U1618
    with article bc_U1619
    with list_together bc_U1620
;
K1_room I_mechanical_room_south_U1    with short_name bc_U1397
    with description bc_U1398
    with map_region I_back_stage_U1
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 31
    with K1_room_Next I_holding_room_U1
    with name 'mechanical' 'room' 'south' 'rooms//p'
    with plural bc_U1399
    with article bc_U1400
    with list_together bc_U1401
;
K2_thing -> I_lights_U1    with short_name bc_U1402
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 180
    with K2_thing_Next I_thick_belts_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'lights' 'things//p'
    with description bc_U1403
    with initial bc_U1404
    with plural bc_U1405
    with article bc_U1406
    with list_together bc_U1407
;
K2_thing -> I_thick_belts_U1    with short_name bc_U1408
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 181
    with K2_thing_Next I_pulleys_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'thick' 'belts' 'things//p'
    with description bc_U1409
    with initial bc_U1410
    with plural bc_U1411
    with article bc_U1412
    with list_together bc_U1413
;
K2_thing -> I_pulleys_U1    with short_name bc_U1414
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 182
    with K2_thing_Next I_gears_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'pulleys' 'things//p'
    with description bc_U1415
    with initial bc_U1416
    with plural bc_U1417
    with article bc_U1418
    with list_together bc_U1419
;
K2_thing -> I_gears_U1    with short_name bc_U1420
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 183
    with K2_thing_Next I_table_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'gears' 'things//p'
    with description bc_U1421
    with initial bc_U1422
    with plural bc_U1423
    with article bc_U1424
    with list_together bc_U1425
;
K2_thing -> I_table_U1    with short_name bc_U1426
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 184
    with K2_thing_Next I_bolts_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'table' 'things//p'
    with description bc_U1427
    with initial bc_U1428
    with plural bc_U1429
    with article bc_U1430
    with list_together bc_U1431
;
K2_thing -> I_bolts_U1    with short_name bc_U1432
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 185
    with K2_thing_Next I_lubricants_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'bolts' 'things//p'
    with description bc_U1433
    with initial bc_U1434
    with plural bc_U1435
    with article bc_U1436
    with list_together bc_U1437
;
K2_thing -> I_lubricants_U1    with short_name bc_U1438
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 186
    with K2_thing_Next I_cooling_fan_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'lubricants' 'things//p'
    with description bc_U1439
    with initial bc_U1440
    with plural bc_U1441
    with article bc_U1442
    with list_together bc_U1443
;
K2_thing -> I_cooling_fan_U1    with short_name bc_U1444
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 187
    with K2_thing_Next I_grate_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cooling' 'fan' 'things//p'
    with description bc_U1445
    with initial bc_U1446
    with plural bc_U1447
    with article bc_U1448
    with list_together bc_U1449
;
K1_room I_holding_room_U1    with short_name bc_U1454
    with description bc_U1455
    with map_region I_second_floor_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 32
    with K1_room_Next I_dungeon_U1
    with name 'holding' 'room' 'rooms//p'
    with plural bc_U1456
    with article bc_U1457
    with list_together bc_U1458
;
K4_door -> I_grate_U1    with short_name bc_U1450
    with description ts_array_U599
    has openable
    has lockable
    has locked
    with vector 0
    has door
    with door_dir I_up_U1
    has mark_as_thing
    with KD_Count 4
    with IK2_Count 188
    with K2_thing_Next I_door7_U1
    with IK4_Count 4
    with K4_door_Next I_door7_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'grate' 'doors//p'
    with initial ts_array_U600
    with plural bc_U1451
    with article bc_U1452
    with list_together bc_U1453
;
K33_wooden_door I_door7_U1    with description ts_array_U601
    with with_key I_silver_key_U1
    with P_color I_gray_U1
    with vector 0
    with found_in I_mechanical_room_south_U1 I_dungeon_U1
    has door
    with door_dir TSD_door_dir_value5
    with door_to TSD_door_to_value5
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 189
    with K2_thing_Next I_iron_chair_U1
    with IK4_Count 5
    with K4_door_Next I_door9_U1
    with K33_wooden_door_Count 3
    with K33_wooden_door_Next I_door9_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door7' 'wooden//p' 'doors//p'
    with initial ts_array_U602
    with short_name ts_array_U603
    with plural bc_U1459
    with article bc_U1460
    with list_together bc_U1461
;
K1_room I_dungeon_U1    with short_name bc_U1462
    with description ts_array_U604
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 33
    with K1_room_Next I_guillotine_room_U1
    with name 'dungeon' 'rooms//p'
    with plural bc_U1463
    with article bc_U1464
    with list_together bc_U1465
;
K6_supporter -> I_iron_chair_U1    with short_name bc_U582
    with description bc_U583
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 48
    with K2_thing_Next I_chains_U1
    with IK6_Count 3
    with K6_supporter_Next I_guillotine_platform_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name69
    with name 'iron' 'chair' 'supporters//p' 'spiked' 'seat'
    with initial bc_U584
    with plural bc_U585
    with article bc_U586
    with list_together bc_U587
;
K2_thing -> I_chains_U1    with short_name bc_U1621
    with description bc_U1622
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name bc_U1623
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 215
    with K2_thing_Next I_rack_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'chains' 'things//p'
    with initial bc_U1624
    with plural bc_U1625
    with article bc_U1626
    with list_together bc_U1627
;
K2_thing -> I_rack_U1    with short_name bc_U1628
    with description bc_U1629
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 216
    with K2_thing_Next I_brazier_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'rack' 'things//p'
    with initial bc_U1630
    with plural bc_U1631
    with article bc_U1632
    with list_together bc_U1633
;
K2_thing -> I_brazier_U1    with short_name bc_U1634
    with description bc_U1635
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 217
    with K2_thing_Next I_riveted_iron_bound_door_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'brazier' 'things//p'
    with initial bc_U1636
    with plural bc_U1637
    with article bc_U1638
    with list_together bc_U1639
;
K2_thing -> I_riveted_iron_bound_door_U1    with short_name bc_U1640
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 218
    with K2_thing_Next I_door9_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'riveted' 'iron-bound' 'door' 'things//p'
    with description bc_U1641
    with initial bc_U1642
    with plural bc_U1643
    with article bc_U1644
    with list_together bc_U1645
;
K33_wooden_door I_door9_U1    with description ts_array_U605
    with with_key I_silver_key_U1
    with P_color I_indigo_U1
    with vector 0
    with found_in I_generator_room_U1 I_guillotine_room_U1
    has door
    with door_dir TSD_door_dir_value6
    with door_to TSD_door_to_value6
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 201
    with K2_thing_Next I_guillotine_platform_U1
    with IK4_Count 6
    with K4_door_Next I_door11_U1
    with K33_wooden_door_Count 4
    with K33_wooden_door_Next I_door11_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door9' 'wooden//p' 'doors//p'
    with initial ts_array_U606
    with short_name ts_array_U607
    with plural bc_U1533
    with article bc_U1534
    with list_together bc_U1535
;
K1_room I_guillotine_room_U1    with short_name bc_U1536
    with description ts_array_U608
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 34
    with K1_room_Next I_ride_exit_U1
    with name 'guillotine' 'room' 'rooms//p'
    with plural bc_U1537
    with article bc_U1538
    with list_together bc_U1539
;
K6_supporter -> I_guillotine_platform_U1    with short_name bc_U572
    with description bc_U573
    with vector 0
    has mark_as_thing
    has supporter
    with KD_Count 6
    with IK2_Count 46
    with K2_thing_Next I_door11_U1
    with IK6_Count 2
    with K6_supporter_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name67
    with name 'guillotine' 'platform' 'supporters//p' 'scaffold'
    with initial bc_U574
    with plural bc_U575
    with article bc_U576
    with list_together bc_U577
;
K33_wooden_door I_door11_U1    with description ts_array_U609
    with with_key I_silver_key_U1
    with P_color I_khaki_U1
    with vector 0
    with found_in I_storage_room_U1 I_ride_exit_U1
    has door
    with door_dir TSD_door_dir_value7
    with door_to TSD_door_to_value7
    has mark_as_thing
    with KD_Count 33
    with IK2_Count 212
    with K2_thing_Next I_merchandise_stand_U1
    with IK4_Count 7
    with K4_door_Next 0
    with K33_wooden_door_Count 5
    with K33_wooden_door_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'door11' 'wooden//p' 'doors//p'
    with initial ts_array_U610
    with short_name ts_array_U611
    with plural bc_U1600
    with article bc_U1601
    with list_together bc_U1602
;
K1_room I_ride_exit_U1    with short_name bc_U1603
    with description ts_array_U612
    with map_region I_hellride_U1
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 35
    with K1_room_Next I_control_room_U1
    with name 'ride' 'exit' 'rooms//p'
    with plural bc_U1604
    with article bc_U1605
    with list_together bc_U1606
;
K5_container -> I_merchandise_stand_U1    with short_name bc_U543
    with description bc_U544
    has static
    has scenery
    with vector 0
    has mark_as_thing
    has container
    with KD_Count 5
    with IK2_Count 40
    with K2_thing_Next I_fuse1_U1
    with IK5_Count 13
    with K5_container_Next I_control_panel_one_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name61
    with name 'merchandise' 'stand' 'containers//p' 'stand'
    with initial bc_U545
    with plural bc_U546
    with article bc_U547
    with list_together bc_U548
;
K29_fuse -> -> I_fuse1_U1    with P_fuse_id 1
    with P_price 350
    with P_color I_aqua_U1
    with vector 0
    has mark_as_thing
    with KD_Count 29
    with IK2_Count 39
    with K2_thing_Next I_plastic_bones_U1
    with K29_fuse_Count 0
    with K29_fuse_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'fuse1' 'fuses//p' 'fuse'
    with description ts_array_U529
    with initial bc_U539
    with short_name ts_array_U530
    with plural bc_U540
    with article bc_U541
    with list_together bc_U542
;
K2_thing -> -> I_plastic_bones_U1    with short_name bc_U1646
    with description bc_U1647
    has proper
    with P_price 100
    with vector 0
    with cap_short_name bc_U1648
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 219
    with K2_thing_Next I_devil_horns_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'plastic' 'bones' 'things//p'
    with initial bc_U1649
    with plural bc_U1650
    with article bc_U1651
    with list_together bc_U1652
;
K2_thing -> -> I_devil_horns_U1    with short_name bc_U1653
    with description bc_U1654
    has proper
    with P_price 200
    with vector 0
    with cap_short_name bc_U1655
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 220
    with K2_thing_Next I_t_shirt_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'devil' 'horns' 'things//p'
    with initial bc_U1656
    with plural bc_U1657
    with article bc_U1658
    with list_together bc_U1659
;
K2_thing -> -> I_t_shirt_U1    with short_name bc_U1660
    with description bc_U1661
    with P_price 750
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 221
    with K2_thing_Next I_big_switch_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name270
    with name 't-shirt' 'things//p' 't-shirts'
    with initial bc_U1662
    with plural bc_U1663
    with article bc_U1664
    with list_together bc_U1665
;
K1_room I_control_room_U1    with short_name bc_U1666
    with description ts_array_U613
    with map_region I_second_floor_U1
    has proper
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 36
    with K1_room_Next 0
    with name 'control' 'room' 'rooms//p'
    with plural bc_U1667
    with article bc_U1668
    with list_together bc_U1669
;
K13_device -> I_big_switch_U1    with short_name bc_U1670
    with description ts_array_U614
    has static
    has on
    with vector 0
    has mark_as_thing
    has switchable
    with KD_Count 13
    with IK2_Count 222
    with K2_thing_Next I_cluttered_desk_U1
    with K13_device_Count 9
    with K13_device_Next I_control_panel_one_s_button_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'big' 'switch' 'devices//p'
    with initial bc_U1671
    with plural bc_U1672
    with article bc_U1673
    with list_together bc_U1674
;
K2_thing -> I_cluttered_desk_U1    with short_name bc_U1675
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 223
    with K2_thing_Next I_cork_board_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cluttered' 'desk' 'things//p'
    with description bc_U1676
    with initial bc_U1677
    with plural bc_U1678
    with article bc_U1679
    with list_together bc_U1680
;
K2_thing -> I_cork_board_U1    with short_name bc_U1681
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 224
    with K2_thing_Next I_charts_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'cork' 'board' 'things//p'
    with description bc_U1682
    with initial bc_U1683
    with plural bc_U1684
    with article bc_U1685
    with list_together bc_U1686
;
K2_thing -> I_charts_U1    with short_name bc_U1687
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 225
    with K2_thing_Next I_control_panel_one_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'charts' 'things//p'
    with description bc_U1688
    with initial bc_U1689
    with plural bc_U1690
    with article bc_U1691
    with list_together bc_U1692
;
K34_control_panel -> I_control_panel_one_U1    with short_name bc_U1693
    with P_panel_id 1
    has proper
    has static
    with P_color I_aqua_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_one_s_button_U1
    with KD_Count 34
    with IK2_Count 226
    with K2_thing_Next I_control_panel_three_U1
    with IK5_Count 25
    with K5_container_Next I_control_panel_three_U1
    with K34_control_panel_Count 0
    with K34_control_panel_Next I_control_panel_three_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'one' 'panels//p' 'control' 'panel'
    with description bc_U1694
    with initial bc_U1695
    with plural bc_U1696
    with article bc_U1697
    with list_together bc_U1698
;
K34_control_panel -> I_control_panel_three_U1    with short_name bc_U1699
    with P_panel_id 3
    has proper
    has static
    with P_color I_crimson_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_three_s_butt_U1
    with KD_Count 34
    with IK2_Count 227
    with K2_thing_Next I_control_panel_five_U1
    with IK5_Count 26
    with K5_container_Next I_control_panel_five_U1
    with K34_control_panel_Count 1
    with K34_control_panel_Next I_control_panel_five_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'three' 'panels//p' 'control' 'panel'
    with description bc_U1700
    with initial bc_U1701
    with plural bc_U1702
    with article bc_U1703
    with list_together bc_U1704
;
K34_control_panel -> I_control_panel_five_U1    with short_name bc_U1705
    with P_panel_id 5
    has proper
    has static
    with P_color I_emerald_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_five_s_butto_U1
    with KD_Count 34
    with IK2_Count 228
    with K2_thing_Next I_control_panel_seven_U1
    with IK5_Count 27
    with K5_container_Next I_control_panel_seven_U1
    with K34_control_panel_Count 2
    with K34_control_panel_Next I_control_panel_seven_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'five' 'panels//p' 'control' 'panel'
    with description bc_U1706
    with initial bc_U1707
    with plural bc_U1708
    with article bc_U1709
    with list_together bc_U1710
;
K34_control_panel -> I_control_panel_seven_U1    with short_name bc_U1711
    with P_panel_id 7
    has proper
    has static
    with P_color I_gray_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_seven_s_butt_U1
    with KD_Count 34
    with IK2_Count 229
    with K2_thing_Next I_control_panel_nine_U1
    with IK5_Count 28
    with K5_container_Next I_control_panel_nine_U1
    with K34_control_panel_Count 3
    with K34_control_panel_Next I_control_panel_nine_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'seven' 'panels//p' 'control' 'panel'
    with description bc_U1712
    with initial bc_U1713
    with plural bc_U1714
    with article bc_U1715
    with list_together bc_U1716
;
K34_control_panel -> I_control_panel_nine_U1    with short_name bc_U1717
    with P_panel_id 9
    has proper
    has static
    with P_color I_indigo_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_nine_s_butto_U1
    with KD_Count 34
    with IK2_Count 230
    with K2_thing_Next I_control_panel_eleven_U1
    with IK5_Count 29
    with K5_container_Next I_control_panel_eleven_U1
    with K34_control_panel_Count 4
    with K34_control_panel_Next I_control_panel_eleven_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'nine' 'panels//p' 'control' 'panel'
    with description bc_U1718
    with initial bc_U1719
    with plural bc_U1720
    with article bc_U1721
    with list_together bc_U1722
;
K34_control_panel -> I_control_panel_eleven_U1    with short_name bc_U1723
    with P_panel_id 11
    has proper
    has static
    with P_color I_khaki_U1
    with vector 0
    has mark_as_thing
    has container
    with component_child I_control_panel_eleven_s_but_U1
    with KD_Count 34
    with IK2_Count 231
    with K2_thing_Next I_monitor_U1
    with IK5_Count 30
    with K5_container_Next 0
    with K34_control_panel_Count 5
    with K34_control_panel_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'eleven' 'panels//p' 'control' 'panel'
    with description bc_U1724
    with initial bc_U1725
    with plural bc_U1726
    with article bc_U1727
    with list_together bc_U1728
;
K2_thing -> I_monitor_U1    with short_name bc_U1729
    with P_figure_id 0
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 250
    with K2_thing_Next I_control_panel_one_s_button_U1
    with action_bitmap 0 0 0 0 0 0 0
    with parse_name parse_name300
    with name 'monitor' 'things//p' 'screen'
    with description bc_U1730
    with initial bc_U1731
    with plural bc_U1732
    with article bc_U1733
    with list_together bc_U1734
;
K35_button I_control_panel_one_s_button_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_one_U1
    with component_sibling I_control_panel_one_s_dial_U1
    has switchable
    with KD_Count 35
    with IK2_Count 232
    with K2_thing_Next I_control_panel_three_s_butt_U1
    with K13_device_Count 10
    with K13_device_Next I_control_panel_three_s_butt_U1
    with K35_button_Count 0
    with K35_button_Next I_control_panel_three_s_butt_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'one^s' 'button' 'buttons//p'
    with description ts_array_U43
    with initial bc_U102
    with short_name ts_array_U44
    with plural bc_U103
    with article bc_U104
    with list_together bc_U105
;
K35_button I_control_panel_three_s_butt_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_three_U1
    with component_sibling I_control_panel_three_s_dial_U1
    has switchable
    with KD_Count 35
    with IK2_Count 233
    with K2_thing_Next I_control_panel_five_s_butto_U1
    with K13_device_Count 11
    with K13_device_Next I_control_panel_five_s_butto_U1
    with K35_button_Count 1
    with K35_button_Next I_control_panel_five_s_butto_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'three^s' 'button' 'buttons//p'
    with description ts_array_U45
    with initial bc_U106
    with short_name ts_array_U46
    with plural bc_U107
    with article bc_U108
    with list_together bc_U109
;
K35_button I_control_panel_five_s_butto_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_five_U1
    with component_sibling I_control_panel_five_s_dial_U1
    has switchable
    with KD_Count 35
    with IK2_Count 234
    with K2_thing_Next I_control_panel_seven_s_butt_U1
    with K13_device_Count 12
    with K13_device_Next I_control_panel_seven_s_butt_U1
    with K35_button_Count 2
    with K35_button_Next I_control_panel_seven_s_butt_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'five^s' 'button' 'buttons//p'
    with description ts_array_U47
    with initial bc_U110
    with short_name ts_array_U48
    with plural bc_U111
    with article bc_U112
    with list_together bc_U113
;
K35_button I_control_panel_seven_s_butt_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_seven_U1
    with component_sibling I_control_panel_seven_s_dial_U1
    has switchable
    with KD_Count 35
    with IK2_Count 235
    with K2_thing_Next I_control_panel_nine_s_butto_U1
    with K13_device_Count 13
    with K13_device_Next I_control_panel_nine_s_butto_U1
    with K35_button_Count 3
    with K35_button_Next I_control_panel_nine_s_butto_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'seven^s' 'button' 'buttons//p'
    with description ts_array_U49
    with initial bc_U114
    with short_name ts_array_U50
    with plural bc_U115
    with article bc_U116
    with list_together bc_U117
;
K35_button I_control_panel_nine_s_butto_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_nine_U1
    with component_sibling I_control_panel_nine_s_dial_U1
    has switchable
    with KD_Count 35
    with IK2_Count 236
    with K2_thing_Next I_control_panel_eleven_s_but_U1
    with K13_device_Count 14
    with K13_device_Next I_control_panel_eleven_s_but_U1
    with K35_button_Count 4
    with K35_button_Next I_control_panel_eleven_s_but_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'nine^s' 'button' 'buttons//p'
    with description ts_array_U51
    with initial bc_U118
    with short_name ts_array_U52
    with plural bc_U119
    with article bc_U120
    with list_together bc_U121
;
K35_button I_control_panel_eleven_s_but_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_eleven_U1
    with component_sibling I_control_panel_eleven_s_dia_U1
    has switchable
    with KD_Count 35
    with IK2_Count 237
    with K2_thing_Next I_control_panel_one_s_dial_U1
    with K13_device_Count 15
    with K13_device_Next 0
    with K35_button_Count 5
    with K35_button_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'eleven^s' 'button' 'buttons//p'
    with description ts_array_U53
    with initial bc_U122
    with short_name ts_array_U54
    with plural bc_U123
    with article bc_U124
    with list_together bc_U125
;
K36_dial I_control_panel_one_s_dial_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_one_U1
    with component_sibling I_control_panel_one_s_light_U1
    with KD_Count 36
    with IK2_Count 238
    with K2_thing_Next I_control_panel_three_s_dial_U1
    with K36_dial_Count 0
    with K36_dial_Next I_control_panel_three_s_dial_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'one^s' 'dial' 'dials//p'
    with description ts_array_U55
    with initial bc_U126
    with short_name ts_array_U56
    with plural bc_U127
    with article bc_U128
    with list_together bc_U129
;
K36_dial I_control_panel_three_s_dial_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_three_U1
    with component_sibling I_control_panel_three_s_ligh_U1
    with KD_Count 36
    with IK2_Count 239
    with K2_thing_Next I_control_panel_five_s_dial_U1
    with K36_dial_Count 1
    with K36_dial_Next I_control_panel_five_s_dial_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'three^s' 'dial' 'dials//p'
    with description ts_array_U57
    with initial bc_U130
    with short_name ts_array_U58
    with plural bc_U131
    with article bc_U132
    with list_together bc_U133
;
K36_dial I_control_panel_five_s_dial_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_five_U1
    with component_sibling I_control_panel_five_s_light_U1
    with KD_Count 36
    with IK2_Count 240
    with K2_thing_Next I_control_panel_seven_s_dial_U1
    with K36_dial_Count 2
    with K36_dial_Next I_control_panel_seven_s_dial_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'five^s' 'dial' 'dials//p'
    with description ts_array_U59
    with initial bc_U134
    with short_name ts_array_U60
    with plural bc_U135
    with article bc_U136
    with list_together bc_U137
;
K36_dial I_control_panel_seven_s_dial_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_seven_U1
    with component_sibling I_control_panel_seven_s_ligh_U1
    with KD_Count 36
    with IK2_Count 241
    with K2_thing_Next I_control_panel_nine_s_dial_U1
    with K36_dial_Count 3
    with K36_dial_Next I_control_panel_nine_s_dial_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'seven^s' 'dial' 'dials//p'
    with description ts_array_U61
    with initial bc_U138
    with short_name ts_array_U62
    with plural bc_U139
    with article bc_U140
    with list_together bc_U141
;
K36_dial I_control_panel_nine_s_dial_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_nine_U1
    with component_sibling I_control_panel_nine_s_light_U1
    with KD_Count 36
    with IK2_Count 242
    with K2_thing_Next I_control_panel_eleven_s_dia_U1
    with K36_dial_Count 4
    with K36_dial_Next I_control_panel_eleven_s_dia_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'nine^s' 'dial' 'dials//p'
    with description ts_array_U63
    with initial bc_U142
    with short_name ts_array_U64
    with plural bc_U143
    with article bc_U144
    with list_together bc_U145
;
K36_dial I_control_panel_eleven_s_dia_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_eleven_U1
    with component_sibling I_control_panel_eleven_s_lig_U1
    with KD_Count 36
    with IK2_Count 243
    with K2_thing_Next I_control_panel_one_s_light_U1
    with K36_dial_Count 5
    with K36_dial_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'eleven^s' 'dial' 'dials//p'
    with description ts_array_U65
    with initial bc_U146
    with short_name ts_array_U66
    with plural bc_U147
    with article bc_U148
    with list_together bc_U149
;
K37_light I_control_panel_one_s_light_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_one_U1
    with KD_Count 37
    with IK2_Count 244
    with K2_thing_Next I_control_panel_three_s_ligh_U1
    with K37_light_Count 0
    with K37_light_Next I_control_panel_three_s_ligh_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'one^s' 'light' 'lights//p'
    with description ts_array_U67
    with initial bc_U150
    with short_name ts_array_U68
    with plural bc_U151
    with article bc_U152
    with list_together bc_U153
;
K37_light I_control_panel_three_s_ligh_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_three_U1
    with KD_Count 37
    with IK2_Count 245
    with K2_thing_Next I_control_panel_five_s_light_U1
    with K37_light_Count 1
    with K37_light_Next I_control_panel_five_s_light_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'three^s' 'light' 'lights//p'
    with description ts_array_U69
    with initial bc_U154
    with short_name ts_array_U70
    with plural bc_U155
    with article bc_U156
    with list_together bc_U157
;
K37_light I_control_panel_five_s_light_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_five_U1
    with KD_Count 37
    with IK2_Count 246
    with K2_thing_Next I_control_panel_seven_s_ligh_U1
    with K37_light_Count 2
    with K37_light_Next I_control_panel_seven_s_ligh_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'five^s' 'light' 'lights//p'
    with description ts_array_U71
    with initial bc_U158
    with short_name ts_array_U72
    with plural bc_U159
    with article bc_U160
    with list_together bc_U161
;
K37_light I_control_panel_seven_s_ligh_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_seven_U1
    with KD_Count 37
    with IK2_Count 247
    with K2_thing_Next I_control_panel_nine_s_light_U1
    with K37_light_Count 3
    with K37_light_Next I_control_panel_nine_s_light_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'seven^s' 'light' 'lights//p'
    with description ts_array_U73
    with initial bc_U162
    with short_name ts_array_U74
    with plural bc_U163
    with article bc_U164
    with list_together bc_U165
;
K37_light I_control_panel_nine_s_light_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_nine_U1
    with KD_Count 37
    with IK2_Count 248
    with K2_thing_Next I_control_panel_eleven_s_lig_U1
    with K37_light_Count 4
    with K37_light_Next I_control_panel_eleven_s_lig_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'nine^s' 'light' 'lights//p'
    with description ts_array_U75
    with initial bc_U166
    with short_name ts_array_U76
    with plural bc_U167
    with article bc_U168
    with list_together bc_U169
;
K37_light I_control_panel_eleven_s_lig_U1    has proper
    with vector 0
    has mark_as_thing
    with component_parent I_control_panel_eleven_U1
    with KD_Count 37
    with IK2_Count 249
    with K2_thing_Next 0
    with K37_light_Count 5
    with K37_light_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'control' 'panel' 'eleven^s' 'light' 'lights//p'
    with description ts_array_U77
    with initial bc_U170
    with short_name ts_array_U78
    with plural bc_U171
    with article bc_U172
    with list_together bc_U173
;
K9_region I_midway_U1    with short_name bc_U1735
    with vector 0
    with regional_found_in RFI_for_I1
    with KD_Count 9
    with IK9_Count 0
    with K9_region_Next I_hellride_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'midway' 'regions//p'
    with plural bc_U1736
    with article bc_U1737
    with list_together bc_U1738
;
K9_region I_hellride_U1    with short_name bc_U1739
    has proper
    with vector 0
    with regional_found_in RFI_for_I2
    with KD_Count 9
    with IK9_Count 1
    with K9_region_Next I_electrical_area_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'hellride' 'regions//p'
    with plural bc_U1740
    with article bc_U1741
    with list_together bc_U1742
;
K9_region I_electrical_area_U1    with short_name bc_U1743
    has proper
    with vector 0
    with regional_found_in RFI_for_I3
    with KD_Count 9
    with IK9_Count 2
    with K9_region_Next I_back_stage_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'electrical' 'area' 'regions//p'
    with plural bc_U1744
    with article bc_U1745
    with list_together bc_U1746
;
K9_region I_back_stage_U1    with short_name bc_U1747
    has proper
    with vector 0
    with regional_found_in RFI_for_I4
    with KD_Count 9
    with IK9_Count 3
    with K9_region_Next I_second_floor_U1
    with action_bitmap 0 0 0 0 0 0 0
    with name 'back' 'stage' 'regions//p'
    with plural bc_U1748
    with article bc_U1749
    with list_together bc_U1750
;
K9_region I_second_floor_U1    with short_name bc_U1751
    has proper
    with vector 0
    with regional_found_in RFI_for_I5
    with KD_Count 9
    with IK9_Count 4
    with K9_region_Next 0
    with action_bitmap 0 0 0 0 0 0 0
    with name 'second' 'floor' 'regions//p'
    with plural bc_U1752
    with article bc_U1753
    with list_together bc_U1754
;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef before; Constant before = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef P_variable_initial_value; Constant P_variable_initial_value = 0; #endif;
#ifndef P_specification; Constant P_specification = 0; #endif;
#ifndef P_indefinite_appearance_text; Constant P_indefinite_appearance_text = 0; #endif;
#ifndef P_adaptive_text_viewpoint; Constant P_adaptive_text_viewpoint = 0; #endif;
#ifndef P_opposite; Constant P_opposite = 0; #endif;
#ifndef P_recurring; Constant P_recurring = 0; #endif;
#ifndef K1_room_Next; Constant K1_room_Next = 0; #endif;
#ifndef K2_thing_Next; Constant K2_thing_Next = 0; #endif;
#ifndef K3_direction_Next; Constant K3_direction_Next = 0; #endif;
#ifndef K4_door_Next; Constant K4_door_Next = 0; #endif;
#ifndef K5_container_Next; Constant K5_container_Next = 0; #endif;
#ifndef K6_supporter_Next; Constant K6_supporter_Next = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef K7_backdrop_Next; Constant K7_backdrop_Next = 0; #endif;
#ifndef K8_person_Next; Constant K8_person_Next = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef K9_region_Next; Constant K9_region_Next = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef K10_man_Next; Constant K10_man_Next = 0; #endif;
#ifndef K11_woman_Count; Constant K11_woman_Count = 0; #endif;
#ifndef K11_woman_Next; Constant K11_woman_Next = 0; #endif;
#ifndef K12_animal_Count; Constant K12_animal_Count = 0; #endif;
#ifndef K12_animal_Next; Constant K12_animal_Next = 0; #endif;
#ifndef K13_device_Count; Constant K13_device_Count = 0; #endif;
#ifndef K13_device_Next; Constant K13_device_Next = 0; #endif;
#ifndef K14_vehicle_Count; Constant K14_vehicle_Count = 0; #endif;
#ifndef K14_vehicle_Next; Constant K14_vehicle_Next = 0; #endif;
#ifndef K15_player_s_holdall_Count; Constant K15_player_s_holdall_Count = 0; #endif;
#ifndef K15_player_s_holdall_Next; Constant K15_player_s_holdall_Next = 0; #endif;
#ifndef K16_passkey_Count; Constant K16_passkey_Count = 0; #endif;
#ifndef K16_passkey_Next; Constant K16_passkey_Next = 0; #endif;
#ifndef K17_keychain_Count; Constant K17_keychain_Count = 0; #endif;
#ifndef K17_keychain_Next; Constant K17_keychain_Next = 0; #endif;
#ifndef P_unbolting_relation_storage; Constant P_unbolting_relation_storage = 0; #endif;
#ifndef K18_fluid_container_Count; Constant K18_fluid_container_Count = 0; #endif;
#ifndef K18_fluid_container_Next; Constant K18_fluid_container_Next = 0; #endif;
#ifndef K19_electric_lamp_Count; Constant K19_electric_lamp_Count = 0; #endif;
#ifndef K19_electric_lamp_Next; Constant K19_electric_lamp_Next = 0; #endif;
#ifndef K20_attendant_Count; Constant K20_attendant_Count = 0; #endif;
#ifndef K20_attendant_Next; Constant K20_attendant_Next = 0; #endif;
#ifndef K21_coin_Count; Constant K21_coin_Count = 0; #endif;
#ifndef K21_coin_Next; Constant K21_coin_Next = 0; #endif;
#ifndef K22_nickel_Count; Constant K22_nickel_Count = 0; #endif;
#ifndef K22_nickel_Next; Constant K22_nickel_Next = 0; #endif;
#ifndef K23_dime_Count; Constant K23_dime_Count = 0; #endif;
#ifndef K23_dime_Next; Constant K23_dime_Next = 0; #endif;
#ifndef K24_quarter_Count; Constant K24_quarter_Count = 0; #endif;
#ifndef K24_quarter_Next; Constant K24_quarter_Next = 0; #endif;
#ifndef K25_electrical_closet_Count; Constant K25_electrical_closet_Count = 0; #endif;
#ifndef K25_electrical_closet_Next; Constant K25_electrical_closet_Next = 0; #endif;
#ifndef K26_electrical_panel_Count; Constant K26_electrical_panel_Count = 0; #endif;
#ifndef K26_electrical_panel_Next; Constant K26_electrical_panel_Next = 0; #endif;
#ifndef K27_socket_Count; Constant K27_socket_Count = 0; #endif;
#ifndef K27_socket_Next; Constant K27_socket_Next = 0; #endif;
#ifndef K28_indicator_Count; Constant K28_indicator_Count = 0; #endif;
#ifndef K28_indicator_Next; Constant K28_indicator_Next = 0; #endif;
#ifndef K29_fuse_Count; Constant K29_fuse_Count = 0; #endif;
#ifndef K29_fuse_Next; Constant K29_fuse_Next = 0; #endif;
#ifndef K30_switch_Count; Constant K30_switch_Count = 0; #endif;
#ifndef K30_switch_Next; Constant K30_switch_Next = 0; #endif;
#ifndef K31_ride_ticket_Count; Constant K31_ride_ticket_Count = 0; #endif;
#ifndef K31_ride_ticket_Next; Constant K31_ride_ticket_Next = 0; #endif;
#ifndef K32_baseball_Count; Constant K32_baseball_Count = 0; #endif;
#ifndef K32_baseball_Next; Constant K32_baseball_Next = 0; #endif;
#ifndef K33_wooden_door_Count; Constant K33_wooden_door_Count = 0; #endif;
#ifndef K33_wooden_door_Next; Constant K33_wooden_door_Next = 0; #endif;
#ifndef K34_control_panel_Count; Constant K34_control_panel_Count = 0; #endif;
#ifndef K34_control_panel_Next; Constant K34_control_panel_Next = 0; #endif;
#ifndef K35_button_Count; Constant K35_button_Count = 0; #endif;
#ifndef K35_button_Next; Constant K35_button_Next = 0; #endif;
#ifndef K36_dial_Count; Constant K36_dial_Count = 0; #endif;
#ifndef K36_dial_Next; Constant K36_dial_Next = 0; #endif;
#ifndef K37_light_Count; Constant K37_light_Count = 0; #endif;
#ifndef K37_light_Next; Constant K37_light_Next = 0; #endif;
#ifndef P_price; Constant P_price = 0; #endif;
#ifndef P_fluid_capacity; Constant P_fluid_capacity = 0; #endif;
#ifndef P_current_volume; Constant P_current_volume = 0; #endif;
#ifndef P_liquid; Constant P_liquid = 0; #endif;
#ifndef P_panel_id; Constant P_panel_id = 0; #endif;
#ifndef P_color; Constant P_color = 0; #endif;
#ifndef P_fuse_id; Constant P_fuse_id = 0; #endif;
#ifndef P_dial_setting; Constant P_dial_setting = 0; #endif;
#ifndef P_figure_id; Constant P_figure_id = 0; #endif;
#ifndef P_underlying_relation_storag; Constant P_underlying_relation_storag = 0; #endif;
#ifndef P_tossing_relation_storage; Constant P_tossing_relation_storage = 0; #endif;
#Ifdef TARGET_ZCODE;
Global max_z_object;
#Ifdef Z__Region;
[ OC__Cl obj cla j a n objflag;
    @jl obj 1 ?NotObj;
    @jg obj max_z_object ?NotObj;
    @inc objflag;
    #Ifdef K1_room;
    @je cla K1_room ?~NotRoom;
    @test_attr obj mark_as_room ?rtrue;
    @rfalse;
    .NotRoom;
    #Endif;
    #Ifdef K2_thing;
    @je cla K2_thing ?~NotObj;
    @test_attr obj mark_as_thing ?rtrue;
    @rfalse;
    #Endif;
    .NotObj;

    @je cla Object Class ?ObjOrClass;
    @je cla Routine String ?RoutOrStr;

    @jin cla 1 ?~Mistake;

    @jz objflag ?rfalse;
    @get_prop_addr obj 2 -> a;
    @jz a ?rfalse;
    @get_prop_len a -> n;

    @div n 2 -> n;
    .Loop;
    @loadw a j -> sp;
    @je sp cla ?rtrue;
    @inc j;
    @jl j n ?Loop;
    @rfalse;

    .ObjOrClass;
    @jz objflag ?rfalse;
    @je cla Object ?JustObj;

    ! So now cla is Class
    @jg obj String ?~rtrue;
    @jin obj Class ?rtrue;
    @rfalse;

    .JustObj;
    ! So now cla is Object
    @jg obj String ?~rfalse;
    @jin obj Class ?rfalse;
    @rtrue;

    .RoutOrStr;
    @jz objflag ?~rfalse;
    @call_2s Z__Region obj -> sp;
    @inc sp;
    @je sp cla ?rtrue;
    @rfalse;

    .Mistake;
    RT__Err("apply 'ofclass' for", cla, -1);
    rfalse;
];
#Endif;
#Endif;
[ Mistake_Token1;
    if ((actor ~= player)) {
        return GPR_FAIL;
    }
    (understand_as_mistake_number = 379);
    return GPR_PREPOSITION;
];
[ Mistake_Token2;
    if ((actor ~= player)) {
        return GPR_FAIL;
    }
    (understand_as_mistake_number = 358);
    return GPR_PREPOSITION;
];
[ Mistake_Token3;
    if ((actor ~= player)) {
        return GPR_FAIL;
    }
    (understand_as_mistake_number = 359);
    return GPR_PREPOSITION;
];
[ Mistake_Token4;
    if ((actor ~= player)) {
        return GPR_FAIL;
    }
    (understand_as_mistake_number = 322);
    return GPR_PREPOSITION;
];
[ Mistake_Token5;
    if ((actor ~= player)) {
        return GPR_FAIL;
    }
    (understand_as_mistake_number = 321);
    return GPR_PREPOSITION;
];
[ KeyPause key;
    while (1) {
        (key = VM_KeyChar());
        if ((key == -4 or -5 or -10 or -11 or -12 or -13)) {
            continue;
        }
        rfalse;
    }
];
[ SPACEPause i;
    while ((i ~= 13 or 31 or 32)) {
        (i = VM_KeyChar());
    }
];
[ GetKey;
    return VM_KeyChar();
];
[ CenterPrint str depth i j len;
    if (0) { font on; } else { font off; }(i = VM_ScreenWidth());
    (len = TEXT_TY_CharacterLength(str));
    if ((len > 63)) {
        (len = 63);
    }
    (j = (((i - len)/2) - 1));
    VM_MoveCursorInStatusLine(depth, j);
    I7_String(str);
    if (1) { font on; } else { font off; }];
[ CenterPrintComplex str i j len;
    if (0) { font on; } else { font off; }print "^";
    (i = VM_ScreenWidth());
    (len = TEXT_TY_CharacterLength(str));
    if ((len > 63)) {
        (len = 63);
    }
    (j = (((i - len)/2) - 1));
    spaces j;
    I7_String(str);
    if (1) { font on; } else { font off; }];
[ I7ScreenHeight i screen_height;
    (i = (0->(32)));
    if ((screen_height == 0 or 255)) {
        (screen_height = 18);
    }
    (screen_height = (screen_height - 7));
    return screen_height;
];
[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    (screen_width = VM_ScreenWidth());
    VM_ClearScreen(1);
];
[ I7VM_MoveCursorInStatusLine depth;
    VM_MoveCursorInStatusLine(depth, 1);
];
[ RightAlign depth screen_width o n;
    (screen_width = VM_ScreenWidth());
    (n = right_alignment_depth);
    (o = (screen_width - n));
    VM_MoveCursorInStatusLine(depth, o);
];
[ call_U1 sk;
    rfalse;
];
[ call_U2 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "printed name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_short_name), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_short_name));
                    print (char) 34;
                }
                print "^";
                print "printed plural name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_plural), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_plural));
                    print (char) 34;
                }
                print "^";
                print "indefinite article: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_article), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_article));
                    print (char) 34;
                }
                print "^";
                print "list grouping key: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_list_together), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_list_together));
                    print (char) 34;
                }
                print "^";
            }
        } else {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_pluralname)) && ((t_0 has pluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "plural-named";
                }
                if (((AllowInShowme(A_pluralname)) && ((~~((t_0 has pluralname)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "singular-named";
                }
                if (((AllowInShowme(A_proper)) && ((t_0 has proper)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "proper-named";
                }
                if (((AllowInShowme(A_proper)) && ((~~((t_0 has proper)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "improper-named";
                }
                if (((AllowInShowme(A_ambigpluralname)) && ((t_0 has ambigpluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "ambiguously plural";
                }
            }
        }
        return na;
    #endif;
];
[ call_U3 sk;
    return I_entire_game_U1;
];
[ PrintSceneName value;
    switch (value) {
        I_entire_game_U1:
            print "Entire Game";
            ;
        I_little_egypt_autoplay_U1:
            print "Little Egypt AutoPlay";
            ;
        I_hell_ride_autoplay_U1:
            print "Hell Ride AutoPlay";
            ;
        default:
            print "<illegal scene>";
            ;
    }
];
[ call_U4 x;
    return ((x%3) + 1);
];
[ call_U5 x;
    return (((x + 1)%3) + 1);
];
[ call_U6 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U7 sk;
    rfalse;
];
[ DECIMAL_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U9 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (original_wn = wn);
    (original_wn = wn);
    return GPR_FAIL;
];
[ call_U10 sk;
    rfalse;
];
[ call_U12 sk;
    rfalse;
];
[ TRUTH_STATE_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U13 sk;
    return BlkValueCreate(sk);
];
[ call_U14 sk;
    return 101;
];
[ call_U15 sk;
    return 32;
];
[ call_U16 sk;
    rfalse;
];
[ call_U17 sk;
    rfalse;
];
[ call_U18 sk;
    rfalse;
];
[ call_U19 sk;
    return TheEmptyTable;
];
[ call_U20 sk;
    rfalse;
];
[ RulebookOutcomePrintingRule nro;
    if ((nro == 0)) {
        print "(no outcome)";
    } else {
        print (string) nro;
        rfalse;
    }
];
[ call_U21 sk;
    return outcome_allow_startup_U1;
];
[ call_U22 sk;
    rfalse;
];
[ PrintExternalFileName value;
    switch (value) {
        default:
            print "<illegal external file>";
            ;
    }
];
[ call_U23 x;
    return x;
];
[ call_U24 x;
    return x;
];
[ call_U25 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(0);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U26 sk;
    rfalse;
];
[ call_U27 sk;
    return BlkValueCreate(sk);
];
[ call_U28 sk;
    return ##Wait;
];
[ call_U29 sk;
    return 540;
];
[ TIME_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U31 sk;
    return I_figure_of_cover_U1;
];
[ PrintFigureName value;
    switch (value) {
        I_figure_of_cover_U1:
            print "Figure of cover";
            ;
        I_figure_of_hell_ride_U1:
            print "Figure of Hell Ride";
            ;
        I_figure_of_ticketbooth_U1:
            print "Figure of TicketBooth";
            ;
        I_figure_of_concessionstand_U1:
            print "Figure of ConcessionStand";
            ;
        I_figure_of_littleegyptfacad_U1:
            print "Figure of LittleEgyptFacade";
            ;
        I_figure_of_littleegyptshow_U1:
            print "Figure of LittleEgyptShow";
            ;
        I_figure_of_highstriker_U1:
            print "Figure of HighStriker";
            ;
        I_figure_of_controlpanel_U1:
            print "Figure of ControlPanel";
            ;
        I_figure_of_controlpanelstoc_U1:
            print "Figure of ControlPanelStocks";
            ;
        I_figure_of_controlpanelgall_U1:
            print "Figure of ControlPanelGallows";
            ;
        I_figure_of_controlpanelstak_U1:
            print "Figure of ControlPanelStake";
            ;
        I_figure_of_controlpaneldung_U1:
            print "Figure of ControlPanelDungeon";
            ;
        I_figure_of_controlpanelguil_U1:
            print "Figure of ControlPanelGuillotine";
            ;
        I_figure_of_controlpanelexit_U1:
            print "Figure of ControlPanelExit";
            ;
        I_figure_of_coupon_U1:
            print "Figure of Coupon";
            ;
        I_figure_of_maintenanceoffic_U1:
            print "Figure of MaintenanceOffice";
            ;
        I_figure_of_ferriswheel_U1:
            print "Figure of FerrisWheel";
            ;
        I_figure_of_bumpercars_U1:
            print "Figure of BumperCars";
            ;
        I_figure_of_fortuneteller_U1:
            print "Figure of FortuneTeller";
            ;
        I_figure_of_carousel_U1:
            print "Figure of Carousel";
            ;
        I_figure_of_dimetoss_U1:
            print "Figure of DimeToss";
            ;
        I_figure_of_milkbottles_U1:
            print "Figure of MilkBottles";
            ;
        I_figure_of_ridestocks_U1:
            print "Figure of RideStocks";
            ;
        I_figure_of_ridegallows_U1:
            print "Figure of RideGallows";
            ;
        I_figure_of_ridestake_U1:
            print "Figure of RideStake";
            ;
        I_figure_of_ridedungeon_U1:
            print "Figure of RideDungeon";
            ;
        I_figure_of_rideguillotine_U1:
            print "Figure of RideGuillotine";
            ;
        I_figure_of_rideexit_U1:
            print "Figure of RideExit";
            ;
        I_figure_of_mercurydime_U1:
            print "Figure of MercuryDime";
            ;
        default:
            print "<illegal figure name>";
            ;
    }
];
[ call_U32 x;
    return ((x%29) + 1);
];
[ call_U33 x;
    return (((x + 27)%29) + 1);
];
[ call_U34 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(29);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U35 sk;
    return I_sound_of_bell_U1;
];
[ PrintSoundName value;
    switch (value) {
        I_sound_of_bell_U1:
            print "Sound of Bell";
            ;
        default:
            print "<illegal sound name>";
            ;
    }
];
[ call_U36 x;
    return x;
];
[ call_U37 x;
    return x;
];
[ call_U38 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U39 sk;
    return DefaultTopic;
];
[ call_U40 sk;
    return BlkValueCreate(sk);
];
[ call_U41 sk;
    rfalse;
];
[ call_U42 sk;
    rfalse;
];
[ call_U43;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U44;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U45;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U46;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U47;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U48;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U49;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U50;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U51;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U52;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U53;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U54;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U55;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U56;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U57;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U58;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U59;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U60;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U61;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U62;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U63;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U64;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U65;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U66;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U67 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U1());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U68;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U69 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U2());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U70;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U71 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U3());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U3;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U72;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U73 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U4());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U4;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U74;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U75 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U5());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U5;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U76;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U77 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U6());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U6;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U78;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ SN_R1;
    PrintShortName(I_electrical_closet_one_s_el_U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R2;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_one_s_el_U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_one_s_el_U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_one_s_el_U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U79 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U7());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U7;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ SN_R3;
    PrintShortName(I_electrical_closet_three_s__U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R4;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_three_s__U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_three_s__U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_three_s__U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U80 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U8());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U8;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ SN_R5;
    PrintShortName(I_electrical_closet_five_s_e_U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R6;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_five_s_e_U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_five_s_e_U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_five_s_e_U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U81 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U9());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U9;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ SN_R7;
    PrintShortName(I_electrical_closet_seven_s__U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R8;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_seven_s__U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_seven_s__U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_seven_s__U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U82 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U10());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U10;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ SN_R9;
    PrintShortName(I_electrical_closet_nine_s_e_U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R10;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_nine_s_e_U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_nine_s_e_U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_nine_s_e_U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U83 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U11());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U11;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ SN_R11;
    PrintShortName(I_electrical_closet_eleven_s_U1);
    print "'s ";
    print "switch";
    rtrue;
];
[ SN_R12;
    if ((_final_propertyarray(OBJECT_TY, I_electrical_closet_eleven_s_U1, A_cap_short_name))) {
        PrintOrRun(I_electrical_closet_eleven_s_U1, A_cap_short_name, 1);
    } else {
        PrintOrRun(I_electrical_closet_eleven_s_U1, A_short_name, 1);
    }
    print "'s ";
    print "switch";
    rtrue;
];
[ call_U84 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U12());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U12;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U85;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U86;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U87;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U88;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U89;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U90;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U91;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U92;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U93;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U94;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U95;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U96;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U97;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U98;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U99;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U100;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U101;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U102;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U103;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U104;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U105;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U106;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U107;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U108;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U109 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U13());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U13;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U110;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U111 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U14());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U14;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U112;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U113 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U15());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U15;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U114;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U115 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U16());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U16;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U116;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U117 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U17());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U17;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U118;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U119 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U18());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U18;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U120;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv:
            InvDbg(n, s, for_say);
            ;
        ##Take:
            TakeDbg(n, s, for_say);
            ;
        ##Remove:
            RemoveDbg(n, s, for_say);
            ;
        ##Drop:
            DropDbg(n, s, for_say);
            ;
        ##PutOn:
            PutOnDbg(n, s, for_say);
            ;
        ##Insert:
            InsertDbg(n, s, for_say);
            ;
        ##Eat:
            EatDbg(n, s, for_say);
            ;
        ##Go:
            GoDbg(n, s, for_say);
            ;
        ##Enter:
            EnterDbg(n, s, for_say);
            ;
        ##Exit:
            ExitDbg(n, s, for_say);
            ;
        ##GetOff:
            GetOffDbg(n, s, for_say);
            ;
        ##Look:
            LookDbg(n, s, for_say);
            ;
        ##Examine:
            ExamineDbg(n, s, for_say);
            ;
        ##LookUnder:
            LookUnderDbg(n, s, for_say);
            ;
        ##Search:
            SearchDbg(n, s, for_say);
            ;
        ##Consult:
            ConsultDbg(n, s, for_say);
            ;
        ##Lock:
            LockDbg(n, s, for_say);
            ;
        ##Unlock:
            UnlockDbg(n, s, for_say);
            ;
        ##SwitchOn:
            SwitchOnDbg(n, s, for_say);
            ;
        ##SwitchOff:
            SwitchOffDbg(n, s, for_say);
            ;
        ##Open:
            OpenDbg(n, s, for_say);
            ;
        ##Close:
            CloseDbg(n, s, for_say);
            ;
        ##Wear:
            WearDbg(n, s, for_say);
            ;
        ##Disrobe:
            DisrobeDbg(n, s, for_say);
            ;
        ##Give:
            GiveDbg(n, s, for_say);
            ;
        ##Show:
            ShowDbg(n, s, for_say);
            ;
        ##WakeOther:
            WakeOtherDbg(n, s, for_say);
            ;
        ##ThrowAt:
            ThrowAtDbg(n, s, for_say);
            ;
        ##Attack:
            AttackDbg(n, s, for_say);
            ;
        ##Kiss:
            KissDbg(n, s, for_say);
            ;
        ##Answer:
            AnswerDbg(n, s, for_say);
            ;
        ##Tell:
            TellDbg(n, s, for_say);
            ;
        ##Ask:
            AskDbg(n, s, for_say);
            ;
        ##AskFor:
            AskForDbg(n, s, for_say);
            ;
        ##Wait:
            WaitDbg(n, s, for_say);
            ;
        ##Touch:
            TouchDbg(n, s, for_say);
            ;
        ##Wave:
            WaveDbg(n, s, for_say);
            ;
        ##Pull:
            PullDbg(n, s, for_say);
            ;
        ##Push:
            PushDbg(n, s, for_say);
            ;
        ##Turn:
            TurnDbg(n, s, for_say);
            ;
        ##PushDir:
            PushDirDbg(n, s, for_say);
            ;
        ##Squeeze:
            SqueezeDbg(n, s, for_say);
            ;
        ##Yes:
            YesDbg(n, s, for_say);
            ;
        ##No:
            NoDbg(n, s, for_say);
            ;
        ##Burn:
            BurnDbg(n, s, for_say);
            ;
        ##Wake:
            WakeDbg(n, s, for_say);
            ;
        ##Think:
            ThinkDbg(n, s, for_say);
            ;
        ##Smell:
            SmellDbg(n, s, for_say);
            ;
        ##Listen:
            ListenDbg(n, s, for_say);
            ;
        ##Taste:
            TasteDbg(n, s, for_say);
            ;
        ##Cut:
            CutDbg(n, s, for_say);
            ;
        ##Jump:
            JumpDbg(n, s, for_say);
            ;
        ##Tie:
            TieDbg(n, s, for_say);
            ;
        ##Drink:
            DrinkDbg(n, s, for_say);
            ;
        ##Sorry:
            SorryDbg(n, s, for_say);
            ;
        ##Swing:
            SwingDbg(n, s, for_say);
            ;
        ##Rub:
            RubDbg(n, s, for_say);
            ;
        ##SetTo:
            SetToDbg(n, s, for_say);
            ;
        ##WaveHands:
            WaveHandsDbg(n, s, for_say);
            ;
        ##Buy:
            BuyDbg(n, s, for_say);
            ;
        ##Climb:
            ClimbDbg(n, s, for_say);
            ;
        ##Sleep:
            SleepDbg(n, s, for_say);
            ;
        ##Quit:
            QuitDbg(n, s, for_say);
            ;
        ##Save:
            SaveDbg(n, s, for_say);
            ;
        ##Restore:
            RestoreDbg(n, s, for_say);
            ;
        ##Restart:
            RestartDbg(n, s, for_say);
            ;
        ##Verify:
            VerifyDbg(n, s, for_say);
            ;
        ##ScriptOn:
            ScriptOnDbg(n, s, for_say);
            ;
        ##ScriptOff:
            ScriptOffDbg(n, s, for_say);
            ;
        ##Version:
            VersionDbg(n, s, for_say);
            ;
        ##Score:
            ScoreDbg(n, s, for_say);
            ;
        ##LMode3:
            LMode3Dbg(n, s, for_say);
            ;
        ##LMode2:
            LMode2Dbg(n, s, for_say);
            ;
        ##LMode1:
            LMode1Dbg(n, s, for_say);
            ;
        ##NotifyOn:
            NotifyOnDbg(n, s, for_say);
            ;
        ##NotifyOff:
            NotifyOffDbg(n, s, for_say);
            ;
        ##Pronouns:
            PronounsDbg(n, s, for_say);
            ;
        ##A_standing:
            A_standingDbg(n, s, for_say);
            ;
        ##A_unlocking_keylessly:
            A_unlocking_keylesslyDbg(n, s, for_say);
            ;
        ##A_locking_keylessly:
            A_locking_keylesslyDbg(n, s, for_say);
            ;
        ##A_universal_unlocking:
            A_universal_unlockingDbg(n, s, for_say);
            ;
        ##A_asking_for_help:
            A_asking_for_helpDbg(n, s, for_say);
            ;
        ##Sing:
            SingDbg(n, s, for_say);
            ;
        ##A_pouring_it_into:
            A_pouring_it_intoDbg(n, s, for_say);
            ;
        ##A_hiding_it_under:
            A_hiding_it_underDbg(n, s, for_say);
            ;
        ##A_hi_speaking:
            A_hi_speakingDbg(n, s, for_say);
            ;
        ##A_casting_xyzzy:
            A_casting_xyzzyDbg(n, s, for_say);
            ;
        ##A_casting_plugh:
            A_casting_plughDbg(n, s, for_say);
            ;
        ##A_talking_randomly_abou:
            A_talking_randomly_abouDbg(n, s, for_say);
            ;
        ##A_talking_about:
            A_talking_aboutDbg(n, s, for_say);
            ;
        ##A_requesting_the_comple:
            A_requesting_the_compleDbg(n, s, for_say);
            ;
        ##Mild:
            MildDbg(n, s, for_say);
            ;
        ##A_fucking:
            A_fuckingDbg(n, s, for_say);
            ;
        ##Strong:
            StrongDbg(n, s, for_say);
            ;
        ##A_toggling:
            A_togglingDbg(n, s, for_say);
            ;
        ##A_flipping:
            A_flippingDbg(n, s, for_say);
            ;
        ##A_reading:
            A_readingDbg(n, s, for_say);
            ;
        ##A_hitting:
            A_hittingDbg(n, s, for_say);
            ;
        ##A_tossing:
            A_tossingDbg(n, s, for_say);
            ;
        ##A_throwing:
            A_throwingDbg(n, s, for_say);
            ;
        ##A_spinning_it_to:
            A_spinning_it_toDbg(n, s, for_say);
            ;
        ##A_crediting:
            A_creditingDbg(n, s, for_say);
            ;
    }
];
[ TestSinglePastState past_flag pt turn_end wanted old new trips consecutives;
    if (past_flag) {
        (new = (((past_chronological_record-->(pt)))&(1)));
        (trips = ((((past_chronological_record-->(pt)))&(254))/2));
        (consecutives = ((((past_chronological_record-->(pt)))&(65280))/256));
    } else {
        (old = (((present_chronological_record-->(pt)))&(1)));
        (trips = ((((present_chronological_record-->(pt)))&(254))/2));
        (consecutives = ((((present_chronological_record-->(pt)))&(65280))/256));
        switch (pt) {
            0:
                (new = PCONR1());
                ;
            1:
                (new = PCONR2());
                ;
            2:
                (new = PCONR3());
                ;
            default:
                print "*** No such past tense condition ***^";
                (new = 0);
                ;
        }
        if (new) {
            if ((old == 0)) {
                (trips)++;
                if ((trips > 127)) {
                    (trips = 127);
                }
            }
            if (turn_end) {
                (consecutives)++;
                if ((consecutives > 127)) {
                    (consecutives = 127);
                }
            }
        } else {
            (consecutives = 0);
        }
        ((present_chronological_record-->(pt)) = (new + ((trips*2) + (consecutives*256))));
    }
    switch (wanted) {
        0:
            if (new) {
                return new;
            }
            ;
        1:
            if (new) {
                return trips;
            }
            ;
        2:
            if (new) {
                return (consecutives + 1);
            }
            ;
        4:
            return new;
            ;
        5:
            return trips;
            ;
        6:
            return consecutives;
            ;
    }
    rfalse;
];
[ ShowExtensionVersions;
    print "Singing Reloaded version 1 by Shin^";
];
[ ShowFullExtensionVersions;
    print "Basic Inform version 1 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Standard Rules version 6 by Graham Nelson^";
    print "Modified Exit version 6 by Emily Short^";
    print "Locksmith version 13 by Emily Short^";
    print "Menus version 3 by Emily Short^";
    print "Basic Help Menu version 1 by Emily Short^";
    print "Basic Screen Effects version 8 by Emily Short^";
    print "Singing Reloaded version 1 by Shin^";
];
[ ShowOneExtension id;
    if ((id == 1)) {
        print "Basic Inform version 1 by Graham Nelson";
    }
    if ((id == 2)) {
        print "English Language version 1 by Graham Nelson";
    }
    if ((id == 3)) {
        print "Standard Rules version 6 by Graham Nelson";
    }
    if ((id == 4)) {
        print "Modified Exit version 6 by Emily Short";
    }
    if ((id == 5)) {
        print "Locksmith version 13 by Emily Short";
    }
    if ((id == 6)) {
        print "Menus version 3 by Emily Short";
    }
    if ((id == 7)) {
        print "Basic Help Menu version 1 by Emily Short";
    }
    if ((id == 8)) {
        print "Basic Screen Effects version 8 by Emily Short";
    }
    if ((id == 9)) {
        print "Singing Reloaded version 1 by Shin";
    }
];
[ ShowMeInstanceDetails which na t_0;
    (na = call_U2253(which, na, t_0));
    (na = call_U2285(which, na, t_0));
    (na = call_U2354(which, na, t_0));
    return na;
];
[ DefaultValueOfKOV sk k;
    (k = KindAtomic(sk));
    switch (k) {
        WEAK_ID_47:
            return call_U204(sk);
            ;
        WEAK_ID_52:
            return call_U1900(sk);
            ;
        WEAK_ID_53:
            return call_U1902(sk);
            ;
        WEAK_ID_54:
            return call_U1904(sk);
            ;
        WEAK_ID_55:
            return call_U1906(sk);
            ;
        WEAK_ID_56:
            return call_U1909(sk);
            ;
        WEAK_ID_57:
            return call_U1911(sk);
            ;
        WEAK_ID_58:
            return call_U1913(sk);
            ;
        WEAK_ID_59:
            return call_U1914(sk);
            ;
        WEAK_ID_60:
            return call_U1916(sk);
            ;
        WEAK_ID_61:
            return call_U1917(sk);
            ;
        WEAK_ID_62:
            return call_U1918(sk);
            ;
        WEAK_ID_63:
            return call_U1919(sk);
            ;
        WEAK_ID_64:
            return call_U1920(sk);
            ;
        WEAK_ID_65:
            return call_U1922(sk);
            ;
        WEAK_ID_66:
            return call_U1923(sk);
            ;
        WEAK_ID_67:
            return call_U1924(sk);
            ;
        WEAK_ID_48:
            return call_U232(sk);
            ;
        WEAK_ID_49:
            return call_U236(sk);
            ;
        WEAK_ID_50:
            return call_U240(sk);
            ;
        WEAK_ID_51:
            return call_U244(sk);
            ;
        WEAK_ID_68:
            return call_U2042(sk);
            ;
        WEAK_ID_69:
            return call_U2043(sk);
            ;
        WEAK_ID_70:
            return call_U2132(sk);
            ;
        WEAK_ID_71:
            return call_U2446(sk);
            ;
        WEAK_ID_72:
            return call_U2448(sk);
            ;
        WEAK_ID_73:
            return call_U2450(sk);
            ;
        WEAK_ID_74:
            return call_U2452(sk);
            ;
        WEAK_ID_75:
            return call_U2458(sk);
            ;
        WEAK_ID_76:
            return call_U2459(sk);
            ;
        WEAK_ID_77:
            return call_U2460(sk);
            ;
        WEAK_ID_78:
            return call_U2461(sk);
            ;
        WEAK_ID_79:
            return call_U2462(sk);
            ;
        WEAK_ID_80:
            return call_U2464(sk);
            ;
        WEAK_ID_81:
            return call_U2466(sk);
            ;
        WEAK_ID_82:
            return call_U2472(sk);
            ;
        WEAK_ID_83:
            return call_U2473(sk);
            ;
        WEAK_ID_84:
            return call_U2477(sk);
            ;
        WEAK_ID_85:
            return call_U2480(sk);
            ;
        WEAK_ID_86:
            return call_U2483(sk);
            ;
        WEAK_ID_87:
            return call_U2487(sk);
            ;
        WEAK_ID_88:
            return call_U2489(sk);
            ;
        WEAK_ID_89:
            return call_U2490(sk);
            ;
        WEAK_ID_90:
            return call_U2494(sk);
            ;
        WEAK_ID_91:
            return call_U2495(sk);
            ;
        WEAK_ID_92:
            return call_U2500(sk);
            ;
        WEAK_ID_93:
            return call_U2502(sk);
            ;
        WEAK_ID_94:
            return call_U2505(sk);
            ;
        WEAK_ID_95:
            return call_U2509(sk);
            ;
        WEAK_ID_96:
            return call_U2512(sk);
            ;
        OBJECT_TY:
            return call_U1(sk);
            ;
        SCENE_TY:
            return call_U3(sk);
            ;
        NUMBER_TY:
            return call_U7(sk);
            ;
        REAL_NUMBER_TY:
            return call_U10(sk);
            ;
        TRUTH_STATE_TY:
            return call_U12(sk);
            ;
        TEXT_TY:
            return call_U13(sk);
            ;
        SNIPPET_TY:
            return call_U14(sk);
            ;
        UNICODE_CHARACTER_TY:
            return call_U15(sk);
            ;
        USE_OPTION_TY:
            return call_U16(sk);
            ;
        RESPONSE_TY:
            return call_U17(sk);
            ;
        VERB_TY:
            return call_U18(sk);
            ;
        TABLE_TY:
            return call_U19(sk);
            ;
        EQUATION_TY:
            return call_U20(sk);
            ;
        RULEBOOK_OUTCOME_TY:
            return call_U21(sk);
            ;
        EXTERNAL_FILE_TY:
            return call_U22(sk);
            ;
        DESCRIPTION_OF_ACTION_TY:
            return call_U26(sk);
            ;
        STORED_ACTION_TY:
            return call_U27(sk);
            ;
        ACTION_NAME_TY:
            return call_U28(sk);
            ;
        TIME_TY:
            return call_U29(sk);
            ;
        FIGURE_NAME_TY:
            return call_U31(sk);
            ;
        SOUND_NAME_TY:
            return call_U35(sk);
            ;
        UNDERSTANDING_TY:
            return call_U39(sk);
            ;
        LIST_OF_TY:
            return call_U40(sk);
            ;
        NIL_TY:
            return call_U41(sk);
            ;
        VOID_TY:
            return call_U42(sk);
            ;
    }
    rfalse;
];
[ DefaultValueFinder k;
    rfalse;
];
[ PrintKindValuePair k v;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            E1(v);
            ;
        WEAK_ID_67:
            E7(v);
            ;
        WEAK_ID_48:
            E2(v);
            ;
        WEAK_ID_49:
            E3(v);
            ;
        WEAK_ID_50:
            E4(v);
            ;
        WEAK_ID_51:
            E5(v);
            ;
        WEAK_ID_70:
            E8(v);
            ;
        WEAK_ID_71:
            E6(v);
            ;
        WEAK_ID_72:
            E9(v);
            ;
        WEAK_ID_74:
            E10(v);
            ;
        WEAK_ID_81:
            E11(v);
            ;
        WEAK_ID_89:
            E12(v);
            ;
        WEAK_ID_96:
            E13(v);
            ;
        OBJECT_TY:
            PrintShortName(v);
            ;
        SCENE_TY:
            PrintSceneName(v);
            ;
        NUMBER_TY:
            DecimalNumber(v);
            ;
        REAL_NUMBER_TY:
            REAL_NUMBER_TY_Say(v);
            ;
        TRUTH_STATE_TY:
            DA_TruthState(v);
            ;
        TEXT_TY:
            TEXT_TY_Say(v);
            ;
        SNIPPET_TY:
            PrintSnippet(v);
            ;
        UNICODE_CHARACTER_TY:
            DecimalNumber(v);
            ;
        USE_OPTION_TY:
            PrintUseOption(v);
            ;
        RESPONSE_TY:
            PrintResponse(v);
            ;
        VERB_TY:
            PrintVerbAsValue(v);
            ;
        TABLE_TY:
            PrintTableName(v);
            ;
        EQUATION_TY:
            DA_Number(v);
            ;
        RULEBOOK_OUTCOME_TY:
            RulebookOutcomePrintingRule(v);
            ;
        EXTERNAL_FILE_TY:
            PrintExternalFileName(v);
            ;
        DESCRIPTION_OF_ACTION_TY:
            DecimalNumber(v);
            ;
        STORED_ACTION_TY:
            STORED_ACTION_TY_Say(v);
            ;
        ACTION_NAME_TY:
            SayActionName(v);
            ;
        TIME_TY:
            PrintTimeOfDay(v);
            ;
        FIGURE_NAME_TY:
            PrintFigureName(v);
            ;
        SOUND_NAME_TY:
            PrintSoundName(v);
            ;
        UNDERSTANDING_TY:
            DecimalNumber(v);
            ;
        LIST_OF_TY:
            LIST_OF_TY_Say(v);
            ;
        VALUE_TY:
            DecimalNumber(v);
            ;
        STORED_VALUE_TY:
            DecimalNumber(v);
            ;
        SAYABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        UNDERSTANDABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        REAL_ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        ENUMERATED_VALUE_TY:
            DecimalNumber(v);
            ;
        POINTER_VALUE_TY:
            DecimalNumber(v);
            ;
        PHRASE_TY:
            SayPhraseName(v);
            ;
        VARIABLE_TY:
            DecimalNumber(v);
            ;
        RELATION_TY:
            RELATION_TY_Say(v);
            ;
        RULE_TY:
            RulePrintingRule(v);
            ;
        RULEBOOK_TY:
            RulePrintingRule(v);
            ;
        ACTIVITY_TY:
            DecimalNumber(v);
            ;
        DESCRIPTION_OF_TY:
            DecimalNumber(v);
            ;
        PROPERTY_TY:
            PROPERTY_TY_Say(v);
            ;
        TABLE_COLUMN_TY:
            DecimalNumber(v);
            ;
        COMBINATION_TY:
            COMBINATION_TY_Say(v);
            ;
        NIL_TY:
            DecimalNumber(v);
            ;
        UNKNOWN_TY:
            DecimalNumber(v);
            ;
        VOID_TY:
            DecimalNumber(v);
            ;
        TUPLE_ENTRY_TY:
            DecimalNumber(v);
            ;
        default:
            print v;
            ;
    }
];
[ KOVComparisonFunction k;
    (k = KindAtomic(k));
    switch (k) {
        OBJECT_TY:
            return UnsignedCompare;
            ;
        SCENE_TY:
            return UnsignedCompare;
            ;
        REAL_NUMBER_TY:
            return REAL_NUMBER_TY_Compare;
            ;
        TRUTH_STATE_TY:
            return UnsignedCompare;
            ;
        TEXT_TY:
            return BlkValueCompare;
            ;
        SNIPPET_TY:
            return UnsignedCompare;
            ;
        UNICODE_CHARACTER_TY:
            return UnsignedCompare;
            ;
        USE_OPTION_TY:
            return UnsignedCompare;
            ;
        RESPONSE_TY:
            return UnsignedCompare;
            ;
        VERB_TY:
            return UnsignedCompare;
            ;
        TABLE_TY:
            return UnsignedCompare;
            ;
        EQUATION_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_OUTCOME_TY:
            return UnsignedCompare;
            ;
        EXTERNAL_FILE_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_ACTION_TY:
            return UnsignedCompare;
            ;
        STORED_ACTION_TY:
            return BlkValueCompare;
            ;
        ACTION_NAME_TY:
            return UnsignedCompare;
            ;
        FIGURE_NAME_TY:
            return UnsignedCompare;
            ;
        SOUND_NAME_TY:
            return UnsignedCompare;
            ;
        UNDERSTANDING_TY:
            return UnsignedCompare;
            ;
        LIST_OF_TY:
            return BlkValueCompare;
            ;
        PHRASE_TY:
            return UnsignedCompare;
            ;
        VARIABLE_TY:
            return UnsignedCompare;
            ;
        RELATION_TY:
            return BlkValueCompare;
            ;
        RULE_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_TY:
            return UnsignedCompare;
            ;
        ACTIVITY_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_TY:
            return UnsignedCompare;
            ;
        PROPERTY_TY:
            return UnsignedCompare;
            ;
        TABLE_COLUMN_TY:
            return UnsignedCompare;
            ;
        COMBINATION_TY:
            return BlkValueCompare;
            ;
        NIL_TY:
            return UnsignedCompare;
            ;
        VOID_TY:
            return UnsignedCompare;
            ;
        TUPLE_ENTRY_TY:
            return UnsignedCompare;
            ;
    }
    rfalse;
];
[ KOVDomainSize k;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            return 6;
            ;
        WEAK_ID_67:
            return 25;
            ;
        WEAK_ID_48:
            return 5;
            ;
        WEAK_ID_49:
            return 6;
            ;
        WEAK_ID_50:
            return 2;
            ;
        WEAK_ID_51:
            return 3;
            ;
        WEAK_ID_70:
            return 3;
            ;
        WEAK_ID_74:
            return 5;
            ;
        WEAK_ID_81:
            return 10;
            ;
        WEAK_ID_89:
            return 5;
            ;
        WEAK_ID_96:
            return 2;
            ;
        SCENE_TY:
            return 3;
            ;
        FIGURE_NAME_TY:
            return 29;
            ;
        SOUND_NAME_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ KOVIsBlockValue k;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            rtrue;
            ;
        STORED_ACTION_TY:
            rtrue;
            ;
        LIST_OF_TY:
            rtrue;
            ;
        RELATION_TY:
            rtrue;
            ;
        COMBINATION_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ I7_Kind_Name k;
    if ((k == K1_room)) {
        print "room";
    }
    if ((k == K2_thing)) {
        print "thing";
    }
    if ((k == K3_direction)) {
        print "direction";
    }
    if ((k == K4_door)) {
        print "door";
    }
    if ((k == K5_container)) {
        print "container";
    }
    if ((k == K6_supporter)) {
        print "supporter";
    }
    if ((k == K7_backdrop)) {
        print "backdrop";
    }
    if ((k == K8_person)) {
        print "person";
    }
    if ((k == K9_region)) {
        print "region";
    }
    if ((k == K10_man)) {
        print "man";
    }
    if ((k == K11_woman)) {
        print "woman";
    }
    if ((k == K12_animal)) {
        print "animal";
    }
    if ((k == K13_device)) {
        print "device";
    }
    if ((k == K14_vehicle)) {
        print "vehicle";
    }
    if ((k == K15_player_s_holdall)) {
        print "player's holdall";
    }
    if ((k == K16_passkey)) {
        print "passkey";
    }
    if ((k == K17_keychain)) {
        print "keychain";
    }
    if ((k == K18_fluid_container)) {
        print "fluid container";
    }
    if ((k == K19_electric_lamp)) {
        print "electric lamp";
    }
    if ((k == K20_attendant)) {
        print "attendant";
    }
    if ((k == K21_coin)) {
        print "coin";
    }
    if ((k == K22_nickel)) {
        print "nickel";
    }
    if ((k == K23_dime)) {
        print "dime";
    }
    if ((k == K24_quarter)) {
        print "quarter";
    }
    if ((k == K25_electrical_closet)) {
        print "electrical closet";
    }
    if ((k == K26_electrical_panel)) {
        print "electrical panel";
    }
    if ((k == K27_socket)) {
        print "socket";
    }
    if ((k == K28_indicator)) {
        print "indicator";
    }
    if ((k == K29_fuse)) {
        print "fuse";
    }
    if ((k == K30_switch)) {
        print "switch";
    }
    if ((k == K31_ride_ticket)) {
        print "ride ticket";
    }
    if ((k == K32_baseball)) {
        print "baseball";
    }
    if ((k == K33_wooden_door)) {
        print "wooden door";
    }
    if ((k == K34_control_panel)) {
        print "control panel";
    }
    if ((k == K35_button)) {
        print "button";
    }
    if ((k == K36_dial)) {
        print "dial";
    }
    if ((k == K37_light)) {
        print "light";
    }
];
[ KOVSupportFunction k fail;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            return TEXT_TY_Support;
            ;
        STORED_ACTION_TY:
            return STORED_ACTION_TY_Support;
            ;
        LIST_OF_TY:
            return LIST_OF_TY_Support;
            ;
        RELATION_TY:
            return RELATION_TY_Support;
            ;
        COMBINATION_TY:
            return COMBINATION_TY_Support;
            ;
    }
    if (fail) {
        BlkValueError(fail);
    }
    rfalse;
];
[ ShowMeKindDetails which na t_0;
    (na = call_U1901(which, na, t_0));
    (na = call_U1903(which, na, t_0));
    (na = call_U1905(which, na, t_0));
    (na = call_U1907(which, na, t_0));
    (na = call_U1910(which, na, t_0));
    (na = call_U1912(which, na, t_0));
    (na = call_U1915(which, na, t_0));
    (na = call_U1921(which, na, t_0));
    (na = call_U2451(which, na, t_0));
    (na = call_U2474(which, na, t_0));
    (na = call_U2484(which, na, t_0));
    (na = call_U2496(which, na, t_0));
    (na = call_U2501(which, na, t_0));
    (na = call_U2506(which, na, t_0));
    (na = call_U2(which, na, t_0));
    return na;
];
[ CreateDynamicRelations;
];
[ IterateRelations callback;
    (callback)(Rel_Record1);
    (callback)(Rel_Record2);
    (callback)(Rel_Record3);
    (callback)(Rel_Record4);
    (callback)(Rel_Record5);
    (callback)(Rel_Record6);
    (callback)(Rel_Record7);
    (callback)(Rel_Record8);
    (callback)(Rel_Record9);
    (callback)(Rel_Record10);
    (callback)(Rel_Record11);
    (callback)(Rel_Record12);
    (callback)(Rel_Record13);
    (callback)(Rel_Record14);
    (callback)(Rel_Record15);
    (callback)(Rel_Record16);
    (callback)(Rel_Record17);
    (callback)(Rel_Record18);
    (callback)(Rel_Record19);
    (callback)(Rel_Record20);
    (callback)(Rel_Record21);
    (callback)(Rel_Record22);
];
[ RProperty obj cl pr;
    if ((obj ofclass cl)) {
        return _final_propertyvalue(OBJECT_TY, obj, pr);
    }
    rfalse;
];
[ MStack_GetRBVarCreator rb;
    return (rulebook_var_creators-->(rb));
];
[ RulePrintingRule R;
    if ((((R >= 0)) && ((R < 453)))) {
        print (string) (RulebookNames-->(R));
    } else {
        if ((R == FINAL_CODE_STARTUP_R)) {
            print "final code startup rule";
            rtrue;
        }
        if ((R == STANDARD_NAME_PRINTING_R)) {
            print "standard name printing rule";
            rtrue;
        }
        if ((R == STANDARD_PLURAL_NAME_PRINTING_R)) {
            print "standard printing the plural name rule";
            rtrue;
        }
        if ((R == ADJUST_LIGHT_R)) {
            print "adjust light rule";
            rtrue;
        }
        if ((R == GENERATE_ACTION_R)) {
            print "generate action rule";
            rtrue;
        }
        if ((R == BASIC_ACCESSIBILITY_R)) {
            print "basic accessibility rule";
            rtrue;
        }
        if ((R == BASIC_VISIBILITY_R)) {
            print "basic visibility rule";
            rtrue;
        }
        if ((R == REQUESTED_ACTIONS_REQUIRE_R)) {
            print "requested actions require persuasion rule";
            rtrue;
        }
        if ((R == CARRY_OUT_REQUESTED_ACTIONS_R)) {
            print "carry out requested actions rule";
            rtrue;
        }
        if ((R == ACCESS_THROUGH_BARRIERS_R)) {
            print "access through barriers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_CLOSED_R)) {
            print "can't reach inside closed containers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_ROOMS_R)) {
            print "can't reach inside rooms rule";
            rtrue;
        }
        if ((R == CANT_REACH_OUTSIDE_CLOSED_R)) {
            print "can't reach outside closed containers rule";
            rtrue;
        }
        if ((R == LIST_WRITER_INTERNAL_R)) {
            print "list writer internal rule";
            rtrue;
        }
        if ((R == ACTION_PROCESSING_INTERNAL_R)) {
            print "action processing internal rule";
            rtrue;
        }
        if ((R == PARSER_ERROR_INTERNAL_R)) {
            print "parser error internal rule";
            rtrue;
        }
        if ((R == PARSER_N_ERROR_INTERNAL_R)) {
            print "parser nothing error internal rule";
            rtrue;
        }
        if ((R == DARKNESS_NAME_INTERNAL_R)) {
            print "darkness name internal rule";
            rtrue;
        }
        if ((R == PARSER_COMMAND_INTERNAL_R)) {
            print "parser command internal rule";
            rtrue;
        }
        if ((R == PARSER_CLARIF_INTERNAL_R)) {
            print "parser clarification internal rule";
            rtrue;
        }
        if ((R == YES_OR_NO_QUESTION_INTERNAL_R)) {
            print "yes or no question internal rule";
            rtrue;
        }
        if ((R == PRINT_PROTAGONIST_INTERNAL_R)) {
            print "print protagonist internal rule";
            rtrue;
        }
        if ((R == STANDARD_IMPLICIT_TAKING_R)) {
            print "standard implicit taking rule";
            rtrue;
        }
        if ((R == PRINT_OBITUARY_HEADLINE_R)) {
            print "print obituary headline rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_UNDO_R)) {
            print "immediately undo rule";
            rtrue;
        }
        if ((R == QUIT_THE_GAME_R)) {
            print "quit the game rule";
            rtrue;
        }
        if ((R == SAVE_THE_GAME_R)) {
            print "save the game rule";
            rtrue;
        }
        if ((R == RESTORE_THE_GAME_R)) {
            print "restore the game rule";
            rtrue;
        }
        if ((R == RESTART_THE_GAME_R)) {
            print "restart the game rule";
            rtrue;
        }
        if ((R == VERIFY_THE_STORY_FILE_R)) {
            print "verify the story file rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_ON_R)) {
            print "switch the story transcript on rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_OFF_R)) {
            print "switch the story transcript off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_SCORE_R)) {
            print "announce the score rule";
            rtrue;
        }
        if ((R == REP_PREFER_ABBREVIATED_R)) {
            print "standard report preferring abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_UNABBREVIATED_R)) {
            print "standard report preferring unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_SOMETIMES_ABBR_R)) {
            print "standard report preferring sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_ON_R)) {
            print "standard report switching score notification on rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_OFF_R)) {
            print "standard report switching score notification off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_PRONOUN_MEANINGS_R)) {
            print "announce the pronoun meanings rule";
            rtrue;
        }
        if ((R == call_U1068)) {
            print "declare everything initially unmentioned rule";
            rtrue;
        }
        if ((R == call_U1070)) {
            print "start in the correct scenes rule";
            rtrue;
        }
        if ((R == call_U1071)) {
            print "when play begins stage rule";
            rtrue;
        }
        if ((R == call_U1072)) {
            print "fix baseline scoring rule";
            rtrue;
        }
        if ((R == call_U1073)) {
            print "display banner rule";
            rtrue;
        }
        if ((R == call_U1074)) {
            print "initial room description rule";
            rtrue;
        }
        if ((R == call_U1075)) {
            print "every turn stage rule";
            rtrue;
        }
        if ((R == call_U1076)) {
            print "A first turn sequence rule";
            rtrue;
        }
        if ((R == call_U1077)) {
            print "A last turn sequence rule";
            rtrue;
        }
        if ((R == call_U1078)) {
            print "notify score changes rule";
            rtrue;
        }
        if ((R == call_U1079)) {
            print "when play ends stage rule";
            rtrue;
        }
        if ((R == call_U1080)) {
            print "print player's obituary rule";
            rtrue;
        }
        if ((R == call_U1081)) {
            print "set pronouns from items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U1082)) {
            print "announce items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U1085)) {
            print "before stage rule";
            rtrue;
        }
        if ((R == call_U1086)) {
            print "instead stage rule";
            rtrue;
        }
        if ((R == call_U1087)) {
            print "end action-processing in success rule";
            rtrue;
        }
        if ((R == call_U1088)) {
            print "investigate player's awareness before action rule";
            rtrue;
        }
        if ((R == call_U1089)) {
            print "check stage rule";
            rtrue;
        }
        if ((R == call_U1090)) {
            print "carry out stage rule";
            rtrue;
        }
        if ((R == call_U1091)) {
            print "after stage rule";
            rtrue;
        }
        if ((R == call_U1092)) {
            print "investigate player's awareness after action rule";
            rtrue;
        }
        if ((R == call_U1093)) {
            print "report stage rule";
            rtrue;
        }
        if ((R == call_U1094)) {
            print "last specific action-processing rule";
            rtrue;
        }
        if ((R == call_U1095)) {
            print "player aware of his own actions rule";
            rtrue;
        }
        if ((R == call_U1096)) {
            print "player aware of actions by visible actors rule";
            rtrue;
        }
        if ((R == call_U1097)) {
            print "player aware of actions on visible nouns rule";
            rtrue;
        }
        if ((R == call_U1098)) {
            print "player aware of actions on visible second nouns rule";
            rtrue;
        }
        if ((R == call_U1099)) {
            print "can't act in the dark rule";
            rtrue;
        }
        if ((R == call_U1100)) {
            print "very unlikely to mean taking what's already carried rule";
            rtrue;
        }
        if ((R == call_U1101)) {
            print "scene description text rule";
            rtrue;
        }
        if ((R == call_U1102)) {
            print "make named things mentioned rule";
            rtrue;
        }
        if ((R == call_U1103)) {
            print "standard printing a number of something rule";
            rtrue;
        }
        if ((R == call_U1104)) {
            print "look around once light available rule";
            rtrue;
        }
        if ((R == call_U1105)) {
            print "exclude scenery from take all rule";
            rtrue;
        }
        if ((R == call_U1106)) {
            print "exclude people from take all rule";
            rtrue;
        }
        if ((R == call_U1107)) {
            print "exclude fixed in place things from take all rule";
            rtrue;
        }
        if ((R == call_U1108)) {
            print "exclude indirect possessions from take all rule";
            rtrue;
        }
        if ((R == call_U1109)) {
            print "exclude people from drop all rule";
            rtrue;
        }
        if ((R == call_U1110)) {
            print "ambient odour rule";
            rtrue;
        }
        if ((R == call_U1111)) {
            print "ambient sound rule";
            rtrue;
        }
        if ((R == call_U1112)) {
            print "block vaguely going rule";
            rtrue;
        }
        if ((R == call_U1115)) {
            print "print the final prompt rule";
            rtrue;
        }
        if ((R == call_U1118)) {
            print "print the final question rule";
            rtrue;
        }
        if ((R == call_U1123)) {
            print "standard respond to final question rule";
            rtrue;
        }
        if ((R == call_U1126)) {
            print "initialise locale description rule";
            rtrue;
        }
        if ((R == call_U1127)) {
            print "find notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1128)) {
            print "interesting locale paragraphs rule";
            rtrue;
        }
        if ((R == call_U1129)) {
            print "you-can-also-see rule";
            rtrue;
        }
        if ((R == call_U1147)) {
            print "standard notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1148)) {
            print "don't mention player's supporter in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1149)) {
            print "don't mention scenery in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1150)) {
            print "don't mention undescribed items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1151)) {
            print "set pronouns from items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1152)) {
            print "offer items to writing a paragraph about rule";
            rtrue;
        }
        if ((R == call_U1153)) {
            print "use initial appearance in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1158)) {
            print "initial appearance on supporters rule";
            rtrue;
        }
        if ((R == call_U1160)) {
            print "describe what's on scenery supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1165)) {
            print "describe what's on mentioned supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1170)) {
            print "print empty inventory rule";
            rtrue;
        }
        if ((R == call_U1173)) {
            print "print standard inventory rule";
            rtrue;
        }
        if ((R == call_U1176)) {
            print "report other people taking inventory rule";
            rtrue;
        }
        if ((R == call_U1179)) {
            print "can't take yourself rule";
            rtrue;
        }
        if ((R == call_U1182)) {
            print "can't take other people rule";
            rtrue;
        }
        if ((R == call_U1185)) {
            print "can't take component parts rule";
            rtrue;
        }
        if ((R == call_U1188)) {
            print "can't take people's possessions rule";
            rtrue;
        }
        if ((R == call_U1191)) {
            print "can't take items out of play rule";
            rtrue;
        }
        if ((R == call_U1194)) {
            print "can't take what you're inside rule";
            rtrue;
        }
        if ((R == call_U1197)) {
            print "can't take what's already taken rule";
            rtrue;
        }
        if ((R == call_U1200)) {
            print "can't take scenery rule";
            rtrue;
        }
        if ((R == call_U1203)) {
            print "can only take things rule";
            rtrue;
        }
        if ((R == call_U1206)) {
            print "can't take what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1209)) {
            print "use player's holdall to avoid exceeding carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1215)) {
            print "can't exceed carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1219)) {
            print "standard taking rule";
            rtrue;
        }
        if ((R == call_U1220)) {
            print "standard report taking rule";
            rtrue;
        }
        if ((R == call_U1225)) {
            print "can't remove what's not inside rule";
            rtrue;
        }
        if ((R == call_U1228)) {
            print "can't remove from people rule";
            rtrue;
        }
        if ((R == call_U1231)) {
            print "convert remove to take rule";
            rtrue;
        }
        if ((R == call_U1232)) {
            print "can't drop yourself rule";
            rtrue;
        }
        if ((R == call_U1235)) {
            print "can't drop body parts rule";
            rtrue;
        }
        if ((R == call_U1238)) {
            print "can't drop what's already dropped rule";
            rtrue;
        }
        if ((R == call_U1241)) {
            print "can't drop what's not held rule";
            rtrue;
        }
        if ((R == call_U1244)) {
            print "can't drop clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1247)) {
            print "can't drop if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1254)) {
            print "standard dropping rule";
            rtrue;
        }
        if ((R == call_U1255)) {
            print "standard report dropping rule";
            rtrue;
        }
        if ((R == call_U1260)) {
            print "convert put to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1261)) {
            print "can't put what's not held rule";
            rtrue;
        }
        if ((R == call_U1262)) {
            print "can't put something on itself rule";
            rtrue;
        }
        if ((R == call_U1265)) {
            print "can't put onto what's not a supporter rule";
            rtrue;
        }
        if ((R == call_U1268)) {
            print "can't put clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1271)) {
            print "can't put if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1275)) {
            print "standard putting rule";
            rtrue;
        }
        if ((R == call_U1276)) {
            print "concise report putting rule";
            rtrue;
        }
        if ((R == call_U1279)) {
            print "standard report putting rule";
            rtrue;
        }
        if ((R == call_U1282)) {
            print "convert insert to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1283)) {
            print "can't insert what's already inserted rule";
            rtrue;
        }
        if ((R == call_U1286)) {
            print "can't insert something into itself rule";
            rtrue;
        }
        if ((R == call_U1289)) {
            print "can't insert what's not held rule";
            rtrue;
        }
        if ((R == call_U1290)) {
            print "can't insert into closed containers rule";
            rtrue;
        }
        if ((R == call_U1293)) {
            print "can't insert into what's not a container rule";
            rtrue;
        }
        if ((R == call_U1296)) {
            print "can't insert clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1299)) {
            print "can't insert if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1303)) {
            print "standard inserting rule";
            rtrue;
        }
        if ((R == call_U1304)) {
            print "concise report inserting rule";
            rtrue;
        }
        if ((R == call_U1307)) {
            print "standard report inserting rule";
            rtrue;
        }
        if ((R == call_U1310)) {
            print "can't eat unless edible rule";
            rtrue;
        }
        if ((R == call_U1313)) {
            print "can't eat clothing without removing it first rule";
            rtrue;
        }
        if ((R == call_U1316)) {
            print "can't eat other people's food rule";
            rtrue;
        }
        if ((R == call_U1320)) {
            print "can't eat portable food without carrying it rule";
            rtrue;
        }
        if ((R == call_U1321)) {
            print "standard eating rule";
            rtrue;
        }
        if ((R == call_U1322)) {
            print "standard report eating rule";
            rtrue;
        }
        if ((R == call_U1327)) {
            print "standard set going variables rule";
            rtrue;
        }
        if ((R == call_U1328)) {
            print "stand up before going rule";
            rtrue;
        }
        if ((R == call_U1331)) {
            print "can't travel in what's not a vehicle rule";
            rtrue;
        }
        if ((R == call_U1336)) {
            print "can't go through undescribed doors rule";
            rtrue;
        }
        if ((R == call_U1339)) {
            print "can't go through closed doors rule";
            rtrue;
        }
        if ((R == call_U1342)) {
            print "determine map connection rule";
            rtrue;
        }
        if ((R == call_U1343)) {
            print "can't go that way rule";
            rtrue;
        }
        if ((R == call_U1348)) {
            print "move player and vehicle rule";
            rtrue;
        }
        if ((R == call_U1349)) {
            print "move floating objects rule";
            rtrue;
        }
        if ((R == call_U1350)) {
            print "check light in new location rule";
            rtrue;
        }
        if ((R == call_U1351)) {
            print "describe room gone into rule";
            rtrue;
        }
        if ((R == call_U1390)) {
            print "find what to enter rule";
            rtrue;
        }
        if ((R == call_U1392)) {
            print "convert enter door into go rule";
            rtrue;
        }
        if ((R == call_U1393)) {
            print "convert enter compass direction into go rule";
            rtrue;
        }
        if ((R == call_U1394)) {
            print "can't enter what's already entered rule";
            rtrue;
        }
        if ((R == call_U1399)) {
            print "can't enter what's not enterable rule";
            rtrue;
        }
        if ((R == call_U1408)) {
            print "can't enter closed containers rule";
            rtrue;
        }
        if ((R == call_U1411)) {
            print "can't enter if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1418)) {
            print "can't enter something carried rule";
            rtrue;
        }
        if ((R == call_U1421)) {
            print "implicitly pass through other barriers rule";
            rtrue;
        }
        if ((R == call_U1432)) {
            print "standard entering rule";
            rtrue;
        }
        if ((R == call_U1433)) {
            print "standard report entering rule";
            rtrue;
        }
        if ((R == call_U1442)) {
            print "describe contents entered into rule";
            rtrue;
        }
        if ((R == call_U1443)) {
            print "standard set exiting variables rule";
            rtrue;
        }
        if ((R == call_U1444)) {
            print "convert exit into go out rule";
            rtrue;
        }
        if ((R == call_U1445)) {
            print "can't exit when not inside anything rule";
            rtrue;
        }
        if ((R == call_U1448)) {
            print "can't exit closed containers rule";
            rtrue;
        }
        if ((R == call_U1451)) {
            print "convert exit into get off rule";
            rtrue;
        }
        if ((R == call_U1452)) {
            print "standard exiting rule";
            rtrue;
        }
        if ((R == call_U1453)) {
            print "standard report exiting rule";
            rtrue;
        }
        if ((R == call_U1460)) {
            print "describe room emerged into rule";
            rtrue;
        }
        if ((R == call_U1461)) {
            print "can't get off things rule";
            rtrue;
        }
        if ((R == call_U1464)) {
            print "standard getting off rule";
            rtrue;
        }
        if ((R == call_U1465)) {
            print "standard report getting off rule";
            rtrue;
        }
        if ((R == call_U1468)) {
            print "describe room stood up into rule";
            rtrue;
        }
        if ((R == call_U1469)) {
            print "determine visibility ceiling rule";
            rtrue;
        }
        if ((R == call_U1470)) {
            print "declare everything unmentioned rule";
            rtrue;
        }
        if ((R == call_U1472)) {
            print "room description heading rule";
            rtrue;
        }
        if ((R == call_U1479)) {
            print "room description body text rule";
            rtrue;
        }
        if ((R == call_U1482)) {
            print "room description paragraphs about objects rule";
            rtrue;
        }
        if ((R == call_U1483)) {
            print "check new arrival rule";
            rtrue;
        }
        if ((R == call_U1484)) {
            print "other people looking rule";
            rtrue;
        }
        if ((R == call_U1487)) {
            print "standard examining rule";
            rtrue;
        }
        if ((R == call_U1488)) {
            print "examine directions rule";
            rtrue;
        }
        if ((R == call_U1491)) {
            print "examine containers rule";
            rtrue;
        }
        if ((R == call_U1498)) {
            print "examine supporters rule";
            rtrue;
        }
        if ((R == call_U1503)) {
            print "examine devices rule";
            rtrue;
        }
        if ((R == call_U1506)) {
            print "examine undescribed things rule";
            rtrue;
        }
        if ((R == call_U1509)) {
            print "report other people examining rule";
            rtrue;
        }
        if ((R == call_U1512)) {
            print "standard looking under rule";
            rtrue;
        }
        if ((R == call_U1515)) {
            print "report other people looking under rule";
            rtrue;
        }
        if ((R == call_U1518)) {
            print "can't search unless container or supporter rule";
            rtrue;
        }
        if ((R == call_U1521)) {
            print "can't search closed opaque containers rule";
            rtrue;
        }
        if ((R == call_U1524)) {
            print "standard search containers rule";
            rtrue;
        }
        if ((R == call_U1530)) {
            print "standard search supporters rule";
            rtrue;
        }
        if ((R == call_U1536)) {
            print "report other people searching rule";
            rtrue;
        }
        if ((R == call_U1539)) {
            print "block consulting rule";
            rtrue;
        }
        if ((R == call_U1544)) {
            print "can't lock without a lock rule";
            rtrue;
        }
        if ((R == call_U1547)) {
            print "can't lock what's already locked rule";
            rtrue;
        }
        if ((R == call_U1550)) {
            print "can't lock what's open rule";
            rtrue;
        }
        if ((R == call_U1553)) {
            print "can't lock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1556)) {
            print "standard locking rule";
            rtrue;
        }
        if ((R == call_U1557)) {
            print "standard report locking rule";
            rtrue;
        }
        if ((R == call_U1562)) {
            print "can't unlock without a lock rule";
            rtrue;
        }
        if ((R == call_U1565)) {
            print "can't unlock what's already unlocked rule";
            rtrue;
        }
        if ((R == call_U1568)) {
            print "can't unlock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1571)) {
            print "standard unlocking rule";
            rtrue;
        }
        if ((R == call_U1572)) {
            print "standard report unlocking rule";
            rtrue;
        }
        if ((R == call_U1577)) {
            print "can't switch on unless switchable rule";
            rtrue;
        }
        if ((R == call_U1580)) {
            print "can't switch on what's already on rule";
            rtrue;
        }
        if ((R == call_U1583)) {
            print "standard switching on rule";
            rtrue;
        }
        if ((R == call_U1584)) {
            print "standard report switching on rule";
            rtrue;
        }
        if ((R == call_U1587)) {
            print "can't switch off unless switchable rule";
            rtrue;
        }
        if ((R == call_U1590)) {
            print "can't switch off what's already off rule";
            rtrue;
        }
        if ((R == call_U1593)) {
            print "standard switching off rule";
            rtrue;
        }
        if ((R == call_U1594)) {
            print "standard report switching off rule";
            rtrue;
        }
        if ((R == call_U1597)) {
            print "can't open unless openable rule";
            rtrue;
        }
        if ((R == call_U1600)) {
            print "can't open what's locked rule";
            rtrue;
        }
        if ((R == call_U1603)) {
            print "can't open what's already open rule";
            rtrue;
        }
        if ((R == call_U1606)) {
            print "standard opening rule";
            rtrue;
        }
        if ((R == call_U1607)) {
            print "reveal any newly visible interior rule";
            rtrue;
        }
        if ((R == call_U1610)) {
            print "standard report opening rule";
            rtrue;
        }
        if ((R == call_U1617)) {
            print "can't close unless openable rule";
            rtrue;
        }
        if ((R == call_U1620)) {
            print "can't close what's already closed rule";
            rtrue;
        }
        if ((R == call_U1623)) {
            print "standard closing rule";
            rtrue;
        }
        if ((R == call_U1624)) {
            print "standard report closing rule";
            rtrue;
        }
        if ((R == call_U1631)) {
            print "can't wear what's not clothing rule";
            rtrue;
        }
        if ((R == call_U1634)) {
            print "can't wear what's not held rule";
            rtrue;
        }
        if ((R == call_U1637)) {
            print "can't wear what's already worn rule";
            rtrue;
        }
        if ((R == call_U1640)) {
            print "standard wearing rule";
            rtrue;
        }
        if ((R == call_U1641)) {
            print "standard report wearing rule";
            rtrue;
        }
        if ((R == call_U1646)) {
            print "Does the player mean taking off something worn";
            rtrue;
        }
        if ((R == call_U1647)) {
            print "can't take off what's not worn rule";
            rtrue;
        }
        if ((R == call_U1650)) {
            print "can't exceed carrying capacity when taking off rule";
            rtrue;
        }
        if ((R == call_U1654)) {
            print "standard taking off rule";
            rtrue;
        }
        if ((R == call_U1655)) {
            print "standard report taking off rule";
            rtrue;
        }
        if ((R == call_U1660)) {
            print "can't give what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1663)) {
            print "can't give to yourself rule";
            rtrue;
        }
        if ((R == call_U1666)) {
            print "can't give to a non-person rule";
            rtrue;
        }
        if ((R == call_U1669)) {
            print "can't give clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1672)) {
            print "block giving rule";
            rtrue;
        }
        if ((R == call_U1675)) {
            print "can't exceed carrying capacity when giving rule";
            rtrue;
        }
        if ((R == call_U1679)) {
            print "standard giving rule";
            rtrue;
        }
        if ((R == call_U1680)) {
            print "standard report giving rule";
            rtrue;
        }
        if ((R == call_U1687)) {
            print "can't show what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1690)) {
            print "convert show to yourself to examine rule";
            rtrue;
        }
        if ((R == call_U1691)) {
            print "block showing rule";
            rtrue;
        }
        if ((R == call_U1694)) {
            print "block waking rule";
            rtrue;
        }
        if ((R == call_U1697)) {
            print "implicitly remove thrown clothing rule";
            rtrue;
        }
        if ((R == call_U1700)) {
            print "futile to throw things at inanimate objects rule";
            rtrue;
        }
        if ((R == call_U1703)) {
            print "block throwing at rule";
            rtrue;
        }
        if ((R == call_U1706)) {
            print "block attacking rule";
            rtrue;
        }
        if ((R == call_U1709)) {
            print "kissing yourself rule";
            rtrue;
        }
        if ((R == call_U1712)) {
            print "block kissing rule";
            rtrue;
        }
        if ((R == call_U1715)) {
            print "block answering rule";
            rtrue;
        }
        if ((R == call_U1718)) {
            print "telling yourself rule";
            rtrue;
        }
        if ((R == call_U1721)) {
            print "block telling rule";
            rtrue;
        }
        if ((R == call_U1724)) {
            print "block asking rule";
            rtrue;
        }
        if ((R == call_U1727)) {
            print "asking yourself for something rule";
            rtrue;
        }
        if ((R == call_U1728)) {
            print "translate asking for to giving rule";
            rtrue;
        }
        if ((R == call_U1729)) {
            print "standard report waiting rule";
            rtrue;
        }
        if ((R == call_U1734)) {
            print "report touching yourself rule";
            rtrue;
        }
        if ((R == call_U1739)) {
            print "report touching other people rule";
            rtrue;
        }
        if ((R == call_U1746)) {
            print "report touching things rule";
            rtrue;
        }
        if ((R == call_U1751)) {
            print "can't wave what's not held rule";
            rtrue;
        }
        if ((R == call_U1754)) {
            print "report waving things rule";
            rtrue;
        }
        if ((R == call_U1759)) {
            print "can't pull what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1762)) {
            print "can't pull scenery rule";
            rtrue;
        }
        if ((R == call_U1765)) {
            print "can't pull people rule";
            rtrue;
        }
        if ((R == call_U1768)) {
            print "report pulling rule";
            rtrue;
        }
        if ((R == call_U1773)) {
            print "can't push what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1776)) {
            print "can't push scenery rule";
            rtrue;
        }
        if ((R == call_U1779)) {
            print "can't push people rule";
            rtrue;
        }
        if ((R == call_U1782)) {
            print "report pushing rule";
            rtrue;
        }
        if ((R == call_U1787)) {
            print "can't turn what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1790)) {
            print "can't turn scenery rule";
            rtrue;
        }
        if ((R == call_U1793)) {
            print "can't turn people rule";
            rtrue;
        }
        if ((R == call_U1796)) {
            print "report turning rule";
            rtrue;
        }
        if ((R == call_U1801)) {
            print "can't push unpushable things rule";
            rtrue;
        }
        if ((R == call_U1804)) {
            print "can't push to non-directions rule";
            rtrue;
        }
        if ((R == call_U1807)) {
            print "can't push vertically rule";
            rtrue;
        }
        if ((R == call_U1810)) {
            print "can't push from within rule";
            rtrue;
        }
        if ((R == call_U1813)) {
            print "standard pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1814)) {
            print "block pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1817)) {
            print "innuendo about squeezing people rule";
            rtrue;
        }
        if ((R == call_U1820)) {
            print "report squeezing rule";
            rtrue;
        }
        if ((R == call_U1825)) {
            print "block saying yes rule";
            rtrue;
        }
        if ((R == call_U1828)) {
            print "block saying no rule";
            rtrue;
        }
        if ((R == call_U1831)) {
            print "block burning rule";
            rtrue;
        }
        if ((R == call_U1834)) {
            print "block waking up rule";
            rtrue;
        }
        if ((R == call_U1837)) {
            print "block thinking rule";
            rtrue;
        }
        if ((R == call_U1840)) {
            print "report smelling rule";
            rtrue;
        }
        if ((R == call_U1845)) {
            print "report listening rule";
            rtrue;
        }
        if ((R == call_U1850)) {
            print "report tasting rule";
            rtrue;
        }
        if ((R == call_U1855)) {
            print "block cutting rule";
            rtrue;
        }
        if ((R == call_U1858)) {
            print "report jumping rule";
            rtrue;
        }
        if ((R == call_U1863)) {
            print "block tying rule";
            rtrue;
        }
        if ((R == call_U1866)) {
            print "block drinking rule";
            rtrue;
        }
        if ((R == call_U1869)) {
            print "block saying sorry rule";
            rtrue;
        }
        if ((R == call_U1872)) {
            print "block swinging rule";
            rtrue;
        }
        if ((R == call_U1875)) {
            print "can't rub another person rule";
            rtrue;
        }
        if ((R == call_U1878)) {
            print "report rubbing rule";
            rtrue;
        }
        if ((R == call_U1883)) {
            print "block setting it to rule";
            rtrue;
        }
        if ((R == call_U1886)) {
            print "report waving hands rule";
            rtrue;
        }
        if ((R == call_U1891)) {
            print "block buying rule";
            rtrue;
        }
        if ((R == call_U1894)) {
            print "block climbing rule";
            rtrue;
        }
        if ((R == call_U1897)) {
            print "block sleeping rule";
            rtrue;
        }
        if ((R == LITTLE_USED_DO_NOTHING_R)) {
            print "little-used do nothing rule";
            rtrue;
        }
        if ((R == VIRTUAL_MACHINE_STARTUP_R)) {
            print "virtual machine startup rule";
            rtrue;
        }
        if ((R == INITIALISE_MEMORY_R)) {
            print "initialise memory rule";
            rtrue;
        }
        if ((R == SEED_RANDOM_NUMBER_GENERATOR_R)) {
            print "seed random number generator rule";
            rtrue;
        }
        if ((R == UPDATE_CHRONOLOGICAL_RECORDS_R)) {
            print "update chronological records rule";
            rtrue;
        }
        if ((R == POSITION_PLAYER_IN_MODEL_R)) {
            print "position player in model world rule";
            rtrue;
        }
        if ((R == ADVANCE_TIME_R)) {
            print "advance time rule";
            rtrue;
        }
        if ((R == NOTE_OBJECT_ACQUISITIONS_R)) {
            print "note object acquisitions rule";
            rtrue;
        }
        if ((R == PARSE_COMMAND_R)) {
            print "parse command rule";
            rtrue;
        }
        if ((R == TIMED_EVENTS_R)) {
            print "timed events rule";
            rtrue;
        }
        if ((R == RESURRECT_PLAYER_IF_ASKED_R)) {
            print "resurrect player if asked rule";
            rtrue;
        }
        if ((R == ASK_FINAL_QUESTION_R)) {
            print "ask the final question rule";
            rtrue;
        }
        if ((R == SCENE_CHANGE_MACHINERY_R)) {
            print "scene change machinery rule";
            rtrue;
        }
        if ((R == CARRYING_REQUIREMENTS_R)) {
            print "carrying requirements rule";
            rtrue;
        }
        if ((R == DESCEND_TO_SPECIFIC_ACTION_R)) {
            print "descend to specific action-processing rule";
            rtrue;
        }
        if ((R == WORK_OUT_DETAILS_OF_SPECIFIC_R)) {
            print "work out details of specific action rule";
            rtrue;
        }
        if ((R == STANDARD_RESPONSE_ISSUING_R)) {
            print "standard issuing the response text rule";
            rtrue;
        }
        if ((R == STANDARD_CONTENTS_LISTING_R)) {
            print "standard contents listing rule";
            rtrue;
        }
        if ((R == PRINT_FINAL_SCORE_R)) {
            print "print final score rule";
            rtrue;
        }
        if ((R == DISPLAY_FINAL_STATUS_LINE_R)) {
            print "display final status line rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTART_VM_R)) {
            print "immediately restart the VM rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTORE_SAVED_R)) {
            print "immediately restore saved game rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_QUIT_R)) {
            print "immediately quit rule";
            rtrue;
        }
        if ((R == READ_FINAL_ANSWER_R)) {
            print "read the final answer rule";
            rtrue;
        }
        if ((R == ANNOUNCE_STORY_FILE_VERSION_R)) {
            print "announce the story file version rule";
            rtrue;
        }
        if ((R == PREFER_ABBREVIATED_R)) {
            print "prefer abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_UNABBREVIATED_R)) {
            print "prefer unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_SOMETIMES_ABBREVIATED_R)) {
            print "prefer sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_ON_R)) {
            print "switch score notification on rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_OFF_R)) {
            print "switch score notification off rule";
            rtrue;
        }
        if ((R == call_U2007)) {
            print "new can't get off things rule";
            rtrue;
        }
        if ((R == call_U2008)) {
            print "clever can't take what you're inside rule";
            rtrue;
        }
        if ((R == call_U2009)) {
            print "no motion without purpose rule";
            rtrue;
        }
        if ((R == call_U2010)) {
            print "rising before departure rule";
            rtrue;
        }
        if ((R == call_U2011)) {
            print "implicit exiting rule";
            rtrue;
        }
        if ((R == call_U2014)) {
            print "new convert exit into go out rule";
            rtrue;
        }
        if ((R == call_U2015)) {
            print "check holder for standing rule";
            rtrue;
        }
        if ((R == call_U2018)) {
            print "convert standing to getting off rule";
            rtrue;
        }
        if ((R == call_U2019)) {
            print "new describe room emerged into rule";
            rtrue;
        }
        if ((R == call_U2020)) {
            print "new describe room stood up into rule";
            rtrue;
        }
        if ((R == call_U2044)) {
            print "opening doors before entering rule";
            rtrue;
        }
        if ((R == call_U2047)) {
            print "closing doors before locking rule";
            rtrue;
        }
        if ((R == call_U2050)) {
            print "closing doors before locking keylessly rule";
            rtrue;
        }
        if ((R == call_U2053)) {
            print "unlocking before opening rule";
            rtrue;
        }
        if ((R == call_U2056)) {
            print "intelligently opening doors rule";
            rtrue;
        }
        if ((R == call_U2057)) {
            print "intelligently closing doors rule";
            rtrue;
        }
        if ((R == call_U2058)) {
            print "intelligently closing keyless doors rule";
            rtrue;
        }
        if ((R == call_U2059)) {
            print "intelligently opening containers rule";
            rtrue;
        }
        if ((R == call_U2060)) {
            print "need a matching key rule";
            rtrue;
        }
        if ((R == call_U2061)) {
            print "standard printing key lack rule";
            rtrue;
        }
        if ((R == call_U2064)) {
            print "must be able to reach the key rule";
            rtrue;
        }
        if ((R == call_U2065)) {
            print "right second rule";
            rtrue;
        }
        if ((R == call_U2068)) {
            print "check keylessly unlocking rule";
            rtrue;
        }
        if ((R == call_U2069)) {
            print "standard keylessly unlocking rule";
            rtrue;
        }
        if ((R == call_U2072)) {
            print "Check locking it with";
            rtrue;
        }
        if ((R == call_U2073)) {
            print "check keylessly locking rule";
            rtrue;
        }
        if ((R == call_U2074)) {
            print "standard keylessly locking rule";
            rtrue;
        }
        if ((R == call_U2077)) {
            print "identify passkeys in inventory rule";
            rtrue;
        }
        if ((R == call_U2080)) {
            print "passkey description rule";
            rtrue;
        }
        if ((R == call_U2083)) {
            print "standard passkey unlocking rule";
            rtrue;
        }
        if ((R == call_U2084)) {
            print "observe someone unlocking rule";
            rtrue;
        }
        if ((R == call_U2085)) {
            print "standard passkey locking rule";
            rtrue;
        }
        if ((R == call_U2086)) {
            print "observe someone locking rule";
            rtrue;
        }
        if ((R == call_U2087)) {
            print "limiting keychains rule";
            rtrue;
        }
        if ((R == call_U2090)) {
            print "keychain-aware carrying requirements rule";
            rtrue;
        }
        if ((R == call_U2091)) {
            print "don't strip keys rule";
            rtrue;
        }
        if ((R == call_U2092)) {
            print "noun autotaking rule";
            rtrue;
        }
        if ((R == call_U2093)) {
            print "second noun autotaking rule";
            rtrue;
        }
        if ((R == call_U2094)) {
            print "must hold the noun rule";
            rtrue;
        }
        if ((R == call_U2095)) {
            print "must hold the second noun rule";
            rtrue;
        }
        if ((R == call_U2096)) {
            print "noun must be accessible rule";
            rtrue;
        }
        if ((R == call_U2099)) {
            print "second noun must be accessible rule";
            rtrue;
        }
        if ((R == call_U2102)) {
            print "lock debugging rule";
            rtrue;
        }
        if ((R == call_U2106)) {
            print "report universal unlocking rule";
            rtrue;
        }
        if ((R == call_U2115)) {
            print "quit rule";
            rtrue;
        }
        if ((R == call_U2116)) {
            print "move down rule";
            rtrue;
        }
        if ((R == call_U2117)) {
            print "move up rule";
            rtrue;
        }
        if ((R == call_U2118)) {
            print "select rule";
            rtrue;
        }
        if ((R == call_U2119)) {
            print "basic menu contents rule";
            rtrue;
        }
        if ((R == call_U2120)) {
            print "constructing status line while displaying rule";
            rtrue;
        }
        if ((R == call_U2121)) {
            print "hint toggle rule";
            rtrue;
        }
        if ((R == call_U2136)) {
            print "switch notification status rule";
            rtrue;
        }
        if ((R == call_U2137)) {
            print "switch description types rule";
            rtrue;
        }
        if ((R == call_U2138)) {
            print "help request rule";
            rtrue;
        }
        if ((R == call_U2157)) {
            print "standard pausing the game rule";
            rtrue;
        }
        if ((R == call_U2167)) {
            print "block singing rule";
            rtrue;
        }
        if ((R == call_U2516)) {
            print "Instead of examining the player";
            rtrue;
        }
        if ((R == call_U2517)) {
            print "before examining the coupon";
            rtrue;
        }
        if ((R == call_U2518)) {
            print "after reading a command";
            rtrue;
        }
        if ((R == call_U2519)) {
            print "after reading a command";
            rtrue;
        }
        if ((R == call_U2520)) {
            print "Rule for printing the player's obituary";
            rtrue;
        }
        if ((R == call_U2521)) {
            print "After printing the player's obituary";
            rtrue;
        }
        if ((R == call_U2522)) {
            print "After examining something for sale";
            rtrue;
        }
        if ((R == call_U2523)) {
            print "Instead of taking something for sale";
            rtrue;
        }
        if ((R == call_U2524)) {
            print "Before buying something for sale when the money is not in the wallet";
            rtrue;
        }
        if ((R == call_U2525)) {
            print "Before buying something for sale when the money is free";
            rtrue;
        }
        if ((R == call_U2526)) {
            print "Before buying something for sale when the price of the money is less than the price of the noun";
            rtrue;
        }
        if ((R == call_U2527)) {
            print "Before buying something free";
            rtrue;
        }
        if ((R == call_U2528)) {
            print "Instead of buying something";
            rtrue;
        }
        if ((R == call_U2529)) {
            print "Instead of taking the money";
            rtrue;
        }
        if ((R == call_U2530)) {
            print "Instead of buying something free when the player carries the noun";
            rtrue;
        }
        if ((R == call_U2531)) {
            print "Instead of buying the money";
            rtrue;
        }
        if ((R == call_U2532)) {
            print "Instead of examining a fluid container";
            rtrue;
        }
        if ((R == call_U2533)) {
            print "Before printing the name of a fluid container ( called the target ) while not drinking";
            rtrue;
        }
        if ((R == call_U2534)) {
            print "After printing the name of a fluid container ( called the target ) while not examining";
            rtrue;
        }
        if ((R == call_U2535)) {
            print "Instead of inserting something into a fluid container";
            rtrue;
        }
        if ((R == call_U2536)) {
            print "Instead of drinking a fluid container";
            rtrue;
        }
        if ((R == call_U2537)) {
            print "Check pouring it into";
            rtrue;
        }
        if ((R == call_U2538)) {
            print "Carry out pouring it into";
            rtrue;
        }
        if ((R == call_U2539)) {
            print "Report pouring it into";
            rtrue;
        }
        if ((R == call_U2540)) {
            print "Instead of looking under a thing which is underlaid by something";
            rtrue;
        }
        if ((R == call_U2544)) {
            print "Check hiding it under";
            rtrue;
        }
        if ((R == call_U2545)) {
            print "Carry out hiding it under";
            rtrue;
        }
        if ((R == call_U2546)) {
            print "Report hiding it under";
            rtrue;
        }
        if ((R == call_U2547)) {
            print "Rule for showing action of something ( called item )";
            rtrue;
        }
        if ((R == call_U2548)) {
            print "new described devices rule";
            rtrue;
        }
        if ((R == call_U2549)) {
            print "Report switching on an electric lamp";
            rtrue;
        }
        if ((R == call_U2550)) {
            print "Rule for showing action of an electric lamp ( called item )";
            rtrue;
        }
        if ((R == call_U2552)) {
            print "Carry out switching on an electric lamp";
            rtrue;
        }
        if ((R == call_U2553)) {
            print "Carry out switching off an electric lamp";
            rtrue;
        }
        if ((R == call_U2554)) {
            print "Rule for showing action of the noun";
            rtrue;
        }
        if ((R == call_U2555)) {
            print "Before printing the name of a lit electric lamp";
            rtrue;
        }
        if ((R == call_U2556)) {
            print "Before printing the name of an unlit lit electric lamp";
            rtrue;
        }
        if ((R == call_U2557)) {
            print "every turn";
            rtrue;
        }
        if ((R == call_U2558)) {
            print "Rule for printing the description of a dark room";
            rtrue;
        }
        if ((R == call_U2559)) {
            print "Rule for printing a refusal to act in the dark";
            rtrue;
        }
        if ((R == call_U2560)) {
            print "every turn when in darkness";
            rtrue;
        }
        if ((R == call_U2561)) {
            print "every turn when not in darkness";
            rtrue;
        }
        if ((R == call_U2562)) {
            print "Check hi-speaking";
            rtrue;
        }
        if ((R == call_U2563)) {
            print "Carry out hi-speaking";
            rtrue;
        }
        if ((R == call_U2564)) {
            print "Check hi-speaking the sailor for the tenth time";
            rtrue;
        }
        if ((R == call_U2565)) {
            print "Check hi-speaking the sailor for the 20th time";
            rtrue;
        }
        if ((R == call_U2566)) {
            print "Carry out casting xyzzy";
            rtrue;
        }
        if ((R == call_U2567)) {
            print "Carry out casting plugh";
            rtrue;
        }
        if ((R == call_U2568)) {
            print "instead of talking randomly about";
            rtrue;
        }
        if ((R == call_U2569)) {
            print "instead of talking about something";
            rtrue;
        }
        if ((R == call_U2570)) {
            print "instead of asking an attendant about @@126@{68}ell@@126";
            rtrue;
        }
        if ((R == call_U2571)) {
            print "instead of asking an attendant about @@126@{68}ell ride@@126";
            rtrue;
        }
        if ((R == call_U2572)) {
            print "Instead of asking an attendant about something";
            rtrue;
        }
        if ((R == call_U2573)) {
            print "Instead of showing an something to an attendant";
            rtrue;
        }
        if ((R == call_U2574)) {
            print "instead of telling an attendant about @@126@{68}ell@@126";
            rtrue;
        }
        if ((R == call_U2575)) {
            print "instead of telling an attendant about @@126@{68}ell ride@@126";
            rtrue;
        }
        if ((R == call_U2576)) {
            print "Instead of telling an attendant about something";
            rtrue;
        }
        if ((R == call_U2577)) {
            print "Persuasion rule for asking an attendant to try going";
            rtrue;
        }
        if ((R == call_U2578)) {
            print "instead of examining an attendant";
            rtrue;
        }
        if ((R == call_U2579)) {
            print "instead of smelling an attendant";
            rtrue;
        }
        if ((R == call_U2580)) {
            print "instead of listening to an attendant";
            rtrue;
        }
        if ((R == call_U2581)) {
            print "instead of touching an attendant";
            rtrue;
        }
        if ((R == call_U2582)) {
            print "award points rule";
            rtrue;
        }
        if ((R == call_U2583)) {
            print "Check requesting the complete score";
            rtrue;
        }
        if ((R == call_U2584)) {
            print "Carry out requesting the complete score";
            rtrue;
        }
        if ((R == call_U2585)) {
            print "check requesting the score";
            rtrue;
        }
        if ((R == call_U2586)) {
            print "block swearing mildly rule";
            rtrue;
        }
        if ((R == call_U2587)) {
            print "instead of fucking something";
            rtrue;
        }
        if ((R == call_U2588)) {
            print "block swearing obscenely rule";
            rtrue;
        }
        if ((R == call_U2589)) {
            print "carry out examining hell ride";
            rtrue;
        }
        if ((R == call_U2590)) {
            print "instead of kissing";
            rtrue;
        }
        if ((R == call_U2591)) {
            print "instead of touching a person";
            rtrue;
        }
        if ((R == call_U2592)) {
            print "instead of touching a thing";
            rtrue;
        }
        if ((R == call_U2593)) {
            print "instead of smelling";
            rtrue;
        }
        if ((R == call_U2594)) {
            print "instead of listening";
            rtrue;
        }
        if ((R == call_U2595)) {
            print "instead of tasting someone";
            rtrue;
        }
        if ((R == call_U2596)) {
            print "instead of tasting something";
            rtrue;
        }
        if ((R == call_U2597)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2598)) {
            print "report unlocking an electrical panel rule";
            rtrue;
        }
        if ((R == call_U2599)) {
            print "Check inserting something into a socket when the holder of the second noun is not open";
            rtrue;
        }
        if ((R == call_U2600)) {
            print "can only insert fuses into sockets rule";
            rtrue;
        }
        if ((R == call_U2601)) {
            print "matching fuse snick rule";
            rtrue;
        }
        if ((R == call_U2602)) {
            print "set object taken from rule";
            rtrue;
        }
        if ((R == call_U2603)) {
            print "check switch after removing fuses rule";
            rtrue;
        }
        if ((R == call_U2604)) {
            print "redirect push to switch on rule";
            rtrue;
        }
        if ((R == call_U2605)) {
            print "redirect push to switch off rule";
            rtrue;
        }
        if ((R == call_U2606)) {
            print "check switching on a switched off switch when the holder of the noun is not open";
            rtrue;
        }
        if ((R == call_U2607)) {
            print "nothing happens unless socket is properly fused rule";
            rtrue;
        }
        if ((R == call_U2608)) {
            print "final report switching on a switch rule";
            rtrue;
        }
        if ((R == call_U2609)) {
            print "final report switching off a switch rule";
            rtrue;
        }
        if ((R == call_U2610)) {
            print "Instead of going from the Electrical Room";
            rtrue;
        }
        if ((R == call_U2612)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2613)) {
            print "after looking when the location is the parking lot";
            rtrue;
        }
        if ((R == call_U2614)) {
            print "instead of looking when the player is in the beater car";
            rtrue;
        }
        if ((R == call_U2615)) {
            print "after eating the blueberries";
            rtrue;
        }
        if ((R == call_U2616)) {
            print "check giving the coupon to the parking attendant";
            rtrue;
        }
        if ((R == call_U2617)) {
            print "instead of buying the parking ticket when the player is not in the car";
            rtrue;
        }
        if ((R == call_U2618)) {
            print "instead of buying something when the player is in the beater car";
            rtrue;
        }
        if ((R == call_U2619)) {
            print "instead of showing the parking stub to the parking attendant";
            rtrue;
        }
        if ((R == call_U2620)) {
            print "instead of asking the parking attendant about @@126@{5b}stub]@@126";
            rtrue;
        }
        if ((R == call_U2621)) {
            print "instead of telling the parking attendant about the @@126@{5b}stub]@@126";
            rtrue;
        }
        if ((R == call_U2622)) {
            print "instead of going south when the location is the parking lot and the player does not carry the parking ticket";
            rtrue;
        }
        if ((R == call_U2623)) {
            print "every turn when the location is the parking lot";
            rtrue;
        }
        if ((R == call_U2625)) {
            print "every turn when the player is in the beater car";
            rtrue;
        }
        if ((R == call_U2626)) {
            print "instead of turning your keys when the player is in the beater car";
            rtrue;
        }
        if ((R == call_U2627)) {
            print "After going south from the parking lot when the Ticket Booth is unvisited and the player carries the parking ticket";
            rtrue;
        }
        if ((R == call_U2628)) {
            print "Before looking when the location is the Ticket Booth";
            rtrue;
        }
        if ((R == call_U2629)) {
            print "instead of reading or examining the signboard";
            rtrue;
        }
        if ((R == call_U2630)) {
            print "Before going southwest when the location is the Ticket Booth and the Concession Stand is unvisited";
            rtrue;
        }
        if ((R == call_U2631)) {
            print "Before looking when the location is the Concession Stand";
            rtrue;
        }
        if ((R == call_U2632)) {
            print "Instead of player drinking a fluid container";
            rtrue;
        }
        if ((R == call_U2633)) {
            print "instead of reading or examining the menu";
            rtrue;
        }
        if ((R == call_U2634)) {
            print "Before going east when the location is the Ticket Booth and the High Striker is unvisited";
            rtrue;
        }
        if ((R == call_U2635)) {
            print "Before looking when the location is the High Striker";
            rtrue;
        }
        if ((R == call_U2636)) {
            print "after looking when the location is the high striker";
            rtrue;
        }
        if ((R == call_U2637)) {
            print "after examining the strongman attendant";
            rtrue;
        }
        if ((R == call_U2638)) {
            print "after looking when the HighStrikerWin is true and the location is the High Striker";
            rtrue;
        }
        if ((R == call_U2639)) {
            print "instead of taking when the noun is part of the Swiss army knife";
            rtrue;
        }
        if ((R == call_U2640)) {
            print "Check hitting";
            rtrue;
        }
        if ((R == call_U2641)) {
            print "Carry out hitting when the player is carrying the mallet";
            rtrue;
        }
        if ((R == call_U2642)) {
            print "After hitting the lever when second noun is the mallet 5 times";
            rtrue;
        }
        if ((R == call_U2643)) {
            print "after reading a command when the location is the high striker and HighStrikerWin is true";
            rtrue;
        }
        if ((R == call_U2644)) {
            print "Before going northeast when the location is the High Striker and the Dime Toss Game is unvisited";
            rtrue;
        }
        if ((R == call_U2645)) {
            print "Before looking when the location is the Dime Toss Game";
            rtrue;
        }
        if ((R == call_U2646)) {
            print "before examining the mercury dime";
            rtrue;
        }
        if ((R == call_U2647)) {
            print "check tossing a dime when the location is the Dime Toss Game";
            rtrue;
        }
        if ((R == call_U2649)) {
            print "instead of tossing a dime when the second noun is the plate and the player carries the noun";
            rtrue;
        }
        if ((R == call_U2650)) {
            print "after reading a command when the location is the Dime Toss Game and TossADimeWin is true";
            rtrue;
        }
        if ((R == call_U2651)) {
            print "after examining the Dime Toss attendant";
            rtrue;
        }
        if ((R == call_U2652)) {
            print "after looking when the TossADimeWin is true and the location is the Dime Toss Game";
            rtrue;
        }
        if ((R == call_U2653)) {
            print "Before going southeast when the location is the High Striker and the Pitcher's Mound is unvisited";
            rtrue;
        }
        if ((R == call_U2654)) {
            print "Before looking when the location is the Pitcher's Mound";
            rtrue;
        }
        if ((R == call_U2655)) {
            print "instead of giving a dime to the pitcher's mound attendant";
            rtrue;
        }
        if ((R == call_U2657)) {
            print "instead of throwing a baseball at the milk bottles";
            rtrue;
        }
        if ((R == call_U2659)) {
            print "instead of throwing a baseball at the milk bottles when the player carries the noun";
            rtrue;
        }
        if ((R == call_U2660)) {
            print "after reading a command when the location is the Pitcher's Mound and PitchersMoundWin is true";
            rtrue;
        }
        if ((R == call_U2661)) {
            print "after examining the pitcher's mound attendant";
            rtrue;
        }
        if ((R == call_U2662)) {
            print "after looking when the PitchersMoundWin is true and the location is the Pitcher's Mound";
            rtrue;
        }
        if ((R == call_U2663)) {
            print "Before looking when the location is the Show Facade";
            rtrue;
        }
        if ((R == call_U2664)) {
            print "report going west when the location is the Show Facade and the location is unvisited";
            rtrue;
        }
        if ((R == call_U2665)) {
            print "after examining the barker";
            rtrue;
        }
        if ((R == call_U2666)) {
            print "Check going west when the location is the Show Facade and the barker is not carrying a dime";
            rtrue;
        }
        if ((R == call_U2668)) {
            print "After giving when the noun is dime and the second noun is barker";
            rtrue;
        }
        if ((R == call_U2669)) {
            print "Before going west when the location is the Show Facade and the Show Tent is unvisited and barker is carrying a dime";
            rtrue;
        }
        if ((R == call_U2671)) {
            print "Before looking when the location is the the Show Tent";
            rtrue;
        }
        if ((R == call_U2672)) {
            print "after wearing the veil";
            rtrue;
        }
        if ((R == call_U2673)) {
            print "after taking the lantern for the first time";
            rtrue;
        }
        if ((R == call_U2674)) {
            print "When Little Egypt AutoPlay ends";
            rtrue;
        }
        if ((R == call_U2675)) {
            print "every turn during Little Egypt AutoPlay";
            rtrue;
        }
        if ((R == call_U2676)) {
            print "Instead of doing something other than waiting , looking , listening or examining during Little Egypt AutoPlay";
            rtrue;
        }
        if ((R == call_U2677)) {
            print "After going east from the high striker when the Ferris wheel ride is unvisited";
            rtrue;
        }
        if ((R == call_U2678)) {
            print "Before looking when the location is the Ferris Wheel Ride";
            rtrue;
        }
        if ((R == call_U2679)) {
            print "instead of giving the Ferris wheel ticket to the Ferris wheel attendant";
            rtrue;
        }
        if ((R == call_U2680)) {
            print "After going northwest from the ticket Booth when the bumper cars ride is unvisited";
            rtrue;
        }
        if ((R == call_U2681)) {
            print "Before looking when the location is the Bumper Cars Ride";
            rtrue;
        }
        if ((R == call_U2682)) {
            print "instead of giving the bumper cars ticket to the bumper cars attendant";
            rtrue;
        }
        if ((R == call_U2683)) {
            print "instead of taking the two dollar bill";
            rtrue;
        }
        if ((R == call_U2684)) {
            print "instead of giving the adjustable wrench to the bumper cars attendant";
            rtrue;
        }
        if ((R == call_U2685)) {
            print "After going southeast from the ticket Booth when the fortune teller booth is unvisited";
            rtrue;
        }
        if ((R == call_U2686)) {
            print "Before looking when the location is the Fortune Teller Booth";
            rtrue;
        }
        if ((R == call_U2687)) {
            print "instead of giving the fortune teller ticket to the Mysterious Woman";
            rtrue;
        }
        if ((R == call_U2688)) {
            print "After going northeast from the ticket Booth when the carousel ride is unvisited";
            rtrue;
        }
        if ((R == call_U2689)) {
            print "Before looking when the location is the Carousel Ride";
            rtrue;
        }
        if ((R == call_U2690)) {
            print "instead of giving the carousel ticket to the carousel attendant";
            rtrue;
        }
        if ((R == call_U2691)) {
            print "Check going south when the location is Head of the Line and the Hell Ride attendant does not have the hell ride ticket";
            rtrue;
        }
        if ((R == call_U2692)) {
            print "instead of looking under when the noun is the pile of junk";
            rtrue;
        }
        if ((R == call_U2693)) {
            print "after examining when the noun is pile of junk and the flashlight is in the pile of junk";
            rtrue;
        }
        if ((R == call_U2694)) {
            print "after taking the flashlight for the first time";
            rtrue;
        }
        if ((R == call_U2695)) {
            print "After going south from the dark passage when the Maintenance Office is unvisited and the the player carries a lit electric lamp";
            rtrue;
        }
        if ((R == call_U2697)) {
            print "Before looking when the location is the Maintenance Office and the the player carries a lit electric lamp";
            rtrue;
        }
        if ((R == call_U2699)) {
            print "Instead of drinking the coffee mug";
            rtrue;
        }
        if ((R == call_U2700)) {
            print "every turn when the radio is switched on and the location is near the maintenance office";
            rtrue;
        }
        if ((R == call_U2701)) {
            print "Rule for showing action of the radio";
            rtrue;
        }
        if ((R == call_U2702)) {
            print "Instead of listening in the presence of the switched on radio";
            rtrue;
        }
        if ((R == call_U2703)) {
            print "Instead of climbing a ladder";
            rtrue;
        }
        if ((R == call_U2704)) {
            print "instead of examining the graffiti";
            rtrue;
        }
        if ((R == call_U2705)) {
            print "When Hell Ride AutoPlay ends";
            rtrue;
        }
        if ((R == call_U2706)) {
            print "Instead of doing something other than waiting , looking , listening or examining during Hell Ride AutoPlay";
            rtrue;
        }
        if ((R == call_U2707)) {
            print "every turn during Hell Ride AutoPlay";
            rtrue;
        }
        if ((R == call_U2708)) {
            print "After going south from the Head of Line when the Ride Entrance is unvisited";
            rtrue;
        }
        if ((R == call_U2709)) {
            print "Before looking when the location is the Ride Entrance";
            rtrue;
        }
        if ((R == call_U2710)) {
            print "Before going south when the player is in the Ride Entrance";
            rtrue;
        }
        if ((R == call_U2711)) {
            print "After going south from the Ride Entrance when the Stocks Room is unvisited";
            rtrue;
        }
        if ((R == call_U2712)) {
            print "Before looking when the location is the Stocks Room";
            rtrue;
        }
        if ((R == call_U2713)) {
            print "After going south from the Stocks Room when the Gallows Room is unvisited";
            rtrue;
        }
        if ((R == call_U2714)) {
            print "Before looking when the location is the Gallows Room";
            rtrue;
        }
        if ((R == call_U2715)) {
            print "After going south from the Gallows Room when the Stake Room is unvisited";
            rtrue;
        }
        if ((R == call_U2716)) {
            print "Before looking when the location is the Stake Room";
            rtrue;
        }
        if ((R == call_U2717)) {
            print "After printing the name of the pyre";
            rtrue;
        }
        if ((R == call_U2718)) {
            print "After printing the name of a closed unopenable container";
            rtrue;
        }
        if ((R == call_U2719)) {
            print "After going south from the Stake Room when the Dungeon is unvisited";
            rtrue;
        }
        if ((R == call_U2720)) {
            print "Before looking when the location is the Dungeon";
            rtrue;
        }
        if ((R == call_U2721)) {
            print "After going south from the Dungeon when the Guillotine Room is unvisited";
            rtrue;
        }
        if ((R == call_U2722)) {
            print "Before looking when the location is the Guillotine Room";
            rtrue;
        }
        if ((R == call_U2723)) {
            print "After going south from the Guillotine Room when the Ride Exit is unvisited";
            rtrue;
        }
        if ((R == call_U2724)) {
            print "Before looking when the location is the Ride Exit";
            rtrue;
        }
        if ((R == call_U2725)) {
            print "every turn when the location is the holding room";
            rtrue;
        }
        if ((R == call_U2726)) {
            print "instead of switching off the big switch";
            rtrue;
        }
        if ((R == call_U2727)) {
            print "Instead of pushing or flipping or toggling a switched off big switch";
            rtrue;
        }
        if ((R == call_U2728)) {
            print "Instead of pushing or flipping or toggling a switched on big switch";
            rtrue;
        }
        if ((R == call_U2729)) {
            print "every turn when the location is the Control Room";
            rtrue;
        }
        if ((R == call_U2732)) {
            print "instead of examining a control panel";
            rtrue;
        }
        if ((R == call_U2734)) {
            print "redirect push to button on rule";
            rtrue;
        }
        if ((R == call_U2735)) {
            print "redirect push to button off rule";
            rtrue;
        }
        if ((R == call_U2736)) {
            print "final report switching on a button rule";
            rtrue;
        }
        if ((R == call_U2738)) {
            print "final report switching off a button rule";
            rtrue;
        }
        if ((R == call_U2740)) {
            print "Does the player mean spinning a dial to a number";
            rtrue;
        }
        if ((R == call_U2741)) {
            print "Does the player mean spinning a control panel to a number";
            rtrue;
        }
        if ((R == call_U2742)) {
            print "Check spinning it to";
            rtrue;
        }
        if ((R == call_U2743)) {
            print "Report spinning it to";
            rtrue;
        }
        if ((R == call_U2744)) {
            print "instead of examining the monitor";
            rtrue;
        }
        if ((R == call_U2745)) {
            print "When play begins";
            rtrue;
        }
        if ((R == call_U2747)) {
            print "report crediting";
            rtrue;
        }
        if ((R == call_U2748)) {
            print "Check asking for help for the first time";
            rtrue;
        }
        if ((R == call_U2749)) {
            print "Check asking for help";
            rtrue;
        }
        print "(nameless rule at address ";
        print R;
        print ")";
    }
];
[ PrintResponse R;
    if ((R == 1)) {
        RulePrintingRule(ADJUST_LIGHT_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 2)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 3)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 4)) {
        RulePrintingRule(BASIC_ACCESSIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 5)) {
        RulePrintingRule(BASIC_VISIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 6)) {
        RulePrintingRule(REQUESTED_ACTIONS_REQUIRE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 7)) {
        RulePrintingRule(CARRY_OUT_REQUESTED_ACTIONS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 8)) {
        RulePrintingRule(ACCESS_THROUGH_BARRIERS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 9)) {
        RulePrintingRule(CANT_REACH_INSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 10)) {
        RulePrintingRule(CANT_REACH_INSIDE_ROOMS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 11)) {
        RulePrintingRule(CANT_REACH_OUTSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 12)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 13)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 14)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 15)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 16)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 17)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 18)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 19)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 20)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 21)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 22)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 23)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 24)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 25)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 26)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 27)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 28)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 29)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 30)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 31)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 32)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 33)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 34)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 35)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 36)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 89;
        print ")";
    }
    if ((R == 37)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 38)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 39)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 40)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 41)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 42)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 43)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 44)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 45)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 46)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 47)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 48)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 49)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 50)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 51)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 52)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 53)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 54)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 55)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 56)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 57)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 58)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 59)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 60)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 61)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 62)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 63)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 64)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 65)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 66)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 67)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 68)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 69)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 70)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 71)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 72)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 73)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 74)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 75)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 76)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 77)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 78)) {
        RulePrintingRule(DARKNESS_NAME_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 79)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 80)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 81)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 82)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 83)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 84)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 85)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 86)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 87)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 88)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 89)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 90)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 91)) {
        RulePrintingRule(YES_OR_NO_QUESTION_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 92)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 93)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 94)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 95)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 96)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 97)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 98)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 99)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 100)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 101)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 102)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 103)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 104)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 105)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 106)) {
        RulePrintingRule(QUIT_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 107)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 108)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 109)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 110)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 111)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 112)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 113)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 114)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 115)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 116)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 117)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 118)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 119)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 120)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 121)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 122)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 123)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 124)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 125)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 126)) {
        RulePrintingRule(REP_PREFER_ABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 127)) {
        RulePrintingRule(REP_PREFER_UNABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 128)) {
        RulePrintingRule(REP_PREFER_SOMETIMES_ABBR_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 129)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 130)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 131)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 132)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 133)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 134)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 135)) {
        RulePrintingRule(call_U1082);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 136)) {
        RulePrintingRule(call_U1112);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 137)) {
        RulePrintingRule(call_U1115);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 138)) {
        RulePrintingRule(call_U1118);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 139)) {
        RulePrintingRule(call_U1118);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 140)) {
        RulePrintingRule(call_U1123);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 141)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 142)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 143)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 144)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 145)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 146)) {
        RulePrintingRule(call_U1129);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 147)) {
        RulePrintingRule(call_U1153);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 148)) {
        RulePrintingRule(call_U1160);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 149)) {
        RulePrintingRule(call_U1165);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 150)) {
        RulePrintingRule(call_U1170);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 151)) {
        RulePrintingRule(call_U1173);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 152)) {
        RulePrintingRule(call_U1176);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 153)) {
        RulePrintingRule(call_U1179);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 154)) {
        RulePrintingRule(call_U1182);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 155)) {
        RulePrintingRule(call_U1185);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 156)) {
        RulePrintingRule(call_U1188);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 157)) {
        RulePrintingRule(call_U1191);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 158)) {
        RulePrintingRule(call_U1194);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 159)) {
        RulePrintingRule(call_U1197);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 160)) {
        RulePrintingRule(call_U1200);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 161)) {
        RulePrintingRule(call_U1203);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 162)) {
        RulePrintingRule(call_U1206);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 163)) {
        RulePrintingRule(call_U1209);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 164)) {
        RulePrintingRule(call_U1215);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 165)) {
        RulePrintingRule(call_U1220);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 166)) {
        RulePrintingRule(call_U1220);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 167)) {
        RulePrintingRule(call_U1225);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 168)) {
        RulePrintingRule(call_U1228);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 169)) {
        RulePrintingRule(call_U1232);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 170)) {
        RulePrintingRule(call_U1235);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 171)) {
        RulePrintingRule(call_U1238);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 172)) {
        RulePrintingRule(call_U1241);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 173)) {
        RulePrintingRule(call_U1244);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 174)) {
        RulePrintingRule(call_U1247);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 175)) {
        RulePrintingRule(call_U1247);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 176)) {
        RulePrintingRule(call_U1255);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 177)) {
        RulePrintingRule(call_U1255);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 178)) {
        RulePrintingRule(call_U1262);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 179)) {
        RulePrintingRule(call_U1265);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 180)) {
        RulePrintingRule(call_U1268);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 181)) {
        RulePrintingRule(call_U1271);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 182)) {
        RulePrintingRule(call_U1276);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 183)) {
        RulePrintingRule(call_U1279);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 184)) {
        RulePrintingRule(call_U1283);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 185)) {
        RulePrintingRule(call_U1286);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 186)) {
        RulePrintingRule(call_U1290);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 187)) {
        RulePrintingRule(call_U1293);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 188)) {
        RulePrintingRule(call_U1296);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 189)) {
        RulePrintingRule(call_U1299);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 190)) {
        RulePrintingRule(call_U1304);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 191)) {
        RulePrintingRule(call_U1307);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 192)) {
        RulePrintingRule(call_U1310);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 193)) {
        RulePrintingRule(call_U1313);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 194)) {
        RulePrintingRule(call_U1316);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 195)) {
        RulePrintingRule(call_U1322);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 196)) {
        RulePrintingRule(call_U1322);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 197)) {
        RulePrintingRule(call_U1328);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 198)) {
        RulePrintingRule(call_U1331);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 199)) {
        RulePrintingRule(call_U1331);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 200)) {
        RulePrintingRule(call_U1336);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 201)) {
        RulePrintingRule(call_U1339);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 202)) {
        RulePrintingRule(call_U1343);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 203)) {
        RulePrintingRule(call_U1343);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 204)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 205)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 206)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 207)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 208)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 209)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 210)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 211)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 212)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 213)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 214)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 215)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 216)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 217)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 218)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 219)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 220)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 221)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 222)) {
        RulePrintingRule(call_U1351);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 223)) {
        RulePrintingRule(call_U1394);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 224)) {
        RulePrintingRule(call_U1394);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 225)) {
        RulePrintingRule(call_U1399);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 226)) {
        RulePrintingRule(call_U1399);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 227)) {
        RulePrintingRule(call_U1399);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 228)) {
        RulePrintingRule(call_U1399);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 229)) {
        RulePrintingRule(call_U1408);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 230)) {
        RulePrintingRule(call_U1411);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 231)) {
        RulePrintingRule(call_U1411);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 232)) {
        RulePrintingRule(call_U1418);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 233)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 234)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 235)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 236)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 237)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 238)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 239)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 240)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 241)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 242)) {
        RulePrintingRule(call_U1445);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 243)) {
        RulePrintingRule(call_U1448);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 244)) {
        RulePrintingRule(call_U1453);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 245)) {
        RulePrintingRule(call_U1453);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 246)) {
        RulePrintingRule(call_U1453);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 247)) {
        RulePrintingRule(call_U1461);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 248)) {
        RulePrintingRule(call_U1465);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 249)) {
        RulePrintingRule(call_U1472);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 250)) {
        RulePrintingRule(call_U1472);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 251)) {
        RulePrintingRule(call_U1472);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 252)) {
        RulePrintingRule(call_U1479);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 253)) {
        RulePrintingRule(call_U1484);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 254)) {
        RulePrintingRule(call_U1488);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 255)) {
        RulePrintingRule(call_U1491);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 256)) {
        RulePrintingRule(call_U1491);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 257)) {
        RulePrintingRule(call_U1498);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 258)) {
        RulePrintingRule(call_U1503);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 259)) {
        RulePrintingRule(call_U1506);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 260)) {
        RulePrintingRule(call_U1509);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 261)) {
        RulePrintingRule(call_U1512);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 262)) {
        RulePrintingRule(call_U1515);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 263)) {
        RulePrintingRule(call_U1518);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 264)) {
        RulePrintingRule(call_U1521);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 265)) {
        RulePrintingRule(call_U1524);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 266)) {
        RulePrintingRule(call_U1524);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 267)) {
        RulePrintingRule(call_U1530);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 268)) {
        RulePrintingRule(call_U1530);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 269)) {
        RulePrintingRule(call_U1536);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 270)) {
        RulePrintingRule(call_U1539);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 271)) {
        RulePrintingRule(call_U1539);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 272)) {
        RulePrintingRule(call_U1544);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 273)) {
        RulePrintingRule(call_U1547);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 274)) {
        RulePrintingRule(call_U1550);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 275)) {
        RulePrintingRule(call_U1553);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 276)) {
        RulePrintingRule(call_U1557);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 277)) {
        RulePrintingRule(call_U1557);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 278)) {
        RulePrintingRule(call_U1562);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 279)) {
        RulePrintingRule(call_U1565);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 280)) {
        RulePrintingRule(call_U1568);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 281)) {
        RulePrintingRule(call_U1572);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 282)) {
        RulePrintingRule(call_U1572);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 283)) {
        RulePrintingRule(call_U1577);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 284)) {
        RulePrintingRule(call_U1580);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 285)) {
        RulePrintingRule(call_U1584);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 286)) {
        RulePrintingRule(call_U1587);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 287)) {
        RulePrintingRule(call_U1590);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 288)) {
        RulePrintingRule(call_U1594);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 289)) {
        RulePrintingRule(call_U1597);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 290)) {
        RulePrintingRule(call_U1600);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 291)) {
        RulePrintingRule(call_U1603);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 292)) {
        RulePrintingRule(call_U1607);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 293)) {
        RulePrintingRule(call_U1610);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 294)) {
        RulePrintingRule(call_U1610);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 295)) {
        RulePrintingRule(call_U1610);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 296)) {
        RulePrintingRule(call_U1617);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 297)) {
        RulePrintingRule(call_U1620);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 298)) {
        RulePrintingRule(call_U1624);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 299)) {
        RulePrintingRule(call_U1624);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 300)) {
        RulePrintingRule(call_U1624);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 301)) {
        RulePrintingRule(call_U1631);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 302)) {
        RulePrintingRule(call_U1634);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 303)) {
        RulePrintingRule(call_U1637);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 304)) {
        RulePrintingRule(call_U1641);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 305)) {
        RulePrintingRule(call_U1641);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 306)) {
        RulePrintingRule(call_U1647);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 307)) {
        RulePrintingRule(call_U1650);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 308)) {
        RulePrintingRule(call_U1655);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 309)) {
        RulePrintingRule(call_U1655);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 310)) {
        RulePrintingRule(call_U1660);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 311)) {
        RulePrintingRule(call_U1663);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 312)) {
        RulePrintingRule(call_U1666);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 313)) {
        RulePrintingRule(call_U1669);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 314)) {
        RulePrintingRule(call_U1672);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 315)) {
        RulePrintingRule(call_U1675);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 316)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 317)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 318)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 319)) {
        RulePrintingRule(call_U1687);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 320)) {
        RulePrintingRule(call_U1691);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 321)) {
        RulePrintingRule(call_U1694);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 322)) {
        RulePrintingRule(call_U1697);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 323)) {
        RulePrintingRule(call_U1700);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 324)) {
        RulePrintingRule(call_U1703);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 325)) {
        RulePrintingRule(call_U1706);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 326)) {
        RulePrintingRule(call_U1709);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 327)) {
        RulePrintingRule(call_U1712);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 328)) {
        RulePrintingRule(call_U1715);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 329)) {
        RulePrintingRule(call_U1718);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 330)) {
        RulePrintingRule(call_U1721);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 331)) {
        RulePrintingRule(call_U1724);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 332)) {
        RulePrintingRule(call_U1729);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 333)) {
        RulePrintingRule(call_U1729);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 334)) {
        RulePrintingRule(call_U1734);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 335)) {
        RulePrintingRule(call_U1734);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 336)) {
        RulePrintingRule(call_U1739);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 337)) {
        RulePrintingRule(call_U1739);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 338)) {
        RulePrintingRule(call_U1739);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 339)) {
        RulePrintingRule(call_U1746);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 340)) {
        RulePrintingRule(call_U1746);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 341)) {
        RulePrintingRule(call_U1751);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 342)) {
        RulePrintingRule(call_U1754);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 343)) {
        RulePrintingRule(call_U1754);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 344)) {
        RulePrintingRule(call_U1759);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 345)) {
        RulePrintingRule(call_U1762);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 346)) {
        RulePrintingRule(call_U1765);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 347)) {
        RulePrintingRule(call_U1768);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 348)) {
        RulePrintingRule(call_U1768);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 349)) {
        RulePrintingRule(call_U1773);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 350)) {
        RulePrintingRule(call_U1776);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 351)) {
        RulePrintingRule(call_U1779);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 352)) {
        RulePrintingRule(call_U1782);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 353)) {
        RulePrintingRule(call_U1782);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 354)) {
        RulePrintingRule(call_U1787);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 355)) {
        RulePrintingRule(call_U1790);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 356)) {
        RulePrintingRule(call_U1793);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 357)) {
        RulePrintingRule(call_U1796);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 358)) {
        RulePrintingRule(call_U1796);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 359)) {
        RulePrintingRule(call_U1801);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 360)) {
        RulePrintingRule(call_U1804);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 361)) {
        RulePrintingRule(call_U1807);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 362)) {
        RulePrintingRule(call_U1810);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 363)) {
        RulePrintingRule(call_U1814);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 364)) {
        RulePrintingRule(call_U1817);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 365)) {
        RulePrintingRule(call_U1820);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 366)) {
        RulePrintingRule(call_U1820);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 367)) {
        RulePrintingRule(call_U1825);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 368)) {
        RulePrintingRule(call_U1828);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 369)) {
        RulePrintingRule(call_U1831);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 370)) {
        RulePrintingRule(call_U1834);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 371)) {
        RulePrintingRule(call_U1837);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 372)) {
        RulePrintingRule(call_U1840);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 373)) {
        RulePrintingRule(call_U1840);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 374)) {
        RulePrintingRule(call_U1845);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 375)) {
        RulePrintingRule(call_U1845);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 376)) {
        RulePrintingRule(call_U1850);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 377)) {
        RulePrintingRule(call_U1850);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 378)) {
        RulePrintingRule(call_U1855);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 379)) {
        RulePrintingRule(call_U1858);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 380)) {
        RulePrintingRule(call_U1858);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 381)) {
        RulePrintingRule(call_U1863);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 382)) {
        RulePrintingRule(call_U1866);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 383)) {
        RulePrintingRule(call_U1869);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 384)) {
        RulePrintingRule(call_U1872);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 385)) {
        RulePrintingRule(call_U1875);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 386)) {
        RulePrintingRule(call_U1878);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 387)) {
        RulePrintingRule(call_U1878);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 388)) {
        RulePrintingRule(call_U1883);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 389)) {
        RulePrintingRule(call_U1886);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 390)) {
        RulePrintingRule(call_U1886);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 391)) {
        RulePrintingRule(call_U1891);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 392)) {
        RulePrintingRule(call_U1894);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 393)) {
        RulePrintingRule(call_U1897);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 394)) {
        RulePrintingRule(call_U2011);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 395)) {
        RulePrintingRule(call_U2015);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 396)) {
        RulePrintingRule(call_U2044);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 397)) {
        RulePrintingRule(call_U2047);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 398)) {
        RulePrintingRule(call_U2050);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 399)) {
        RulePrintingRule(call_U2053);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 400)) {
        RulePrintingRule(call_U2061);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 401)) {
        RulePrintingRule(call_U2065);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 402)) {
        RulePrintingRule(call_U2069);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 403)) {
        RulePrintingRule(call_U2074);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 404)) {
        RulePrintingRule(call_U2077);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 405)) {
        RulePrintingRule(call_U2080);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 406)) {
        RulePrintingRule(call_U2087);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 407)) {
        RulePrintingRule(call_U2096);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 408)) {
        RulePrintingRule(call_U2099);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 409)) {
        RulePrintingRule(call_U2102);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 410)) {
        RulePrintingRule(call_U2106);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 411)) {
        RulePrintingRule(call_U2157);
        print " response (";
        print (char) 65;
        print ")";
    }
];
[ ShowSceneStatus;
    call_U433();
    call_U2311();
    call_U2351();
];
[ DetectSceneChange chs;
    .Again;
    if (call_U432()) {
        jump CScene;
    }
    if (call_U2310()) {
        jump CScene;
    }
    if (call_U2350()) {
        jump CScene;
    }
    rfalse;
    .CScene;
    if ((chs > 20)) {
        print ">--> The scene change machinery is stuck.^";
        rtrue;
    }
    ++(chs);
    jump Again;
];
[ PrintTableName T;
    switch (T) {
        TheEmptyTable:
            print "(the empty table)";
            rtrue;
            ;
        table_data_U1:
            print "Table of Final Question Options";
            rtrue;
            ;
        table_data_U2:
            print "Table of Locale Priorities";
            rtrue;
            ;
        table_data_U3:
            print "Table of Sample Options";
            rtrue;
            ;
        table_data_U4:
            print "Table of Menu Commands";
            rtrue;
            ;
        table_data_U5:
            print "Table of Shallow Menu Status";
            rtrue;
            ;
        table_data_U6:
            print "Table of Deep Menu Status";
            rtrue;
            ;
        table_data_U7:
            print "Table of Sample Hints";
            rtrue;
            ;
        table_data_U8:
            print "Table of Basic Help Options";
            rtrue;
            ;
        table_data_U9:
            print "Table of Instruction Options";
            rtrue;
            ;
        table_data_U10:
            print "Table of Setting Options";
            rtrue;
            ;
        table_data_U11:
            print "Table of IF Elements";
            rtrue;
            ;
        table_data_U12:
            print "Table of Stuckness Advice";
            rtrue;
            ;
        table_data_U13:
            print "Table of Ordinary Status";
            rtrue;
            ;
        table_data_U14:
            print "Table of High Striker Prizes";
            rtrue;
            ;
        table_data_U15:
            print "Table of Ticket Prices";
            rtrue;
            ;
        table_data_U16:
            print "Table of Little Egypt Events";
            rtrue;
            ;
        table_data_U17:
            print "Table of Hell Ride Events";
            rtrue;
            ;
        table_data_U18:
            print "Table of Parking Lot Hints";
            rtrue;
            ;
        table_data_U19:
            print "Table of Attractions Hints";
            rtrue;
            ;
        table_data_U20:
            print "Table of Games Hints";
            rtrue;
            ;
        table_data_U21:
            print "Table of Back Stage Hints";
            rtrue;
            ;
        table_data_U22:
            print "Table of Hell Ride Hints";
            rtrue;
            ;
        table_data_U23:
            print "Table of Electrical Area Hints";
            rtrue;
            ;
        table_data_U24:
            print "Table of Control Room Hints";
            rtrue;
            ;
        table_data_U25:
            print "Table of Scored Circumstances";
            rtrue;
            ;
        table_data_U26:
            print "Table of Bored Responses";
            rtrue;
            ;
        table_data_U27:
            print "Table of Songs";
            rtrue;
            ;
        table_data_U28:
            print "Table of Monitor Descriptions";
            rtrue;
            ;
        table_data_U29:
            print "Table of Dime Toss Prizes";
            rtrue;
            ;
        table_data_U30:
            print "Table of Pitcher's Mound Prizes";
            rtrue;
            ;
        table_data_U31:
            print "Table of Concession Prices";
            rtrue;
            ;
        table_data_U32:
            print "Table of Glove Box Hints";
            rtrue;
            ;
        table_data_U33:
            print "Table of Leaving Lot Hints";
            rtrue;
            ;
        table_data_U34:
            print "Table of String Hints";
            rtrue;
            ;
        table_data_U35:
            print "Table of Toad Away Hints";
            rtrue;
            ;
        table_data_U36:
            print "Table of Ride the Ride Hints";
            rtrue;
            ;
        table_data_U37:
            print "Table of Ticket Price Hints";
            rtrue;
            ;
        table_data_U38:
            print "Table of Boring Ride Hints";
            rtrue;
            ;
        table_data_U39:
            print "Table of Important Prizes Hints";
            rtrue;
            ;
        table_data_U40:
            print "Table of Game Cost Hints";
            rtrue;
            ;
        table_data_U41:
            print "Table of Mercury Dime Hints";
            rtrue;
            ;
        table_data_U42:
            print "Table of Grue Hints";
            rtrue;
            ;
        table_data_U43:
            print "Table of Doors Hints";
            rtrue;
            ;
        table_data_U44:
            print "Table of Guillotine Hints";
            rtrue;
            ;
        table_data_U45:
            print "Table of Hell Ride Rooms";
            rtrue;
            ;
        table_data_U46:
            print "Table of Electrical Room Hints";
            rtrue;
            ;
        table_data_U47:
            print "Table of Electrical Panel Hints";
            rtrue;
            ;
        table_data_U48:
            print "Table of Fuse Hints";
            rtrue;
            ;
        table_data_U49:
            print "Table of Big Switch Hints";
            rtrue;
            ;
        table_data_U50:
            print "Table of Control Panel Hints";
            rtrue;
            ;
        default:
            print "** No such table **";
            rtrue;
            ;
    }
];
[ TC_KOV tc unk;
    switch (tc) {
        100:
            return TEXT_TY;
            ;
        101:
            return TRUTH_STATE_TY;
            ;
        102:
            return UNDERSTANDING_TY;
            ;
        103:
            return DK1_rule;
            ;
        104:
            return DK2_activity_on_objects;
            ;
        105:
            return OBJECT_TY;
            ;
        106:
            return NUMBER_TY;
            ;
        107:
            return TEXT_TY;
            ;
        108:
            return TABLE_TY;
            ;
        109:
            return TEXT_TY;
            ;
        110:
            return DK1_rule;
            ;
        111:
            return NUMBER_TY;
            ;
        112:
            return DK1_rule;
            ;
        113:
            return TEXT_TY;
            ;
        114:
            return TEXT_TY;
            ;
        115:
            return TEXT_TY;
            ;
        116:
            return TEXT_TY;
            ;
        117:
            return NUMBER_TY;
            ;
        118:
            return TEXT_TY;
            ;
        119:
            return NUMBER_TY;
            ;
        120:
            return NUMBER_TY;
            ;
        121:
            return TEXT_TY;
            ;
        122:
            return TEXT_TY;
            ;
        123:
            return TEXT_TY;
            ;
        124:
            return TRUTH_STATE_TY;
            ;
        125:
            return NUMBER_TY;
            ;
        126:
            return FIGURE_NAME_TY;
            ;
        127:
            return TEXT_TY;
            ;
        128:
            return OBJECT_TY;
            ;
        129:
            return WEAK_ID_71;
            ;
        130:
            return OBJECT_TY;
            ;
        131:
            return TEXT_TY;
            ;
        132:
            return FIGURE_NAME_TY;
            ;
    }
    return unk;
];
[ TestScriptSub;
    switch (special_word) {
        'life':
            TestStart(script_U1, requirements_U1, 87);
            ;
        'death':
            TestStart(script_U2, requirements_U2, 82);
            ;
        'parking':
            TestStart(script_U3, requirements_U3, 544);
            ;
        'toadaway':
            TestStart(script_U4, requirements_U4, 83);
            ;
        'g1':
            TestStart(script_U5, requirements_U5, 83);
            ;
        'g2':
            TestStart(script_U6, requirements_U6, 50);
            ;
        'g3':
            TestStart(script_U7, requirements_U7, 179);
            ;
        'games':
            TestStart(script_U8, requirements_U8, 23);
            ;
        'attractions':
            TestStart(script_U9, requirements_U9, 275);
            ;
        'b1':
            TestStart(script_U10, requirements_U10, 320);
            ;
        'b1a':
            TestStart(script_U11, requirements_U11, 65);
            ;
        'b2':
            TestStart(script_U12, requirements_U12, 204);
            ;
        'b3':
            TestStart(script_U13, requirements_U13, 431);
            ;
        'b4':
            TestStart(script_U14, requirements_U14, 365);
            ;
        'backstage':
            TestStart(script_U15, requirements_U15, 40);
            ;
        'concession':
            TestStart(script_U16, requirements_U16, 142);
            ;
        'ride':
            TestStart(script_U17, requirements_U17, 103);
            ;
        'electrocution':
            TestStart(script_U18, requirements_U18, 135);
            ;
        'grues':
            TestStart(script_U19, requirements_U19, 73);
            ;
        'misc':
            TestStart(script_U20, requirements_U20, 58);
            ;
        default:
            print ">--> The following tests are available:^";
            print "'test life'^";
            print "'test death'^";
            print "'test parking'^";
            print "'test toadaway'^";
            print "'test g1'^";
            print "'test g2'^";
            print "'test g3'^";
            print "'test games'^";
            print "'test attractions'^";
            print "'test b1'^";
            print "'test b1a'^";
            print "'test b2'^";
            print "'test b3'^";
            print "'test b4'^";
            print "'test backstage'^";
            print "'test concession'^";
            print "'test ride'^";
            print "'test electrocution'^";
            print "'test grues'^";
            print "'test misc'^";
            print "^";
            ;
    }
];
[ TestUseOption UO;
    if ((UO == 1)) {
        rtrue;
    }
    if ((UO == 2)) {
        rtrue;
    }
    if ((UO == 14)) {
        rtrue;
    }
    if ((UO == 15)) {
        rtrue;
    }
    if ((UO == 16)) {
        rtrue;
    }
    if ((UO == 20)) {
        rtrue;
    }
    if ((UO == 27)) {
        rtrue;
    }
    rfalse;
];
[ PrintUseOption UO;
    switch (UO) {
        0:
            print "ineffectual option";
            ;
        1:
            print "american dialect option";
            ;
        2:
            print "serial comma option";
            ;
        3:
            print "memory economy option";
            ;
        4:
            print "engineering notation option";
            ;
        5:
            print "unabbreviated object names option";
            ;
        6:
            print "predictable randomisation option";
            ;
        7:
            print "fast route-finding option";
            ;
        8:
            print "slow route-finding option";
            ;
        9:
            print "numbered rules option";
            ;
        10:
            print "telemetry recordings option";
            ;
        11:
            print "no deprecated features option";
            ;
        12:
            print "gn testing version option";
            ;
        13:
            print "authorial modesty option";
            ;
        14:
            print "dynamic memory allocation option [131072]";
            ;
        15:
            print "maximum text length option [4096]";
            ;
        16:
            print "index figure thumbnails option [50]";
            ;
        17:
            print "command line echoing option";
            ;
        18:
            print "full-length room descriptions option";
            ;
        19:
            print "abbreviated room descriptions option";
            ;
        20:
            print "scoring option";
            ;
        21:
            print "no scoring option";
            ;
        22:
            print "manual pronouns option";
            ;
        23:
            print "undo prevention option";
            ;
        24:
            print "verbose room descriptions option";
            ;
        25:
            print "brief room descriptions option";
            ;
        26:
            print "superbrief room descriptions option";
            ;
        27:
            print "maximum things understood at once option [300]";
            ;
        28:
            print "sequential action option";
            ;
    }
];
[ call_U121 t_0;
    if (1) {
        return (IntegerRemainder(t_0, 2) == 0);
    }
    rfalse;
];
[ call_U122 t_0;
    if (1) {
        return (~~((IntegerRemainder(t_0, 2) == 0)));
    }
    rfalse;
];
[ call_U123 t_0;
    if (1) {
        return (t_0 > 0);
    }
    rfalse;
];
[ call_U124 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0);
    }
    rfalse;
];
[ call_U125 t_0;
    if (1) {
        return (t_0 < 0);
    }
    rfalse;
];
[ call_U126 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0);
    }
    rfalse;
];
[ call_U127 t_0;
    if (1) {
        return TEXT_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U128 t_0;
    if (1) {
        return (TableFilledRows(t_0) == 0);
    }
    rfalse;
];
[ call_U129 t_0;
    if (1) {
        return RulebookEmpty(t_0);
    }
    rfalse;
];
[ call_U130 t_0;
    if (1) {
        return ActivityEmpty(t_0);
    }
    rfalse;
];
[ call_U131 t_0;
    if (1) {
        return LIST_OF_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U132 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, (-(1)));
    }
    rfalse;
];
[ call_U133 t_0;
    if ((t_0 ofclass K18_fluid_container)) {
        return (GProperty(OBJECT_TY, t_0, A_P_current_volume) == 0);
    }
    rfalse;
];
[ call_U134 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U135 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U136 t_0;
    if (1) {
        return (~~(TEXT_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U137 t_0;
    if (1) {
        return (~~((TableFilledRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U138 t_0;
    if (1) {
        return (~~(RulebookEmpty(t_0)));
    }
    rfalse;
];
[ call_U139 t_0;
    if (1) {
        return (~~(ActivityEmpty(t_0)));
    }
    rfalse;
];
[ call_U140 t_0;
    if (1) {
        return (~~(LIST_OF_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U141 t_0;
    if (1) {
        return (~~(RELATION_TY_Empty(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U142 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U143 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U144 t_0;
    if (1) {
        return TEXT_TY_IsSubstituted(t_0);
    }
    rfalse;
];
[ call_U145 t_0;
    if (1) {
        return (~~(TEXT_TY_IsSubstituted(t_0)));
    }
    rfalse;
];
[ call_U146 t_0;
    if (1) {
        return (TableBlankRows(t_0) == 0);
    }
    rfalse;
];
[ call_U147 t_0;
    if ((t_0 ofclass K18_fluid_container)) {
        return (GProperty(OBJECT_TY, t_0, A_P_current_volume) == GProperty(OBJECT_TY, t_0, A_P_fluid_capacity));
    }
    rfalse;
];
[ call_U148 t_0;
    if (1) {
        return (~~((TableBlankRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U149 t_0;
    if (1) {
        return TestActivity(t_0);
    }
    rfalse;
];
[ call_U150 t_0;
    if (1) {
        return TestUseOption(t_0);
    }
    rfalse;
];
[ call_U151 t_0;
    if (1) {
        return (~~(TestUseOption(t_0)));
    }
    rfalse;
];
[ call_U152 t_0;
    if (1) {
        return VerbIsModal(t_0);
    }
    rfalse;
];
[ call_U153 t_0;
    if (1) {
        return (~~(VerbIsModal(t_0)));
    }
    rfalse;
];
[ call_U154 t_0;
    if (1) {
        return VerbIsMeaningful(t_0);
    }
    rfalse;
];
[ call_U155 t_0;
    if (1) {
        return (~~(VerbIsMeaningful(t_0)));
    }
    rfalse;
];
[ call_U156 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U157 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U158 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U159 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U160 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U161 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U162 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U163 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U164 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U165 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U166 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U167 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U168 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U169 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U170 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U171 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U172 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U173 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U174 t_0;
    if (1) {
        return ((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)));
    }
    rfalse;
];
[ call_U175 t_0;
    if (1) {
        return (~~(((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)))));
    }
    rfalse;
];
[ call_U176 t_0;
    if (1) {
        return REAL_NUMBER_TY_Nan(t_0);
    }
    rfalse;
];
[ call_U177 t_0;
    if (1) {
        return (~~(REAL_NUMBER_TY_Nan(t_0)));
    }
    rfalse;
];
[ call_U178 t_0;
    if (t_0) {
        return (t_0 has pluralname);
    }
    rfalse;
];
[ call_U179 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U180 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U181 t_0;
    if (t_0) {
        return ((t_0 has pluralname) == 0);
    }
    rfalse;
];
[ call_U182 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U183 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U184 t_0;
    if (t_0) {
        return (t_0 has proper);
    }
    rfalse;
];
[ call_U185 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U186 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U187 t_0;
    if (t_0) {
        return ((t_0 has proper) == 0);
    }
    rfalse;
];
[ call_U188 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U189 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U190 t_0;
    if (t_0) {
        return (t_0 has ambigpluralname);
    }
    rfalse;
];
[ call_U191 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 1);
    }
    rfalse;
];
[ call_U192 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 0);
    }
    rfalse;
];
[ ADJDEFN2 t_0;
    rfalse;
];
[ ADJDEFN3 t_0;
    rfalse;
];
[ ADJDEFN4 t_0;
    rfalse;
];
[ ADJDEFN5 t_0;
    rfalse;
];
[ ADJDEFN6 t_0;
    rfalse;
];
[ ADJDEFN7 t_0;
    rfalse;
];
[ ADJDEFN8 t_0;
    rfalse;
];
[ ADJDEFN9 t_0;
    rfalse;
];
[ ADJDEFN10 t_0;
    rfalse;
];
[ ADJDEFN11 t_0;
    rfalse;
];
[ ADJDEFN12 t_0;
    rfalse;
];
[ ADJDEFN13 t_0;
    rfalse;
];
[ ADJDEFN14 t_0;
    rfalse;
];
[ ADJDEFN15 t_0;
    rfalse;
];
[ ADJDEFN16 t_0;
    rfalse;
];
[ ADJDEFN17 t_0;
    rfalse;
];
[ ADJDEFN18 t_0;
    rfalse;
];
[ ADJDEFN19 t_0;
    rfalse;
];
[ ADJDEFN20 t_0;
    rfalse;
];
[ ADJDEFN21 t_0;
    rfalse;
];
[ ADJDEFN22 t_0;
    rfalse;
];
[ ADJDEFN23 t_0;
    rfalse;
];
[ ADJDEFN24 t_0;
    rfalse;
];
[ ADJDEFN25 t_0;
    rfalse;
];
[ ADJDEFN26 t_0;
    rfalse;
];
[ call_U193 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(INITIALISE_MEMORY_R, 0, 0);
    }
    (rv = (INITIALISE_MEMORY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return INITIALISE_MEMORY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(VIRTUAL_MACHINE_STARTUP_R, 0, 0);
    }
    (rv = (VIRTUAL_MACHINE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VIRTUAL_MACHINE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(SEED_RANDOM_NUMBER_GENERATOR_R, 0, 0);
    }
    (rv = (SEED_RANDOM_NUMBER_GENERATOR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1068)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1068;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(POSITION_PLAYER_IN_MODEL_R, 0, 0);
    }
    (rv = (POSITION_PLAYER_IN_MODEL_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return POSITION_PLAYER_IN_MODEL_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1070)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1070;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1071)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1071;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1072)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1072;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1073)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1073;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1074)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1074;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U194 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1079)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1079;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(RESURRECT_PLAYER_IF_ASKED_R, 0, 0);
    }
    (rv = (RESURRECT_PLAYER_IF_ASKED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1080)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1080;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ASK_FINAL_QUESTION_R, 0, 0);
    }
    (rv = (ASK_FINAL_QUESTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ASK_FINAL_QUESTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U196 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(FINAL_CODE_STARTUP_R, 0, 0);
    }
    (rv = (FINAL_CODE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return FINAL_CODE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U198 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2533)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2533;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2556)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2556;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2555)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2555;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1102)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1102;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U199 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U200 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2077)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2077;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2534)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2534;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2717)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2717;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2718)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2718;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U202 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_PLURAL_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_PLURAL_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_PLURAL_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U204 sk;
    return I_english_language_U1;
];
[ E1 value;
    switch (value) {
        I_english_language_U1:
            print "English language";
            ;
        I_french_language_U1:
            print "French language";
            ;
        I_german_language_U1:
            print "German language";
            ;
        I_italian_language_U1:
            print "Italian language";
            ;
        I_spanish_language_U1:
            print "Spanish language";
            ;
        I_swedish_language_U1:
            print "Swedish language";
            ;
        default:
            print "<illegal natural language>";
            ;
    }
];
[ call_U205 x;
    return ((x%6) + 1);
];
[ call_U206 x;
    return (((x + 4)%6) + 1);
];
[ call_U207 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U208;
    rfalse;
];
[ call_U209 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)));
    return tmp_0;
    rfalse;
];
[ call_U210 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Plus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U211 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Minus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U212 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Times(1056964608, REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)), (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))));
    return tmp_0;
    rfalse;
];
[ ConjugateVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record9;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has had";
                    } else {
                        print "have had";
                    }
                    ;
                4:
                    print "had had";
                    ;
                5:
                    print "will have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not have";
                    } else {
                        print "do not have";
                    }
                    ;
                2:
                    print "did not have";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not had";
                    } else {
                        print "have not had";
                    }
                    ;
                4:
                    print "had not had";
                    ;
                5:
                    print "will not have";
                    ;
            }
            ;
    }
];
[ call_U213 fn vp t modal_to;
    (t = ConjugateVerb4(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record9;
    }
];
[ ConjugateVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U214 fn vp t modal_to;
    (t = ConjugateVerb8(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb62 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record8;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ call_U215 fn vp t modal_to;
    (t = ConjugateVerb62(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ ConjugateVerb63 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to be";
            ;
        2:
            print "been able to be";
            ;
        3:
            print "being able to be";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can be";
                    ;
                2:
                    print "could be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to be";
                    } else {
                        print "have been able to be";
                    }
                    ;
                4:
                    print "had been able to be";
                    ;
                5:
                    print "will be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot be";
                    ;
                2:
                    print "could not be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to be";
                    } else {
                        print "have not been able to be";
                    }
                    ;
                4:
                    print "had not been able to be";
                    ;
                5:
                    print "will not be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
    }
];
[ call_U216 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb64 fn vp t modal_to;
    switch (fn) {
        1:
            print "specify";
            ;
        2:
            print "specified";
            ;
        3:
            print "specifying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "specifies";
                    } else {
                        print "specify";
                    }
                    ;
                2:
                    print "specified";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has specified";
                    } else {
                        print "have specified";
                    }
                    ;
                4:
                    print "had specified";
                    ;
                5:
                    print "will specify";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not specify";
                    } else {
                        print "do not specify";
                    }
                    ;
                2:
                    print "did not specify";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not specified";
                    } else {
                        print "have not specified";
                    }
                    ;
                4:
                    print "had not specified";
                    ;
                5:
                    print "will not specify";
                    ;
            }
            ;
    }
];
[ call_U217 fn vp t modal_to;
    (t = ConjugateVerb64(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb65 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record10;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ call_U218 fn vp t modal_to;
    (t = ConjugateVerb65(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb66 fn vp t modal_to;
    switch (fn) {
        1:
            print "substitute";
            ;
        2:
            print "substituted";
            ;
        3:
            print "substituting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "substitutes";
                    } else {
                        print "substitute";
                    }
                    ;
                2:
                    print "substituted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has substituted";
                    } else {
                        print "have substituted";
                    }
                    ;
                4:
                    print "had substituted";
                    ;
                5:
                    print "will substitute";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not substitute";
                    } else {
                        print "do not substitute";
                    }
                    ;
                2:
                    print "did not substitute";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not substituted";
                    } else {
                        print "have not substituted";
                    }
                    ;
                4:
                    print "had not substituted";
                    ;
                5:
                    print "will not substitute";
                    ;
            }
            ;
    }
];
[ call_U219 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U220 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " for";
];
[ ConjugateModalVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateVerb67 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ call_U221 fn vp t modal_to;
    (t = ConjugateVerb67(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U222 fn vp t modal_to;
    (t = ConjugateVerb67(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " into";
];
[ call_U223 fn vp t modal_to;
    (t = ConjugateVerb67(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " as";
];
[ ConjugateModalVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb68 fn vp t modal_to;
    switch (fn) {
        1:
            print "provide";
            ;
        2:
            print "provided";
            ;
        3:
            print "providing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record11;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provides";
                    } else {
                        print "provide";
                    }
                    ;
                2:
                    print "provided";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provided";
                    } else {
                        print "have provided";
                    }
                    ;
                4:
                    print "had provided";
                    ;
                5:
                    print "will provide";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provide";
                    } else {
                        print "do not provide";
                    }
                    ;
                2:
                    print "did not provide";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provided";
                    } else {
                        print "have not provided";
                    }
                    ;
                4:
                    print "had not provided";
                    ;
                5:
                    print "will not provide";
                    ;
            }
            ;
    }
];
[ call_U224 fn vp t modal_to;
    (t = ConjugateVerb68(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record11;
    }
];
[ ConjugateVerb69 fn vp t modal_to;
    switch (fn) {
        1:
            print "use";
            ;
        2:
            print "used";
            ;
        3:
            print "using";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "uses";
                    } else {
                        print "use";
                    }
                    ;
                2:
                    print "used";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has used";
                    } else {
                        print "have used";
                    }
                    ;
                4:
                    print "had used";
                    ;
                5:
                    print "will use";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not use";
                    } else {
                        print "do not use";
                    }
                    ;
                2:
                    print "did not use";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not used";
                    } else {
                        print "have not used";
                    }
                    ;
                4:
                    print "had not used";
                    ;
                5:
                    print "will not use";
                    ;
            }
            ;
    }
];
[ call_U225 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb70 fn vp t modal_to;
    switch (fn) {
        1:
            print "include";
            ;
        2:
            print "included";
            ;
        3:
            print "including";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "includes";
                    } else {
                        print "include";
                    }
                    ;
                2:
                    print "included";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has included";
                    } else {
                        print "have included";
                    }
                    ;
                4:
                    print "had included";
                    ;
                5:
                    print "will include";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not include";
                    } else {
                        print "do not include";
                    }
                    ;
                2:
                    print "did not include";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not included";
                    } else {
                        print "have not included";
                    }
                    ;
                4:
                    print "had not included";
                    ;
                5:
                    print "will not include";
                    ;
            }
            ;
    }
];
[ call_U226 fn vp t modal_to;
    (t = ConjugateVerb70(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U227 fn vp t modal_to;
    (t = ConjugateVerb70(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb71 fn vp t modal_to;
    switch (fn) {
        1:
            print "omit";
            ;
        2:
            print "omitted";
            ;
        3:
            print "omitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "omits";
                    } else {
                        print "omit";
                    }
                    ;
                2:
                    print "omitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has omitted";
                    } else {
                        print "have omitted";
                    }
                    ;
                4:
                    print "had omitted";
                    ;
                5:
                    print "will omit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not omit";
                    } else {
                        print "do not omit";
                    }
                    ;
                2:
                    print "did not omit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not omitted";
                    } else {
                        print "have not omitted";
                    }
                    ;
                4:
                    print "had not omitted";
                    ;
                5:
                    print "will not omit";
                    ;
            }
            ;
    }
];
[ call_U228 fn vp t modal_to;
    (t = ConjugateVerb71(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U229 fn vp t modal_to;
    (t = ConjugateVerb71(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb72 fn vp t modal_to;
    switch (fn) {
        1:
            print "test";
            ;
        2:
            print "tested";
            ;
        3:
            print "testing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tests";
                    } else {
                        print "test";
                    }
                    ;
                2:
                    print "tested";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tested";
                    } else {
                        print "have tested";
                    }
                    ;
                4:
                    print "had tested";
                    ;
                5:
                    print "will test";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not test";
                    } else {
                        print "do not test";
                    }
                    ;
                2:
                    print "did not test";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tested";
                    } else {
                        print "have not tested";
                    }
                    ;
                4:
                    print "had not tested";
                    ;
                5:
                    print "will not test";
                    ;
            }
            ;
    }
];
[ call_U230 fn vp t modal_to;
    (t = ConjugateVerb72(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U231 fn vp t modal_to;
    (t = ConjugateVerb72(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U232 sk;
    return I_present_tense_U1;
];
[ E2 value;
    switch (value) {
        I_present_tense_U1:
            print "present tense";
            ;
        I_past_tense_U1:
            print "past tense";
            ;
        I_perfect_tense_U1:
            print "perfect tense";
            ;
        I_past_perfect_tense_U1:
            print "past perfect tense";
            ;
        I_future_tense_U1:
            print "future tense";
            ;
        default:
            print "<illegal grammatical tense>";
            ;
    }
];
[ call_U233 x;
    return ((x%5) + 1);
];
[ call_U234 x;
    return (((x + 3)%5) + 1);
];
[ call_U235 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U236 sk;
    return I_first_person_singular_U1;
];
[ E3 value;
    switch (value) {
        I_first_person_singular_U1:
            print "first person singular";
            ;
        I_second_person_singular_U1:
            print "second person singular";
            ;
        I_third_person_singular_U1:
            print "third person singular";
            ;
        I_first_person_plural_U1:
            print "first person plural";
            ;
        I_second_person_plural_U1:
            print "second person plural";
            ;
        I_third_person_plural_U1:
            print "third person plural";
            ;
        default:
            print "<illegal narrative viewpoint>";
            ;
    }
];
[ call_U237 x;
    return ((x%6) + 1);
];
[ call_U238 x;
    return (((x + 4)%6) + 1);
];
[ call_U239 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U240 sk;
    return I_nominative_U1;
];
[ E4 value;
    switch (value) {
        I_nominative_U1:
            print "nominative";
            ;
        I_accusative_U1:
            print "accusative";
            ;
        default:
            print "<illegal grammatical case>";
            ;
    }
];
[ call_U241 x;
    return ((x%2) + 1);
];
[ call_U242 x;
    return ((x%2) + 1);
];
[ call_U243 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(2);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U244 sk;
    return I_neuter_gender_U1;
];
[ E5 value;
    switch (value) {
        I_neuter_gender_U1:
            print "neuter gender";
            ;
        I_masculine_gender_U1:
            print "masculine gender";
            ;
        I_feminine_gender_U1:
            print "feminine gender";
            ;
        default:
            print "<illegal grammatical gender>";
            ;
    }
];
[ call_U245 x;
    return ((x%3) + 1);
];
[ call_U246 x;
    return (((x + 1)%3) + 1);
];
[ call_U247 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U248;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "he";
        } else {
            (say__p = 1);
            ParaContent();
            print "she";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "we";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "they";
    }
    rfalse;
];
[ call_U249;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "him";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "them";
    }
    rfalse;
];
[ call_U250;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    }
    rfalse;
];
[ call_U251;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    }
    rfalse;
];
[ call_U252;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "my";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "their";
    }
    rfalse;
];
[ call_U253;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "He";
        } else {
            (say__p = 1);
            ParaContent();
            print "She";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "We";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "They";
    }
    rfalse;
];
[ call_U254;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "Him";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Them";
    }
    rfalse;
];
[ call_U255;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    }
    rfalse;
];
[ call_U256;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "Himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "Herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    }
    rfalse;
];
[ call_U257;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "My";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U408(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Their";
    }
    rfalse;
];
[ call_U258;
    (say__p = 1);
    ParaContent();
    call_U260(I_accusative_U1);
    rfalse;
];
[ call_U259;
    (say__p = 1);
    ParaContent();
    call_U261(I_nominative_U1);
    rfalse;
];
[ call_U260 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U248();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "he";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "she";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U248();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U261 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U253();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "He";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "She";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U253();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "Her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U262 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U248();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U263 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U253();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U264 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U252();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U265 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U257();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U266 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U249();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U267 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U254();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U268 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U250();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U269 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U255();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U270 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U251();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U271 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U256();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U272 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U248();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "that";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U273 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U253();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U408(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U405(tmp_0)))) && ((~~(call_U411(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "That";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U274;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    rfalse;
];
[ call_U275;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    rfalse;
];
[ call_U276;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    rfalse;
];
[ call_U277;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    rfalse;
];
[ call_U278;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U279;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U280;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U281;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U282 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U252();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ call_U283 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U257();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ ConjugateVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "can't";
            ;
        2:
            print "can'ted";
            ;
        3:
            print "can'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "aren't";
            ;
        2:
            print "aren'ted";
            ;
        3:
            print "aren'ting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "aren't";
                            ;
                        2:
                            print "aren't";
                            ;
                        5:
                            print "aren't";
                            ;
                        3:
                            print "isn't";
                            ;
                        6:
                            print "aren't";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wasn't";
                            ;
                        4:
                            print "weren't";
                            ;
                        2:
                            print "weren't";
                            ;
                        5:
                            print "weren't";
                            ;
                        3:
                            print "wasn't";
                            ;
                        6:
                            print "weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "hasn't been";
                    } else {
                        print "haven't been";
                    }
                    ;
                4:
                    print "hadn't been";
                    ;
                5:
                    print "won't be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "'re";
            ;
        2:
            print " been";
            ;
        3:
            print " being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m";
                            ;
                        4:
                            print "'re";
                            ;
                        2:
                            print "'re";
                            ;
                        5:
                            print "'re";
                            ;
                        3:
                            print "'s";
                            ;
                        6:
                            print "'re";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " was";
                            ;
                        4:
                            print " were";
                            ;
                        2:
                            print " were";
                            ;
                        5:
                            print " were";
                            ;
                        3:
                            print " was";
                            ;
                        6:
                            print " were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s been";
                    } else {
                        print "'ve been";
                    }
                    ;
                4:
                    print "'d been";
                    ;
                5:
                    print "'ll be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m not";
                            ;
                        4:
                            print "'re not";
                            ;
                        2:
                            print "'re not";
                            ;
                        5:
                            print "'re not";
                            ;
                        3:
                            print "'s not";
                            ;
                        6:
                            print "'re not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " wasn't";
                            ;
                        4:
                            print " weren't";
                            ;
                        2:
                            print " weren't";
                            ;
                        5:
                            print " weren't";
                            ;
                        3:
                            print " wasn't";
                            ;
                        6:
                            print " weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not been";
                    } else {
                        print "'ve not been";
                    }
                    ;
                4:
                    print "'d not been";
                    ;
                5:
                    print "'ll not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "would";
            ;
        2:
            print "woulded";
            ;
        3:
            print "woulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U284 fn vp t modal_to;
    (t = ConjugateVerb10(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "might";
            ;
        2:
            print "mighted";
            ;
        3:
            print "mighting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U285 fn vp t modal_to;
    (t = ConjugateVerb19(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "don't";
            ;
        2:
            print "don'ted";
            ;
        3:
            print "don'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "doesn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateModalVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ ConjugateVerb73 fn vp t modal_to;
    switch (fn) {
        1:
            print "could";
            ;
        2:
            print "coulded";
            ;
        3:
            print "coulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U286 fn vp t modal_to;
    (t = ConjugateVerb73(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb74 fn vp t modal_to;
    switch (fn) {
        1:
            print "may";
            ;
        2:
            print "mayed";
            ;
        3:
            print "maying";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U287 fn vp t modal_to;
    (t = ConjugateVerb74(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb75 fn vp t modal_to;
    switch (fn) {
        1:
            print "must";
            ;
        2:
            print "musted";
            ;
        3:
            print "musting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U288 fn vp t modal_to;
    (t = ConjugateVerb75(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb76 fn vp t modal_to;
    switch (fn) {
        1:
            print "should";
            ;
        2:
            print "shoulded";
            ;
        3:
            print "shoulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U289 fn vp t modal_to;
    (t = ConjugateVerb76(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb77 fn vp t modal_to;
    switch (fn) {
        1:
            print "'ve";
            ;
        2:
            print " had";
            ;
        3:
            print " having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s";
                    } else {
                        print "'ve";
                    }
                    ;
                2:
                    print " had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s had";
                    } else {
                        print "'ve had";
                    }
                    ;
                4:
                    print "'d had";
                    ;
                5:
                    print "'ll have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s not";
                    } else {
                        print "'ve not";
                    }
                    ;
                2:
                    print " hadn't";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not had";
                    } else {
                        print "'ve not had";
                    }
                    ;
                4:
                    print "'d not had";
                    ;
                5:
                    print "'ll not have";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb78 fn vp t modal_to;
    switch (fn) {
        1:
            print "mustn't";
            ;
        2:
            print "mustn'ted";
            ;
        3:
            print "mustn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb79 fn vp t modal_to;
    switch (fn) {
        1:
            print "mightn't";
            ;
        2:
            print "mightn'ted";
            ;
        3:
            print "mightn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb80 fn vp t modal_to;
    switch (fn) {
        1:
            print "mayn't";
            ;
        2:
            print "mayn'ted";
            ;
        3:
            print "mayn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb81 fn vp t modal_to;
    switch (fn) {
        1:
            print "wouldn't";
            ;
        2:
            print "wouldn'ted";
            ;
        3:
            print "wouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb82 fn vp t modal_to;
    switch (fn) {
        1:
            print "couldn't";
            ;
        2:
            print "couldn'ted";
            ;
        3:
            print "couldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb83 fn vp t modal_to;
    switch (fn) {
        1:
            print "shouldn't";
            ;
        2:
            print "shouldn'ted";
            ;
        3:
            print "shouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb84 fn vp t modal_to;
    switch (fn) {
        1:
            print "won't";
            ;
        2:
            print "won'ted";
            ;
        3:
            print "won'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ call_U290 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == WearerOf(t_0));
    }
    rfalse;
];
[ call_U291 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == CarrierOf(t_0));
    }
    rfalse;
];
[ call_U292 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == HolderOf(t_0));
    }
    rfalse;
];
[ call_U293 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestVisibility(player, t_0);
    }
    rfalse;
];
[ call_U294 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestVisibility(player, t_0)));
    }
    rfalse;
];
[ call_U295 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestTouchability(player, t_0);
    }
    rfalse;
];
[ call_U296 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestTouchability(player, t_0)));
    }
    rfalse;
];
[ call_U297 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestConcealment(HolderOf(t_0), t_0);
    }
    rfalse;
];
[ call_U298 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestConcealment(HolderOf(t_0), t_0)));
    }
    rfalse;
];
[ call_U299 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, (-(1)));
    }
    rfalse;
];
[ call_U300 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U301 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U302 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(OnStage(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U303 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U304 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U305 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(call_U299(t_0)));
    }
    rfalse;
];
[ call_U306 t_0;
    if (1) {
        return ((scene_status-->((t_0 - 1))) == 1);
    }
    rfalse;
];
[ call_U307 t_0;
    if ((t_0 ofclass K1_room)) {
        return TestAdjacency(real_location, t_0);
    }
    rfalse;
];
[ call_U308 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (((~~(call_U345(t_0)))) && ((((~~(call_U369(t_0)))) && ((~~(call_U357(t_0)))))));
    }
    rfalse;
];
[ call_U309 t_0;
    if (t_0) {
        return (t_0 has privately_named);
    }
    rfalse;
];
[ call_U310 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U311 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U312 t_0;
    if (t_0) {
        return ((t_0 has privately_named) == 0);
    }
    rfalse;
];
[ call_U313 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U314 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U315 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U316 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U317 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U318 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U319 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U320 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U321 t_0;
    if (t_0) {
        return (t_0 has visited);
    }
    rfalse;
];
[ call_U322 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U323 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U324 t_0;
    if (t_0) {
        return ((t_0 has visited) == 0);
    }
    rfalse;
];
[ call_U325 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U326 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U327 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U328 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U329 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U330 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U331 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U332 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U333 t_0;
    if (t_0) {
        return (t_0 has edible);
    }
    rfalse;
];
[ call_U334 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U335 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U336 t_0;
    if (t_0) {
        return ((t_0 has edible) == 0);
    }
    rfalse;
];
[ call_U337 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U338 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U339 t_0;
    if (t_0) {
        return (t_0 has static);
    }
    rfalse;
];
[ call_U340 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U341 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U342 t_0;
    if (t_0) {
        return ((t_0 has static) == 0);
    }
    rfalse;
];
[ call_U343 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U344 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U345 t_0;
    if (t_0) {
        return (t_0 has scenery);
    }
    rfalse;
];
[ call_U346 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 1);
    }
    rfalse;
];
[ call_U347 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 0);
    }
    rfalse;
];
[ call_U348 t_0;
    if (t_0) {
        return (t_0 has clothing);
    }
    rfalse;
];
[ call_U349 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 1);
    }
    rfalse;
];
[ call_U350 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 0);
    }
    rfalse;
];
[ call_U351 t_0;
    if (t_0) {
        return (t_0 has pushable);
    }
    rfalse;
];
[ call_U352 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 1);
    }
    rfalse;
];
[ call_U353 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 0);
    }
    rfalse;
];
[ call_U354 t_0;
    if (t_0) {
        return (t_0 has moved);
    }
    rfalse;
];
[ call_U355 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 1);
    }
    rfalse;
];
[ call_U356 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 0);
    }
    rfalse;
];
[ call_U357 t_0;
    if (t_0) {
        return (t_0 has concealed);
    }
    rfalse;
];
[ call_U358 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U359 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U360 t_0;
    if (t_0) {
        return ((t_0 has concealed) == 0);
    }
    rfalse;
];
[ call_U361 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U362 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U363 t_0;
    if (t_0) {
        return (t_0 has workflag);
    }
    rfalse;
];
[ call_U364 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U365 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U366 t_0;
    if (t_0) {
        return ((t_0 has workflag) == 0);
    }
    rfalse;
];
[ call_U367 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U368 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U369 t_0;
    if (t_0) {
        return (t_0 has mentioned);
    }
    rfalse;
];
[ call_U370 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U371 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U372 t_0;
    if (t_0) {
        return ((t_0 has mentioned) == 0);
    }
    rfalse;
];
[ call_U373 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U374 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U375 t_0;
    if (t_0) {
        return (t_0 has enterable);
    }
    rfalse;
];
[ call_U376 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 1);
    }
    rfalse;
];
[ call_U377 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 0);
    }
    rfalse;
];
[ call_U378 t_0;
    if (t_0) {
        return (t_0 has transparent);
    }
    rfalse;
];
[ call_U379 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U380 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U381 t_0;
    if (t_0) {
        return ((t_0 has transparent) == 0);
    }
    rfalse;
];
[ call_U382 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U383 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U384 t_0;
    if (t_0) {
        return (t_0 has open);
    }
    rfalse;
];
[ call_U385 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U386 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U387 t_0;
    if (t_0) {
        return ((t_0 has open) == 0);
    }
    rfalse;
];
[ call_U388 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U389 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U390 t_0;
    if (t_0) {
        return (t_0 has openable);
    }
    rfalse;
];
[ call_U391 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U392 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U393 t_0;
    if (t_0) {
        return ((t_0 has openable) == 0);
    }
    rfalse;
];
[ call_U394 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U395 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U396 t_0;
    if (t_0) {
        return (t_0 has lockable);
    }
    rfalse;
];
[ call_U397 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 1);
    }
    rfalse;
];
[ call_U398 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 0);
    }
    rfalse;
];
[ call_U399 t_0;
    if (t_0) {
        return (t_0 has locked);
    }
    rfalse;
];
[ call_U400 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U401 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U402 t_0;
    if (t_0) {
        return ((t_0 has locked) == 0);
    }
    rfalse;
];
[ call_U403 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U404 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U405 t_0;
    if (t_0) {
        return (t_0 has female);
    }
    rfalse;
];
[ call_U406 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U407 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U408 t_0;
    if (t_0) {
        return ((t_0 has female) == 0);
    }
    rfalse;
];
[ call_U409 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U410 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U411 t_0;
    if (t_0) {
        return (t_0 has neuter);
    }
    rfalse;
];
[ call_U412 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 1);
    }
    rfalse;
];
[ call_U413 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 0);
    }
    rfalse;
];
[ call_U414 t_0;
    if (t_0) {
        return (t_0 has on);
    }
    rfalse;
];
[ call_U415 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U416 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U417 t_0;
    if (t_0) {
        return ((t_0 has on) == 0);
    }
    rfalse;
];
[ call_U418 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U419 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U420 t_0;
    if (1) {
        return _final_propertyvalue(SCENE_TY, t_0, A_P_recurring);
    }
    rfalse;
];
[ call_U421 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ call_U422 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U423 t_0;
    if (1) {
        return (_final_propertyvalue(SCENE_TY, t_0, A_P_recurring) == 0);
    }
    rfalse;
];
[ call_U424 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U425 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ call_U426 t_0;
    if (t_0) {
        return (t_0 has absent);
    }
    rfalse;
];
[ call_U427 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 1);
    }
    rfalse;
];
[ call_U428 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 0);
    }
    rfalse;
];
[ call_U429 t_0;
    if (t_0) {
        return (t_0 has door);
    }
    rfalse;
];
[ call_U430 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 1);
    }
    rfalse;
];
[ call_U431 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 0);
    }
    rfalse;
];
[ ADJDEFN27 t_0;
    rfalse;
];
[ ADJDEFN28 t_0;
    rfalse;
];
[ ADJDEFN29 t_0;
    rfalse;
];
[ ADJDEFN30 t_0;
    rfalse;
];
[ ADJDEFN31 t_0;
    rfalse;
];
[ ADJDEFN32 t_0;
    rfalse;
];
[ ADJDEFN33 t_0;
    rfalse;
];
[ ADJDEFN34 t_0;
    rfalse;
];
[ ADJDEFN35 t_0;
    rfalse;
];
[ ADJDEFN36 t_0;
    rfalse;
];
[ ADJDEFN37 t_0;
    rfalse;
];
[ call_U432 ch;
    if (((scene_status-->(0)) == 1)) {
        if ((deadflag ~= 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' ends]^";
            }
            if (GProperty(SCENE_TY, 1, A_P_recurring)) {
                ((scene_status-->(0)) = 0);
            } else {
                ((scene_status-->(0)) = 2);
            }
            FollowRulebook(rulebook_id_U38);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            ((scene_ended-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(2)));
            ((scene_latest_ending-->(0)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(0)) == 0)) {
        if ((deadflag == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' begins]^";
            }
            ((scene_status-->(0)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(rulebook_id_U37);
            ((scene_started-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(1)));
            ((scene_latest_ending-->(0)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U433;
    #ifdef DEBUG;
        if (((scene_status-->(0)) == 1)) {
            print "Scene 'Entire Game' playing (for ";
            print (the_time - (scene_started-->(0)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(0)) > 0)) {
                print "Scene 'Entire Game' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U434 X;
    if ((X ofclass K4_door)) {
        return (X.door_to);
    }
    rfalse;
];
[ call_U435 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        ((R.door_to) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U436 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        Relation_NowN1toV(R, A_door_to, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U437 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U434(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    if ((call_U437)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K4_door_First):Z1:(Z1 = (Z1.K4_door_Next))) {
                    if ((call_U437)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                if ((call_U437)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K4_door_First):Z1:(Z1 = (Z1.K4_door_Next))) {
                if ((call_U437)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    for ((Z3 = K4_door_First):Z3:(Z3 = (Z3.K4_door_Next))) {
                        if ((call_U437)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                        for ((Z3 = K4_door_First):Z3:(Z3 = (Z3.K4_door_Next))) {
                            if ((call_U437)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U435(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U436(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U438 X;
    if ((X ofclass K2_thing)) {
        return (X.with_key);
    }
    rfalse;
];
[ call_U439 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        ((R.with_key) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U440 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(R, A_with_key, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U441 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U438(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U441)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U441)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U441)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U441)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U441)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U441)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U439(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U440(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U442 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(PARSE_COMMAND_R, 0, 0);
    }
    (rv = (PARSE_COMMAND_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PARSE_COMMAND_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1068)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1068;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(GENERATE_ACTION_R, 0, 0);
    }
    (rv = (GENERATE_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return GENERATE_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1076)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1076;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1075)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1075;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(TIMED_EVENTS_R, 0, 0);
    }
    (rv = (TIMED_EVENTS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return TIMED_EVENTS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADVANCE_TIME_R, 0, 0);
    }
    (rv = (ADVANCE_TIME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADVANCE_TIME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2582)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2582;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1077)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1077;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADJUST_LIGHT_R, 0, 0);
    }
    (rv = (ADJUST_LIGHT_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADJUST_LIGHT_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(NOTE_OBJECT_ACQUISITIONS_R, 0, 0);
    }
    (rv = (NOTE_OBJECT_ACQUISITIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1078)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1078;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U443 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SCENE_CHANGE_MACHINERY_R, 0, 0);
    }
    (rv = (SCENE_CHANGE_MACHINERY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SCENE_CHANGE_MACHINERY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U444 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2597)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2597;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2612)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2612;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2745)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2745;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U446 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1101)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1101;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U448 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2700)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2700;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2560)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2560;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2561)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2561;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2623)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2623;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2625)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2625;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2725)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2725;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2729)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2729;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2675)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2675;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2707)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2707;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2557)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2557;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2582)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2582;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U449 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1082)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1082;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1081)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1081;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1085)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1085;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_VISIBILITY_R, 0, 0);
    }
    (rv = (BASIC_VISIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_VISIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_ACCESSIBILITY_R, 0, 0);
    }
    (rv = (BASIC_ACCESSIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_ACCESSIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2090)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2090;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1086)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1086;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(REQUESTED_ACTIONS_REQUIRE_R, 0, 0);
    }
    (rv = (REQUESTED_ACTIONS_REQUIRE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(CARRY_OUT_REQUESTED_ACTIONS_R, 0, 0);
    }
    (rv = (CARRY_OUT_REQUESTED_ACTIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(DESCEND_TO_SPECIFIC_ACTION_R, 0, 0);
    }
    (rv = (DESCEND_TO_SPECIFIC_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1087)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1087;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U450 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = selfobj);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ call_U451 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U1327)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1327;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Exit)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1443)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1443;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1469)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1469;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2602)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2602;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U452 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(WORK_OUT_DETAILS_OF_SPECIFIC_R, 0, 0);
    }
    (rv = (WORK_OUT_DETAILS_OF_SPECIFIC_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1088)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1088;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1089)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1089;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1090)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1090;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1091)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1091;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1092)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1092;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1093)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1093;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1094)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1094;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U453 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 6;
];
[ call_U454 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1095)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1095;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1096)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1096;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1097)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1097;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1098)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1098;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U455 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ACCESS_THROUGH_BARRIERS_R, 0, 0);
    }
    (rv = (ACCESS_THROUGH_BARRIERS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ACCESS_THROUGH_BARRIERS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U456 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_ROOMS_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_ROOMS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U457 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_OUTSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_OUTSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U458 forbid_breaks rv;
    (rv = (call_U1099)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1099;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U459 forbid_breaks rv;
    if ((action == ##Go)) {
        (rv = (call_U2577)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2577;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U461 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U2056)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2056;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2669)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2669;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2630)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2630;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2634)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2634;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2644)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2644;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2653)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2653;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2710)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2710;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2524)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2524;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2525)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2525;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2526)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2526;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2044)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2044;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Lock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2057)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2057;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2047)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2047;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2517)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2517;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2646)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2646;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_locking_keylessly)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2058)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2058;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Open)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2059)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2059;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_locking_keylessly)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2050)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2050;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Open)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2053)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2053;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2527)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2527;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2697)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2697;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2628)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2628;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2631)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2631;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2635)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2635;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2645)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2645;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2654)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2654;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2663)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2663;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2671)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2671;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2678)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2678;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2681)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2681;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2686)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2686;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2689)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2689;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2709)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2709;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2712)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2712;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2714)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2714;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2716)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2716;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2720)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2720;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2722)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2722;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2724)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2724;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U462 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U2009)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2009;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##ThrowAt)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2659)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2659;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2622)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2622;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2617)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2617;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Turn)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2626)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2626;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2530)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2530;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_tossing)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2649)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2649;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2618)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2618;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Go)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2610)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2610;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Listen)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2702)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2702;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Show)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2619)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2619;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Give)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2679)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2679;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2682)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2682;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2684)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2684;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2687)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2687;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2690)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2690;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2655)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2655;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##ThrowAt)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2657)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2657;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Ask)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2620)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2620;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Tell)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2621)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2621;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Ask)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2570)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2570;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2571)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2571;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2572)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2572;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Tell)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2574)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2574;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2575)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2575;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2576)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2576;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##PutOn)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2087)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2087;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2535)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2535;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Show)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2573)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2573;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2727)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2727;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2728)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2728;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2529)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2529;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2531)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2531;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2683)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2683;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Drink)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2699)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2699;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Climb)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2703)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2703;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2704)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2704;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##SwitchOff)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2726)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2726;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2744)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2744;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2629)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2629;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2633)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2633;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2516)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2516;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##LookUnder)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2540)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2540;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Push)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2604)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2604;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2605)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2605;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2734)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2734;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2735)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2735;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2523)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2523;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Drink)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2632)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2632;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2532)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2532;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Drink)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2536)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2536;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2578)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2578;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Smell)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2579)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2579;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Listen)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2580)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2580;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Touch)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2581)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2581;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2591)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2591;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Taste)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2595)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2595;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2732)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2732;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Buy)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2528)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2528;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_talking_about)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2569)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2569;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_fucking)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2587)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2587;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Touch)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2592)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2592;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Taste)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2596)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2596;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2614)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2614;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2639)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2639;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##LookUnder)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2692)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2692;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2676)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2676;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2706)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2706;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((action == ##A_talking_randomly_abou)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2568)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2568;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Kiss)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2590)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2590;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Smell)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2593)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2593;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Listen)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2594)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2594;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U465 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U2695)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2695;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2627)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2627;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2677)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2677;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2680)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2680;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2685)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2685;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2688)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2688;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2708)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2708;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2711)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2711;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2713)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2713;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2715)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2715;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2719)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2719;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2721)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2721;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2723)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2723;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Insert)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2601)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2601;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##A_hitting)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2642)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2642;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2673)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2673;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2694)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2694;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2603)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2603;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Unlock)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2598)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2598;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Eat)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2615)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2615;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2637)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2637;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2651)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2651;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2661)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2661;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2665)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2665;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Wear)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2672)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2672;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2080)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2080;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2522)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2522;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2638)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2638;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2652)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2652;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2662)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2662;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Give)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2668)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2668;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Examine)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2693)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2693;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2613)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2613;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2636)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2636;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U467 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##A_spinning_it_to)) {
        (rv = (call_U2740)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2740;
        }
        ((latest_rule_result-->(0)) = 0);
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U2741)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U2741;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Take)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1100)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1100;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Disrobe)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1646)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1646;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U472 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_RESPONSE_ISSUING_R, 0, 0);
    }
    (rv = (STANDARD_RESPONSE_ISSUING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_RESPONSE_ISSUING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U475 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1103)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1103;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U484 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_CONTENTS_LISTING_R, 0, 0);
    }
    (rv = (STANDARD_CONTENTS_LISTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_CONTENTS_LISTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U499 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2558)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2558;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U505 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1104)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1104;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U508 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2559)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2559;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U511 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2120)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2120;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U518 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2643)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2643;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2650)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2650;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2660)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2660;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2518)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2518;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2519)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2519;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U526 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1109)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1109;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1105)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1105;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1107)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1107;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1106)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1106;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1108)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1108;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2091)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2091;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U538 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1110)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1110;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1111)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1111;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1112)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1112;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1390)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1390;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U544 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_IMPLICIT_TAKING_R, 0, 0);
    }
    (rv = (STANDARD_IMPLICIT_TAKING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_IMPLICIT_TAKING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U550 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2520)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2520;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_OBITUARY_HEADLINE_R, 0, 0);
    }
    (rv = (PRINT_OBITUARY_HEADLINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_OBITUARY_HEADLINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_FINAL_SCORE_R, 0, 0);
    }
    (rv = (PRINT_FINAL_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_FINAL_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(DISPLAY_FINAL_STATUS_LINE_R, 0, 0);
    }
    (rv = (DISPLAY_FINAL_STATUS_LINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U551 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2521)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2521;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U552 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1118)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1118;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1115)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1115;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(READ_FINAL_ANSWER_R, 0, 0);
    }
    (rv = (READ_FINAL_ANSWER_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return READ_FINAL_ANSWER_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U553 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1123)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1123;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U555 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1126)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1126;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1127)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1127;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U556 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1128)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1128;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1129)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1129;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U559 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1147)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1147;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U562 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1158)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1158;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1148)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1148;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1149)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1149;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1150)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1150;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1151)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1151;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1152)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1152;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1153)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1153;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1160)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1160;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1165)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1165;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U565 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1170)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1170;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1173)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1173;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U566 forbid_breaks rv;
    (rv = (call_U1176)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1176;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InvSub;
    return GenericVerbSub(rulebook_id_U132, rulebook_id_U133, rulebook_id_U134);
];
[ InvDbg n s for_say;
    print "taking inventory";
];
[ call_U567 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1179)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1179;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1182)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1182;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1185)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1185;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1188)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1188;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1191)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1191;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1197)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1197;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1200)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1200;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1203)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1203;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1206)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1206;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1209)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1209;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1215)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1215;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2008)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2008;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U568 forbid_breaks rv;
    (rv = (call_U1219)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1219;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U569 forbid_breaks rv;
    (rv = (call_U1220)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1220;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U570 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ TakeSub;
    return GenericVerbSub(rulebook_id_U135, rulebook_id_U136, rulebook_id_U137);
];
[ TakeDbg n s for_say;
    print "taking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U571 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1185)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1185;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1225)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1225;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1228)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1228;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1231)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1231;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RemoveSub;
    return GenericVerbSub(rulebook_id_U138, rulebook_id_U139, rulebook_id_U140);
];
[ RemoveDbg n s for_say;
    print "removing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "from";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U574 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1235)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1235;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1232)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1232;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1238)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1238;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1241)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1241;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1244)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1244;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1247)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1247;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U575 forbid_breaks rv;
    (rv = (call_U1254)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1254;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U576 forbid_breaks rv;
    (rv = (call_U1255)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1255;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DropSub;
    return GenericVerbSub(rulebook_id_U141, rulebook_id_U142, rulebook_id_U143);
];
[ DropDbg n s for_say;
    print "dropping";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U577 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1260)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1260;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1261)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1261;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1262)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1262;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1265)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1265;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1268)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1268;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1271)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1271;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U578 forbid_breaks rv;
    (rv = (call_U1275)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1275;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U579 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1276)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1276;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1279)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1279;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PutOnSub;
    return GenericVerbSub(rulebook_id_U144, rulebook_id_U145, rulebook_id_U146);
];
[ PutOnDbg n s for_say;
    print "putting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U580 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2599)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2599;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2600)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2600;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1282)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1282;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1283)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1283;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1286)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1286;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1289)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1289;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1290)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1290;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1293)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1293;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1296)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1296;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1299)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1299;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U581 forbid_breaks rv;
    (rv = (call_U1303)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1303;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U582 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1304)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1304;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1307)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1307;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InsertSub;
    return GenericVerbSub(rulebook_id_U147, rulebook_id_U148, rulebook_id_U149);
];
[ InsertDbg n s for_say;
    print "inserting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "into";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U583 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1310)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1310;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1313)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1313;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1316)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1316;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1320)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1320;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U584 forbid_breaks rv;
    (rv = (call_U1321)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1321;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U585 forbid_breaks rv;
    (rv = (call_U1322)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1322;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EatSub;
    return GenericVerbSub(rulebook_id_U150, rulebook_id_U151, rulebook_id_U152);
];
[ EatDbg n s for_say;
    print "eating";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U586 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2010)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2010;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2666)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2666;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2691)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2691;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1328)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1328;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1331)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1331;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1336)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1336;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1339)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1339;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1342)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1342;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1343)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1343;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U587 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1348)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1348;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1349)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1349;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1350)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1350;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U588 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2664)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2664;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1351)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1351;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U589 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = I_parking_lot_U1);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 5;
];
[ GoSub;
    return GenericVerbSub(rulebook_id_U153, rulebook_id_U154, rulebook_id_U155);
];
[ GoDbg n s for_say;
    print "going";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U590 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1392)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1392;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1393)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1393;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1394)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1394;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1399)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1399;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1408)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1408;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1411)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1411;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1418)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1418;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1421)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1421;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U591 forbid_breaks rv;
    (rv = (call_U1432)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1432;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U592 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1433)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1433;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1442)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1442;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EnterSub;
    return GenericVerbSub(rulebook_id_U156, rulebook_id_U157, rulebook_id_U158);
];
[ EnterDbg n s for_say;
    print "entering";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U593 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2014)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2014;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1445)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1445;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1448)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1448;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1451)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1451;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U594 forbid_breaks rv;
    (rv = (call_U1452)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1452;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U595 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1453)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1453;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2019)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2019;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U596 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExitSub;
    return GenericVerbSub(rulebook_id_U159, rulebook_id_U160, rulebook_id_U161);
];
[ ExitDbg n s for_say;
    print "exiting";
];
[ call_U597 forbid_breaks rv;
    (rv = (call_U2007)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2007;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U598 forbid_breaks rv;
    (rv = (call_U1464)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1464;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U599 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1465)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1465;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2020)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2020;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GetOffSub;
    return GenericVerbSub(rulebook_id_U162, rulebook_id_U163, rulebook_id_U164);
];
[ GetOffDbg n s for_say;
    print "getting off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U601 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1470)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1470;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1472)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1472;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1479)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1479;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1482)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1482;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1483)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1483;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U602 forbid_breaks rv;
    (rv = (call_U1484)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1484;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U603 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = ##Wait);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 4;
];
[ LookSub;
    return GenericVerbSub(rulebook_id_U165, rulebook_id_U166, rulebook_id_U167);
];
[ LookDbg n s for_say;
    print "looking";
];
[ call_U605 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2589)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2589;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1487)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1487;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1488)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1488;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1491)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1491;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1498)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1498;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2548)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2548;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1506)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1506;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U606 forbid_breaks rv;
    (rv = (call_U1509)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1509;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U607 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExamineSub;
    return GenericVerbSub(rulebook_id_U168, rulebook_id_U169, rulebook_id_U170);
];
[ ExamineDbg n s for_say;
    print "examining";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U609 forbid_breaks rv;
    (rv = (call_U1512)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1512;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U610 forbid_breaks rv;
    (rv = (call_U1515)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1515;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LookUnderSub;
    return GenericVerbSub(rulebook_id_U171, rulebook_id_U172, rulebook_id_U173);
];
[ LookUnderDbg n s for_say;
    print "looking under";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U611 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1518)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1518;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1521)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1521;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U613 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1524)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1524;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1530)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1530;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1536)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1536;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SearchSub;
    return GenericVerbSub(rulebook_id_U174, rulebook_id_U175, rulebook_id_U176);
];
[ SearchDbg n s for_say;
    print "searching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U616 forbid_breaks rv;
    (rv = (call_U1539)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1539;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ConsultSub;
    return GenericVerbSub(rulebook_id_U177, rulebook_id_U178, rulebook_id_U179);
];
[ ConsultDbg n s for_say;
    print "consulting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U617 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1544)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1544;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1547)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1547;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1550)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1550;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2065)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2065;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2072)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2072;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U618 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2085)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2085;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1556)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1556;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U619 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2086)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2086;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1557)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1557;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LockSub;
    return GenericVerbSub(rulebook_id_U180, rulebook_id_U181, rulebook_id_U182);
];
[ LockDbg n s for_say;
    print "locking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U620 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1562)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1562;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1565)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1565;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2065)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2065;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2064)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2064;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U621 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2083)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2083;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1571)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1571;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U622 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2084)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2084;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1572)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1572;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ UnlockSub;
    return GenericVerbSub(rulebook_id_U183, rulebook_id_U184, rulebook_id_U185);
];
[ UnlockDbg n s for_say;
    print "unlocking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U623 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2606)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2606;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2607)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2607;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1577)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1577;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1580)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1580;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U624 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2552)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2552;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1583)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1583;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U625 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2549)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2549;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1584)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1584;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2608)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2608;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2736)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2736;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOnSub;
    return GenericVerbSub(rulebook_id_U186, rulebook_id_U187, rulebook_id_U188);
];
[ SwitchOnDbg n s for_say;
    print "switching on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U626 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1587)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1587;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1590)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1590;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U627 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2553)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2553;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1593)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1593;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U628 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1594)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1594;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2609)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2609;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2738)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2738;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOffSub;
    return GenericVerbSub(rulebook_id_U189, rulebook_id_U190, rulebook_id_U191);
];
[ SwitchOffDbg n s for_say;
    print "switching off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U629 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1597)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1597;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1600)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1600;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1603)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1603;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U630 forbid_breaks rv;
    (rv = (call_U1606)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1606;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U631 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1607)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1607;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1610)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1610;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ OpenSub;
    return GenericVerbSub(rulebook_id_U192, rulebook_id_U193, rulebook_id_U194);
];
[ OpenDbg n s for_say;
    print "opening";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U632 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1617)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1617;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1620)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1620;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U633 forbid_breaks rv;
    (rv = (call_U1623)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1623;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U634 forbid_breaks rv;
    (rv = (call_U1624)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1624;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CloseSub;
    return GenericVerbSub(rulebook_id_U195, rulebook_id_U196, rulebook_id_U197);
];
[ CloseDbg n s for_say;
    print "closing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U635 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1631)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1631;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1634)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1634;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1637)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1637;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U636 forbid_breaks rv;
    (rv = (call_U1640)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1640;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U637 forbid_breaks rv;
    (rv = (call_U1641)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1641;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WearSub;
    return GenericVerbSub(rulebook_id_U198, rulebook_id_U199, rulebook_id_U200);
];
[ WearDbg n s for_say;
    print "wearing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U638 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1647)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1647;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1650)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1650;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U639 forbid_breaks rv;
    (rv = (call_U1654)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1654;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U640 forbid_breaks rv;
    (rv = (call_U1655)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1655;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DisrobeSub;
    return GenericVerbSub(rulebook_id_U201, rulebook_id_U202, rulebook_id_U203);
];
[ DisrobeDbg n s for_say;
    print "taking off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U641 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2616)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2616;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1660)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1660;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1663)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1663;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1666)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1666;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1669)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1669;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1675)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1675;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U642 forbid_breaks rv;
    (rv = (call_U1679)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1679;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U643 forbid_breaks rv;
    (rv = (call_U1680)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1680;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GiveSub;
    return GenericVerbSub(rulebook_id_U204, rulebook_id_U205, rulebook_id_U206);
];
[ GiveDbg n s for_say;
    print "giving";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U644 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1687)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1687;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1690)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1690;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1691)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1691;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ShowSub;
    return GenericVerbSub(rulebook_id_U207, rulebook_id_U208, rulebook_id_U209);
];
[ ShowDbg n s for_say;
    print "showing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U647 forbid_breaks rv;
    (rv = (call_U1694)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1694;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeOtherSub;
    return GenericVerbSub(rulebook_id_U210, rulebook_id_U211, rulebook_id_U212);
];
[ WakeOtherDbg n s for_say;
    print "waking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U650 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1697)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1697;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1700)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1700;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1703)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1703;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThrowAtSub;
    return GenericVerbSub(rulebook_id_U213, rulebook_id_U214, rulebook_id_U215);
];
[ ThrowAtDbg n s for_say;
    print "throwing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "at";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U653 forbid_breaks rv;
    (rv = (call_U1706)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1706;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AttackSub;
    return GenericVerbSub(rulebook_id_U216, rulebook_id_U217, rulebook_id_U218);
];
[ AttackDbg n s for_say;
    print "attacking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U656 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1709)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1709;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1712)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1712;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ KissSub;
    return GenericVerbSub(rulebook_id_U219, rulebook_id_U220, rulebook_id_U221);
];
[ KissDbg n s for_say;
    print "kissing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U661 forbid_breaks rv;
    (rv = (call_U1715)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1715;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AnswerSub;
    return GenericVerbSub(rulebook_id_U222, rulebook_id_U223, rulebook_id_U224);
];
[ AnswerDbg n s for_say;
    print "answering";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "that";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U662 forbid_breaks rv;
    (rv = (call_U1718)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1718;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U664 forbid_breaks rv;
    (rv = (call_U1721)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1721;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TellSub;
    return GenericVerbSub(rulebook_id_U225, rulebook_id_U226, rulebook_id_U227);
];
[ TellDbg n s for_say;
    print "telling";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U667 forbid_breaks rv;
    (rv = (call_U1724)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1724;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskSub;
    return GenericVerbSub(rulebook_id_U228, rulebook_id_U229, rulebook_id_U230);
];
[ AskDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U668 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1727)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1727;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1728)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1728;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskForSub;
    return GenericVerbSub(rulebook_id_U231, rulebook_id_U232, rulebook_id_U233);
];
[ AskForDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "for";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U673 forbid_breaks rv;
    (rv = (call_U1729)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1729;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaitSub;
    return GenericVerbSub(rulebook_id_U234, rulebook_id_U235, rulebook_id_U236);
];
[ WaitDbg n s for_say;
    print "waiting";
];
[ call_U676 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1734)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1734;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1739)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1739;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1746)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1746;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TouchSub;
    return GenericVerbSub(rulebook_id_U237, rulebook_id_U238, rulebook_id_U239);
];
[ TouchDbg n s for_say;
    print "touching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U677 forbid_breaks rv;
    (rv = (call_U1751)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1751;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U679 forbid_breaks rv;
    (rv = (call_U1754)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1754;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveSub;
    return GenericVerbSub(rulebook_id_U240, rulebook_id_U241, rulebook_id_U242);
];
[ WaveDbg n s for_say;
    print "waving";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U680 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1759)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1759;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1762)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1762;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1765)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1765;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U682 forbid_breaks rv;
    (rv = (call_U1768)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1768;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PullSub;
    return GenericVerbSub(rulebook_id_U243, rulebook_id_U244, rulebook_id_U245);
];
[ PullDbg n s for_say;
    print "pulling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U683 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1773)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1773;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1776)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1776;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1779)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1779;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U685 forbid_breaks rv;
    (rv = (call_U1782)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1782;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushSub;
    return GenericVerbSub(rulebook_id_U246, rulebook_id_U247, rulebook_id_U248);
];
[ PushDbg n s for_say;
    print "pushing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U686 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1787)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1787;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1790)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1790;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1793)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1793;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U688 forbid_breaks rv;
    (rv = (call_U1796)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1796;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TurnSub;
    return GenericVerbSub(rulebook_id_U249, rulebook_id_U250, rulebook_id_U251);
];
[ TurnDbg n s for_say;
    print "turning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U689 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1801)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1801;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1804)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1804;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1807)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1807;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1810)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1810;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1813)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1813;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1814)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1814;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushDirSub;
    return GenericVerbSub(rulebook_id_U252, rulebook_id_U253, rulebook_id_U254);
];
[ PushDirDbg n s for_say;
    print "pushing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U692 forbid_breaks rv;
    (rv = (call_U1817)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1817;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U694 forbid_breaks rv;
    (rv = (call_U1820)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1820;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SqueezeSub;
    return GenericVerbSub(rulebook_id_U255, rulebook_id_U256, rulebook_id_U257);
];
[ SqueezeDbg n s for_say;
    print "squeezing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U695 forbid_breaks rv;
    (rv = (call_U1825)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1825;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ YesSub;
    return GenericVerbSub(rulebook_id_U258, rulebook_id_U259, rulebook_id_U260);
];
[ YesDbg n s for_say;
    print "saying yes";
];
[ call_U698 forbid_breaks rv;
    (rv = (call_U1828)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1828;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NoSub;
    return GenericVerbSub(rulebook_id_U261, rulebook_id_U262, rulebook_id_U263);
];
[ NoDbg n s for_say;
    print "saying no";
];
[ call_U701 forbid_breaks rv;
    (rv = (call_U1831)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1831;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BurnSub;
    return GenericVerbSub(rulebook_id_U264, rulebook_id_U265, rulebook_id_U266);
];
[ BurnDbg n s for_say;
    print "burning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U704 forbid_breaks rv;
    (rv = (call_U1834)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1834;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeSub;
    return GenericVerbSub(rulebook_id_U267, rulebook_id_U268, rulebook_id_U269);
];
[ WakeDbg n s for_say;
    print "waking up";
];
[ call_U707 forbid_breaks rv;
    (rv = (call_U1837)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1837;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThinkSub;
    return GenericVerbSub(rulebook_id_U270, rulebook_id_U271, rulebook_id_U272);
];
[ ThinkDbg n s for_say;
    print "thinking";
];
[ call_U712 forbid_breaks rv;
    (rv = (call_U1840)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1840;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SmellSub;
    return GenericVerbSub(rulebook_id_U273, rulebook_id_U274, rulebook_id_U275);
];
[ SmellDbg n s for_say;
    print "smelling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U715 forbid_breaks rv;
    (rv = (call_U1845)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1845;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ListenSub;
    return GenericVerbSub(rulebook_id_U276, rulebook_id_U277, rulebook_id_U278);
];
[ ListenDbg n s for_say;
    print "listening to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U718 forbid_breaks rv;
    (rv = (call_U1850)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1850;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TasteSub;
    return GenericVerbSub(rulebook_id_U279, rulebook_id_U280, rulebook_id_U281);
];
[ TasteDbg n s for_say;
    print "tasting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U719 forbid_breaks rv;
    (rv = (call_U1855)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1855;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CutSub;
    return GenericVerbSub(rulebook_id_U282, rulebook_id_U283, rulebook_id_U284);
];
[ CutDbg n s for_say;
    print "cutting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U724 forbid_breaks rv;
    (rv = (call_U1858)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1858;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ JumpSub;
    return GenericVerbSub(rulebook_id_U285, rulebook_id_U286, rulebook_id_U287);
];
[ JumpDbg n s for_say;
    print "jumping";
];
[ call_U725 forbid_breaks rv;
    (rv = (call_U1863)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1863;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TieSub;
    return GenericVerbSub(rulebook_id_U288, rulebook_id_U289, rulebook_id_U290);
];
[ TieDbg n s for_say;
    print "tying";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U728 forbid_breaks rv;
    (rv = (call_U1866)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1866;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DrinkSub;
    return GenericVerbSub(rulebook_id_U291, rulebook_id_U292, rulebook_id_U293);
];
[ DrinkDbg n s for_say;
    print "drinking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U731 forbid_breaks rv;
    (rv = (call_U1869)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1869;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SorrySub;
    return GenericVerbSub(rulebook_id_U294, rulebook_id_U295, rulebook_id_U296);
];
[ SorryDbg n s for_say;
    print "saying sorry";
];
[ call_U734 forbid_breaks rv;
    (rv = (call_U1872)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1872;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwingSub;
    return GenericVerbSub(rulebook_id_U297, rulebook_id_U298, rulebook_id_U299);
];
[ SwingDbg n s for_say;
    print "swinging";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U737 forbid_breaks rv;
    (rv = (call_U1875)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1875;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U739 forbid_breaks rv;
    (rv = (call_U1878)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1878;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RubSub;
    return GenericVerbSub(rulebook_id_U300, rulebook_id_U301, rulebook_id_U302);
];
[ RubDbg n s for_say;
    print "rubbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U740 forbid_breaks rv;
    (rv = (call_U1883)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1883;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SetToSub;
    return GenericVerbSub(rulebook_id_U303, rulebook_id_U304, rulebook_id_U305);
];
[ SetToDbg n s for_say;
    print "setting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U745 forbid_breaks rv;
    (rv = (call_U1886)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1886;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveHandsSub;
    return GenericVerbSub(rulebook_id_U306, rulebook_id_U307, rulebook_id_U308);
];
[ WaveHandsDbg n s for_say;
    print "waving hands";
];
[ call_U746 forbid_breaks rv;
    (rv = (call_U1891)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1891;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BuySub;
    return GenericVerbSub(rulebook_id_U309, rulebook_id_U310, rulebook_id_U311);
];
[ BuyDbg n s for_say;
    print "buying";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U749 forbid_breaks rv;
    (rv = (call_U1894)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1894;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ClimbSub;
    return GenericVerbSub(rulebook_id_U312, rulebook_id_U313, rulebook_id_U314);
];
[ ClimbDbg n s for_say;
    print "climbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U752 forbid_breaks rv;
    (rv = (call_U1897)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1897;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SleepSub;
    return GenericVerbSub(rulebook_id_U315, rulebook_id_U316, rulebook_id_U317);
];
[ SleepDbg n s for_say;
    print "sleeping";
];
[ call_U756 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(QUIT_THE_GAME_R, 0, 0);
    }
    (rv = (QUIT_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return QUIT_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ QuitSub;
    return GenericVerbSub(rulebook_id_U318, rulebook_id_U319, rulebook_id_U320);
];
[ QuitDbg n s for_say;
    print "quitting the game";
];
[ call_U759 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SAVE_THE_GAME_R, 0, 0);
    }
    (rv = (SAVE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SAVE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SaveSub;
    return GenericVerbSub(rulebook_id_U321, rulebook_id_U322, rulebook_id_U323);
];
[ SaveDbg n s for_say;
    print "saving the game";
];
[ call_U762 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTORE_THE_GAME_R, 0, 0);
    }
    (rv = (RESTORE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTORE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestoreSub;
    return GenericVerbSub(rulebook_id_U324, rulebook_id_U325, rulebook_id_U326);
];
[ RestoreDbg n s for_say;
    print "restoring the game";
];
[ call_U765 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTART_THE_GAME_R, 0, 0);
    }
    (rv = (RESTART_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTART_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestartSub;
    return GenericVerbSub(rulebook_id_U327, rulebook_id_U328, rulebook_id_U329);
];
[ RestartDbg n s for_say;
    print "restarting the game";
];
[ call_U768 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(VERIFY_THE_STORY_FILE_R, 0, 0);
    }
    (rv = (VERIFY_THE_STORY_FILE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VERIFY_THE_STORY_FILE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VerifySub;
    return GenericVerbSub(rulebook_id_U330, rulebook_id_U331, rulebook_id_U332);
];
[ VerifyDbg n s for_say;
    print "verifying the story file";
];
[ call_U771 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_ON_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOnSub;
    return GenericVerbSub(rulebook_id_U333, rulebook_id_U334, rulebook_id_U335);
];
[ ScriptOnDbg n s for_say;
    print "switching the story transcript on";
];
[ call_U774 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_OFF_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOffSub;
    return GenericVerbSub(rulebook_id_U336, rulebook_id_U337, rulebook_id_U338);
];
[ ScriptOffDbg n s for_say;
    print "switching the story transcript off";
];
[ call_U777 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_STORY_FILE_VERSION_R, 0, 0);
    }
    (rv = (ANNOUNCE_STORY_FILE_VERSION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VersionSub;
    return GenericVerbSub(rulebook_id_U339, rulebook_id_U340, rulebook_id_U341);
];
[ VersionDbg n s for_say;
    print "requesting the story file version";
];
[ call_U779 forbid_breaks rv;
    (rv = (call_U2585)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2585;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U780 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_SCORE_R, 0, 0);
    }
    (rv = (ANNOUNCE_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScoreSub;
    return GenericVerbSub(rulebook_id_U342, rulebook_id_U343, rulebook_id_U344);
];
[ ScoreDbg n s for_say;
    print "requesting the score";
];
[ call_U783 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U784 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode3Sub;
    return GenericVerbSub(rulebook_id_U345, rulebook_id_U346, rulebook_id_U347);
];
[ LMode3Dbg n s for_say;
    print "preferring abbreviated room descriptions";
];
[ call_U786 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U787 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode2Sub;
    return GenericVerbSub(rulebook_id_U348, rulebook_id_U349, rulebook_id_U350);
];
[ LMode2Dbg n s for_say;
    print "preferring unabbreviated room descriptions";
];
[ call_U789 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_SOMETIMES_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_SOMETIMES_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U790 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_SOMETIMES_ABBR_R, 0, 0);
    }
    (rv = (REP_PREFER_SOMETIMES_ABBR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode1Sub;
    return GenericVerbSub(rulebook_id_U351, rulebook_id_U352, rulebook_id_U353);
];
[ LMode1Dbg n s for_say;
    print "preferring sometimes abbreviated room descriptions";
];
[ call_U792 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_ON_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U793 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_ON_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOnSub;
    return GenericVerbSub(rulebook_id_U354, rulebook_id_U355, rulebook_id_U356);
];
[ NotifyOnDbg n s for_say;
    print "switching score notification on";
];
[ call_U795 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U796 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOffSub;
    return GenericVerbSub(rulebook_id_U357, rulebook_id_U358, rulebook_id_U359);
];
[ NotifyOffDbg n s for_say;
    print "switching score notification off";
];
[ call_U798 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_PRONOUN_MEANINGS_R, 0, 0);
    }
    (rv = (ANNOUNCE_PRONOUN_MEANINGS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PronounsSub;
    return GenericVerbSub(rulebook_id_U360, rulebook_id_U361, rulebook_id_U362);
];
[ PronounsDbg n s for_say;
    print "requesting the pronoun meanings";
];
[ call_U800;
    ResponseViaActivity(response_id_U1);
];
[ call_U801;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] [if story tense is present tense]now [end if]pitch dark in^[if story tense is present tense]here[else]there[end if]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U274();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now ";
    .L_Say0;
    ParaContent();
    print "pitch dark in ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say1;
    }
    ParaContent();
    print "here";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "there";
    .L_SayX1;
    ParaContent();
    print "!";
    rtrue;
];
[ ADJUST_LIGHT_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U1);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U802;
    ResponseViaActivity(response_id_U2);
];
[ call_U803;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(considering the first sixteen objects only)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(considering the first sixteen objects only)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U804;
    ResponseViaActivity(response_id_U3);
];
[ call_U805;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing to do!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ GENERATE_ACTION_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U2);
            ;
        66:
            (str = as_block_constant_U3);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U806;
    ResponseViaActivity(response_id_U4);
];
[ call_U807;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name something more substantial.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name something more substantial.";
    rtrue;
];
[ BASIC_ACCESSIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U4);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U808;
    ResponseViaActivity(response_id_U5);
];
[ call_U809;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] pitch dark, and [we] [can't see] a thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U274();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ BASIC_VISIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U5);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U810;
    ResponseViaActivity(response_id_U6);
];
[ call_U811;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [have] better things to do.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " better things to do.";
    rtrue;
];
[ REQUESTED_ACTIONS_REQUIRE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U6);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U812;
    ResponseViaActivity(response_id_U7);
];
[ call_U813;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] unable to do that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to do that.";
    rtrue;
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U7);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U814;
    ResponseViaActivity(response_id_U8);
];
[ call_U815;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [aren't] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ ACCESS_THROUGH_BARRIERS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U8);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U816;
    ResponseViaActivity(response_id_U9);
];
[ call_U817;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U9);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U818;
    ResponseViaActivity(response_id_U10);
];
[ call_U819;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] reach into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " reach into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ CANT_REACH_INSIDE_ROOMS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U10);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U820;
    ResponseViaActivity(response_id_U11);
];
[ call_U821;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_OUTSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U11);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U822;
    ResponseViaActivity(response_id_U12);
];
[ call_U823;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (";
    rtrue;
];
[ call_U824;
    ResponseViaActivity(response_id_U13);
];
[ call_U825;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~)~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U826;
    ResponseViaActivity(response_id_U14);
];
[ call_U827;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ and ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " and ";
    rtrue;
];
[ call_U828;
    ResponseViaActivity(response_id_U15);
];
[ call_U829;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "providing light";
    rtrue;
];
[ call_U830;
    ResponseViaActivity(response_id_U16);
];
[ call_U831;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U832;
    ResponseViaActivity(response_id_U17);
];
[ call_U833;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "empty";
    rtrue;
];
[ call_U834;
    ResponseViaActivity(response_id_U18);
];
[ call_U835;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and empty";
    rtrue;
];
[ call_U836;
    ResponseViaActivity(response_id_U19);
];
[ call_U837;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and providing light";
    rtrue;
];
[ call_U838;
    ResponseViaActivity(response_id_U20);
];
[ call_U839;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~empty and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "empty and providing light";
    rtrue;
];
[ call_U840;
    ResponseViaActivity(response_id_U21);
];
[ call_U841;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed, empty[if serial comma option is active],[end if] and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed, empty";
    if ((~~(call_U150(use_option_id_U3)))) {
        jump L_Say0;
    }
    ParaContent();
    print ",";
    .L_Say0;
    ParaContent();
    print " and providing light";
    rtrue;
];
[ call_U842;
    ResponseViaActivity(response_id_U22);
];
[ call_U843;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~providing light and being worn~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "providing light and being worn";
    rtrue;
];
[ call_U844;
    ResponseViaActivity(response_id_U23);
];
[ call_U845;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~being worn~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "being worn";
    rtrue;
];
[ call_U846;
    ResponseViaActivity(response_id_U24);
];
[ call_U847;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~open~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "open";
    rtrue;
];
[ call_U848;
    ResponseViaActivity(response_id_U25);
];
[ call_U849;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~open but empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "open but empty";
    rtrue;
];
[ call_U850;
    ResponseViaActivity(response_id_U26);
];
[ call_U851;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U852;
    ResponseViaActivity(response_id_U27);
];
[ call_U853;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and locked~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and locked";
    rtrue;
];
[ call_U854;
    ResponseViaActivity(response_id_U28);
];
[ call_U855;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~containing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "containing";
    rtrue;
];
[ call_U856;
    ResponseViaActivity(response_id_U29);
];
[ call_U857;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~on [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "on ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U858;
    ResponseViaActivity(response_id_U30);
];
[ call_U859;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, on top of [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", on top of ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U860;
    ResponseViaActivity(response_id_U31);
];
[ call_U861;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~in [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "in ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U862;
    ResponseViaActivity(response_id_U32);
];
[ call_U863;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, inside [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", inside ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U864;
    ResponseViaActivity(response_id_U33);
];
[ call_U865;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding list writer internals][are]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U866;
    ResponseViaActivity(response_id_U34);
];
[ call_U867;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding list writer internals][are] nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing";
    rtrue;
];
[ call_U868;
    ResponseViaActivity(response_id_U35);
];
[ call_U869;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing";
    rtrue;
];
[ call_U870;
    ResponseViaActivity(response_id_U36);
];
[ call_U871;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "nothing";
    rtrue;
];
[ LIST_WRITER_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U12);
            ;
        66:
            (str = as_block_constant_U13);
            ;
        67:
            (str = as_block_constant_U14);
            ;
        68:
            (str = as_block_constant_U15);
            ;
        69:
            (str = as_block_constant_U16);
            ;
        70:
            (str = as_block_constant_U17);
            ;
        71:
            (str = as_block_constant_U18);
            ;
        72:
            (str = as_block_constant_U19);
            ;
        73:
            (str = as_block_constant_U20);
            ;
        74:
            (str = as_block_constant_U21);
            ;
        75:
            (str = as_block_constant_U22);
            ;
        76:
            (str = as_block_constant_U23);
            ;
        77:
            (str = as_block_constant_U24);
            ;
        78:
            (str = as_block_constant_U25);
            ;
        79:
            (str = as_block_constant_U26);
            ;
        80:
            (str = as_block_constant_U27);
            ;
        81:
            (str = as_block_constant_U28);
            ;
        82:
            (str = as_block_constant_U29);
            ;
        83:
            (str = as_block_constant_U30);
            ;
        84:
            (str = as_block_constant_U31);
            ;
        85:
            (str = as_block_constant_U32);
            ;
        86:
            (str = as_block_constant_U33);
            ;
        87:
            (str = as_block_constant_U34);
            ;
        88:
            (str = as_block_constant_U35);
            ;
        89:
            (str = as_block_constant_U36);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U872;
    ResponseViaActivity(response_id_U37);
];
[ call_U873;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]That command asks to do something outside of play, so it can^only make sense from you to me. [The noun] cannot be asked to do this.[close^bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "That command asks to do something outside of play, so it can only make sense from you to me. ";
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " cannot be asked to do this.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U874;
    ResponseViaActivity(response_id_U38);
];
[ call_U875;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name an object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name an object.";
    rtrue;
];
[ call_U876;
    ResponseViaActivity(response_id_U39);
];
[ call_U877;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not name an object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not name an object.";
    rtrue;
];
[ call_U878;
    ResponseViaActivity(response_id_U40);
];
[ call_U879;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must supply a noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must supply a noun.";
    rtrue;
];
[ call_U880;
    ResponseViaActivity(response_id_U41);
];
[ call_U881;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not supply a noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not supply a noun.";
    rtrue;
];
[ call_U882;
    ResponseViaActivity(response_id_U42);
];
[ call_U883;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name a second object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name a second object.";
    rtrue;
];
[ call_U884;
    ResponseViaActivity(response_id_U43);
];
[ call_U885;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not name a second object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not name a second object.";
    rtrue;
];
[ call_U886;
    ResponseViaActivity(response_id_U44);
];
[ call_U887;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must supply a second noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must supply a second noun.";
    rtrue;
];
[ call_U888;
    ResponseViaActivity(response_id_U45);
];
[ call_U889;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not supply a second noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not supply a second noun.";
    rtrue;
];
[ call_U890;
    ResponseViaActivity(response_id_U46);
];
[ call_U891;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(Since something dramatic has happened, your list of commands has been^cut short.)~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(Since something dramatic has happened, your list of commands has been cut short.)";
    rtrue;
];
[ call_U892;
    ResponseViaActivity(response_id_U47);
];
[ call_U893;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that instruction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that instruction.";
    rtrue;
];
[ ACTION_PROCESSING_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U37);
            ;
        66:
            (str = as_block_constant_U38);
            ;
        67:
            (str = as_block_constant_U39);
            ;
        68:
            (str = as_block_constant_U40);
            ;
        69:
            (str = as_block_constant_U41);
            ;
        70:
            (str = as_block_constant_U42);
            ;
        71:
            (str = as_block_constant_U43);
            ;
        72:
            (str = as_block_constant_U44);
            ;
        73:
            (str = as_block_constant_U45);
            ;
        74:
            (str = as_block_constant_U46);
            ;
        75:
            (str = as_block_constant_U47);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U894;
    ResponseViaActivity(response_id_U48);
];
[ call_U895;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that sentence.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that sentence.";
    rtrue;
];
[ call_U896;
    ResponseViaActivity(response_id_U49);
];
[ call_U897;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I only understood you as far as wanting to ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to ";
    rtrue;
];
[ call_U898;
    ResponseViaActivity(response_id_U50);
];
[ call_U899;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I only understood you as far as wanting to (go) ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to (go) ";
    rtrue;
];
[ call_U900;
    ResponseViaActivity(response_id_U51);
];
[ call_U901;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that number.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that number.";
    rtrue;
];
[ call_U902;
    ResponseViaActivity(response_id_U52);
];
[ call_U903;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] see any such thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see any such thing.";
    rtrue;
];
[ call_U904;
    ResponseViaActivity(response_id_U53);
];
[ call_U905;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You seem to have said too little!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You seem to have said too little!";
    rtrue;
];
[ call_U906;
    ResponseViaActivity(response_id_U54);
];
[ call_U907;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding that!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding that!";
    rtrue;
];
[ call_U908;
    ResponseViaActivity(response_id_U55);
];
[ call_U909;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't use multiple objects with that verb.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't use multiple objects with that verb.";
    rtrue;
];
[ call_U910;
    ResponseViaActivity(response_id_U56);
];
[ call_U911;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can only use multiple objects once on a line.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can only use multiple objects once on a line.";
    rtrue;
];
[ call_U912;
    ResponseViaActivity(response_id_U57);
];
[ call_U913;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I'm not sure what ['][pronoun i6 dictionary word]['] refers to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I'm not sure what ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " refers to.";
    rtrue;
];
[ call_U914;
    ResponseViaActivity(response_id_U58);
];
[ call_U915;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] see ['][pronoun i6 dictionary word]['] ([the noun]) at the moment.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " (";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ") at the moment.";
    rtrue;
];
[ call_U916;
    ResponseViaActivity(response_id_U59);
];
[ call_U917;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You excepted something not included anyway!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You excepted something not included anyway!";
    rtrue;
];
[ call_U918;
    ResponseViaActivity(response_id_U60);
];
[ call_U919;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can only do that to something animate.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can only do that to something animate.";
    rtrue;
];
[ call_U920;
    ResponseViaActivity(response_id_U61);
];
[ call_U921;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That's not a verb I [if American dialect option is^active]recognize[otherwise]recognise[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That's not a verb I ";
    if ((~~(call_U150(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "recognize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "recognise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U922;
    ResponseViaActivity(response_id_U62);
];
[ call_U923;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That's not something you need to refer to in the course of this game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That's not something you need to refer to in the course of this game.";
    rtrue;
];
[ call_U924;
    ResponseViaActivity(response_id_U63);
];
[ call_U925;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand the way that finished.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand the way that finished.";
    rtrue;
];
[ call_U926;
    ResponseViaActivity(response_id_U64);
];
[ call_U927;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if number understood is 0]None[otherwise]Only [number understood in words][end if]^of those [regarding the number understood][are] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((parsed_number == 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "None";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Only ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    .L_SayX0;
    ParaContent();
    print " of those ";
    ParaContent();
    RegardingNumber(parsed_number);
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U928;
    ResponseViaActivity(response_id_U65);
];
[ call_U929;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That noun did not make sense in this context.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That noun did not make sense in this context.";
    rtrue;
];
[ call_U930;
    ResponseViaActivity(response_id_U66);
];
[ call_U931;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
    rtrue;
];
[ call_U932;
    ResponseViaActivity(response_id_U67);
];
[ call_U933;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't begin with a comma.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't begin with a comma.";
    rtrue;
];
[ call_U934;
    ResponseViaActivity(response_id_U68);
];
[ call_U935;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You seem to want to talk to someone, but I can't see whom.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You seem to want to talk to someone, but I can't see whom.";
    rtrue;
];
[ call_U936;
    ResponseViaActivity(response_id_U69);
];
[ call_U937;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't talk to [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't talk to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U938;
    ResponseViaActivity(response_id_U70);
];
[ call_U939;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To talk to someone, try 'someone, hello' or some such.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To talk to someone, try ~someone, hello~ or some such.";
    rtrue;
];
[ call_U940;
    ResponseViaActivity(response_id_U71);
];
[ call_U941;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I beg your pardon?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I beg your pardon?";
    rtrue;
];
[ PARSER_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U48);
            ;
        66:
            (str = as_block_constant_U49);
            ;
        67:
            (str = as_block_constant_U50);
            ;
        68:
            (str = as_block_constant_U51);
            ;
        69:
            (str = as_block_constant_U52);
            ;
        70:
            (str = as_block_constant_U53);
            ;
        71:
            (str = as_block_constant_U54);
            ;
        72:
            (str = as_block_constant_U55);
            ;
        73:
            (str = as_block_constant_U56);
            ;
        74:
            (str = as_block_constant_U57);
            ;
        75:
            (str = as_block_constant_U58);
            ;
        76:
            (str = as_block_constant_U59);
            ;
        77:
            (str = as_block_constant_U60);
            ;
        78:
            (str = as_block_constant_U61);
            ;
        79:
            (str = as_block_constant_U62);
            ;
        80:
            (str = as_block_constant_U63);
            ;
        81:
            (str = as_block_constant_U64);
            ;
        82:
            (str = as_block_constant_U65);
            ;
        83:
            (str = as_block_constant_U66);
            ;
        84:
            (str = as_block_constant_U67);
            ;
        85:
            (str = as_block_constant_U68);
            ;
        86:
            (str = as_block_constant_U69);
            ;
        87:
            (str = as_block_constant_U70);
            ;
        88:
            (str = as_block_constant_U71);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U942;
    ResponseViaActivity(response_id_U72);
];
[ call_U943;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing to do!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ call_U944;
    ResponseViaActivity(response_id_U73);
];
[ call_U945;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [adapt the verb are from the third person plural] none at all available!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ParaContent();
    (call_U2893)(CV_POS,I_third_person_plural_U1,story_tense);
    ParaContent();
    print " none at all available!";
    rtrue;
];
[ call_U946;
    ResponseViaActivity(response_id_U74);
];
[ call_U947;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U948;
    ResponseViaActivity(response_id_U75);
];
[ call_U949;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [can't] contain things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " contain things.";
    rtrue;
];
[ call_U950;
    ResponseViaActivity(response_id_U76);
];
[ call_U951;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U952;
    ResponseViaActivity(response_id_U77);
];
[ call_U953;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ PARSER_N_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U72);
            ;
        66:
            (str = as_block_constant_U73);
            ;
        67:
            (str = as_block_constant_U74);
            ;
        68:
            (str = as_block_constant_U75);
            ;
        69:
            (str = as_block_constant_U76);
            ;
        70:
            (str = as_block_constant_U77);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U954;
    ResponseViaActivity(response_id_U78);
];
[ call_U955;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Darkness~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ DARKNESS_NAME_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U78);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U956;
    ResponseViaActivity(response_id_U79);
];
[ call_U957;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Sorry, that can't be corrected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Sorry, that can't be corrected.";
    rtrue;
];
[ call_U958;
    ResponseViaActivity(response_id_U80);
];
[ call_U959;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Think nothing of it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Think nothing of it.";
    rtrue;
];
[ call_U960;
    ResponseViaActivity(response_id_U81);
];
[ call_U961;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Oops' can only correct a single word.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Oops~ can only correct a single word.";
    rtrue;
];
[ call_U962;
    ResponseViaActivity(response_id_U82);
];
[ call_U963;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can hardly repeat that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can hardly repeat that.";
    rtrue;
];
[ PARSER_COMMAND_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U79);
            ;
        66:
            (str = as_block_constant_U80);
            ;
        67:
            (str = as_block_constant_U81);
            ;
        68:
            (str = as_block_constant_U82);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U964;
    ResponseViaActivity(response_id_U83);
];
[ call_U965;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Who do you mean, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Who do you mean, ";
    rtrue;
];
[ call_U966;
    ResponseViaActivity(response_id_U84);
];
[ call_U967;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Which do you mean, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Which do you mean, ";
    rtrue;
];
[ call_U968;
    ResponseViaActivity(response_id_U85);
];
[ call_U969;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Sorry, you can only have one item here. Which exactly?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Sorry, you can only have one item here. Which exactly?";
    rtrue;
];
[ call_U970;
    ResponseViaActivity(response_id_U86);
];
[ call_U971;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Whom do you want [if the noun is not the player][the noun] [end if]to^[parser command so far]?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Whom do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U972;
    ResponseViaActivity(response_id_U87);
];
[ call_U973;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What do you want [if the noun is not the player][the noun] [end if]to^[parser command so far]?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U974;
    ResponseViaActivity(response_id_U88);
];
[ call_U975;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~those things~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "those things";
    rtrue;
];
[ call_U976;
    ResponseViaActivity(response_id_U89);
];
[ call_U977;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~that~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "that";
    rtrue;
];
[ call_U978;
    ResponseViaActivity(response_id_U90);
];
[ call_U979;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ or ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ PARSER_CLARIF_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U83);
            ;
        66:
            (str = as_block_constant_U84);
            ;
        67:
            (str = as_block_constant_U85);
            ;
        68:
            (str = as_block_constant_U86);
            ;
        69:
            (str = as_block_constant_U87);
            ;
        70:
            (str = as_block_constant_U88);
            ;
        71:
            (str = as_block_constant_U89);
            ;
        72:
            (str = as_block_constant_U90);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U980;
    ResponseViaActivity(response_id_U91);
];
[ call_U981;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Please answer yes or no.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Please answer yes or no.";
    rtrue;
];
[ YES_OR_NO_QUESTION_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U91);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U982;
    ResponseViaActivity(response_id_U92);
];
[ call_U983;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    rtrue;
];
[ call_U984;
    ResponseViaActivity(response_id_U93);
];
[ call_U985;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[ourselves]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U251();
    rtrue;
];
[ call_U986;
    ResponseViaActivity(response_id_U94);
];
[ call_U987;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[our] former self~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U252();
    ParaContent();
    print " former self";
    rtrue;
];
[ PRINT_PROTAGONIST_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U92);
            ;
        66:
            (str = as_block_constant_U93);
            ;
        67:
            (str = as_block_constant_U94);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U988;
    ResponseViaActivity(response_id_U95);
];
[ call_U989;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U990;
    ResponseViaActivity(response_id_U96);
];
[ call_U991;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~([the second noun] first taking [the noun])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ STANDARD_IMPLICIT_TAKING_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U95);
            ;
        66:
            (str = as_block_constant_U96);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U992;
    ResponseViaActivity(response_id_U97);
];
[ call_U993;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ You have died ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " You have died ";
    rtrue;
];
[ call_U994;
    ResponseViaActivity(response_id_U98);
];
[ call_U995;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ You have won ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " You have won ";
    rtrue;
];
[ call_U996;
    ResponseViaActivity(response_id_U99);
];
[ call_U997;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ The End ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " The End ";
    rtrue;
];
[ PRINT_OBITUARY_HEADLINE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U97);
            ;
        66:
            (str = as_block_constant_U98);
            ;
        67:
            (str = as_block_constant_U99);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U998;
    ResponseViaActivity(response_id_U100);
];
[ call_U999;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The use of 'undo' is forbidden in this story.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The use of ~undo~ is forbidden in this story.";
    rtrue;
];
[ call_U1000;
    ResponseViaActivity(response_id_U101);
];
[ call_U1001;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't 'undo' what hasn't been done!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't ~undo~ what hasn't been done!";
    rtrue;
];
[ call_U1002;
    ResponseViaActivity(response_id_U102);
];
[ call_U1003;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Your interpreter does not provide 'undo'. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Your interpreter does not provide ~undo~. Sorry!";
    rtrue;
];
[ call_U1004;
    ResponseViaActivity(response_id_U103);
];
[ call_U1005;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Undo' failed. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Undo~ failed. Sorry!";
    rtrue;
];
[ call_U1006;
    ResponseViaActivity(response_id_U104);
];
[ call_U1007;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Previous turn undone.[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Previous turn undone.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U1008;
    ResponseViaActivity(response_id_U105);
];
[ call_U1009;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Undo' capacity exhausted. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Undo~ capacity exhausted. Sorry!";
    rtrue;
];
[ IMMEDIATELY_UNDO_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U100);
            ;
        66:
            (str = as_block_constant_U101);
            ;
        67:
            (str = as_block_constant_U102);
            ;
        68:
            (str = as_block_constant_U103);
            ;
        69:
            (str = as_block_constant_U104);
            ;
        70:
            (str = as_block_constant_U105);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1010;
    ResponseViaActivity(response_id_U106);
];
[ call_U1011;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Are you sure you want to quit? ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to quit? ";
    rtrue;
];
[ QUIT_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U106);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1012;
    ResponseViaActivity(response_id_U107);
];
[ call_U1013;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Save failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Save failed.";
    rtrue;
];
[ call_U1014;
    ResponseViaActivity(response_id_U108);
];
[ call_U1015;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Ok.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ SAVE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U107);
            ;
        66:
            (str = as_block_constant_U108);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1016;
    ResponseViaActivity(response_id_U109);
];
[ call_U1017;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Restore failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Restore failed.";
    rtrue;
];
[ call_U1018;
    ResponseViaActivity(response_id_U110);
];
[ call_U1019;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Ok.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ RESTORE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U109);
            ;
        66:
            (str = as_block_constant_U110);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1020;
    ResponseViaActivity(response_id_U111);
];
[ call_U1021;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Are you sure you want to restart? ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to restart? ";
    rtrue;
];
[ call_U1022;
    ResponseViaActivity(response_id_U112);
];
[ call_U1023;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Failed.";
    rtrue;
];
[ RESTART_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U111);
            ;
        66:
            (str = as_block_constant_U112);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1024;
    ResponseViaActivity(response_id_U113);
];
[ call_U1025;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game file has verified as intact.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game file has verified as intact.";
    rtrue;
];
[ call_U1026;
    ResponseViaActivity(response_id_U114);
];
[ call_U1027;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game file did not verify as intact, and may be corrupt.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game file did not verify as intact, and may be corrupt.";
    rtrue;
];
[ VERIFY_THE_STORY_FILE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U113);
            ;
        66:
            (str = as_block_constant_U114);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1028;
    ResponseViaActivity(response_id_U115);
];
[ call_U1029;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Transcripting is already on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already on.";
    rtrue;
];
[ call_U1030;
    ResponseViaActivity(response_id_U116);
];
[ call_U1031;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Start of a transcript of:~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Start of a transcript of:";
    rtrue;
];
[ call_U1032;
    ResponseViaActivity(response_id_U117);
];
[ call_U1033;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Attempt to begin transcript failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Attempt to begin transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U115);
            ;
        66:
            (str = as_block_constant_U116);
            ;
        67:
            (str = as_block_constant_U117);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1034;
    ResponseViaActivity(response_id_U118);
];
[ call_U1035;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Transcripting is already off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already off.";
    rtrue;
];
[ call_U1036;
    ResponseViaActivity(response_id_U119);
];
[ call_U1037;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[line break]End of transcript.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "^";
    ParaContent();
    print "End of transcript.";
    rtrue;
];
[ call_U1038;
    ResponseViaActivity(response_id_U120);
];
[ call_U1039;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Attempt to end transcript failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Attempt to end transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U118);
            ;
        66:
            (str = as_block_constant_U119);
            ;
        67:
            (str = as_block_constant_U120);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1040;
    ResponseViaActivity(response_id_U121);
];
[ call_U1041;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the story has ended]In that game you scored[otherwise]You have so far scored[end if]^[score] out of a possible [maximum score], in [turn count] turn[s]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((deadflag ~= 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "In that game you scored";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "You have so far scored";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    print (say__n = score);
    ParaContent();
    print " out of a possible ";
    ParaContent();
    print (say__n = MAX_SCORE);
    ParaContent();
    print ", in ";
    ParaContent();
    print (say__n = turns);
    ParaContent();
    print " turn";
    ParaContent();
    STextSubstitution();
    rtrue;
];
[ call_U1042;
    ResponseViaActivity(response_id_U122);
];
[ call_U1043;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, earning you the rank of ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", earning you the rank of ";
    rtrue;
];
[ call_U1044;
    ResponseViaActivity(response_id_U123);
];
[ call_U1045;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no score in this story.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no score in this story.";
    rtrue;
];
[ call_U1046;
    ResponseViaActivity(response_id_U124);
];
[ call_U1047;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Your score has just gone up by [number understood in words]^point[s].[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone up by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U1048;
    ResponseViaActivity(response_id_U125);
];
[ call_U1049;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Your score has just gone down by [number understood in words]^point[s].[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone down by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ ANNOUNCE_SCORE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U121);
            ;
        66:
            (str = as_block_constant_U122);
            ;
        67:
            (str = as_block_constant_U123);
            ;
        68:
            (str = as_block_constant_U124);
            ;
        69:
            (str = as_block_constant_U125);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1050;
    ResponseViaActivity(response_id_U126);
];
[ call_U1051;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'superbrief' mode, which always gives short descriptions^of locations (even if you haven't been there before).~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~superbrief~ mode, which always gives short descriptions of locations (even if you haven't been there before).";
    rtrue;
];
[ REP_PREFER_ABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U126);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1052;
    ResponseViaActivity(response_id_U127);
];
[ call_U1053;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'verbose' mode, which always gives long descriptions of^locations (even if you've been there before).~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~verbose~ mode, which always gives long descriptions of locations (even if you've been there before).";
    rtrue;
];
[ REP_PREFER_UNABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U127);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1054;
    ResponseViaActivity(response_id_U128);
];
[ call_U1055;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'brief' printing mode, which gives long descriptions^of places never before visited and short descriptions otherwise.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~brief~ printing mode, which gives long descriptions of places never before visited and short descriptions otherwise.";
    rtrue;
];
[ REP_PREFER_SOMETIMES_ABBR_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U128);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1056;
    ResponseViaActivity(response_id_U129);
];
[ call_U1057;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Score notification on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Score notification on.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U129);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1058;
    ResponseViaActivity(response_id_U130);
];
[ call_U1059;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Score notification off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Score notification off.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U130);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1060;
    ResponseViaActivity(response_id_U131);
];
[ call_U1061;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~At the moment, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "At the moment, ";
    rtrue;
];
[ call_U1062;
    ResponseViaActivity(response_id_U132);
];
[ call_U1063;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~means ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "means ";
    rtrue;
];
[ call_U1064;
    ResponseViaActivity(response_id_U133);
];
[ call_U1065;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~is unset~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "is unset";
    rtrue;
];
[ call_U1066;
    ResponseViaActivity(response_id_U134);
];
[ call_U1067;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~no pronouns are known to the game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "no pronouns are known to the game.";
    rtrue;
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U131);
            ;
        66:
            (str = as_block_constant_U132);
            ;
        67:
            (str = as_block_constant_U133);
            ;
        68:
            (str = as_block_constant_U134);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U1068 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1068, 368, 0);
    }
    for (((tmp_0 = (call_U1069)(0)),(tmp_1 = (call_U1069)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U1069)(tmp_1)))) {
        call_U371(tmp_0);
    }
    rfalse;
];
[ call_U1069 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1070;
    if (debug_rules) {
        DB_Rule(call_U1070, 369, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U1071;
    if (debug_rules) {
        DB_Rule(call_U1071, 370, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U14));
    rfalse;
];
[ call_U1072;
    if (debug_rules) {
        DB_Rule(call_U1072, 371, 0);
    }
    (last_score = score);
    rfalse;
];
[ call_U1073;
    if (debug_rules) {
        DB_Rule(call_U1073, 372, 0);
    }
    (say__p = 1);
    ParaContent();
    Banner();
    rfalse;
];
[ call_U1074;
    if (debug_rules) {
        DB_Rule(call_U1074, 373, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U1075;
    if (debug_rules) {
        DB_Rule(call_U1075, 374, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U18));
    rfalse;
];
[ call_U1076;
    if (debug_rules) {
        DB_Rule(call_U1076, 375, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U1077;
    if (debug_rules) {
        DB_Rule(call_U1077, 376, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U1078;
    if (debug_rules) {
        DB_Rule(call_U1078, 377, 0);
    }
    if ((~~((score == last_score)))) {
        NotifyTheScore();
        (last_score = score);
    }
    rfalse;
];
[ call_U1079;
    if (debug_rules) {
        DB_Rule(call_U1079, 378, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U15));
    rfalse;
];
[ call_U1080;
    if (debug_rules) {
        DB_Rule(call_U1080, 379, 0);
    }
    CarryOutActivity(V30_printing_the_player_s_obi);
    rfalse;
];
[ call_U1081;
    if (debug_rules) {
        DB_Rule(call_U1081, 380, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        PronounNotice(multiple_object_item);
    }
    rfalse;
];
[ call_U1082;
    if (debug_rules) {
        DB_Rule(call_U1082, 381, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U135);
    }
    rfalse;
];
[ call_U1083;
    ResponseViaActivity(response_id_U135);
];
[ call_U1084;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[current item from the multiple object list]: [run paragraph on]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    PrintShortName(multiple_object_item);
    ParaContent();
    print ": ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U1085;
    if (debug_rules) {
        DB_Rule(call_U1085, 382, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U29))) {
        rtrue;
    }
    rfalse;
];
[ call_U1086;
    if (debug_rules) {
        DB_Rule(call_U1086, 383, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U30))) {
        rtrue;
    }
    rfalse;
];
[ call_U1087;
    if (debug_rules) {
        DB_Rule(call_U1087, 384, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1088;
    if (debug_rules) {
        DB_Rule(call_U1088, 385, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
    if (RulebookSucceeded()) {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
    } else {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 0);
    }
    rfalse;
];
[ call_U1089;
    if (debug_rules) {
        DB_Rule(call_U1089, 386, 0);
    }
    if ((temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 2))))))) {
        if (RulebookSucceeded()) {
            ActRulebookSucceeds(temporary_value);
        } else {
            ActRulebookFails(temporary_value);
        }
        return 2;
    }
    rfalse;
];
[ call_U1090;
    if (debug_rules) {
        DB_Rule(call_U1090, 387, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 3)))));
    rfalse;
];
[ call_U1091;
    if (debug_rules) {
        DB_Rule(call_U1091, 388, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 0))) == 1)) {
        if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U33))) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1092;
    if (debug_rules) {
        DB_Rule(call_U1092, 389, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 5))) == 0)) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
        if (RulebookSucceeded()) {
            ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
        }
    }
    rfalse;
];
[ call_U1093;
    if (debug_rules) {
        DB_Rule(call_U1093, 390, 0);
    }
    if (((((MStack-->(MstVO(rulebook_id_U21, 5))) == 1)) && (((MStack-->(MstVO(rulebook_id_U21, 1))) == 0)))) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 4)))));
    }
    rfalse;
];
[ call_U1094;
    if (debug_rules) {
        DB_Rule(call_U1094, 391, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1095;
    if (debug_rules) {
        DB_Rule(call_U1095, 392, 0);
    }
    if ((player == actor)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1096;
    if (debug_rules) {
        DB_Rule(call_U1096, 393, 0);
    }
    if ((((~~((player == actor)))) && (TestVisibility(player, actor)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1097;
    if (debug_rules) {
        DB_Rule(call_U1097, 394, 0);
    }
    if ((((noun ofclass K2_thing)) && (TestVisibility(player, noun)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1098;
    if (debug_rules) {
        DB_Rule(call_U1098, 395, 0);
    }
    if ((((second ofclass K2_thing)) && (TestVisibility(player, second)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1099;
    if (debug_rules) {
        DB_Rule(call_U1099, 396, 0);
    }
    if ((location == thedark)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1100;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((player == CarrierOf(noun))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1100, 397, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_unlikely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1100, 397, 2);
        }
    }
    rfalse;
];
[ call_U1101 tmp_0;
    if (((((tmp_0 = parameter_value),((1) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = I_entire_game_U1),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1101, 398, 0);
        }
        if ((~~(((BlkValueCompare)(GProperty(SCENE_TY, tmp_0, A_description),bc_U237) == 0)))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(SCENE_TY, (self = tmp_0), A_description));
            @pull self;
            ParaContent();
            DivideParagraphPoint();
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1101, 398, 2);
        }
    }
    rfalse;
];
[ call_U1102 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1102, 399, 0);
        }
        if (say__comp) {
            rfalse;
        }
        call_U370(tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1102, 399, 2);
        }
    }
    rfalse;
];
[ call_U1103 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1103, 400, 0);
        }
        (say__p = 1);
        ParaContent();
        LanguageNumber((say__n = listing_size));
        ParaContent();
        print " ";
        CarryOutActivity(V3_printing_the_plural_name, tmp_0);
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1103, 400, 2);
        }
    }
    rfalse;
];
[ call_U1104;
    if (debug_rules) {
        DB_Rule(call_U1104, 401, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U1105;
    if (call_U345(parameter_value)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1105, 402, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1105, 402, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1105, 402, 2);
        }
    }
    rfalse;
];
[ call_U1106;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1106, 403, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1106, 403, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1106, 403, 2);
        }
    }
    rfalse;
];
[ call_U1107;
    if ((((parameter_value ofclass K2_thing)) && (call_U339(parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1107, 404, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1107, 404, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1107, 404, 2);
        }
    }
    rfalse;
];
[ call_U1108;
    if ((((parameter_value ofclass K2_thing)) && (IndirectlyContains(actor, parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((action == ##Disrobe)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U1108, 405, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1108, 405, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1108, 405, 2);
        }
    }
    rfalse;
];
[ call_U1109;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Drop)) && ((actor == player)))) || ((((((action == ##A_throwing)) && ((actor == player)))) || ((((((action == ##Insert)) && ((actor == player)))) || ((((action == ##PutOn)) && ((actor == player)))))))))) {
            if (debug_rules) {
                DB_Rule(call_U1109, 406, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1109, 406, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1109, 406, 2);
        }
    }
    rfalse;
];
[ call_U1110;
    if ((((action == ##Smell)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1110, 407, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1110, 407, 4);
        }
    }
    rfalse;
];
[ call_U1111;
    if ((((action == ##Listen)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1111, 408, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1111, 408, 4);
        }
    }
    rfalse;
];
[ call_U1112;
    if ((((action == ##Go)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1112, 409, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U136);
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1112, 409, 4);
        }
    }
    rfalse;
];
[ call_U1113;
    ResponseViaActivity(response_id_U136);
];
[ call_U1114;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You'll have to say which compass direction to go in.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You'll have to say which compass direction to go in.";
    rtrue;
];
[ call_U1115;
    if (debug_rules) {
        DB_Rule(call_U1115, 410, 0);
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(as_block_constant_U137);
    rfalse;
];
[ call_U1116;
    ResponseViaActivity(response_id_U137);
];
[ call_U1117;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~> [run paragraph on]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "> ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U1118 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1118, 411, 0);
    }
    (tmp_0 = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U130(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (tmp_0 = (tmp_0 + 1));
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_0 < 1)) {
        if (FollowRulebook(IMMEDIATELY_QUIT_R)) {
            rtrue;
        }
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U138))))));
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U130(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U1, ct_1));
                        (tmp_0 = (tmp_0 - 1));
                        if ((tmp_0 == 1)) {
                            if (call_U150(use_option_id_U3)) {
                                (say__p = 1);
                                ParaContent();
                                print ",";
                            }
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U139))))));
                        } else {
                            if ((tmp_0 == 0)) {
                                (say__p = 1);
                                ParaContent();
                                print "?";
                                ParaContent();
                                print "^";
                            } else {
                                (say__p = 1);
                                ParaContent();
                                print ", ";
                            }
                        }
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1119;
    ResponseViaActivity(response_id_U138);
];
[ call_U1120 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Would you like to ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Would you like to ";
    rtrue;
];
[ call_U1121;
    ResponseViaActivity(response_id_U139);
];
[ call_U1122 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ or ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ call_U1123 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1123, 412, 0);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U1),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U130(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (SnippetMatches(players_command, TableLookUpEntry(ct_0, table_column_id_U3, ct_1))) {
                        if (ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) {
                            if (FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U4, ct_1))) {
                                rtrue;
                            }
                        } else {
                            CarryOutActivity(TableLookUpEntry(ct_0, table_column_id_U5, ct_1));
                        }
                        RulebookSucceeds();
                        rtrue;
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = ct_0),(((LocalParking-->(1)) = ct_1),(((LocalParking-->(2)) = tmp_0),(((LocalParking-->(3)) = tmp_1),as_block_constant_U140)))));
    print "^";
    rfalse;
];
[ call_U1124;
    ResponseViaActivity(response_id_U140);
];
[ call_U1125 tmp_0 tmp_1 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Please give one of the answers above.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Please give one of the answers above.";
    rtrue;
];
[ call_U1126 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1126, 415, 0);
    }
    ((Global_Vars-->31) = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U2),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            TableBlankOutRow(ct_0, ct_1);
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1127 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U1127, 416, 0);
    }
    (tmp_0 = parameter_value);
    CarryOutActivity(V33_choosing_notable_locale_o, tmp_0);
    rfalse;
    rfalse;
];
[ call_U1128 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1128, 417, 0);
    }
    (tmp_0 = parameter_value);
    TableSort(table_data_U2, table_column_id_U7, 1);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U2),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            CarryOutActivity(V34_printing_a_locale_paragra, TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1129 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1 tmp_4 tmp_5;
    if (debug_rules) {
        DB_Rule(call_U1129, 418, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = 0);
    for (((tmp_2 = (call_U1130)(0)),(tmp_3 = (call_U1130)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1130)(tmp_3)))) {
        call_U365(tmp_2);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_2 = table_data_U2),((tmp_3 = 1),((ct_0 = tmp_2),(ct_1 = tmp_3)))):(tmp_3 <= TableRows(tmp_2)):((tmp_3)++,((ct_0 = tmp_2),(ct_1 = tmp_3)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((TableLookUpEntry(ct_0, table_column_id_U7, ct_1) > 0)) {
                call_U364(TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
            }
            (tmp_1 = (tmp_1 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_1 > 0)) {
        for (((tmp_2 = (call_U1131)(0)),(tmp_3 = (call_U1131)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1131)(tmp_3)))) {
            if (call_U369(tmp_2)) {
                call_U365(tmp_2);
            }
        }
        BeginActivity(V11_listing_nondescript_items, tmp_0);
        if (((call_U1132)() == 0)) {
            AbandonActivity(V11_listing_nondescript_items, tmp_0);
        } else {
            if ((~~(ForActivity(V11_listing_nondescript_items, tmp_0)))) {
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U141)))))));
                } else {
                    if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U142)))))));
                    } else {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U143)))))));
                    }
                }
                if (((Global_Vars-->31) > 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U144)))))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U145)))))));
                }
                (tmp_2 = 0);
                (tmp_3 = 1);
                for (((tmp_4 = (call_U1133)(0)),(tmp_5 = (call_U1133)(tmp_4))):tmp_4:((tmp_4 = tmp_5),(tmp_5 = (call_U1133)(tmp_5)))) {
                    if ((~~((HolderOf(tmp_4) == tmp_2)))) {
                        if ((tmp_2 == 0)) {
                            (tmp_2 = HolderOf(tmp_4));
                        } else {
                            (tmp_3 = 0);
                        }
                    }
                    if (call_U369(tmp_4)) {
                        call_U365(tmp_4);
                    }
                }
                (list_filter_routine = call_U1134);
                if ((((tmp_3 == 1)) && ((~~((tmp_2 == 0)))))) {
                    WriteListFrom(child(tmp_2), 2776);
                } else {
                    (say__p = 1);
                    ParaContent();
                    objectloop (tmp_4 ofclass Object && (tmp_4 ofclass Object)) {
                        if ((((tmp_4 ofclass K2_thing)) && (call_U363(tmp_4)))) {
                            give tmp_4 workflag2;
                        } else {
                            give tmp_4 ~workflag2;
                        }
                    }
                    WriteListOfMarkedObjects(((((ENGLISH_BIT + RECURSE_BIT) + PARTINV_BIT) + TERSE_BIT) + CONCEAL_BIT));
                }
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),(((LocalParking-->(6)) = tmp_4),(((LocalParking-->(7)) = tmp_5),as_block_constant_U146)))))))));
                }
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
                (list_filter_routine = 0);
            }
            EndActivity(V11_listing_nondescript_items, tmp_0);
        }
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1130 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1131 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1132 x x_ix counter;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U363(x)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1133 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U363(x)) {
            return x;
        }
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1134 reason x x_ix total counter selection best best_with;
    if ((reason >= 0)) {
        (x = reason);
        (reason = -1);
    }
    switch (reason) {
        -7:
            if ((property_loop_sign > 0)) {
                (best = MIN_NEGATIVE_NUMBER);
            } else {
                (best = MAX_POSITIVE_NUMBER);
            }
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                    if ((property_loop_sign > 0)) {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) >= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    } else {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) <= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    }
                }
            }
            return best_with;
            ;
        -6:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                    (total = REAL_NUMBER_TY_Plus(total, _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_7;
                }
                .NextOuterLoop_7;
            }
            return total;
            ;
        -5:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                    (total = (total + _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
            ;
        -4:
            (selection = -1);
            while (1) {
                (counter = 0);
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                        (counter)++;
                        if ((counter == selection)) {
                            return x;
                        }
                        jump NextOuterLoop_8;
                    }
                    .NextOuterLoop_8;
                }
                if ((((counter == 0)) || ((selection >= 0)))) {
                    rfalse;
                }
                (selection = random(counter));
            }
            -3:
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                        (counter)++;
                        jump NextOuterLoop_5;
                    }
                    .NextOuterLoop_5;
                }
                return counter;
                ;
            -2:
                if ((x_ix > 0)) {
                    (x_ix)--;
                    jump NextOuterLoop_4;
                }
                if (x) {
                    jump NextOuterLoop_4;
                }
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U372(x)))) {
                        return x;
                    }
                    .NextOuterLoop_4;
                }
                rfalse;
                ;
            -1:
                if ((((x ofclass K2_thing)) && ((((x ofclass K2_thing)) && (call_U372(x)))))) {
                    rtrue;
                }
                rfalse;
                ;
            ;
    }
];
[ call_U1135;
    ResponseViaActivity(response_id_U141);
];
[ call_U1136 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1137;
    ResponseViaActivity(response_id_U142);
];
[ call_U1138 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the domain] [we] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1139;
    ResponseViaActivity(response_id_U143);
];
[ call_U1140 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the domain] [we] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1141;
    ResponseViaActivity(response_id_U144);
];
[ call_U1142 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the player][can] also see ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " also see ";
    rtrue;
];
[ call_U1143;
    ResponseViaActivity(response_id_U145);
];
[ call_U1144 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the player][can] see ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    rtrue;
];
[ call_U1145;
    ResponseViaActivity(response_id_U146);
];
[ call_U1146 tmp_0 tmp_1 tmp_2 tmp_3 tmp_4 tmp_5 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ here~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " here";
    rtrue;
];
[ call_U1147 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1147, 419, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = child(tmp_0));
    while ((tmp_1 ofclass K2_thing)) {
        call_U1929(tmp_1, 5);
        (tmp_1 = sibling(tmp_1));
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1148 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1148, 420, 0);
        }
        if (IndirectlyContains(tmp_0, player)) {
            call_U1929(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1148, 420, 2);
        }
    }
    rfalse;
];
[ call_U1149 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1149, 421, 0);
        }
        if (call_U345(tmp_0)) {
            call_U1929(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1149, 421, 2);
        }
    }
    rfalse;
];
[ call_U1150 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1150, 422, 0);
        }
        if (call_U357(tmp_0)) {
            call_U1929(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1150, 422, 2);
        }
    }
    rfalse;
];
[ call_U1151 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1151, 423, 0);
        }
        if ((~~(call_U369(tmp_0)))) {
            PronounNotice(tmp_0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1151, 423, 2);
        }
    }
    rfalse;
];
[ call_U1152 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1152, 424, 0);
        }
        if ((~~(call_U369(tmp_0)))) {
            if (say__p) {
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
            CarryOutActivity(V10_writing_a_paragraph_about, tmp_0);
            if (say__p) {
                ((Global_Vars-->31) = ((Global_Vars-->31) + 1));
                call_U370(tmp_0);
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1152, 424, 2);
        }
    }
    rfalse;
];
[ call_U1153 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1153, 425, 0);
        }
        if ((~~(call_U369(tmp_0)))) {
            if (((ProvidesProperty(OBJECT_TY, tmp_0, A_initial)) && ((((~~(call_U354(tmp_0)))) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_0, A_initial),bc_U238) == 0)))))))) {
                ((Global_Vars-->31) = ((Global_Vars-->31) + 1));
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_0), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
                if (call_U1154(tmp_0)) {
                    for (((tmp_1 = (call_U1155)(tmp_0,0)),(tmp_2 = (call_U1155)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1155)(tmp_0,tmp_2)))) {
                        call_U364(tmp_1);
                        if (call_U369(tmp_1)) {
                            call_U365(tmp_1);
                        }
                    }
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U147))));
                    WriteListFrom(child(tmp_0), 3800);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                }
                call_U370(tmp_0);
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1153, 425, 2);
        }
    }
    rfalse;
];
[ call_U1154 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U308(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1155 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1156;
    ResponseViaActivity(response_id_U147);
];
[ call_U1157 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1158 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K6_supporter)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1158, 426, 0);
        }
        for (((tmp_1 = (call_U1159)(tmp_0,tmp_0,tmp_0,0)),(tmp_2 = (call_U1159)(tmp_0,tmp_0,tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1159)(tmp_0,tmp_0,tmp_0,tmp_2)))) {
            if ((((~~((tmp_1 ofclass K8_person)))) && ((((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_1, A_initial),bc_U239) == 0)))) && ((~~(call_U357(tmp_1)))))))) {
                call_U370(tmp_1);
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_1), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1158, 426, 2);
        }
    }
    rfalse;
];
[ call_U1159 const_0 const_1 const_2 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_2) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && ((((~~(call_U354(x)))) && ((((const_0 ofclass K6_supporter)) && (ProvidesProperty(OBJECT_TY, const_1, A_initial)))))))) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1160 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1160, 428, 0);
        }
        if (((call_U345(tmp_0)) && ((~~(IndirectlyContains(tmp_0, player)))))) {
            if (call_U1161(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1162)(tmp_0,0)),(tmp_2 = (call_U1162)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1162)(tmp_0,tmp_2)))) {
                    call_U364(tmp_1);
                    if (call_U369(tmp_1)) {
                        call_U365(tmp_1);
                    }
                }
                ((Global_Vars-->31) = ((Global_Vars-->31) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U148))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1160, 428, 2);
        }
    }
    rfalse;
];
[ call_U1161 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U308(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1162 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1163;
    ResponseViaActivity(response_id_U148);
];
[ call_U1164 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1165 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1165, 429, 0);
        }
        if (((call_U369(tmp_0)) && ((((~~(call_U357(tmp_0)))) && ((((~~(call_U345(tmp_0)))) && ((~~(IndirectlyContains(tmp_0, player)))))))))) {
            if (call_U1166(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1167)(tmp_0,0)),(tmp_2 = (call_U1167)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1167)(tmp_0,tmp_2)))) {
                    call_U364(tmp_1);
                    if (call_U369(tmp_1)) {
                        call_U365(tmp_1);
                    }
                }
                ((Global_Vars-->31) = ((Global_Vars-->31) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U149))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1165, 429, 2);
        }
    }
    rfalse;
];
[ call_U1166 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U308(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1167 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1168;
    ResponseViaActivity(response_id_U149);
];
[ call_U1169 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1170;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1170, 430, 0);
        }
        if ((child(player) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U150);
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1170, 430, 3);
        }
    }
    rfalse;
];
[ call_U1171;
    ResponseViaActivity(response_id_U150);
];
[ call_U1172;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] carrying nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying nothing.";
    rtrue;
];
[ call_U1173;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1173, 431, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U151);
        WriteListFrom(child(player), 8215);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1173, 431, 3);
        }
    }
    rfalse;
];
[ call_U1174;
    ResponseViaActivity(response_id_U151);
];
[ call_U1175;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] carrying:[line break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying:";
    ParaContent();
    print "^";
    rtrue;
];
[ call_U1176;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1176, 432, 0);
        }
        if ((((~~((actor == player)))) && ((keep_silent == 0)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U152);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1176, 432, 2);
        }
    }
    rfalse;
];
[ call_U1177;
    ResponseViaActivity(response_id_U152);
];
[ call_U1178;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] through [their] possessions.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    call_U264();
    ParaContent();
    print " possessions.";
    rtrue;
];
[ call_U1179;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1179, 433, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U153);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1179, 433, 2);
        }
    }
    rfalse;
];
[ call_U1180;
    ResponseViaActivity(response_id_U153);
];
[ call_U1181;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] always self-possessed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " always self-possessed.";
    rtrue;
];
[ call_U1182;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1182, 434, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U154);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1182, 434, 2);
        }
    }
    rfalse;
];
[ call_U1183;
    ResponseViaActivity(response_id_U154);
];
[ call_U1184;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I don't suppose [the noun] [would care] for that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I don't suppose ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb11);
    (say__p = 1);
    ParaContent();
    print " for that.";
    rtrue;
];
[ call_U1185 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1185, 435, 0);
        }
        if ((((PartOf(noun) ofclass K2_thing)) && (((tmp_0 = PartOf(noun)),1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U155));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1185, 435, 2);
        }
    }
    rfalse;
];
[ call_U1186;
    ResponseViaActivity(response_id_U155);
];
[ call_U1187 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to be a part of [the whole].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be a part of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1188 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1188, 436, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        (tmp_1 = CoreOfParentOfCoreOf(noun));
        while ((((~~((tmp_1 == 0)))) && ((~~((tmp_1 == tmp_0)))))) {
            if ((tmp_1 ofclass K8_person)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U156)));
                    print "^";
                }
                rtrue;
            }
            (tmp_1 = CoreOfParentOfCoreOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1188, 436, 2);
        }
    }
    rfalse;
];
[ call_U1189;
    ResponseViaActivity(response_id_U156);
];
[ call_U1190 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the owner].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1191 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1191, 437, 0);
        }
        (tmp_0 = noun);
        while ((((~~((tmp_0 == 0)))) && ((~~((tmp_0 ofclass K1_room)))))) {
            (tmp_0 = CoreOfParentOfCoreOf(tmp_0));
        }
        if ((tmp_0 == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U157));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1191, 437, 2);
        }
    }
    rfalse;
];
[ call_U1192;
    ResponseViaActivity(response_id_U157);
];
[ call_U1193 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [aren't] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U1194 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1194, 438, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U158));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1194, 438, 2);
        }
    }
    rfalse;
];
[ call_U1195;
    ResponseViaActivity(response_id_U158);
];
[ call_U1196 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get^[if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get ";
    if ((~~((noun ofclass K6_supporter)))) {
        jump L_Say0;
    }
    ParaContent();
    print "off";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "out of";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1197;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1197, 439, 0);
        }
        if ((((actor == CarrierOf(noun))) || ((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U159);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1197, 439, 2);
        }
    }
    rfalse;
];
[ call_U1198;
    ResponseViaActivity(response_id_U159);
];
[ call_U1199;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] already [have] [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " already ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1200;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1200, 440, 0);
        }
        if (call_U345(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U160);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1200, 440, 2);
        }
    }
    rfalse;
];
[ call_U1201;
    ResponseViaActivity(response_id_U160);
];
[ call_U1202;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] hardly portable.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " hardly portable.";
    rtrue;
];
[ call_U1203;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1203, 441, 0);
        }
        if ((~~((noun ofclass K2_thing)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U161);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1203, 441, 2);
        }
    }
    rfalse;
];
[ call_U1204;
    ResponseViaActivity(response_id_U161);
];
[ call_U1205;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [cannot] carry [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carry ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1206;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1206, 442, 0);
        }
        if (call_U339(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U162);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1206, 442, 2);
        }
    }
    rfalse;
];
[ call_U1207;
    ResponseViaActivity(response_id_U162);
];
[ call_U1208;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1209 tmp_0 tmp_1 tmp_2 tmp_3;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1209, 443, 0);
        }
        if (((call_U1210)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if (((((call_U1211()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
                (tmp_1 = 0);
                for (((tmp_2 = (call_U1212)(0)),(tmp_3 = (call_U1212)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1212)(tmp_3)))) {
                    if ((((~~(call_U327(tmp_2)))) && ((~~((tmp_2 == tmp_0)))))) {
                        (tmp_1 = tmp_2);
                    }
                }
                if ((~~((tmp_1 == 0)))) {
                    if ((actor == player)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),as_block_constant_U163)))));
                    }
                    @push keep_silent;
                    (keep_silent = 1);
                    @push say__p;
                    @push say__pc;
                    ClearParagraphing(1);
                    TryAction(0, actor, ##Insert, tmp_1, tmp_0);
                    DivideParagraphPoint();
                    @pull say__pc;
                    @pull say__p;
                    AdjustParagraphPoint();
                    @pull keep_silent;
                    if ((~~((tmp_0 == ContainerOf(tmp_1))))) {
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1209, 443, 2);
        }
    }
    rfalse;
];
[ call_U1210 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1211 x x_ix;
    for ((x = 0):0:) {
        if ((actor == HolderOf(x))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1212 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1213;
    ResponseViaActivity(response_id_U163);
];
[ call_U1214 tmp_1 tmp_0 tmp_2 tmp_3;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(putting [the transferred item] into [the current working sack]^to make room)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(putting ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " to make room)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1215;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1215, 444, 0);
        }
        if (((call_U1216)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U164);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1215, 444, 2);
        }
    }
    rfalse;
];
[ call_U1216 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1217;
    ResponseViaActivity(response_id_U164);
];
[ call_U1218;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1219;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1219, 445, 0);
        }
        MoveObject(noun, actor);
        if ((actor == player)) {
            call_U355(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1219, 445, 2);
        }
    }
    rfalse;
];
[ call_U1220;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1220, 446, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U165);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U166);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1220, 446, 2);
        }
    }
    rfalse;
];
[ call_U1221;
    ResponseViaActivity(response_id_U165);
];
[ call_U1222;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Taken.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Taken.";
    rtrue;
];
[ call_U1223;
    ResponseViaActivity(response_id_U166);
];
[ call_U1224;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [pick] up [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb12(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1225;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1225, 447, 0);
        }
        if ((~~((HolderOf(noun) == second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U167);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1225, 447, 2);
        }
    }
    rfalse;
];
[ call_U1226;
    ResponseViaActivity(response_id_U167);
];
[ call_U1227;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [regarding the noun][they] [aren't] there now.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U262();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " there now.";
    rtrue;
];
[ call_U1228 tmp_0;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1228, 448, 0);
        }
        (tmp_0 = HolderOf(noun));
        if ((tmp_0 ofclass K8_person)) {
            if ((tmp_0 == actor)) {
                return GVS_Convert(##Disrobe, noun, 0);
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U168));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1228, 448, 2);
        }
    }
    rfalse;
];
[ call_U1229;
    ResponseViaActivity(response_id_U168);
];
[ call_U1230 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the owner].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1231;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1231, 449, 0);
        }
        return GVS_Convert(##Take, noun, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1231, 449, 2);
        }
    }
    rfalse;
];
[ call_U1232;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1232, 450, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U169);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1232, 450, 2);
        }
    }
    rfalse;
];
[ call_U1233;
    ResponseViaActivity(response_id_U169);
];
[ call_U1234;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lack] the dexterity.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the dexterity.";
    rtrue;
];
[ call_U1235;
    if ((((act_requester == 0)) && ((((noun ofclass K2_thing)) && ((actor == PartOf(noun))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1235, 451, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U170);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1235, 451, 2);
        }
    }
    rfalse;
];
[ call_U1236;
    ResponseViaActivity(response_id_U170);
];
[ call_U1237;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't drop] part of [ourselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb14);
    (say__p = 1);
    ParaContent();
    print " part of ";
    ParaContent();
    call_U251();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1238;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1238, 452, 0);
        }
        if ((HolderOf(actor) == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U171);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1238, 452, 2);
        }
    }
    rfalse;
];
[ call_U1239;
    ResponseViaActivity(response_id_U171);
];
[ call_U1240;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] already here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already here.";
    rtrue;
];
[ call_U1241;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1241, 453, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U172);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1241, 453, 2);
        }
    }
    rfalse;
];
[ call_U1242;
    ResponseViaActivity(response_id_U172);
];
[ call_U1243;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [haven't] got [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb15(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " got ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1244;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1244, 454, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U173);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1244, 454, 2);
        }
    }
    rfalse;
];
[ call_U1245;
    ResponseViaActivity(response_id_U173);
];
[ call_U1246;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1247 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1247, 455, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 ofclass K1_room)) {
            rfalse;
        }
        if (ProvidesProperty(OBJECT_TY, tmp_0, A_capacity)) {
            if ((tmp_0 ofclass K6_supporter)) {
                if (((call_U1248)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U174));
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((tmp_0 ofclass K5_container)) {
                    if (((call_U1249)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U175));
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1247, 455, 2);
        }
    }
    rfalse;
];
[ call_U1248 const_0 x x_ix counter;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1249 const_0 x x_ix counter;
    for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1250;
    ResponseViaActivity(response_id_U174);
];
[ call_U1251 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the receptacle].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1252;
    ResponseViaActivity(response_id_U175);
];
[ call_U1253 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the receptacle].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1254;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1254, 456, 0);
        }
        MoveObject(noun, HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1254, 456, 2);
        }
    }
    rfalse;
];
[ call_U1255;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1255, 457, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U176);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U177);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1255, 457, 2);
        }
    }
    rfalse;
];
[ call_U1256;
    ResponseViaActivity(response_id_U176);
];
[ call_U1257;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Dropped.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Dropped.";
    rtrue;
];
[ call_U1258;
    ResponseViaActivity(response_id_U177);
];
[ call_U1259;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] down [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1260;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1260, 458, 0);
        }
        if ((((second == I_down_U1)) || ((second == SupporterOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1260, 458, 2);
        }
    }
    rfalse;
];
[ call_U1261;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1261, 459, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1261, 459, 2);
        }
    }
    rfalse;
];
[ call_U1262 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1262, 460, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U178))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1262, 460, 2);
        }
    }
    rfalse;
];
[ call_U1263;
    ResponseViaActivity(response_id_U178);
];
[ call_U1264 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't put] something on top of itself.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something on top of itself.";
    rtrue;
];
[ call_U1265;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1265, 461, 0);
        }
        if ((~~((second ofclass K6_supporter)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U179);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1265, 461, 2);
        }
    }
    rfalse;
];
[ call_U1266;
    ResponseViaActivity(response_id_U179);
];
[ call_U1267;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Putting things on [the second noun] [would achieve] nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Putting things on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing.";
    rtrue;
];
[ call_U1268;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1268, 462, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U180);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1268, 462, 2);
        }
    }
    rfalse;
];
[ call_U1269;
    ResponseViaActivity(response_id_U180);
];
[ call_U1270;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [regarding the noun][them] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U266();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1271;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1271, 463, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1272)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U181);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1271, 463, 2);
        }
    }
    rfalse;
];
[ call_U1272 x x_ix counter;
    objectloop (x in second) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1273;
    ResponseViaActivity(response_id_U181);
];
[ call_U1274;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1275;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1275, 464, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1275, 464, 2);
        }
    }
    rfalse;
];
[ call_U1276;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1276, 465, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U182);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1276, 465, 2);
        }
    }
    rfalse;
];
[ call_U1277;
    ResponseViaActivity(response_id_U182);
];
[ call_U1278;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Done.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1279;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1279, 466, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U183);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1279, 466, 2);
        }
    }
    rfalse;
];
[ call_U1280;
    ResponseViaActivity(response_id_U183);
];
[ call_U1281;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] [the noun] on [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1282;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1282, 467, 0);
        }
        if ((((second == I_down_U1)) || ((second == ContainerOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1282, 467, 2);
        }
    }
    rfalse;
];
[ call_U1283;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1283, 468, 0);
        }
        if ((second == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U184);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1283, 468, 2);
        }
    }
    rfalse;
];
[ call_U1284;
    ResponseViaActivity(response_id_U184);
];
[ call_U1285;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] already there.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already there.";
    rtrue;
];
[ call_U1286 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1286, 469, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U185))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1286, 469, 2);
        }
    }
    rfalse;
];
[ call_U1287;
    ResponseViaActivity(response_id_U185);
];
[ call_U1288 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't put] something inside itself.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something inside itself.";
    rtrue;
];
[ call_U1289;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1289, 470, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1289, 470, 2);
        }
    }
    rfalse;
];
[ call_U1290;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1290, 471, 0);
        }
        if ((((second ofclass K5_container)) && (call_U387(second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U186);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1290, 471, 2);
        }
    }
    rfalse;
];
[ call_U1291;
    ResponseViaActivity(response_id_U186);
];
[ call_U1292;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1293;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1293, 472, 0);
        }
        if ((~~((second ofclass K5_container)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U187);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1293, 472, 2);
        }
    }
    rfalse;
];
[ call_U1294;
    ResponseViaActivity(response_id_U187);
];
[ call_U1295;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [can't contain] things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb18);
    (say__p = 1);
    ParaContent();
    print " things.";
    rtrue;
];
[ call_U1296;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1296, 473, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U188);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1296, 473, 2);
        }
    }
    rfalse;
];
[ call_U1297;
    ResponseViaActivity(response_id_U188);
];
[ call_U1298;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [regarding the noun][them] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U266();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1299;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1299, 474, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1300)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (prior_named_noun = 0);
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U189);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1299, 474, 2);
        }
    }
    rfalse;
];
[ call_U1300 x x_ix counter;
    for ((x = TestContainmentRange(second)):x:(x = TestContainmentRange(second, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1301;
    ResponseViaActivity(response_id_U189);
];
[ call_U1302;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1303;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1303, 475, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1303, 475, 2);
        }
    }
    rfalse;
];
[ call_U1304;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1304, 476, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U190);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1304, 476, 2);
        }
    }
    rfalse;
];
[ call_U1305;
    ResponseViaActivity(response_id_U190);
];
[ call_U1306;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Done.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1307;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1307, 477, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U191);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1307, 477, 2);
        }
    }
    rfalse;
];
[ call_U1308;
    ResponseViaActivity(response_id_U191);
];
[ call_U1309;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] [the noun] into [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1310;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1310, 478, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U333(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U192);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1310, 478, 2);
        }
    }
    rfalse;
];
[ call_U1311;
    ResponseViaActivity(response_id_U192);
];
[ call_U1312;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] plainly inedible.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " plainly inedible.";
    rtrue;
];
[ call_U1313;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1313, 479, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U193);
            }
            TryAction(0, actor, ##Disrobe, noun, 0);
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1313, 479, 2);
        }
    }
    rfalse;
];
[ call_U1314;
    ResponseViaActivity(response_id_U193);
];
[ call_U1315;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1316 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1316, 480, 0);
        }
        if ((((~~((actor == HolderOf(noun))))) && (call_U1317()))) {
            (tmp_0 = HolderOf(noun));
            while ((~~((tmp_0 ofclass K8_person)))) {
                (tmp_0 = HolderOf(tmp_0));
            }
            if ((~~((tmp_0 == actor)))) {
                if ((((actor == player)) && ((keep_silent == 0)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U194));
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1316, 480, 2);
        }
    }
    rfalse;
];
[ call_U1317 x x_ix;
    for ((x = K8_person_First):x:(x = (x.K8_person_Next))) {
        if (IndirectlyContains(x, noun)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1318;
    ResponseViaActivity(response_id_U194);
];
[ call_U1319 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The owner] [might not appreciate] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(tmp_0);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb20);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1320;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1320, 481, 0);
        }
        if (((call_U342(noun)) && ((~~((actor == CarrierOf(noun))))))) {
            CarryOutActivity(V28_implicitly_taking, noun);
            if ((~~((actor == CarrierOf(noun))))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1320, 481, 2);
        }
    }
    rfalse;
];
[ call_U1321;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1321, 482, 0);
        }
        RemoveFromPlay(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1321, 482, 2);
        }
    }
    rfalse;
];
[ call_U1322;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1322, 483, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U195);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U196);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1322, 483, 2);
        }
    }
    rfalse;
];
[ call_U1323;
    ResponseViaActivity(response_id_U195);
];
[ call_U1324;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [eat] [the noun]. Not bad.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ". Not bad.";
    rtrue;
];
[ call_U1325;
    ResponseViaActivity(response_id_U196);
];
[ call_U1326;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [eat] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1327 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U19());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U19 tmp_0 tmp_1 tmp_2;
    if ((action == ##Go)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1327, 484, 0);
        }
        ((MStack-->(MstVO(var_id_U42, 4))) = move_pushing);
        ((MStack-->(MstVO(var_id_U42, 0))) = LocationOf(actor));
        if ((((ContainerOf(actor) ofclass K14_vehicle)) && (((call_U375(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            ((MStack-->(MstVO(var_id_U42, 3))) = tmp_0);
        }
        (tmp_1 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_2 = noun);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1815, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_2))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_1 = noun);
            }
        }
        if ((tmp_1 ofclass K4_door)) {
            ((MStack-->(MstVO(var_id_U42, 2))) = tmp_1);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1820, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_1);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1327, 484, 2);
        }
    }
    rfalse;
];
[ call_U1328 tmp_0;
    if ((((act_requester == 0)) && (((((self = actor),1)) && ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1328, 485, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U197));
        }
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1328, 485, 2);
        }
    }
    rfalse;
];
[ call_U1329;
    ResponseViaActivity(response_id_U197);
];
[ call_U1330 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first getting off [the chaise])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first getting off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1331 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1331, 486, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 0))))) {
            rfalse;
        }
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 3))))) {
            rfalse;
        }
        if ((actor == player)) {
            if ((tmp_0 ofclass K6_supporter)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U198));
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U199));
                print "^";
            }
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1331, 486, 2);
        }
    }
    rfalse;
];
[ call_U1332;
    ResponseViaActivity(response_id_U198);
];
[ call_U1333 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get off [the nonvehicle] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1334;
    ResponseViaActivity(response_id_U199);
];
[ call_U1335 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get out of [the nonvehicle] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get out of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1336;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1336, 487, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U357((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U200);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1336, 487, 2);
        }
    }
    rfalse;
];
[ call_U1337;
    ResponseViaActivity(response_id_U200);
];
[ call_U1338;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't go] that way.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1339;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1339, 488, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U387((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U201);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Open, (MStack-->(MstVO(var_id_U42, 2))), 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if (call_U384((MStack-->(MstVO(var_id_U42, 2))))) {
                rfalse;
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1339, 488, 2);
        }
    }
    rfalse;
];
[ call_U1340;
    ResponseViaActivity(response_id_U201);
];
[ call_U1341;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first opening [the door gone through])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first opening ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1342 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U20());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U20 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1342, 489, 0);
        }
        (tmp_0 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_1 = noun);
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1858, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_0 = noun);
            }
        }
        if ((tmp_0 ofclass K4_door)) {
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1862, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_0))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1342, 489, 2);
        }
    }
    rfalse;
];
[ call_U1343;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1343, 490, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 1))) == 0)) {
            if (((MStack-->(MstVO(var_id_U42, 2))) == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U202);
                    print "^";
                }
                rtrue;
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U203);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1343, 490, 2);
        }
    }
    rfalse;
];
[ call_U1344;
    ResponseViaActivity(response_id_U202);
];
[ call_U1345;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't go] that way.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1346;
    ResponseViaActivity(response_id_U203);
];
[ call_U1347;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't], since [the door gone through] [lead] nowhere.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", since ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print " ";
    ConjugateVerb23(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nowhere.";
    rtrue;
];
[ call_U1348;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1348, 491, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 3))) == 0)) {
            MoveDuringGoing(actor, (MStack-->(MstVO(var_id_U42, 1))));
        } else {
            MoveDuringGoing((MStack-->(MstVO(var_id_U42, 3))), (MStack-->(MstVO(var_id_U42, 1))));
        }
        if ((~~((real_location == LocationOf(player))))) {
            (real_location = LocationOf(player));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1348, 491, 2);
        }
    }
    rfalse;
];
[ call_U1349;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1349, 492, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            MoveFloatingObjects();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1349, 492, 2);
        }
    }
    rfalse;
];
[ call_U1350;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1350, 493, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            SilentlyConsiderLight();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1350, 493, 2);
        }
    }
    rfalse;
];
[ call_U1351 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U21());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U21 tmp_0 tmp_1 tmp_2;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1351, 494, 0);
        }
        if ((player == actor)) {
            if ((keep_silent == 0)) {
                LookAfterGoing();
            }
        } else {
            if ((noun ofclass K3_direction)) {
                if ((((real_location == (MStack-->(MstVO(var_id_U42, 0))))) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                    if (((MStack-->(MstVO(var_id_U42, 0))) == (MStack-->(MstVO(var_id_U42, 1))))) {
                        rfalse;
                    } else {
                        if ((noun == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U204);
                        } else {
                            if ((noun == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U205);
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U206);
                            }
                        }
                    }
                } else {
                    (tmp_0 = GProperty(OBJECT_TY, noun, A_P_opposite));
                    if ((real_location == (MStack-->(MstVO(var_id_U42, 1))))) {
                        (tmp_1 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1913, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = real_location) + (formal_par0 = tmp_0))))
                        )
                        );
                        (tmp_2 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1915, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = noun))))
                        )
                        );
                        if ((((tmp_1 == (MStack-->(MstVO(var_id_U42, 0))))) || ((tmp_1 == tmp_2)))) {
                            if ((tmp_0 == I_up_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U207))));
                            } else {
                                if ((tmp_0 == I_down_U1)) {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U208))));
                                } else {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U209))));
                                }
                            }
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U210))));
                        }
                    } else {
                        if ((tmp_0 == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U211))));
                        } else {
                            if ((tmp_0 == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U212))));
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U213))));
                            }
                        }
                    }
                }
            } else {
                if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U214))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U215))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 3))) == 0)))) {
                (say__p = 1);
                ParaContent();
                print " ";
                if (((MStack-->(MstVO(var_id_U42, 3))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U216))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U217))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 4))) == 0)))) {
                if (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U218))));
                } else {
                    if (((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U219))));
                    } else {
                        if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U220))));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U221))));
                        }
                    }
                }
            }
            if (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) && ((~~(((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U222))));
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                TryAction(0, player, ##Look, 0, 0);
                rfalse;
            }
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1351, 494, 2);
        }
    }
    rfalse;
];
[ call_U1352;
    ResponseViaActivity(response_id_U204);
];
[ call_U1353;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] up~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up";
    rtrue;
];
[ call_U1354;
    ResponseViaActivity(response_id_U205);
];
[ call_U1355;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] down~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down";
    rtrue;
];
[ call_U1356;
    ResponseViaActivity(response_id_U206);
];
[ call_U1357;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] [noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    PrintShortName(noun);
    rtrue;
];
[ call_U1358;
    ResponseViaActivity(response_id_U207);
];
[ call_U1359 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from above~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1360;
    ResponseViaActivity(response_id_U208);
];
[ call_U1361 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from below~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1362;
    ResponseViaActivity(response_id_U209);
];
[ call_U1363 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from [the back way]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1364;
    ResponseViaActivity(response_id_U210);
];
[ call_U1365 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U1366;
    ResponseViaActivity(response_id_U211);
];
[ call_U1367 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from above~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1368;
    ResponseViaActivity(response_id_U212);
];
[ call_U1369 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from below~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1370;
    ResponseViaActivity(response_id_U213);
];
[ call_U1371 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from [the back way]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1372;
    ResponseViaActivity(response_id_U214);
];
[ call_U1373 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] through [the noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1374;
    ResponseViaActivity(response_id_U215);
];
[ call_U1375 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from [the noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1376;
    ResponseViaActivity(response_id_U216);
];
[ call_U1377 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~on [the vehicle gone by]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "on ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1378;
    ResponseViaActivity(response_id_U217);
];
[ call_U1379 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~in [the vehicle gone by]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "in ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1380;
    ResponseViaActivity(response_id_U218);
];
[ call_U1381 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in front, and [us] along too~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front, and ";
    ParaContent();
    call_U249();
    ParaContent();
    print " along too";
    rtrue;
];
[ call_U1382;
    ResponseViaActivity(response_id_U219);
];
[ call_U1383 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in front~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front";
    rtrue;
];
[ call_U1384;
    ResponseViaActivity(response_id_U220);
];
[ call_U1385 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] away~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " away";
    rtrue;
];
[ call_U1386;
    ResponseViaActivity(response_id_U221);
];
[ call_U1387 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in";
    rtrue;
];
[ call_U1388;
    ResponseViaActivity(response_id_U222);
];
[ call_U1389 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, taking [us] along~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", taking ";
    ParaContent();
    call_U249();
    ParaContent();
    print " along";
    rtrue;
];
[ call_U1390 tmp_0;
    if ((((action == ##Enter)) && ((actor == player)))) {
        if (debug_rules) {
            DB_Rule(call_U1390, 495, 0);
        }
        if (((((call_U1391()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
            (noun = tmp_0);
        } else {
            rfalse;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1390, 495, 4);
        }
    }
    rfalse;
];
[ call_U1391 x x_ix;
    for ((x = TestContainmentRange(real_location)):x:(x = TestContainmentRange(real_location, x))) {
        if ((((x ofclass K2_thing)) && (call_U375(x)))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1392;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1392, 496, 0);
        }
        if ((noun ofclass K4_door)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1392, 496, 2);
        }
    }
    rfalse;
];
[ call_U1393;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1393, 497, 0);
        }
        if ((noun ofclass K3_direction)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1393, 497, 2);
        }
    }
    rfalse;
];
[ call_U1394 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1394, 498, 0);
        }
        if ((actor == noun)) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((player == actor)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U223));
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U224));
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1394, 498, 2);
        }
    }
    rfalse;
];
[ call_U1395;
    ResponseViaActivity(response_id_U223);
];
[ call_U1396 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we]['re] already on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U248();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1397;
    ResponseViaActivity(response_id_U224);
];
[ call_U1398 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we]['re] already in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U248();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1399;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1399, 499, 0);
        }
        if ((~~(call_U375(noun)))) {
            if ((player == actor)) {
                if ((matched_text = SnippetIncludes(Consult_Grammar6, players_command))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U225);
                    print "^";
                } else {
                    if ((matched_text = SnippetIncludes(Consult_Grammar7, players_command))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U226);
                        print "^";
                    } else {
                        if ((matched_text = SnippetIncludes(Consult_Grammar8, players_command))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U227);
                            print "^";
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U228);
                            print "^";
                        }
                    }
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1399, 499, 2);
        }
    }
    rfalse;
];
[ call_U1400;
    ResponseViaActivity(response_id_U225);
];
[ call_U1401;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] stand on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " stand on.";
    rtrue;
];
[ call_U1402;
    ResponseViaActivity(response_id_U226);
];
[ call_U1403;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] sit down on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " sit down on.";
    rtrue;
];
[ call_U1404;
    ResponseViaActivity(response_id_U227);
];
[ call_U1405;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] lie down on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lie down on.";
    rtrue;
];
[ call_U1406;
    ResponseViaActivity(response_id_U228);
];
[ call_U1407;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] enter.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " enter.";
    rtrue;
];
[ call_U1408;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1408, 500, 0);
        }
        if ((((noun ofclass K5_container)) && (call_U387(noun)))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U229);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1408, 500, 2);
        }
    }
    rfalse;
];
[ call_U1409;
    ResponseViaActivity(response_id_U229);
];
[ call_U1410;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't get] into the closed [noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb25);
    (say__p = 1);
    ParaContent();
    print " into the closed ";
    ParaContent();
    PrintShortName(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1411;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1411, 501, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_capacity)) {
            if ((noun ofclass K6_supporter)) {
                if (((call_U1412)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U230);
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((noun ofclass K5_container)) {
                    if (((call_U1413)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U231);
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1411, 501, 2);
        }
    }
    rfalse;
];
[ call_U1412 x x_ix counter;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1413 x x_ix counter;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1414;
    ResponseViaActivity(response_id_U230);
];
[ call_U1415;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1416;
    ResponseViaActivity(response_id_U231);
];
[ call_U1417;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1418 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1418, 502, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == actor)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U232));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1418, 502, 2);
        }
    }
    rfalse;
];
[ call_U1419;
    ResponseViaActivity(response_id_U232);
];
[ call_U1420 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can] only get into something free-standing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " only get into something free-standing.";
    rtrue;
];
[ call_U1421 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1421, 503, 0);
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        while ((~~((HolderOf(actor) == tmp_0)))) {
            (tmp_1 = HolderOf(actor));
            if ((player == actor)) {
                if ((((tmp_1 ofclass K6_supporter)) || ((tmp_1 ofclass K12_animal)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U233)));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U234)));
                }
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Exit, 0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((HolderOf(actor) == tmp_1)) {
                rtrue;
            }
        }
        if ((HolderOf(actor) == noun)) {
            rtrue;
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_1 = HolderOf(noun));
        if ((tmp_1 == PartOf(noun))) {
            (tmp_1 = HolderOf(tmp_1));
        }
        while ((tmp_1 ofclass K2_thing)) {
            if ((HolderOf(tmp_1) == tmp_0)) {
                if ((player == actor)) {
                    if ((tmp_1 ofclass K6_supporter)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U235)));
                    } else {
                        if ((tmp_1 ofclass K5_container)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U236)));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U237)));
                        }
                    }
                }
                @push keep_silent;
                (keep_silent = 1);
                @push say__p;
                @push say__pc;
                ClearParagraphing(1);
                TryAction(0, actor, ##Enter, tmp_1, 0);
                DivideParagraphPoint();
                @pull say__pc;
                @pull say__p;
                AdjustParagraphPoint();
                @pull keep_silent;
                if ((~~((HolderOf(actor) == tmp_1)))) {
                    rtrue;
                }
                return GVS_Convert(##Enter, noun, 0);
                rfalse;
            }
            (tmp_1 = HolderOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1421, 503, 2);
        }
    }
    rfalse;
];
[ call_U1422;
    ResponseViaActivity(response_id_U233);
];
[ call_U1423 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting off [the current home])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting off ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1424;
    ResponseViaActivity(response_id_U234);
];
[ call_U1425 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting out of [the current home])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting out of ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1426;
    ResponseViaActivity(response_id_U235);
];
[ call_U1427 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting onto [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting onto ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1428;
    ResponseViaActivity(response_id_U236);
];
[ call_U1429 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting into [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting into ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1430;
    ResponseViaActivity(response_id_U237);
];
[ call_U1431 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(entering [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(entering ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1432;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1432, 504, 0);
        }
        move actor to noun;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1432, 504, 2);
        }
    }
    rfalse;
];
[ call_U1433;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1433, 505, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U238);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U239);
                    print "^";
                }
            }
        } else {
            if ((noun ofclass K5_container)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U240);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U241);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1433, 505, 2);
        }
    }
    rfalse;
];
[ call_U1434;
    ResponseViaActivity(response_id_U238);
];
[ call_U1435;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] onto [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1436;
    ResponseViaActivity(response_id_U239);
];
[ call_U1437;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1438;
    ResponseViaActivity(response_id_U240);
];
[ call_U1439;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1440;
    ResponseViaActivity(response_id_U241);
];
[ call_U1441;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] onto [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1442;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1442, 506, 0);
        }
        if ((actor == player)) {
            call_U1928(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1442, 506, 2);
        }
    }
    rfalse;
];
[ call_U1443;
    if ((action == ##Exit)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1443, 507, 0);
        }
        ((MStack-->(MstVO(var_id_U44, 0))) = HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1443, 507, 2);
        }
    }
    rfalse;
];
[ call_U1444 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1444, 508, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((~~((RoomOrDoorFrom(tmp_0, out_obj) == 0)))) {
                return GVS_Convert(##Go, out_obj, 0);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1444, 508, 2);
        }
    }
    rfalse;
];
[ call_U1445 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1445, 509, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U242));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1445, 509, 2);
        }
    }
    rfalse;
];
[ call_U1446;
    ResponseViaActivity(response_id_U242);
];
[ call_U1447 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] in anything at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " in anything at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1448 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1448, 510, 0);
        }
        if ((((ContainerOf(actor) ofclass K5_container)) && (((call_U387(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U243));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1448, 510, 2);
        }
    }
    rfalse;
];
[ call_U1449;
    ResponseViaActivity(response_id_U243);
];
[ call_U1450 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't get out of the closed [cage].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't get out of the closed ";
    ParaContent();
    PrintShortName(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1451 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1451, 511, 0);
        }
        if ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))) {
            return GVS_Convert(##GetOff, tmp_0, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1451, 511, 2);
        }
    }
    rfalse;
];
[ call_U1452 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1452, 512, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf((MStack-->(MstVO(var_id_U44, 0)))));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1452, 512, 2);
        }
    }
    rfalse;
];
[ call_U1453;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1453, 513, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                if (((MStack-->(MstVO(var_id_U44, 0))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U244);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U245);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U246);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1453, 513, 2);
        }
    }
    rfalse;
];
[ call_U1454;
    ResponseViaActivity(response_id_U244);
];
[ call_U1455;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] off [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1456;
    ResponseViaActivity(response_id_U245);
];
[ call_U1457;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] out of [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1458;
    ResponseViaActivity(response_id_U246);
];
[ call_U1459;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] out of [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1460;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1460, 514, 0);
        }
        if ((actor == player)) {
            SilentlyConsiderLight();
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1460, 514, 2);
        }
    }
    rfalse;
];
[ call_U1461;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1461, 515, 0);
        }
        if ((noun == SupporterOf(actor))) {
            rfalse;
        }
        if ((noun == CarrierOf(actor))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U247);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1461, 515, 2);
        }
    }
    rfalse;
];
[ call_U1462;
    ResponseViaActivity(response_id_U247);
];
[ call_U1463;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] on [the noun] at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1464 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1464, 516, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf(noun));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1464, 516, 2);
        }
    }
    rfalse;
];
[ call_U1465;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1465, 517, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U248);
            print "^";
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1465, 517, 2);
        }
    }
    rfalse;
];
[ call_U1466;
    ResponseViaActivity(response_id_U248);
];
[ call_U1467;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1468;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1468, 518, 0);
        }
        if ((actor == player)) {
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1468, 518, 2);
        }
    }
    rfalse;
];
[ call_U1469;
    if ((action == ##Look)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1469, 519, 0);
        }
        if ((actor == player)) {
            FindVisibilityLevels();
        }
        ((MStack-->(MstVO(var_id_U46, 2))) = visibility_levels);
        ((MStack-->(MstVO(var_id_U46, 3))) = visibility_ceiling);
        ((MStack-->(MstVO(var_id_U46, 0))) = ##Look);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1469, 519, 2);
        }
    }
    rfalse;
];
[ call_U1470 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1470, 520, 0);
        }
        for (((tmp_0 = (call_U1471)(0)),(tmp_1 = (call_U1471)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U1471)(tmp_1)))) {
            call_U371(tmp_0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1470, 520, 3);
        }
    }
    rfalse;
];
[ call_U1471 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1472 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1472, 521, 0);
        }
        (say__p = 1);
        ParaContent();
        style bold;
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            BeginActivity(V12_printing_the_name_of_a_da);
            if ((~~(ForActivity(V12_printing_the_name_of_a_da)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U249);
            }
            EndActivity(V12_printing_the_name_of_a_da);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                (say__p = 1);
                ParaContent();
                PrintShortName((MStack-->(MstVO(var_id_U46, 3))));
            } else {
                (say__p = 1);
                ParaContent();
                CDefArt((MStack-->(MstVO(var_id_U46, 3))));
            }
        }
        (say__p = 1);
        ParaContent();
        style roman;
        (tmp_0 = VisibilityParent(actor));
        for ((tmp_1 = 2):(tmp_1 <= (MStack-->(MstVO(var_id_U46, 2)))):(tmp_1)++) {
            if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U250)));
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U251)));
            }
            (tmp_0 = VisibilityParent(tmp_0));
        }
        (say__p = 1);
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        SpecialLookSpacingBreak();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1472, 521, 3);
        }
    }
    rfalse;
];
[ call_U1473;
    ResponseViaActivity(response_id_U249);
];
[ call_U1474;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Darkness~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ call_U1475;
    ResponseViaActivity(response_id_U250);
];
[ call_U1476 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (on [the intermediate level])~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1477;
    ResponseViaActivity(response_id_U251);
];
[ call_U1478 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (in [the intermediate level])~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1479;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1479, 522, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            if ((lookmode == 3)) {
                rfalse;
            }
            if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (((Global_Vars-->23) == 1)))))) {
                rfalse;
            }
            BeginActivity(V13_printing_the_description_);
            if ((~~(ForActivity(V13_printing_the_description_)))) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U252);
                print "^";
            }
            EndActivity(V13_printing_the_description_);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                if ((lookmode == 3)) {
                    rfalse;
                }
                if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (call_U321(real_location)))))) {
                    rfalse;
                }
                PrintOrRun(location, A_description);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1479, 522, 3);
        }
    }
    rfalse;
];
[ call_U1480;
    ResponseViaActivity(response_id_U252);
];
[ call_U1481;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] pitch dark, and [we] [can't see] a thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U274();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ call_U1482 tmp_0 tmp_1 tmp_2;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1482, 523, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) > 0)) {
            (tmp_0 = actor);
            (tmp_1 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_1 > 0)) {
                call_U364(tmp_0);
                (tmp_0 = VisibilityParent(tmp_0));
                (tmp_1 = (tmp_1 - 1));
            }
            (tmp_2 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_2 > 0)) {
                (tmp_0 = actor);
                (tmp_1 = 0);
                while ((tmp_1 < tmp_2)) {
                    (tmp_0 = VisibilityParent(tmp_0));
                    (tmp_1 = (tmp_1 + 1));
                }
                call_U1928(tmp_0);
                (tmp_2 = (tmp_2 - 1));
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1482, 523, 3);
        }
    }
    rfalse;
];
[ call_U1483;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1483, 524, 0);
        }
        if ((location == thedark)) {
            ((Global_Vars-->23) = 1);
        } else {
            if ((real_location ofclass K1_room)) {
                call_U322(real_location);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1483, 524, 3);
        }
    }
    rfalse;
];
[ call_U1484;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1484, 525, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U253);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1484, 525, 2);
        }
    }
    rfalse;
];
[ call_U1485;
    ResponseViaActivity(response_id_U253);
];
[ call_U1486;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] around.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " around.";
    rtrue;
];
[ call_U1487;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1487, 526, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_description)) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, noun, A_description),bc_U240) == 0)))))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(OBJECT_TY, (self = noun), A_description));
            @pull self;
            ParaContent();
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1487, 526, 3);
        }
    }
    rfalse;
];
[ call_U1488;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1488, 527, 0);
        }
        if ((noun ofclass K3_direction)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U254);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1488, 527, 3);
        }
    }
    rfalse;
];
[ call_U1489;
    ResponseViaActivity(response_id_U254);
];
[ call_U1490;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [see] nothing unexpected in that direction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected in that direction.";
    rtrue;
];
[ call_U1491;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1491, 528, 0);
        }
        if ((noun ofclass K5_container)) {
            if (((call_U384(noun)) || (call_U378(noun)))) {
                if (((call_U1492()) && (call_U1493()))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U255);
                    WriteListFrom(child(noun), 3144);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                    ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                } else {
                    if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
                        if ((noun == ContainerOf(player))) {
                            rfalse;
                        }
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U256);
                        print "^";
                        ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1491, 528, 3);
        }
    }
    rfalse;
];
[ call_U1492 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U360(x)))) {
            if ((~~(call_U345(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1493 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            if ((~~((x == player)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1494;
    ResponseViaActivity(response_id_U255);
];
[ call_U1495;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1496;
    ResponseViaActivity(response_id_U256);
];
[ call_U1497;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1498;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1498, 529, 0);
        }
        if ((noun ofclass K6_supporter)) {
            if (((call_U1499()) && (call_U1500()))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U257);
                WriteListFrom(child(noun), 3288);
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                ((MStack-->(MstVO(var_id_U47, 0))) = 1);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1498, 529, 3);
        }
    }
    rfalse;
];
[ call_U1499 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U360(x)))) {
                if ((~~(call_U345(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1500 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                if ((~~((x == player)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1501;
    ResponseViaActivity(response_id_U257);
];
[ call_U1502;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1503;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1503, 530, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U258);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1503, 530, 3);
        }
    }
    rfalse;
];
[ call_U1504;
    ResponseViaActivity(response_id_U258);
];
[ call_U1505;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] [if story tense is present tense]currently [end if]switched^[if the noun is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "currently ";
    .L_Say0;
    ParaContent();
    print "switched ";
    if ((~~(call_U414(noun)))) {
        jump L_Say1;
    }
    ParaContent();
    print "on";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "off";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1506;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1506, 531, 0);
        }
        if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U259);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1506, 531, 3);
        }
    }
    rfalse;
];
[ call_U1507;
    ResponseViaActivity(response_id_U259);
];
[ call_U1508;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [see] nothing special about [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing special about ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1509;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1509, 532, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U260);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1509, 532, 2);
        }
    }
    rfalse;
];
[ call_U1510;
    ResponseViaActivity(response_id_U260);
];
[ call_U1511;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] closely at [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closely at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1512;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1512, 533, 0);
        }
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U261);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1512, 533, 2);
        }
    }
    rfalse;
];
[ call_U1513;
    ResponseViaActivity(response_id_U261);
];
[ call_U1514;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [find] nothing of interest.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1515;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1515, 534, 0);
        }
        if ((keep_silent == 0)) {
            if ((~~((actor == player)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U262);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1515, 534, 2);
        }
    }
    rfalse;
];
[ call_U1516;
    ResponseViaActivity(response_id_U262);
];
[ call_U1517;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] under [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " under ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1518;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1518, 535, 0);
        }
        if ((((~~((noun ofclass K5_container)))) && ((~~((noun ofclass K6_supporter)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U263);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1518, 535, 2);
        }
    }
    rfalse;
];
[ call_U1519;
    ResponseViaActivity(response_id_U263);
];
[ call_U1520;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [find] nothing of interest.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1521;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1521, 536, 0);
        }
        if ((((noun ofclass K5_container)) && (((call_U387(noun)) && (call_U381(noun)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U264);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1521, 536, 2);
        }
    }
    rfalse;
];
[ call_U1522;
    ResponseViaActivity(response_id_U264);
];
[ call_U1523;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't see] inside, since [the noun] [are] closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " inside, since ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1524;
    if ((((actor == player)) && ((noun ofclass K5_container)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1524, 537, 0);
        }
        if (call_U1525()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U265);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U266);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1524, 537, 2);
        }
    }
    rfalse;
];
[ call_U1525 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U360(x)))) {
            if ((~~(call_U345(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1526;
    ResponseViaActivity(response_id_U265);
];
[ call_U1527;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1528;
    ResponseViaActivity(response_id_U266);
];
[ call_U1529;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1530;
    if ((((actor == player)) && ((noun ofclass K6_supporter)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1530, 538, 0);
        }
        if (call_U1531()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U267);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U268);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1530, 538, 2);
        }
    }
    rfalse;
];
[ call_U1531 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U360(x)))) {
                if ((~~(call_U345(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1532;
    ResponseViaActivity(response_id_U267);
];
[ call_U1533;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1534;
    ResponseViaActivity(response_id_U268);
];
[ call_U1535;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] nothing on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1536;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1536, 539, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U269);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1536, 539, 2);
        }
    }
    rfalse;
];
[ call_U1537;
    ResponseViaActivity(response_id_U269);
];
[ call_U1538;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [search] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb27(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1539;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1539, 540, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U270);
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U271);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1539, 540, 2);
        }
    }
    rfalse;
];
[ call_U1540;
    ResponseViaActivity(response_id_U270);
];
[ call_U1541;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [discover] nothing of interest in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb28(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1542;
    ResponseViaActivity(response_id_U271);
];
[ call_U1543;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] at [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1544;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1544, 541, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U396(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U272);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1544, 541, 2);
        }
    }
    rfalse;
];
[ call_U1545;
    ResponseViaActivity(response_id_U272);
];
[ call_U1546;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lock.";
    rtrue;
];
[ call_U1547;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1547, 542, 0);
        }
        if (call_U399(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U273);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1547, 542, 2);
        }
    }
    rfalse;
];
[ call_U1548;
    ResponseViaActivity(response_id_U273);
];
[ call_U1549;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] locked at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " locked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1550;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1550, 543, 0);
        }
        if (call_U384(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U274);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1550, 543, 2);
        }
    }
    rfalse;
];
[ call_U1551;
    ResponseViaActivity(response_id_U274);
];
[ call_U1552;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~First [we] [would have] to close [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "First ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to close ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1553;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1553, 544, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U275);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1553, 544, 2);
        }
    }
    rfalse;
];
[ call_U1554;
    ResponseViaActivity(response_id_U275);
];
[ call_U1555;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [don't] seem to fit the lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1556;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1556, 545, 0);
        }
        call_U400(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1556, 545, 2);
        }
    }
    rfalse;
];
[ call_U1557;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1557, 546, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U276);
                print "^";
            }
        } else {
            if (call_U293(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U277);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1557, 546, 2);
        }
    }
    rfalse;
];
[ call_U1558;
    ResponseViaActivity(response_id_U276);
];
[ call_U1559;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1560;
    ResponseViaActivity(response_id_U277);
];
[ call_U1561;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [lock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1562;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1562, 547, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U396(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U278);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1562, 547, 2);
        }
    }
    rfalse;
];
[ call_U1563;
    ResponseViaActivity(response_id_U278);
];
[ call_U1564;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unlock.";
    rtrue;
];
[ call_U1565;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1565, 548, 0);
        }
        if ((~~(call_U399(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U279);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1565, 548, 2);
        }
    }
    rfalse;
];
[ call_U1566;
    ResponseViaActivity(response_id_U279);
];
[ call_U1567;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] unlocked at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " unlocked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1568;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1568, 549, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U280);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1568, 549, 2);
        }
    }
    rfalse;
];
[ call_U1569;
    ResponseViaActivity(response_id_U280);
];
[ call_U1570;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [don't] seem to fit the lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U259();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1571;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1571, 550, 0);
        }
        call_U401(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1571, 550, 2);
        }
    }
    rfalse;
];
[ call_U1572;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1572, 551, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U281);
                print "^";
            }
        } else {
            if (call_U293(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U282);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1572, 551, 2);
        }
    }
    rfalse;
];
[ call_U1573;
    ResponseViaActivity(response_id_U281);
];
[ call_U1574;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [unlock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1575;
    ResponseViaActivity(response_id_U282);
];
[ call_U1576;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [unlock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1577;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1577, 552, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U283);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1577, 552, 2);
        }
    }
    rfalse;
];
[ call_U1578;
    ResponseViaActivity(response_id_U283);
];
[ call_U1579;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] switch.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1580;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1580, 553, 0);
        }
        if (call_U414(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U284);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1580, 553, 2);
        }
    }
    rfalse;
];
[ call_U1581;
    ResponseViaActivity(response_id_U284);
];
[ call_U1582;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " already on.";
    rtrue;
];
[ call_U1583;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1583, 554, 0);
        }
        call_U415(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1583, 554, 2);
        }
    }
    rfalse;
];
[ call_U1584;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1584, 555, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U285);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1584, 555, 2);
        }
    }
    rfalse;
];
[ call_U1585;
    ResponseViaActivity(response_id_U285);
];
[ call_U1586;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [switch] [the noun] on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on.";
    rtrue;
];
[ call_U1587;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1587, 556, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U286);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1587, 556, 2);
        }
    }
    rfalse;
];
[ call_U1588;
    ResponseViaActivity(response_id_U286);
];
[ call_U1589;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] switch.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1590;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1590, 557, 0);
        }
        if (call_U417(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U287);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1590, 557, 2);
        }
    }
    rfalse;
];
[ call_U1591;
    ResponseViaActivity(response_id_U287);
];
[ call_U1592;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " already off.";
    rtrue;
];
[ call_U1593;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1593, 558, 0);
        }
        call_U418(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1593, 558, 2);
        }
    }
    rfalse;
];
[ call_U1594;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1594, 559, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U288);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1594, 559, 2);
        }
    }
    rfalse;
];
[ call_U1595;
    ResponseViaActivity(response_id_U288);
];
[ call_U1596;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [switch] [the noun] off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off.";
    rtrue;
];
[ call_U1597;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1597, 560, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U390(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U289);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1597, 560, 2);
        }
    }
    rfalse;
];
[ call_U1598;
    ResponseViaActivity(response_id_U289);
];
[ call_U1599;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U1600;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1600, 561, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U399(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U290);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1600, 561, 2);
        }
    }
    rfalse;
];
[ call_U1601;
    ResponseViaActivity(response_id_U290);
];
[ call_U1602;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [seem] to be locked.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be locked.";
    rtrue;
];
[ call_U1603;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1603, 562, 0);
        }
        if (call_U384(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U291);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1603, 562, 2);
        }
    }
    rfalse;
];
[ call_U1604;
    ResponseViaActivity(response_id_U291);
];
[ call_U1605;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " already open.";
    rtrue;
];
[ call_U1606;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1606, 563, 0);
        }
        call_U385(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1606, 563, 2);
        }
    }
    rfalse;
];
[ call_U1607;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1607, 564, 0);
        }
        if ((((actor == player)) && ((((((noun ofclass K5_container)) && (call_U381(noun)))) && ((((~~((child(noun) == 0)))) && ((~~(IndirectlyContains(noun, actor)))))))))) {
            if ((keep_silent == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U292);
                    WriteListFrom(child(noun), 2120);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1607, 564, 2);
        }
    }
    rfalse;
];
[ call_U1608;
    ResponseViaActivity(response_id_U292);
];
[ call_U1609;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [open] [the noun], revealing ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ", revealing ";
    rtrue;
];
[ call_U1610;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1610, 565, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U293);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U294);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U295);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1610, 565, 2);
        }
    }
    rfalse;
];
[ call_U1611;
    ResponseViaActivity(response_id_U293);
];
[ call_U1612;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [open] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1613;
    ResponseViaActivity(response_id_U294);
];
[ call_U1614;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [open] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1615;
    ResponseViaActivity(response_id_U295);
];
[ call_U1616;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [open].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1617;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1617, 566, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U390(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U296);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1617, 566, 2);
        }
    }
    rfalse;
];
[ call_U1618;
    ResponseViaActivity(response_id_U296);
];
[ call_U1619;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] close.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " close.";
    rtrue;
];
[ call_U1620;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1620, 567, 0);
        }
        if (call_U387(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U297);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1620, 567, 2);
        }
    }
    rfalse;
];
[ call_U1621;
    ResponseViaActivity(response_id_U297);
];
[ call_U1622;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U273();
    ParaContent();
    print " already closed.";
    rtrue;
];
[ call_U1623;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1623, 568, 0);
        }
        call_U388(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1623, 568, 2);
        }
    }
    rfalse;
];
[ call_U1624;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1624, 569, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U298);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U299);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U300);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1624, 569, 2);
        }
    }
    rfalse;
];
[ call_U1625;
    ResponseViaActivity(response_id_U298);
];
[ call_U1626;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [close] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1627;
    ResponseViaActivity(response_id_U299);
];
[ call_U1628;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [close] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1629;
    ResponseViaActivity(response_id_U300);
];
[ call_U1630;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [close].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1631;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1631, 570, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U348(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U301);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1631, 570, 2);
        }
    }
    rfalse;
];
[ call_U1632;
    ResponseViaActivity(response_id_U301);
];
[ call_U1633;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't wear] [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb35);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1634;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1634, 571, 0);
        }
        if ((~~((HolderOf(noun) == actor)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U302);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1634, 571, 2);
        }
    }
    rfalse;
];
[ call_U1635;
    ResponseViaActivity(response_id_U302);
];
[ call_U1636;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1637;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1637, 572, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U303);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1637, 572, 2);
        }
    }
    rfalse;
];
[ call_U1638;
    ResponseViaActivity(response_id_U303);
];
[ call_U1639;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] already wearing [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already wearing ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1640;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1640, 573, 0);
        }
        WearObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1640, 573, 2);
        }
    }
    rfalse;
];
[ call_U1641;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1641, 574, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U304);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U305);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1641, 574, 2);
        }
    }
    rfalse;
];
[ call_U1642;
    ResponseViaActivity(response_id_U304);
];
[ call_U1643;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [put] on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1644;
    ResponseViaActivity(response_id_U305);
];
[ call_U1645;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1646;
    if ((((action == ##Disrobe)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U290(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1646, 575, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_likely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1646, 575, 2);
        }
    }
    rfalse;
];
[ call_U1647;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1647, 576, 0);
        }
        if ((~~((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U306);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1647, 576, 2);
        }
    }
    rfalse;
];
[ call_U1648;
    ResponseViaActivity(response_id_U306);
];
[ call_U1649;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] wearing [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " wearing ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1650;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1650, 577, 0);
        }
        if (((call_U1651)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U307);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1650, 577, 2);
        }
    }
    rfalse;
];
[ call_U1651 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1652;
    ResponseViaActivity(response_id_U307);
];
[ call_U1653;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1654;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1654, 578, 0);
        }
        MoveObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1654, 578, 2);
        }
    }
    rfalse;
];
[ call_U1655;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1655, 579, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U308);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U309);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1655, 579, 2);
        }
    }
    rfalse;
];
[ call_U1656;
    ResponseViaActivity(response_id_U308);
];
[ call_U1657;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [take] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1658;
    ResponseViaActivity(response_id_U309);
];
[ call_U1659;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [take] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1660;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1660, 580, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U310);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1660, 580, 2);
        }
    }
    rfalse;
];
[ call_U1661;
    ResponseViaActivity(response_id_U310);
];
[ call_U1662;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1663;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1663, 581, 0);
        }
        if ((actor == second)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U311);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1663, 581, 2);
        }
    }
    rfalse;
];
[ call_U1664;
    ResponseViaActivity(response_id_U311);
];
[ call_U1665;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't give] [the noun] to [ourselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb37);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U251();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1666;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1666, 582, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U312);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1666, 582, 2);
        }
    }
    rfalse;
];
[ call_U1667;
    ResponseViaActivity(response_id_U312);
];
[ call_U1668;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [aren't] able to receive things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " able to receive things.";
    rtrue;
];
[ call_U1669;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1669, 583, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U313);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1669, 583, 2);
        }
    }
    rfalse;
];
[ call_U1670;
    ResponseViaActivity(response_id_U313);
];
[ call_U1671;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1672;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1672, 584, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U314);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1672, 584, 2);
        }
    }
    rfalse;
];
[ call_U1673;
    ResponseViaActivity(response_id_U314);
];
[ call_U1674;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [don't] seem interested.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem interested.";
    rtrue;
];
[ call_U1675;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1675, 585, 0);
        }
        if (((call_U1676)() >= GProperty(OBJECT_TY, second, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U315);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1675, 585, 2);
        }
    }
    rfalse;
];
[ call_U1676 x x_ix counter;
    objectloop (x in second) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1677;
    ResponseViaActivity(response_id_U315);
];
[ call_U1678;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1679;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1679, 586, 0);
        }
        MoveObject(noun, second, 0, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1679, 586, 2);
        }
    }
    rfalse;
];
[ call_U1680;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1680, 587, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U316);
            print "^";
        } else {
            if ((second == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U317);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U318);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1680, 587, 2);
        }
    }
    rfalse;
];
[ call_U1681;
    ResponseViaActivity(response_id_U316);
];
[ call_U1682;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [give] [the noun] to [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1683;
    ResponseViaActivity(response_id_U317);
];
[ call_U1684;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [give] [the noun] to [us].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U249();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1685;
    ResponseViaActivity(response_id_U318);
];
[ call_U1686;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [give] [the noun] to [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1687;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1687, 588, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U319);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1687, 588, 2);
        }
    }
    rfalse;
];
[ call_U1688;
    ResponseViaActivity(response_id_U319);
];
[ call_U1689;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1690;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1690, 589, 0);
        }
        if ((actor == second)) {
            return GVS_Convert(##Examine, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1690, 589, 2);
        }
    }
    rfalse;
];
[ call_U1691;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1691, 590, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U320);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1691, 590, 2);
        }
    }
    rfalse;
];
[ call_U1692;
    ResponseViaActivity(response_id_U320);
];
[ call_U1693;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] unimpressed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unimpressed.";
    rtrue;
];
[ call_U1694;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1694, 591, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U321);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1694, 591, 2);
        }
    }
    rfalse;
];
[ call_U1695;
    ResponseViaActivity(response_id_U321);
];
[ call_U1696;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That [seem] unnecessary.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unnecessary.";
    rtrue;
];
[ call_U1697;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1697, 592, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U322);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1697, 592, 2);
        }
    }
    rfalse;
];
[ call_U1698;
    ResponseViaActivity(response_id_U322);
];
[ call_U1699;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1700;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1700, 593, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U323);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1700, 593, 2);
        }
    }
    rfalse;
];
[ call_U1701;
    ResponseViaActivity(response_id_U323);
];
[ call_U1702;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Futile.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Futile.";
    rtrue;
];
[ call_U1703;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1703, 594, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U324);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1703, 594, 2);
        }
    }
    rfalse;
];
[ call_U1704;
    ResponseViaActivity(response_id_U324);
];
[ call_U1705;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lack] the nerve when it [if story tense is the past^tense]came[otherwise]comes[end if] to the crucial moment.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the nerve when it ";
    if ((~~((story_tense == I_past_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "came";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "comes";
    .L_SayX0;
    ParaContent();
    print " to the crucial moment.";
    rtrue;
];
[ call_U1706;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1706, 595, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U325);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1706, 595, 2);
        }
    }
    rfalse;
];
[ call_U1707;
    ResponseViaActivity(response_id_U325);
];
[ call_U1708;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Violence [aren't] the answer to this one.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Violence ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the answer to this one.";
    rtrue;
];
[ call_U1709;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1709, 596, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U326);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1709, 596, 2);
        }
    }
    rfalse;
];
[ call_U1710;
    ResponseViaActivity(response_id_U326);
];
[ call_U1711;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [don't] get much from that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " get much from that.";
    rtrue;
];
[ call_U1712;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1712, 597, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U327);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1712, 597, 2);
        }
    }
    rfalse;
];
[ call_U1713;
    ResponseViaActivity(response_id_U327);
];
[ call_U1714;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not] like that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " like that.";
    rtrue;
];
[ call_U1715;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1715, 598, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U328);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1715, 598, 2);
        }
    }
    rfalse;
];
[ call_U1716;
    ResponseViaActivity(response_id_U328);
];
[ call_U1717;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no reply.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1718;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1718, 599, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U329);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1718, 599, 2);
        }
    }
    rfalse;
];
[ call_U1719;
    ResponseViaActivity(response_id_U329);
];
[ call_U1720;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [talk] to [ourselves] a while.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb38(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to ";
    ParaContent();
    call_U251();
    ParaContent();
    print " a while.";
    rtrue;
];
[ call_U1721;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1721, 600, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U330);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1721, 600, 2);
        }
    }
    rfalse;
];
[ call_U1722;
    ResponseViaActivity(response_id_U330);
];
[ call_U1723;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This [provoke] no reaction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This ";
    ConjugateVerb39(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reaction.";
    rtrue;
];
[ call_U1724;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1724, 601, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U331);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1724, 601, 2);
        }
    }
    rfalse;
];
[ call_U1725;
    ResponseViaActivity(response_id_U331);
];
[ call_U1726;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no reply.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U275();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1727;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1727, 602, 0);
        }
        if ((((actor == noun)) && ((actor == player)))) {
            TryAction(0, player, ##Inv, 0, 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1727, 602, 2);
        }
    }
    rfalse;
];
[ call_U1728;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1728, 603, 0);
        }
        return ConvertToRequest(noun, ##Give, second, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1728, 603, 2);
        }
    }
    rfalse;
];
[ call_U1729;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1729, 604, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U332);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U333);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1729, 604, 2);
        }
    }
    rfalse;
];
[ call_U1730;
    ResponseViaActivity(response_id_U332);
];
[ call_U1731;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Time [pass].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Time ";
    ConjugateVerb40(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1732;
    ResponseViaActivity(response_id_U333);
];
[ call_U1733;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wait].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb41(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1734;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1734, 605, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U334);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U335);
                print "^";
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1734, 605, 2);
        }
    }
    rfalse;
];
[ call_U1735;
    ResponseViaActivity(response_id_U334);
];
[ call_U1736;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1737;
    ResponseViaActivity(response_id_U335);
];
[ call_U1738;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [themselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U270();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1739;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1739, 606, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U336);
                    print "^";
                }
            } else {
                if ((noun == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U337);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U338);
                    print "^";
                }
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1739, 606, 2);
        }
    }
    rfalse;
];
[ call_U1740;
    ResponseViaActivity(response_id_U336);
];
[ call_U1741;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1742;
    ResponseViaActivity(response_id_U337);
];
[ call_U1743;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [us].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U249();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1744;
    ResponseViaActivity(response_id_U338);
];
[ call_U1745;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1746;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1746, 607, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U339);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U340);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1746, 607, 2);
        }
    }
    rfalse;
];
[ call_U1747;
    ResponseViaActivity(response_id_U339);
];
[ call_U1748;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [feel] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb44(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1749;
    ResponseViaActivity(response_id_U340);
];
[ call_U1750;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1751;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1751, 608, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U341);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1751, 608, 2);
        }
    }
    rfalse;
];
[ call_U1752;
    ResponseViaActivity(response_id_U341);
];
[ call_U1753;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] holding [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1754;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1754, 609, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U342);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U343);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1754, 609, 2);
        }
    }
    rfalse;
];
[ call_U1755;
    ResponseViaActivity(response_id_U342);
];
[ call_U1756;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [wave] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1757;
    ResponseViaActivity(response_id_U343);
];
[ call_U1758;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wave] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1759;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1759, 610, 0);
        }
        if (call_U339(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U344);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1759, 610, 2);
        }
    }
    rfalse;
];
[ call_U1760;
    ResponseViaActivity(response_id_U344);
];
[ call_U1761;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1762;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1762, 611, 0);
        }
        if (call_U345(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U345);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1762, 611, 2);
        }
    }
    rfalse;
];
[ call_U1763;
    ResponseViaActivity(response_id_U345);
];
[ call_U1764;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1765;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1765, 612, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U346);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1765, 612, 2);
        }
    }
    rfalse;
];
[ call_U1766;
    ResponseViaActivity(response_id_U346);
];
[ call_U1767;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1768;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1768, 613, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U347);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U348);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1768, 613, 2);
        }
    }
    rfalse;
];
[ call_U1769;
    ResponseViaActivity(response_id_U347);
];
[ call_U1770;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1771;
    ResponseViaActivity(response_id_U348);
];
[ call_U1772;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [pull] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb47(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1773;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1773, 614, 0);
        }
        if (call_U339(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U349);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1773, 614, 2);
        }
    }
    rfalse;
];
[ call_U1774;
    ResponseViaActivity(response_id_U349);
];
[ call_U1775;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1776;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1776, 615, 0);
        }
        if (call_U345(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U350);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1776, 615, 2);
        }
    }
    rfalse;
];
[ call_U1777;
    ResponseViaActivity(response_id_U350);
];
[ call_U1778;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1779;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1779, 616, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U351);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1779, 616, 2);
        }
    }
    rfalse;
];
[ call_U1780;
    ResponseViaActivity(response_id_U351);
];
[ call_U1781;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1782;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1782, 617, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U352);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U353);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1782, 617, 2);
        }
    }
    rfalse;
];
[ call_U1783;
    ResponseViaActivity(response_id_U352);
];
[ call_U1784;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1785;
    ResponseViaActivity(response_id_U353);
];
[ call_U1786;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [push] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb48(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1787;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1787, 618, 0);
        }
        if (call_U339(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U354);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1787, 618, 2);
        }
    }
    rfalse;
];
[ call_U1788;
    ResponseViaActivity(response_id_U354);
];
[ call_U1789;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1790;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1790, 619, 0);
        }
        if (call_U345(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U355);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1790, 619, 2);
        }
    }
    rfalse;
];
[ call_U1791;
    ResponseViaActivity(response_id_U355);
];
[ call_U1792;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1793;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1793, 620, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U356);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1793, 620, 2);
        }
    }
    rfalse;
];
[ call_U1794;
    ResponseViaActivity(response_id_U356);
];
[ call_U1795;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1796;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1796, 621, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U357);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U358);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1796, 621, 2);
        }
    }
    rfalse;
];
[ call_U1797;
    ResponseViaActivity(response_id_U357);
];
[ call_U1798;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1799;
    ResponseViaActivity(response_id_U358);
];
[ call_U1800;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [turn] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb49(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1801;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1801, 622, 0);
        }
        if ((~~(call_U351(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U359);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1801, 622, 2);
        }
    }
    rfalse;
];
[ call_U1802;
    ResponseViaActivity(response_id_U359);
];
[ call_U1803;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from place to place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1804;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1804, 623, 0);
        }
        if ((~~((second ofclass K3_direction)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U360);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1804, 623, 2);
        }
    }
    rfalse;
];
[ call_U1805;
    ResponseViaActivity(response_id_U360);
];
[ call_U1806;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] a direction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U263();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a direction.";
    rtrue;
];
[ call_U1807;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1807, 624, 0);
        }
        if ((((second == I_up_U1)) || ((second == I_down_U1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U361);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1807, 624, 2);
        }
    }
    rfalse;
];
[ call_U1808;
    ResponseViaActivity(response_id_U361);
];
[ call_U1809;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed up or down.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed up or down.";
    rtrue;
];
[ call_U1810;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1810, 625, 0);
        }
        if (IndirectlyContains(noun, actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U362);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1810, 625, 2);
        }
    }
    rfalse;
];
[ call_U1811;
    ResponseViaActivity(response_id_U362);
];
[ call_U1812;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from here.";
    rtrue;
];
[ call_U1813;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1813, 626, 0);
        }
        return ConvertToGoingWithPush();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1813, 626, 2);
        }
    }
    rfalse;
];
[ call_U1814;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1814, 627, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U363);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1814, 627, 2);
        }
    }
    rfalse;
];
[ call_U1815;
    ResponseViaActivity(response_id_U363);
];
[ call_U1816;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from place to place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1817;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1817, 628, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U364);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1817, 628, 2);
        }
    }
    rfalse;
];
[ call_U1818;
    ResponseViaActivity(response_id_U364);
];
[ call_U1819;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1820;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1820, 629, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U365);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U366);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1820, 629, 2);
        }
    }
    rfalse;
];
[ call_U1821;
    ResponseViaActivity(response_id_U365);
];
[ call_U1822;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1823;
    ResponseViaActivity(response_id_U366);
];
[ call_U1824;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [squeeze] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb50(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1825;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1825, 630, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U367);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1825, 630, 2);
        }
    }
    rfalse;
];
[ call_U1826;
    ResponseViaActivity(response_id_U367);
];
[ call_U1827;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That was a rhetorical question.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1828;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1828, 631, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U368);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1828, 631, 2);
        }
    }
    rfalse;
];
[ call_U1829;
    ResponseViaActivity(response_id_U368);
];
[ call_U1830;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That was a rhetorical question.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1831;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1831, 632, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U369);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1831, 632, 2);
        }
    }
    rfalse;
];
[ call_U1832;
    ResponseViaActivity(response_id_U369);
];
[ call_U1833;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This dangerous act [would achieve] little.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This dangerous act ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1834;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1834, 633, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U370);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1834, 633, 2);
        }
    }
    rfalse;
];
[ call_U1835;
    ResponseViaActivity(response_id_U370);
];
[ call_U1836;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The dreadful truth [are], this [are not] a dream.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The dreadful truth ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", this ";
    ConjugateVerb1(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a dream.";
    rtrue;
];
[ call_U1837;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1837, 634, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U371);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1837, 634, 2);
        }
    }
    rfalse;
];
[ call_U1838;
    ResponseViaActivity(response_id_U371);
];
[ call_U1839;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What a good idea.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What a good idea.";
    rtrue;
];
[ call_U1840;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1840, 635, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U372);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U373);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1840, 635, 2);
        }
    }
    rfalse;
];
[ call_U1841;
    ResponseViaActivity(response_id_U372);
];
[ call_U1842;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [smell] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb51(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1843;
    ResponseViaActivity(response_id_U373);
];
[ call_U1844;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [sniff].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb52(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1845;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1845, 636, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U374);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U375);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1845, 636, 2);
        }
    }
    rfalse;
];
[ call_U1846;
    ResponseViaActivity(response_id_U374);
];
[ call_U1847;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [hear] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb53(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1848;
    ResponseViaActivity(response_id_U375);
];
[ call_U1849;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [listen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb54(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1850;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1850, 637, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U376);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U377);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1850, 637, 2);
        }
    }
    rfalse;
];
[ call_U1851;
    ResponseViaActivity(response_id_U376);
];
[ call_U1852;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [taste] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1853;
    ResponseViaActivity(response_id_U377);
];
[ call_U1854;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [taste] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1855;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1855, 638, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U378);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1855, 638, 2);
        }
    }
    rfalse;
];
[ call_U1856;
    ResponseViaActivity(response_id_U378);
];
[ call_U1857;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Cutting [regarding the noun][them] up [would achieve] little.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Cutting ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U266();
    ParaContent();
    print " up ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1858;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1858, 639, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U379);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U380);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1858, 639, 2);
        }
    }
    rfalse;
];
[ call_U1859;
    ResponseViaActivity(response_id_U379);
];
[ call_U1860;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [jump] on the spot.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1861;
    ResponseViaActivity(response_id_U380);
];
[ call_U1862;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [jump] on the spot.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1863;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1863, 640, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U381);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1863, 640, 2);
        }
    }
    rfalse;
];
[ call_U1864;
    ResponseViaActivity(response_id_U381);
];
[ call_U1865;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1866;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1866, 641, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U382);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1866, 641, 2);
        }
    }
    rfalse;
];
[ call_U1867;
    ResponseViaActivity(response_id_U382);
];
[ call_U1868;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There's] nothing suitable to drink here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U279();
    ParaContent();
    print " nothing suitable to drink here.";
    rtrue;
];
[ call_U1869;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1869, 642, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U383);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1869, 642, 2);
        }
    }
    rfalse;
];
[ call_U1870;
    ResponseViaActivity(response_id_U383);
];
[ call_U1871;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Oh, don't [if American dialect option is^active]apologize[otherwise]apologise[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Oh, don't ";
    if ((~~(call_U150(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "apologize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "apologise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1872;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1872, 643, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U384);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1872, 643, 2);
        }
    }
    rfalse;
];
[ call_U1873;
    ResponseViaActivity(response_id_U384);
];
[ call_U1874;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There's] nothing sensible to swing here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U279();
    ParaContent();
    print " nothing sensible to swing here.";
    rtrue;
];
[ call_U1875;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1875, 644, 0);
        }
        if ((((noun ofclass K8_person)) && ((~~((noun == actor)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U385);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1875, 644, 2);
        }
    }
    rfalse;
];
[ call_U1876;
    ResponseViaActivity(response_id_U385);
];
[ call_U1877;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1878;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1878, 645, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U386);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U387);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1878, 645, 2);
        }
    }
    rfalse;
];
[ call_U1879;
    ResponseViaActivity(response_id_U386);
];
[ call_U1880;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [rub] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1881;
    ResponseViaActivity(response_id_U387);
];
[ call_U1882;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [rub] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1883;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1883, 646, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U388);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1883, 646, 2);
        }
    }
    rfalse;
];
[ call_U1884;
    ResponseViaActivity(response_id_U388);
];
[ call_U1885;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~No, [we] [can't set] [regarding the noun][those] to anything.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "No, ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb58);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U258();
    ParaContent();
    print " to anything.";
    rtrue;
];
[ call_U1886;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1886, 647, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U389);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U390);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1886, 647, 2);
        }
    }
    rfalse;
];
[ call_U1887;
    ResponseViaActivity(response_id_U389);
];
[ call_U1888;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [wave].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1889;
    ResponseViaActivity(response_id_U390);
];
[ call_U1890;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wave].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1891;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1891, 648, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U391);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1891, 648, 2);
        }
    }
    rfalse;
];
[ call_U1892;
    ResponseViaActivity(response_id_U391);
];
[ call_U1893;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing [are] on sale.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on sale.";
    rtrue;
];
[ call_U1894;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1894, 649, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U392);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1894, 649, 2);
        }
    }
    rfalse;
];
[ call_U1895;
    ResponseViaActivity(response_id_U392);
];
[ call_U1896;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Little [are] to be achieved by that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Little ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be achieved by that.";
    rtrue;
];
[ call_U1897;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1897, 650, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U393);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1897, 650, 2);
        }
    }
    rfalse;
];
[ call_U1898;
    ResponseViaActivity(response_id_U393);
];
[ call_U1899;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] feeling especially drowsy.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " feeling especially drowsy.";
    rtrue;
];
[ call_U1900 sk;
    rfalse;
];
[ call_U1901 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_map_region)) {
                    print "map region: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_map_region));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_light)) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lighted";
                }
                if (((AllowInShowme(A_light)) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "dark";
                }
                if (((AllowInShowme(A_visited)) && ((t_0 has visited)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "visited";
                }
                if (((AllowInShowme(A_visited)) && ((~~((t_0 has visited)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unvisited";
                }
                if (((AllowInShowme(A_P_indoors)) && ((t_0 has P_indoors)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "indoors";
                }
                if (((AllowInShowme(A_P_indoors)) && ((~~((t_0 has P_indoors)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "outdoors";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1902 sk;
    rfalse;
];
[ call_U1903 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                print "initial appearance: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_initial), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_initial));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_with_key)) {
                    print "matching key: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_with_key));
                    print "^";
                }
                print "price: ";
                (E6)(GProperty(OBJECT_TY, t_0, A_P_price));
                print "^";
            }
        } else {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_light)) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lit";
                }
                if (((AllowInShowme(A_light)) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlit";
                }
                if (((AllowInShowme(A_edible)) && ((t_0 has edible)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "edible";
                }
                if (((AllowInShowme(A_edible)) && ((~~((t_0 has edible)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "inedible";
                }
                if (((AllowInShowme(A_static)) && ((t_0 has static)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "fixed in place";
                }
                if (((AllowInShowme(A_static)) && ((~~((t_0 has static)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "portable";
                }
                if (((AllowInShowme(A_scenery)) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((AllowInShowme(A_clothing)) && ((t_0 has clothing)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "wearable";
                }
                if (((AllowInShowme(A_pushable)) && ((t_0 has pushable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "pushable between rooms";
                }
                if (((AllowInShowme(A_moved)) && ((t_0 has moved)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "handled";
                }
                if (((AllowInShowme(A_concealed)) && ((t_0 has concealed)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "undescribed";
                }
                if (((AllowInShowme(A_concealed)) && ((~~((t_0 has concealed)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "described";
                }
                if (((AllowInShowme(A_workflag)) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((AllowInShowme(A_workflag)) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
                if (((AllowInShowme(A_mentioned)) && ((t_0 has mentioned)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "mentioned";
                }
                if (((AllowInShowme(A_mentioned)) && ((~~((t_0 has mentioned)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmentioned";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1904 sk;
    rfalse;
];
[ call_U1905 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_P_opposite)) {
                    print "opposite: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_P_opposite));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_scenery)) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((AllowInShowme(A_workflag)) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((AllowInShowme(A_workflag)) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1906 sk;
    rfalse;
];
[ call_U1907 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_door_to)) {
                    print "leading-through destination: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_door_to));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_open)) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((AllowInShowme(A_open)) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((AllowInShowme(A_openable)) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((AllowInShowme(A_openable)) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((AllowInShowme(A_lockable)) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((AllowInShowme(A_locked)) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((AllowInShowme(A_locked)) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1908 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U22());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U22;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1909 sk;
    rfalse;
];
[ call_U1910 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_enterable)) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((AllowInShowme(A_open)) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((AllowInShowme(A_open)) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((AllowInShowme(A_openable)) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((AllowInShowme(A_openable)) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((AllowInShowme(A_lockable)) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((AllowInShowme(A_locked)) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((AllowInShowme(A_locked)) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1911 sk;
    rfalse;
];
[ call_U1912 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_enterable)) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1913 sk;
    rfalse;
];
[ call_U1914 sk;
    rfalse;
];
[ call_U1915 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((AllowInShowme(A_female)) && ((t_0 has female)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "female";
                }
                if (((AllowInShowme(A_female)) && ((~~((t_0 has female)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "male";
                }
                if (((AllowInShowme(A_neuter)) && ((t_0 has neuter)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "neuter";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1916 sk;
    rfalse;
];
[ call_U1917 sk;
    rfalse;
];
[ call_U1918 sk;
    rfalse;
];
[ call_U1919 sk;
    rfalse;
];
[ call_U1920 sk;
    rfalse;
];
[ call_U1921 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 ofclass K13_device)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_on)) && ((t_0 has on)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched on";
                }
                if (((AllowInShowme(A_on)) && ((~~((t_0 has on)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched off";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1922 sk;
    rfalse;
];
[ call_U1923 sk;
    rfalse;
];
[ call_U1924 sk;
    return I_didn_t_understand_error_U1;
];
[ E7 value;
    switch (value) {
        I_didn_t_understand_error_U1:
            print "didn't understand error";
            ;
        I_only_understood_as_far_as__U1:
            print "only understood as far as error";
            ;
        I_didn_t_understand_that_num_U1:
            print "didn't understand that number error";
            ;
        I_can_only_do_that_to_someth_U1:
            print "can only do that to something animate error";
            ;
        I_can_t_see_any_such_thing_e_U1:
            print "can't see any such thing error";
            ;
        I_said_too_little_error_U1:
            print "said too little error";
            ;
        I_aren_t_holding_that_error_U1:
            print "aren't holding that error";
            ;
        I_can_t_use_multiple_objects_U1:
            print "can't use multiple objects error";
            ;
        I_can_only_use_multiple_obje_U1:
            print "can only use multiple objects error";
            ;
        I_not_sure_what_it_refers_to_U1:
            print "not sure what it refers to error";
            ;
        I_excepted_something_not_inc_U1:
            print "excepted something not included error";
            ;
        I_not_a_verb_i_recognise_err_U1:
            print "not a verb I recognise error";
            ;
        I_not_something_you_need_to__U1:
            print "not something you need to refer to error";
            ;
        I_can_t_see_it_at_the_moment_U1:
            print "can't see it at the moment error";
            ;
        I_didn_t_understand_the_way__U1:
            print "didn't understand the way that finished error";
            ;
        I_not_enough_of_those_availa_U1:
            print "not enough of those available error";
            ;
        I_nothing_to_do_error_U1:
            print "nothing to do error";
            ;
        I_referred_to_a_determinatio_U1:
            print "referred to a determination of scope error";
            ;
        I_noun_did_not_make_sense_in_U1:
            print "noun did not make sense in that context error";
            ;
        I_i_beg_your_pardon_error_U1:
            print "I beg your pardon error";
            ;
        I_can_t_again_the_addressee__U1:
            print "can't again the addressee error";
            ;
        I_comma_can_t_begin_error_U1:
            print "comma can't begin error";
            ;
        I_can_t_see_whom_to_talk_to__U1:
            print "can't see whom to talk to error";
            ;
        I_can_t_talk_to_inanimate_th_U1:
            print "can't talk to inanimate things error";
            ;
        I_didn_t_understand_addresse_U1:
            print "didn't understand addressee's last name error";
            ;
        default:
            print "<illegal command parser error>";
            ;
    }
];
[ call_U1925 x;
    return ((x%25) + 1);
];
[ call_U1926 x;
    return (((x + 23)%25) + 1);
];
[ call_U1927 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(25);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ CommandPromptText;
    return (Global_Vars-->24);
];
[ call_U1928 t_0;
    CarryOutActivity(V32_printing_the_locale_descr, t_0);
    rfalse;
];
[ call_U1929 t_0 t_1 ct_0 ct_1;
    if ((t_0 ofclass K2_thing)) {
        if ((t_1 <= 0)) {
            call_U370(t_0);
        }
        if (ExistsTableLookUpCorr(table_data_U2, table_column_id_U6, table_column_id_U6, t_0)) {
            (ct_0 = table_data_U2);
            (ct_1 = TableRowCorr(ct_0, table_column_id_U6, t_0));
            if ((t_1 <= 0)) {
                TableBlankOutRow(ct_0, ct_1);
            } else {
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        } else {
            if ((t_1 > 0)) {
                (ct_0 = table_data_U2);
                (ct_1 = TableBlankRow(ct_0));
                (TableLookUpEntry)(ct_0,table_column_id_U6,ct_1,1,t_0);
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        }
    }
    rfalse;
];
[ call_U1930;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "here";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "there";
    .L_SayX0;
    rfalse;
];
[ call_U1931;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "then";
    .L_SayX0;
    rfalse;
];
[ call_U1932 t_0;
    CarryOutActivity(V4_issuing_the_response_text, t_0);
    rfalse;
];
[ ConjugateVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ call_U1933 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "seem";
            ;
        2:
            print "seemed";
            ;
        3:
            print "seeming";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "seems";
                    } else {
                        print "seem";
                    }
                    ;
                2:
                    print "seemed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seemed";
                    } else {
                        print "have seemed";
                    }
                    ;
                4:
                    print "had seemed";
                    ;
                5:
                    print "will seem";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not seem";
                    } else {
                        print "do not seem";
                    }
                    ;
                2:
                    print "did not seem";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seemed";
                    } else {
                        print "have not seemed";
                    }
                    ;
                4:
                    print "had not seemed";
                    ;
                5:
                    print "will not seem";
                    ;
            }
            ;
    }
];
[ call_U1934 fn vp t modal_to;
    (t = ConjugateVerb6(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "look";
            ;
        2:
            print "looked";
            ;
        3:
            print "looking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "looks";
                    } else {
                        print "look";
                    }
                    ;
                2:
                    print "looked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has looked";
                    } else {
                        print "have looked";
                    }
                    ;
                4:
                    print "had looked";
                    ;
                5:
                    print "will look";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not look";
                    } else {
                        print "do not look";
                    }
                    ;
                2:
                    print "did not look";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not looked";
                    } else {
                        print "have not looked";
                    }
                    ;
                4:
                    print "had not looked";
                    ;
                5:
                    print "will not look";
                    ;
            }
            ;
    }
];
[ call_U1935 fn vp t modal_to;
    (t = ConjugateVerb9(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "care";
            ;
        2:
            print "cared";
            ;
        3:
            print "caring";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "cares";
                    } else {
                        print "care";
                    }
                    ;
                2:
                    print "cared";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has cared";
                    } else {
                        print "have cared";
                    }
                    ;
                4:
                    print "had cared";
                    ;
                5:
                    print "will care";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not care";
                    } else {
                        print "do not care";
                    }
                    ;
                2:
                    print "did not care";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not cared";
                    } else {
                        print "have not cared";
                    }
                    ;
                4:
                    print "had not cared";
                    ;
                5:
                    print "will not care";
                    ;
            }
            ;
    }
];
[ call_U1936 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "pick";
            ;
        2:
            print "picked";
            ;
        3:
            print "picking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "picks";
                    } else {
                        print "pick";
                    }
                    ;
                2:
                    print "picked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has picked";
                    } else {
                        print "have picked";
                    }
                    ;
                4:
                    print "had picked";
                    ;
                5:
                    print "will pick";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pick";
                    } else {
                        print "do not pick";
                    }
                    ;
                2:
                    print "did not pick";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not picked";
                    } else {
                        print "have not picked";
                    }
                    ;
                4:
                    print "had not picked";
                    ;
                5:
                    print "will not pick";
                    ;
            }
            ;
    }
];
[ call_U1937 fn vp t modal_to;
    (t = ConjugateVerb12(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "lack";
            ;
        2:
            print "lacked";
            ;
        3:
            print "lacking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "lacks";
                    } else {
                        print "lack";
                    }
                    ;
                2:
                    print "lacked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has lacked";
                    } else {
                        print "have lacked";
                    }
                    ;
                4:
                    print "had lacked";
                    ;
                5:
                    print "will lack";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lack";
                    } else {
                        print "do not lack";
                    }
                    ;
                2:
                    print "did not lack";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not lacked";
                    } else {
                        print "have not lacked";
                    }
                    ;
                4:
                    print "had not lacked";
                    ;
                5:
                    print "will not lack";
                    ;
            }
            ;
    }
];
[ call_U1938 fn vp t modal_to;
    (t = ConjugateVerb13(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "drop";
            ;
        2:
            print "dropped";
            ;
        3:
            print "dropping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "drops";
                    } else {
                        print "drop";
                    }
                    ;
                2:
                    print "dropped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has dropped";
                    } else {
                        print "have dropped";
                    }
                    ;
                4:
                    print "had dropped";
                    ;
                5:
                    print "will drop";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not drop";
                    } else {
                        print "do not drop";
                    }
                    ;
                2:
                    print "did not drop";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not dropped";
                    } else {
                        print "have not dropped";
                    }
                    ;
                4:
                    print "had not dropped";
                    ;
                5:
                    print "will not drop";
                    ;
            }
            ;
    }
];
[ call_U1939 fn vp t modal_to;
    (t = ConjugateVerb14(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "put";
            ;
        2:
            print "put";
            ;
        3:
            print "putting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "puts";
                    } else {
                        print "put";
                    }
                    ;
                2:
                    print "put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has put";
                    } else {
                        print "have put";
                    }
                    ;
                4:
                    print "had put";
                    ;
                5:
                    print "will put";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not put";
                    } else {
                        print "do not put";
                    }
                    ;
                2:
                    print "did not put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not put";
                    } else {
                        print "have not put";
                    }
                    ;
                4:
                    print "had not put";
                    ;
                5:
                    print "will not put";
                    ;
            }
            ;
    }
];
[ call_U1940 fn vp t modal_to;
    (t = ConjugateVerb16(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "achieve";
            ;
        2:
            print "achieved";
            ;
        3:
            print "achieving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "achieves";
                    } else {
                        print "achieve";
                    }
                    ;
                2:
                    print "achieved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has achieved";
                    } else {
                        print "have achieved";
                    }
                    ;
                4:
                    print "had achieved";
                    ;
                5:
                    print "will achieve";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not achieve";
                    } else {
                        print "do not achieve";
                    }
                    ;
                2:
                    print "did not achieve";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not achieved";
                    } else {
                        print "have not achieved";
                    }
                    ;
                4:
                    print "had not achieved";
                    ;
                5:
                    print "will not achieve";
                    ;
            }
            ;
    }
];
[ call_U1941 fn vp t modal_to;
    (t = ConjugateVerb17(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "contain";
            ;
        2:
            print "contained";
            ;
        3:
            print "containing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record12;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "contains";
                    } else {
                        print "contain";
                    }
                    ;
                2:
                    print "contained";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has contained";
                    } else {
                        print "have contained";
                    }
                    ;
                4:
                    print "had contained";
                    ;
                5:
                    print "will contain";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not contain";
                    } else {
                        print "do not contain";
                    }
                    ;
                2:
                    print "did not contain";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not contained";
                    } else {
                        print "have not contained";
                    }
                    ;
                4:
                    print "had not contained";
                    ;
                5:
                    print "will not contain";
                    ;
            }
            ;
    }
];
[ call_U1942 fn vp t modal_to;
    (t = ConjugateVerb18(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record12;
    }
];
[ ConjugateVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "appreciate";
            ;
        2:
            print "appreciated";
            ;
        3:
            print "appreciating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "appreciates";
                    } else {
                        print "appreciate";
                    }
                    ;
                2:
                    print "appreciated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has appreciated";
                    } else {
                        print "have appreciated";
                    }
                    ;
                4:
                    print "had appreciated";
                    ;
                5:
                    print "will appreciate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not appreciate";
                    } else {
                        print "do not appreciate";
                    }
                    ;
                2:
                    print "did not appreciate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not appreciated";
                    } else {
                        print "have not appreciated";
                    }
                    ;
                4:
                    print "had not appreciated";
                    ;
                5:
                    print "will not appreciate";
                    ;
            }
            ;
    }
];
[ call_U1943 fn vp t modal_to;
    (t = ConjugateVerb20(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "eat";
            ;
        2:
            print "eaten";
            ;
        3:
            print "eating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "eats";
                    } else {
                        print "eat";
                    }
                    ;
                2:
                    print "ate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has eaten";
                    } else {
                        print "have eaten";
                    }
                    ;
                4:
                    print "had eaten";
                    ;
                5:
                    print "will eat";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not eat";
                    } else {
                        print "do not eat";
                    }
                    ;
                2:
                    print "did not eat";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not eaten";
                    } else {
                        print "have not eaten";
                    }
                    ;
                4:
                    print "had not eaten";
                    ;
                5:
                    print "will not eat";
                    ;
            }
            ;
    }
];
[ call_U1944 fn vp t modal_to;
    (t = ConjugateVerb21(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "go";
            ;
        2:
            print "gone";
            ;
        3:
            print "going";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "goes";
                    } else {
                        print "go";
                    }
                    ;
                2:
                    print "went";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has gone";
                    } else {
                        print "have gone";
                    }
                    ;
                4:
                    print "had gone";
                    ;
                5:
                    print "will go";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not go";
                    } else {
                        print "do not go";
                    }
                    ;
                2:
                    print "did not go";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not gone";
                    } else {
                        print "have not gone";
                    }
                    ;
                4:
                    print "had not gone";
                    ;
                5:
                    print "will not go";
                    ;
            }
            ;
    }
];
[ call_U1945 fn vp t modal_to;
    (t = ConjugateVerb22(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "lead";
            ;
        2:
            print "led";
            ;
        3:
            print "leading";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "leads";
                    } else {
                        print "lead";
                    }
                    ;
                2:
                    print "led";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has led";
                    } else {
                        print "have led";
                    }
                    ;
                4:
                    print "had led";
                    ;
                5:
                    print "will lead";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lead";
                    } else {
                        print "do not lead";
                    }
                    ;
                2:
                    print "did not lead";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not led";
                    } else {
                        print "have not led";
                    }
                    ;
                4:
                    print "had not led";
                    ;
                5:
                    print "will not lead";
                    ;
            }
            ;
    }
];
[ call_U1946 fn vp t modal_to;
    (t = ConjugateVerb23(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "arrive";
            ;
        2:
            print "arrived";
            ;
        3:
            print "arriving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "arrives";
                    } else {
                        print "arrive";
                    }
                    ;
                2:
                    print "arrived";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has arrived";
                    } else {
                        print "have arrived";
                    }
                    ;
                4:
                    print "had arrived";
                    ;
                5:
                    print "will arrive";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not arrive";
                    } else {
                        print "do not arrive";
                    }
                    ;
                2:
                    print "did not arrive";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not arrived";
                    } else {
                        print "have not arrived";
                    }
                    ;
                4:
                    print "had not arrived";
                    ;
                5:
                    print "will not arrive";
                    ;
            }
            ;
    }
];
[ call_U1947 fn vp t modal_to;
    (t = ConjugateVerb24(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "get";
            ;
        2:
            print "got";
            ;
        3:
            print "getting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gets";
                    } else {
                        print "get";
                    }
                    ;
                2:
                    print "got";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has got";
                    } else {
                        print "have got";
                    }
                    ;
                4:
                    print "had got";
                    ;
                5:
                    print "will get";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not get";
                    } else {
                        print "do not get";
                    }
                    ;
                2:
                    print "did not get";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not got";
                    } else {
                        print "have not got";
                    }
                    ;
                4:
                    print "had not got";
                    ;
                5:
                    print "will not get";
                    ;
            }
            ;
    }
];
[ call_U1948 fn vp t modal_to;
    (t = ConjugateVerb25(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "find";
            ;
        2:
            print "found";
            ;
        3:
            print "finding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "finds";
                    } else {
                        print "find";
                    }
                    ;
                2:
                    print "found";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has found";
                    } else {
                        print "have found";
                    }
                    ;
                4:
                    print "had found";
                    ;
                5:
                    print "will find";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not find";
                    } else {
                        print "do not find";
                    }
                    ;
                2:
                    print "did not find";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not found";
                    } else {
                        print "have not found";
                    }
                    ;
                4:
                    print "had not found";
                    ;
                5:
                    print "will not find";
                    ;
            }
            ;
    }
];
[ call_U1949 fn vp t modal_to;
    (t = ConjugateVerb26(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "search";
            ;
        2:
            print "searched";
            ;
        3:
            print "searching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "searches";
                    } else {
                        print "search";
                    }
                    ;
                2:
                    print "searched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has searched";
                    } else {
                        print "have searched";
                    }
                    ;
                4:
                    print "had searched";
                    ;
                5:
                    print "will search";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not search";
                    } else {
                        print "do not search";
                    }
                    ;
                2:
                    print "did not search";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not searched";
                    } else {
                        print "have not searched";
                    }
                    ;
                4:
                    print "had not searched";
                    ;
                5:
                    print "will not search";
                    ;
            }
            ;
    }
];
[ call_U1950 fn vp t modal_to;
    (t = ConjugateVerb27(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "discover";
            ;
        2:
            print "discovered";
            ;
        3:
            print "discovering";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "discovers";
                    } else {
                        print "discover";
                    }
                    ;
                2:
                    print "discovered";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has discovered";
                    } else {
                        print "have discovered";
                    }
                    ;
                4:
                    print "had discovered";
                    ;
                5:
                    print "will discover";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not discover";
                    } else {
                        print "do not discover";
                    }
                    ;
                2:
                    print "did not discover";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not discovered";
                    } else {
                        print "have not discovered";
                    }
                    ;
                4:
                    print "had not discovered";
                    ;
                5:
                    print "will not discover";
                    ;
            }
            ;
    }
];
[ call_U1951 fn vp t modal_to;
    (t = ConjugateVerb28(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "lock";
            ;
        2:
            print "locked";
            ;
        3:
            print "locking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "locks";
                    } else {
                        print "lock";
                    }
                    ;
                2:
                    print "locked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has locked";
                    } else {
                        print "have locked";
                    }
                    ;
                4:
                    print "had locked";
                    ;
                5:
                    print "will lock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lock";
                    } else {
                        print "do not lock";
                    }
                    ;
                2:
                    print "did not lock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not locked";
                    } else {
                        print "have not locked";
                    }
                    ;
                4:
                    print "had not locked";
                    ;
                5:
                    print "will not lock";
                    ;
            }
            ;
    }
];
[ call_U1952 fn vp t modal_to;
    (t = ConjugateVerb30(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "unlock";
            ;
        2:
            print "unlocked";
            ;
        3:
            print "unlocking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record2;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unlocks";
                    } else {
                        print "unlock";
                    }
                    ;
                2:
                    print "unlocked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unlocked";
                    } else {
                        print "have unlocked";
                    }
                    ;
                4:
                    print "had unlocked";
                    ;
                5:
                    print "will unlock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unlock";
                    } else {
                        print "do not unlock";
                    }
                    ;
                2:
                    print "did not unlock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unlocked";
                    } else {
                        print "have not unlocked";
                    }
                    ;
                4:
                    print "had not unlocked";
                    ;
                5:
                    print "will not unlock";
                    ;
            }
            ;
    }
];
[ call_U1953 fn vp t modal_to;
    (t = ConjugateVerb31(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record2;
    }
];
[ ConjugateVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "switch";
            ;
        2:
            print "switched";
            ;
        3:
            print "switching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "switches";
                    } else {
                        print "switch";
                    }
                    ;
                2:
                    print "switched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has switched";
                    } else {
                        print "have switched";
                    }
                    ;
                4:
                    print "had switched";
                    ;
                5:
                    print "will switch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not switch";
                    } else {
                        print "do not switch";
                    }
                    ;
                2:
                    print "did not switch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not switched";
                    } else {
                        print "have not switched";
                    }
                    ;
                4:
                    print "had not switched";
                    ;
                5:
                    print "will not switch";
                    ;
            }
            ;
    }
];
[ call_U1954 fn vp t modal_to;
    (t = ConjugateVerb32(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "open";
            ;
        2:
            print "opened";
            ;
        3:
            print "opening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "opens";
                    } else {
                        print "open";
                    }
                    ;
                2:
                    print "opened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has opened";
                    } else {
                        print "have opened";
                    }
                    ;
                4:
                    print "had opened";
                    ;
                5:
                    print "will open";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not open";
                    } else {
                        print "do not open";
                    }
                    ;
                2:
                    print "did not open";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not opened";
                    } else {
                        print "have not opened";
                    }
                    ;
                4:
                    print "had not opened";
                    ;
                5:
                    print "will not open";
                    ;
            }
            ;
    }
];
[ call_U1955 fn vp t modal_to;
    (t = ConjugateVerb33(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "close";
            ;
        2:
            print "closed";
            ;
        3:
            print "closing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "closes";
                    } else {
                        print "close";
                    }
                    ;
                2:
                    print "closed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has closed";
                    } else {
                        print "have closed";
                    }
                    ;
                4:
                    print "had closed";
                    ;
                5:
                    print "will close";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not close";
                    } else {
                        print "do not close";
                    }
                    ;
                2:
                    print "did not close";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not closed";
                    } else {
                        print "have not closed";
                    }
                    ;
                4:
                    print "had not closed";
                    ;
                5:
                    print "will not close";
                    ;
            }
            ;
    }
];
[ call_U1956 fn vp t modal_to;
    (t = ConjugateVerb34(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "wear";
            ;
        2:
            print "worn";
            ;
        3:
            print "wearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record18;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wears";
                    } else {
                        print "wear";
                    }
                    ;
                2:
                    print "wore";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has worn";
                    } else {
                        print "have worn";
                    }
                    ;
                4:
                    print "had worn";
                    ;
                5:
                    print "will wear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wear";
                    } else {
                        print "do not wear";
                    }
                    ;
                2:
                    print "did not wear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not worn";
                    } else {
                        print "have not worn";
                    }
                    ;
                4:
                    print "had not worn";
                    ;
                5:
                    print "will not wear";
                    ;
            }
            ;
    }
];
[ call_U1957 fn vp t modal_to;
    (t = ConjugateVerb35(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record18;
    }
];
[ ConjugateVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "take";
            ;
        2:
            print "taken";
            ;
        3:
            print "taking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "takes";
                    } else {
                        print "take";
                    }
                    ;
                2:
                    print "took";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has taken";
                    } else {
                        print "have taken";
                    }
                    ;
                4:
                    print "had taken";
                    ;
                5:
                    print "will take";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not take";
                    } else {
                        print "do not take";
                    }
                    ;
                2:
                    print "did not take";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not taken";
                    } else {
                        print "have not taken";
                    }
                    ;
                4:
                    print "had not taken";
                    ;
                5:
                    print "will not take";
                    ;
            }
            ;
    }
];
[ call_U1958 fn vp t modal_to;
    (t = ConjugateVerb36(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "give";
            ;
        2:
            print "given";
            ;
        3:
            print "giving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gives";
                    } else {
                        print "give";
                    }
                    ;
                2:
                    print "gave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has given";
                    } else {
                        print "have given";
                    }
                    ;
                4:
                    print "had given";
                    ;
                5:
                    print "will give";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not give";
                    } else {
                        print "do not give";
                    }
                    ;
                2:
                    print "did not give";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not given";
                    } else {
                        print "have not given";
                    }
                    ;
                4:
                    print "had not given";
                    ;
                5:
                    print "will not give";
                    ;
            }
            ;
    }
];
[ call_U1959 fn vp t modal_to;
    (t = ConjugateVerb37(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "talk";
            ;
        2:
            print "talked";
            ;
        3:
            print "talking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "talks";
                    } else {
                        print "talk";
                    }
                    ;
                2:
                    print "talked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has talked";
                    } else {
                        print "have talked";
                    }
                    ;
                4:
                    print "had talked";
                    ;
                5:
                    print "will talk";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not talk";
                    } else {
                        print "do not talk";
                    }
                    ;
                2:
                    print "did not talk";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not talked";
                    } else {
                        print "have not talked";
                    }
                    ;
                4:
                    print "had not talked";
                    ;
                5:
                    print "will not talk";
                    ;
            }
            ;
    }
];
[ call_U1960 fn vp t modal_to;
    (t = ConjugateVerb38(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "provoke";
            ;
        2:
            print "provoked";
            ;
        3:
            print "provoking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provokes";
                    } else {
                        print "provoke";
                    }
                    ;
                2:
                    print "provoked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provoked";
                    } else {
                        print "have provoked";
                    }
                    ;
                4:
                    print "had provoked";
                    ;
                5:
                    print "will provoke";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provoke";
                    } else {
                        print "do not provoke";
                    }
                    ;
                2:
                    print "did not provoke";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provoked";
                    } else {
                        print "have not provoked";
                    }
                    ;
                4:
                    print "had not provoked";
                    ;
                5:
                    print "will not provoke";
                    ;
            }
            ;
    }
];
[ call_U1961 fn vp t modal_to;
    (t = ConjugateVerb39(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "pass";
            ;
        2:
            print "passed";
            ;
        3:
            print "passing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "passes";
                    } else {
                        print "pass";
                    }
                    ;
                2:
                    print "passed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has passed";
                    } else {
                        print "have passed";
                    }
                    ;
                4:
                    print "had passed";
                    ;
                5:
                    print "will pass";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pass";
                    } else {
                        print "do not pass";
                    }
                    ;
                2:
                    print "did not pass";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not passed";
                    } else {
                        print "have not passed";
                    }
                    ;
                4:
                    print "had not passed";
                    ;
                5:
                    print "will not pass";
                    ;
            }
            ;
    }
];
[ call_U1962 fn vp t modal_to;
    (t = ConjugateVerb40(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "wait";
            ;
        2:
            print "waited";
            ;
        3:
            print "waiting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waits";
                    } else {
                        print "wait";
                    }
                    ;
                2:
                    print "waited";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waited";
                    } else {
                        print "have waited";
                    }
                    ;
                4:
                    print "had waited";
                    ;
                5:
                    print "will wait";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wait";
                    } else {
                        print "do not wait";
                    }
                    ;
                2:
                    print "did not wait";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waited";
                    } else {
                        print "have not waited";
                    }
                    ;
                4:
                    print "had not waited";
                    ;
                5:
                    print "will not wait";
                    ;
            }
            ;
    }
];
[ call_U1963 fn vp t modal_to;
    (t = ConjugateVerb41(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ call_U1964 fn vp t modal_to;
    (t = ConjugateVerb42(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "like";
            ;
        2:
            print "liked";
            ;
        3:
            print "liking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "likes";
                    } else {
                        print "like";
                    }
                    ;
                2:
                    print "liked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has liked";
                    } else {
                        print "have liked";
                    }
                    ;
                4:
                    print "had liked";
                    ;
                5:
                    print "will like";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not like";
                    } else {
                        print "do not like";
                    }
                    ;
                2:
                    print "did not like";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not liked";
                    } else {
                        print "have not liked";
                    }
                    ;
                4:
                    print "had not liked";
                    ;
                5:
                    print "will not like";
                    ;
            }
            ;
    }
];
[ call_U1965 fn vp t modal_to;
    (t = ConjugateVerb43(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "feel";
            ;
        2:
            print "felt";
            ;
        3:
            print "feeling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "feels";
                    } else {
                        print "feel";
                    }
                    ;
                2:
                    print "felt";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has felt";
                    } else {
                        print "have felt";
                    }
                    ;
                4:
                    print "had felt";
                    ;
                5:
                    print "will feel";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not feel";
                    } else {
                        print "do not feel";
                    }
                    ;
                2:
                    print "did not feel";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not felt";
                    } else {
                        print "have not felt";
                    }
                    ;
                4:
                    print "had not felt";
                    ;
                5:
                    print "will not feel";
                    ;
            }
            ;
    }
];
[ call_U1966 fn vp t modal_to;
    (t = ConjugateVerb44(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "wave";
            ;
        2:
            print "waved";
            ;
        3:
            print "waving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waves";
                    } else {
                        print "wave";
                    }
                    ;
                2:
                    print "waved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waved";
                    } else {
                        print "have waved";
                    }
                    ;
                4:
                    print "had waved";
                    ;
                5:
                    print "will wave";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wave";
                    } else {
                        print "do not wave";
                    }
                    ;
                2:
                    print "did not wave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waved";
                    } else {
                        print "have not waved";
                    }
                    ;
                4:
                    print "had not waved";
                    ;
                5:
                    print "will not wave";
                    ;
            }
            ;
    }
];
[ call_U1967 fn vp t modal_to;
    (t = ConjugateVerb45(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "happen";
            ;
        2:
            print "happened";
            ;
        3:
            print "happening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "happens";
                    } else {
                        print "happen";
                    }
                    ;
                2:
                    print "happened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has happened";
                    } else {
                        print "have happened";
                    }
                    ;
                4:
                    print "had happened";
                    ;
                5:
                    print "will happen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not happen";
                    } else {
                        print "do not happen";
                    }
                    ;
                2:
                    print "did not happen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not happened";
                    } else {
                        print "have not happened";
                    }
                    ;
                4:
                    print "had not happened";
                    ;
                5:
                    print "will not happen";
                    ;
            }
            ;
    }
];
[ call_U1968 fn vp t modal_to;
    (t = ConjugateVerb46(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "pull";
            ;
        2:
            print "pulled";
            ;
        3:
            print "pulling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pulls";
                    } else {
                        print "pull";
                    }
                    ;
                2:
                    print "pulled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pulled";
                    } else {
                        print "have pulled";
                    }
                    ;
                4:
                    print "had pulled";
                    ;
                5:
                    print "will pull";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pull";
                    } else {
                        print "do not pull";
                    }
                    ;
                2:
                    print "did not pull";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pulled";
                    } else {
                        print "have not pulled";
                    }
                    ;
                4:
                    print "had not pulled";
                    ;
                5:
                    print "will not pull";
                    ;
            }
            ;
    }
];
[ call_U1969 fn vp t modal_to;
    (t = ConjugateVerb47(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "push";
            ;
        2:
            print "pushed";
            ;
        3:
            print "pushing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pushes";
                    } else {
                        print "push";
                    }
                    ;
                2:
                    print "pushed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pushed";
                    } else {
                        print "have pushed";
                    }
                    ;
                4:
                    print "had pushed";
                    ;
                5:
                    print "will push";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not push";
                    } else {
                        print "do not push";
                    }
                    ;
                2:
                    print "did not push";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pushed";
                    } else {
                        print "have not pushed";
                    }
                    ;
                4:
                    print "had not pushed";
                    ;
                5:
                    print "will not push";
                    ;
            }
            ;
    }
];
[ call_U1970 fn vp t modal_to;
    (t = ConjugateVerb48(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "turn";
            ;
        2:
            print "turned";
            ;
        3:
            print "turning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "turns";
                    } else {
                        print "turn";
                    }
                    ;
                2:
                    print "turned";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has turned";
                    } else {
                        print "have turned";
                    }
                    ;
                4:
                    print "had turned";
                    ;
                5:
                    print "will turn";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not turn";
                    } else {
                        print "do not turn";
                    }
                    ;
                2:
                    print "did not turn";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not turned";
                    } else {
                        print "have not turned";
                    }
                    ;
                4:
                    print "had not turned";
                    ;
                5:
                    print "will not turn";
                    ;
            }
            ;
    }
];
[ call_U1971 fn vp t modal_to;
    (t = ConjugateVerb49(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "squeeze";
            ;
        2:
            print "squeezed";
            ;
        3:
            print "squeezing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "squeezes";
                    } else {
                        print "squeeze";
                    }
                    ;
                2:
                    print "squeezed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has squeezed";
                    } else {
                        print "have squeezed";
                    }
                    ;
                4:
                    print "had squeezed";
                    ;
                5:
                    print "will squeeze";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not squeeze";
                    } else {
                        print "do not squeeze";
                    }
                    ;
                2:
                    print "did not squeeze";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not squeezed";
                    } else {
                        print "have not squeezed";
                    }
                    ;
                4:
                    print "had not squeezed";
                    ;
                5:
                    print "will not squeeze";
                    ;
            }
            ;
    }
];
[ call_U1972 fn vp t modal_to;
    (t = ConjugateVerb50(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "smell";
            ;
        2:
            print "smelled";
            ;
        3:
            print "smelling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "smells";
                    } else {
                        print "smell";
                    }
                    ;
                2:
                    print "smelled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has smelled";
                    } else {
                        print "have smelled";
                    }
                    ;
                4:
                    print "had smelled";
                    ;
                5:
                    print "will smell";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not smell";
                    } else {
                        print "do not smell";
                    }
                    ;
                2:
                    print "did not smell";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not smelled";
                    } else {
                        print "have not smelled";
                    }
                    ;
                4:
                    print "had not smelled";
                    ;
                5:
                    print "will not smell";
                    ;
            }
            ;
    }
];
[ call_U1973 fn vp t modal_to;
    (t = ConjugateVerb51(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "sniff";
            ;
        2:
            print "sniffed";
            ;
        3:
            print "sniffing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sniffs";
                    } else {
                        print "sniff";
                    }
                    ;
                2:
                    print "sniffed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has sniffed";
                    } else {
                        print "have sniffed";
                    }
                    ;
                4:
                    print "had sniffed";
                    ;
                5:
                    print "will sniff";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not sniff";
                    } else {
                        print "do not sniff";
                    }
                    ;
                2:
                    print "did not sniff";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not sniffed";
                    } else {
                        print "have not sniffed";
                    }
                    ;
                4:
                    print "had not sniffed";
                    ;
                5:
                    print "will not sniff";
                    ;
            }
            ;
    }
];
[ call_U1974 fn vp t modal_to;
    (t = ConjugateVerb52(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb53 fn vp t modal_to;
    switch (fn) {
        1:
            print "hear";
            ;
        2:
            print "heard";
            ;
        3:
            print "hearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "hears";
                    } else {
                        print "hear";
                    }
                    ;
                2:
                    print "heard";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has heard";
                    } else {
                        print "have heard";
                    }
                    ;
                4:
                    print "had heard";
                    ;
                5:
                    print "will hear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hear";
                    } else {
                        print "do not hear";
                    }
                    ;
                2:
                    print "did not hear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not heard";
                    } else {
                        print "have not heard";
                    }
                    ;
                4:
                    print "had not heard";
                    ;
                5:
                    print "will not hear";
                    ;
            }
            ;
    }
];
[ call_U1975 fn vp t modal_to;
    (t = ConjugateVerb53(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb54 fn vp t modal_to;
    switch (fn) {
        1:
            print "listen";
            ;
        2:
            print "listened";
            ;
        3:
            print "listening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "listens";
                    } else {
                        print "listen";
                    }
                    ;
                2:
                    print "listened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has listened";
                    } else {
                        print "have listened";
                    }
                    ;
                4:
                    print "had listened";
                    ;
                5:
                    print "will listen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not listen";
                    } else {
                        print "do not listen";
                    }
                    ;
                2:
                    print "did not listen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not listened";
                    } else {
                        print "have not listened";
                    }
                    ;
                4:
                    print "had not listened";
                    ;
                5:
                    print "will not listen";
                    ;
            }
            ;
    }
];
[ call_U1976 fn vp t modal_to;
    (t = ConjugateVerb54(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb55 fn vp t modal_to;
    switch (fn) {
        1:
            print "taste";
            ;
        2:
            print "tasted";
            ;
        3:
            print "tasting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tastes";
                    } else {
                        print "taste";
                    }
                    ;
                2:
                    print "tasted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tasted";
                    } else {
                        print "have tasted";
                    }
                    ;
                4:
                    print "had tasted";
                    ;
                5:
                    print "will taste";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not taste";
                    } else {
                        print "do not taste";
                    }
                    ;
                2:
                    print "did not taste";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tasted";
                    } else {
                        print "have not tasted";
                    }
                    ;
                4:
                    print "had not tasted";
                    ;
                5:
                    print "will not taste";
                    ;
            }
            ;
    }
];
[ call_U1977 fn vp t modal_to;
    (t = ConjugateVerb55(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb56 fn vp t modal_to;
    switch (fn) {
        1:
            print "jump";
            ;
        2:
            print "jumped";
            ;
        3:
            print "jumping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "jumps";
                    } else {
                        print "jump";
                    }
                    ;
                2:
                    print "jumped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has jumped";
                    } else {
                        print "have jumped";
                    }
                    ;
                4:
                    print "had jumped";
                    ;
                5:
                    print "will jump";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not jump";
                    } else {
                        print "do not jump";
                    }
                    ;
                2:
                    print "did not jump";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not jumped";
                    } else {
                        print "have not jumped";
                    }
                    ;
                4:
                    print "had not jumped";
                    ;
                5:
                    print "will not jump";
                    ;
            }
            ;
    }
];
[ call_U1978 fn vp t modal_to;
    (t = ConjugateVerb56(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb57 fn vp t modal_to;
    switch (fn) {
        1:
            print "rub";
            ;
        2:
            print "rubbed";
            ;
        3:
            print "rubbing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "rubs";
                    } else {
                        print "rub";
                    }
                    ;
                2:
                    print "rubbed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has rubbed";
                    } else {
                        print "have rubbed";
                    }
                    ;
                4:
                    print "had rubbed";
                    ;
                5:
                    print "will rub";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not rub";
                    } else {
                        print "do not rub";
                    }
                    ;
                2:
                    print "did not rub";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not rubbed";
                    } else {
                        print "have not rubbed";
                    }
                    ;
                4:
                    print "had not rubbed";
                    ;
                5:
                    print "will not rub";
                    ;
            }
            ;
    }
];
[ call_U1979 fn vp t modal_to;
    (t = ConjugateVerb57(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb58 fn vp t modal_to;
    switch (fn) {
        1:
            print "set";
            ;
        2:
            print "set";
            ;
        3:
            print "setting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sets";
                    } else {
                        print "set";
                    }
                    ;
                2:
                    print "set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has set";
                    } else {
                        print "have set";
                    }
                    ;
                4:
                    print "had set";
                    ;
                5:
                    print "will set";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not set";
                    } else {
                        print "do not set";
                    }
                    ;
                2:
                    print "did not set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not set";
                    } else {
                        print "have not set";
                    }
                    ;
                4:
                    print "had not set";
                    ;
                5:
                    print "will not set";
                    ;
            }
            ;
    }
];
[ call_U1980 fn vp t modal_to;
    (t = ConjugateVerb58(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb85 fn vp t modal_to;
    switch (fn) {
        1:
            print "begin";
            ;
        2:
            print "begun";
            ;
        3:
            print "beginning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "begins";
                    } else {
                        print "begin";
                    }
                    ;
                2:
                    print "began";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has begun";
                    } else {
                        print "have begun";
                    }
                    ;
                4:
                    print "had begun";
                    ;
                5:
                    print "will begin";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not begin";
                    } else {
                        print "do not begin";
                    }
                    ;
                2:
                    print "did not begin";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not begun";
                    } else {
                        print "have not begun";
                    }
                    ;
                4:
                    print "had not begun";
                    ;
                5:
                    print "will not begin";
                    ;
            }
            ;
    }
];
[ call_U1981 fn vp t modal_to;
    (t = ConjugateVerb85(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1982 fn vp t modal_to;
    (t = ConjugateVerb85(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ ConjugateVerb86 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ call_U1983 fn vp t modal_to;
    (t = ConjugateVerb86(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1984 fn vp t modal_to;
    (t = ConjugateVerb86(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ call_U1985 fn vp t modal_to;
    (t = ConjugateVerb86(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ ConjugateVerb87 fn vp t modal_to;
    switch (fn) {
        1:
            print "understand";
            ;
        2:
            print "understood";
            ;
        3:
            print "understanding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "understands";
                    } else {
                        print "understand";
                    }
                    ;
                2:
                    print "understood";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has understood";
                    } else {
                        print "have understood";
                    }
                    ;
                4:
                    print "had understood";
                    ;
                5:
                    print "will understand";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not understand";
                    } else {
                        print "do not understand";
                    }
                    ;
                2:
                    print "did not understand";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not understood";
                    } else {
                        print "have not understood";
                    }
                    ;
                4:
                    print "had not understood";
                    ;
                5:
                    print "will not understand";
                    ;
            }
            ;
    }
];
[ call_U1986 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1987 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb88 fn vp t modal_to;
    switch (fn) {
        1:
            print "release";
            ;
        2:
            print "released";
            ;
        3:
            print "releasing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "releases";
                    } else {
                        print "release";
                    }
                    ;
                2:
                    print "released";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has released";
                    } else {
                        print "have released";
                    }
                    ;
                4:
                    print "had released";
                    ;
                5:
                    print "will release";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not release";
                    } else {
                        print "do not release";
                    }
                    ;
                2:
                    print "did not release";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not released";
                    } else {
                        print "have not released";
                    }
                    ;
                4:
                    print "had not released";
                    ;
                5:
                    print "will not release";
                    ;
            }
            ;
    }
];
[ call_U1988 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1989 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " along with";
];
[ ConjugateVerb89 fn vp t modal_to;
    switch (fn) {
        1:
            print "index";
            ;
        2:
            print "indexed";
            ;
        3:
            print "indexing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "indexes";
                    } else {
                        print "index";
                    }
                    ;
                2:
                    print "indexed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has indexed";
                    } else {
                        print "have indexed";
                    }
                    ;
                4:
                    print "had indexed";
                    ;
                5:
                    print "will index";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not index";
                    } else {
                        print "do not index";
                    }
                    ;
                2:
                    print "did not index";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not indexed";
                    } else {
                        print "have not indexed";
                    }
                    ;
                4:
                    print "had not indexed";
                    ;
                5:
                    print "will not index";
                    ;
            }
            ;
    }
];
[ call_U1990 fn vp t modal_to;
    (t = ConjugateVerb89(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1991 fn vp t modal_to;
    (t = ConjugateVerb89(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " map with";
];
[ ConjugateModalVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb90 fn vp t modal_to;
    switch (fn) {
        1:
            print "support";
            ;
        2:
            print "supported";
            ;
        3:
            print "supporting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record13;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "supports";
                    } else {
                        print "support";
                    }
                    ;
                2:
                    print "supported";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has supported";
                    } else {
                        print "have supported";
                    }
                    ;
                4:
                    print "had supported";
                    ;
                5:
                    print "will support";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not support";
                    } else {
                        print "do not support";
                    }
                    ;
                2:
                    print "did not support";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not supported";
                    } else {
                        print "have not supported";
                    }
                    ;
                4:
                    print "had not supported";
                    ;
                5:
                    print "will not support";
                    ;
            }
            ;
    }
];
[ call_U1992 fn vp t modal_to;
    (t = ConjugateVerb90(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record13;
    }
];
[ ConjugateModalVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb91 fn vp t modal_to;
    switch (fn) {
        1:
            print "incorporate";
            ;
        2:
            print "incorporated";
            ;
        3:
            print "incorporating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record14;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "incorporates";
                    } else {
                        print "incorporate";
                    }
                    ;
                2:
                    print "incorporated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has incorporated";
                    } else {
                        print "have incorporated";
                    }
                    ;
                4:
                    print "had incorporated";
                    ;
                5:
                    print "will incorporate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not incorporate";
                    } else {
                        print "do not incorporate";
                    }
                    ;
                2:
                    print "did not incorporate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not incorporated";
                    } else {
                        print "have not incorporated";
                    }
                    ;
                4:
                    print "had not incorporated";
                    ;
                5:
                    print "will not incorporate";
                    ;
            }
            ;
    }
];
[ call_U1993 fn vp t modal_to;
    (t = ConjugateVerb91(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record14;
    }
];
[ ConjugateModalVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb92 fn vp t modal_to;
    switch (fn) {
        1:
            print "enclose";
            ;
        2:
            print "enclosed";
            ;
        3:
            print "enclosing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record15;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "encloses";
                    } else {
                        print "enclose";
                    }
                    ;
                2:
                    print "enclosed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has enclosed";
                    } else {
                        print "have enclosed";
                    }
                    ;
                4:
                    print "had enclosed";
                    ;
                5:
                    print "will enclose";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not enclose";
                    } else {
                        print "do not enclose";
                    }
                    ;
                2:
                    print "did not enclose";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not enclosed";
                    } else {
                        print "have not enclosed";
                    }
                    ;
                4:
                    print "had not enclosed";
                    ;
                5:
                    print "will not enclose";
                    ;
            }
            ;
    }
];
[ call_U1994 fn vp t modal_to;
    (t = ConjugateVerb92(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record15;
    }
];
[ ConjugateVerb93 fn vp t modal_to;
    switch (fn) {
        1:
            print "carry";
            ;
        2:
            print "carried";
            ;
        3:
            print "carrying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record16;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "carries";
                    } else {
                        print "carry";
                    }
                    ;
                2:
                    print "carried";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has carried";
                    } else {
                        print "have carried";
                    }
                    ;
                4:
                    print "had carried";
                    ;
                5:
                    print "will carry";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not carry";
                    } else {
                        print "do not carry";
                    }
                    ;
                2:
                    print "did not carry";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not carried";
                    } else {
                        print "have not carried";
                    }
                    ;
                4:
                    print "had not carried";
                    ;
                5:
                    print "will not carry";
                    ;
            }
            ;
    }
];
[ call_U1995 fn vp t modal_to;
    (t = ConjugateVerb93(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record16;
    }
];
[ ConjugateVerb94 fn vp t modal_to;
    switch (fn) {
        1:
            print "hold";
            ;
        2:
            print "held";
            ;
        3:
            print "holding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record17;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "holds";
                    } else {
                        print "hold";
                    }
                    ;
                2:
                    print "held";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has held";
                    } else {
                        print "have held";
                    }
                    ;
                4:
                    print "had held";
                    ;
                5:
                    print "will hold";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hold";
                    } else {
                        print "do not hold";
                    }
                    ;
                2:
                    print "did not hold";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not held";
                    } else {
                        print "have not held";
                    }
                    ;
                4:
                    print "had not held";
                    ;
                5:
                    print "will not hold";
                    ;
            }
            ;
    }
];
[ call_U1996 fn vp t modal_to;
    (t = ConjugateVerb94(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record17;
    }
];
[ ConjugateVerb95 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to see";
            ;
        2:
            print "been able to see";
            ;
        3:
            print "being able to see";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record19;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can see";
                    ;
                2:
                    print "could see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to see";
                    } else {
                        print "have been able to see";
                    }
                    ;
                4:
                    print "had been able to see";
                    ;
                5:
                    print "will be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot see";
                    ;
                2:
                    print "could not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to see";
                    } else {
                        print "have not been able to see";
                    }
                    ;
                4:
                    print "had not been able to see";
                    ;
                5:
                    print "will not be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
    }
];
[ call_U1997 fn vp t modal_to;
    (t = ConjugateVerb95(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record19;
    }
];
[ ConjugateVerb96 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to touch";
            ;
        2:
            print "been able to touch";
            ;
        3:
            print "being able to touch";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record20;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can touch";
                    ;
                2:
                    print "could touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to touch";
                    } else {
                        print "have been able to touch";
                    }
                    ;
                4:
                    print "had been able to touch";
                    ;
                5:
                    print "will be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot touch";
                    ;
                2:
                    print "could not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to touch";
                    } else {
                        print "have not been able to touch";
                    }
                    ;
                4:
                    print "had not been able to touch";
                    ;
                5:
                    print "will not be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
    }
];
[ call_U1998 fn vp t modal_to;
    (t = ConjugateVerb96(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record20;
    }
];
[ ConjugateVerb97 fn vp t modal_to;
    switch (fn) {
        1:
            print "conceal";
            ;
        2:
            print "concealed";
            ;
        3:
            print "concealing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record21;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "conceals";
                    } else {
                        print "conceal";
                    }
                    ;
                2:
                    print "concealed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has concealed";
                    } else {
                        print "have concealed";
                    }
                    ;
                4:
                    print "had concealed";
                    ;
                5:
                    print "will conceal";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not conceal";
                    } else {
                        print "do not conceal";
                    }
                    ;
                2:
                    print "did not conceal";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not concealed";
                    } else {
                        print "have not concealed";
                    }
                    ;
                4:
                    print "had not concealed";
                    ;
                5:
                    print "will not conceal";
                    ;
            }
            ;
    }
];
[ call_U1999 fn vp t modal_to;
    (t = ConjugateVerb97(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record21;
    }
];
[ ConjugateModalVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb98 fn vp t modal_to;
    switch (fn) {
        1:
            print "die";
            ;
        2:
            print "died";
            ;
        3:
            print "dying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "dies";
                    } else {
                        print "die";
                    }
                    ;
                2:
                    print "died";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has died";
                    } else {
                        print "have died";
                    }
                    ;
                4:
                    print "had died";
                    ;
                5:
                    print "will die";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not die";
                    } else {
                        print "do not die";
                    }
                    ;
                2:
                    print "did not die";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not died";
                    } else {
                        print "have not died";
                    }
                    ;
                4:
                    print "had not died";
                    ;
                5:
                    print "will not die";
                    ;
            }
            ;
    }
];
[ call_U2000 fn vp t modal_to;
    (t = ConjugateVerb98(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb99 fn vp t modal_to;
    switch (fn) {
        1:
            print "need";
            ;
        2:
            print "needed";
            ;
        3:
            print "needing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "needs";
                    } else {
                        print "need";
                    }
                    ;
                2:
                    print "needed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has needed";
                    } else {
                        print "have needed";
                    }
                    ;
                4:
                    print "had needed";
                    ;
                5:
                    print "will need";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not need";
                    } else {
                        print "do not need";
                    }
                    ;
                2:
                    print "did not need";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not needed";
                    } else {
                        print "have not needed";
                    }
                    ;
                4:
                    print "had not needed";
                    ;
                5:
                    print "will not need";
                    ;
            }
            ;
    }
];
[ call_U2001 fn vp t modal_to;
    (t = ConjugateVerb99(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb100 fn vp t modal_to;
    switch (fn) {
        1:
            print "say";
            ;
        2:
            print "said";
            ;
        3:
            print "saying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "says";
                    } else {
                        print "say";
                    }
                    ;
                2:
                    print "said";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has said";
                    } else {
                        print "have said";
                    }
                    ;
                4:
                    print "had said";
                    ;
                5:
                    print "will say";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not say";
                    } else {
                        print "do not say";
                    }
                    ;
                2:
                    print "did not say";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not said";
                    } else {
                        print "have not said";
                    }
                    ;
                4:
                    print "had not said";
                    ;
                5:
                    print "will not say";
                    ;
            }
            ;
    }
];
[ call_U2002 fn vp t modal_to;
    (t = ConjugateVerb100(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ ConjugateVerb101 fn vp t modal_to;
    switch (fn) {
        1:
            print "win";
            ;
        2:
            print "won";
            ;
        3:
            print "winning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wins";
                    } else {
                        print "win";
                    }
                    ;
                2:
                    print "won";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has won";
                    } else {
                        print "have won";
                    }
                    ;
                4:
                    print "had won";
                    ;
                5:
                    print "will win";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not win";
                    } else {
                        print "do not win";
                    }
                    ;
                2:
                    print "did not win";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not won";
                    } else {
                        print "have not won";
                    }
                    ;
                4:
                    print "had not won";
                    ;
                5:
                    print "will not win";
                    ;
            }
            ;
    }
];
[ call_U2003 fn vp t modal_to;
    (t = ConjugateVerb101(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ Noun_Filter5 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter8 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter9 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter11 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U414(noun)));
];
[ call_U2004 forbid_breaks rv;
    (rv = (call_U2015)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2015;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2005 forbid_breaks rv;
    (rv = (call_U2018)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2018;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_standingSub;
    return GenericVerbSub(rulebook_id_U363, rulebook_id_U364, rulebook_id_U365);
];
[ A_standingDbg n s for_say;
    print "standing";
];
[ call_U2007;
    if (debug_rules) {
        DB_Rule(call_U2007, 800, 0);
    }
    if ((noun == SupporterOf(actor))) {
        rfalse;
    }
    if ((noun == CarrierOf(actor))) {
        rfalse;
    }
    if ((noun == ContainerOf(actor))) {
        rfalse;
    }
    (say__p = 1);
    ParaContent();
    call_U1932(response_id_U247);
    ParaContent();
    print "^";
    rtrue;
    rfalse;
];
[ call_U2008;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2008, 801, 0);
        }
        if ((HolderOf(actor) == noun)) {
            if (FollowRulebook(call_U2011)) {
                rtrue;
            }
        }
        if ((noun == ContainerOf(HolderOf(actor)))) {
            RulebookFails();
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2008, 801, 2);
        }
    }
    rfalse;
];
[ call_U2009 tmp_0;
    if ((((action == ##Go)) && ((((actor == player)) && (((((MStack-->(MstVON(var_id_U42, 1))) == 0)) && (((((self = actor),1)) && ((((HolderOf(player) ofclass K2_thing)) && (((call_U375(HolderOf(player))) && (((tmp_0 = HolderOf(player)),1)))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2009, 802, 0);
        }
        if ((noun == out_obj)) {
            TryAction(0, player, ##Exit, 0, 0);
            rtrue;
        }
        (say__p = 1);
        ParaContent();
        call_U279();
        ParaContent();
        print " no exit that way, and ";
        ParaContent();
        call_U248();
        ParaContent();
        print " ";
        ConjugateVerb1(CV_POS, PNToVP(), story_tense);
        (say__p = 1);
        ParaContent();
        print " ";
        if ((~~((tmp_0 ofclass K6_supporter)))) {
            jump L_Say0;
        }
        ParaContent();
        print "on";
        jump L_SayX0;
        .L_Say0;
        ParaContent();
        print "in";
        .L_SayX0;
        ParaContent();
        print " ";
        ParaContent();
        DefArt(tmp_0);
        ParaContent();
        print " anyway.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2009, 802, 2);
        }
    }
    rfalse;
];
[ call_U2010 tmp_0;
    if ((((act_requester == 0)) && (((((MStack-->(MstVON(var_id_U42, 1))) ofclass K1_room)) && (((((self = actor),1)) && ((((HolderOf(actor) ofclass K2_thing)) && (((call_U375(HolderOf(actor))) && (((tmp_0 = HolderOf(actor)),1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2010, 803, 0);
        }
        if ((tmp_0 ofclass K14_vehicle)) {
            rfalse;
        }
        while ((((HolderOf(actor) ofclass K2_thing)) && (((call_U375(HolderOf(actor))) && (((tmp_0 = HolderOf(actor)),1)))))) {
            if (FollowRulebook(call_U2011)) {
                rtrue;
            }
            if ((HolderOf(actor) == tmp_0)) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2010, 803, 2);
        }
    }
    rfalse;
];
[ call_U2011 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2011, 804, 0);
    }
    (tmp_0 = HolderOf(actor));
    if ((((actor == player)) && ((~~(call_U150(use_option_id_U29)))))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U394));
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
    } else {
        TryAction(0, actor, ##Exit, 0, 0);
    }
    rfalse;
];
[ call_U2012;
    ResponseViaActivity(response_id_U394);
];
[ call_U2013 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first getting [if the chaise is a supporter]off[otherwise]out of[end if] [the chaise])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first getting ";
    if ((~~((tmp_0 ofclass K6_supporter)))) {
        jump L_Say0;
    }
    ParaContent();
    print "off";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "out of";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2014 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2014, 805, 0);
    }
    (tmp_0 = LocationOf(actor));
    if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
        return GVS_Convert(##Go, out_obj, 0);
    }
    rfalse;
];
[ call_U2015;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2015, 806, 0);
        }
        if ((HolderOf(actor) ofclass K1_room)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U395);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2015, 806, 2);
        }
    }
    rfalse;
];
[ call_U2016;
    ResponseViaActivity(response_id_U395);
];
[ call_U2017;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] already up.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already up.";
    rtrue;
];
[ call_U2018;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2018, 807, 0);
        }
        TryAction(0, actor, ##GetOff, HolderOf(actor), 0);
        RulebookSucceeds();
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2018, 807, 2);
        }
    }
    rfalse;
];
[ call_U2019;
    if (debug_rules) {
        DB_Rule(call_U2019, 808, 0);
    }
    if ((~~(call_U150(use_option_id_U29)))) {
        if (FollowRulebook(call_U1460)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U2020;
    if (debug_rules) {
        DB_Rule(call_U2020, 809, 0);
    }
    if ((~~(call_U150(use_option_id_U29)))) {
        if (FollowRulebook(call_U1468)) {
            rtrue;
        }
    }
    rfalse;
];
[ Noun_Filter1 x;
    (x = noun);
    return (noun ofclass K2_thing);
];
[ Noun_Filter7 x;
    (x = noun);
    return (noun ofclass K2_thing);
];
[ call_U2021 t_0;
    if ((t_0 ofclass K2_thing)) {
        return ADJDEFN1(t_0);
    }
    rfalse;
];
[ call_U2022 t_0;
    if ((t_0 ofclass K16_passkey)) {
        return call_U2023(t_0);
    }
    rfalse;
];
[ call_U2023 const_0 x x_ix;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((const_0 == call_U2038(x))) {
            rtrue;
        }
    }
    rfalse;
];
[ ADJDEFN1 t_0;
    if ((actor == CarrierOf(t_0))) {
        rtrue;
    }
    if ((((SupporterOf(t_0) ofclass K17_keychain)) && ((actor == CarrierOf(SupporterOf(t_0)))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ ADJDEFN38 t_0;
    rfalse;
];
[ call_U2025 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2061)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2061;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2027 forbid_breaks rv;
    (rv = (call_U2068)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2068;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2028 forbid_breaks rv;
    (rv = (call_U2069)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2069;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2030 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ A_unlocking_keylesslySub;
    return GenericVerbSub(rulebook_id_U369, rulebook_id_U370, rulebook_id_U371);
];
[ A_unlocking_keylesslyDbg n s for_say;
    print "unlocking keylessly";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2031 forbid_breaks rv;
    (rv = (call_U2073)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2073;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2032 forbid_breaks rv;
    (rv = (call_U2074)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2074;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2034 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ A_locking_keylesslySub;
    return GenericVerbSub(rulebook_id_U372, rulebook_id_U373, rulebook_id_U374);
];
[ A_locking_keylesslyDbg n s for_say;
    print "locking keylessly";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2036 forbid_breaks rv;
    (rv = (call_U2102)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2102;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2037 forbid_breaks rv;
    (rv = (call_U2106)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2106;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_universal_unlockingSub;
    return GenericVerbSub(rulebook_id_U375, rulebook_id_U376, rulebook_id_U377);
];
[ A_universal_unlockingDbg n s for_say;
    print "universal unlocking";
];
[ call_U2038 X;
    if ((X ofclass K2_thing)) {
        return (X.P_unbolting_relation_storage);
    }
    rfalse;
];
[ call_U2039 L R;
    if ((((L ofclass K16_passkey)) && ((R ofclass K2_thing)))) {
        ((R.P_unbolting_relation_storage) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record3);
];
[ call_U2040 L R;
    if ((((L ofclass K16_passkey)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(R, A_P_unbolting_relation_storage, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record3);
];
[ call_U2041 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U2038(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = 0):0:) {
                    if ((call_U2041)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2041)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = 0):0:) {
                if ((call_U2041)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2041)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = 0):0:) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2041)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = 0):0:) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2041)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U2039(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U2040(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U2042 sk;
    rfalse;
];
[ call_U2043 sk;
    rfalse;
];
[ call_U2044 tmp_0;
    if ((((((action == ##Go)) && ((((actor == player)) && (((((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),((((MStack-->(MstVON(var_id_U42, 2))) ofclass K4_door)) && (((call_U387((MStack-->(MstVON(var_id_U42, 2))))) && (((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),1))))))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2044, 810, 0);
        }
        if (call_U150(use_option_id_U29)) {
            TryAction(0, player, ##Open, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U396));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Open, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U387(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2044, 810, 2);
        }
    }
    rfalse;
];
[ call_U2045;
    ResponseViaActivity(response_id_U396);
];
[ call_U2046 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first opening [the blocking door])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first opening ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2047 tmp_0;
    if ((((((action == ##Lock)) && ((((actor == player)) && (((((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U384(noun)) && (((tmp_0 = noun),1))))))) && ((second ofclass K2_thing)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2047, 811, 0);
        }
        if (call_U150(use_option_id_U29)) {
            TryAction(0, player, ##Close, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U397));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Close, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U384(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2047, 811, 2);
        }
    }
    rfalse;
];
[ call_U2048;
    ResponseViaActivity(response_id_U397);
];
[ call_U2049 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first closing [the door ajar])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first closing ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2050 tmp_0;
    if ((((((action == ##A_locking_keylessly)) && ((((actor == player)) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U384(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2050, 812, 0);
        }
        if (call_U150(use_option_id_U29)) {
            TryAction(0, player, ##Close, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U398));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##Close, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U384(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2050, 812, 2);
        }
    }
    rfalse;
];
[ call_U2051;
    ResponseViaActivity(response_id_U398);
];
[ call_U2052 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first closing [the door ajar])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first closing ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2053 tmp_0;
    if ((((((action == ##Open)) && ((((actor == player)) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U399(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2053, 813, 0);
        }
        if (call_U150(use_option_id_U29)) {
            TryAction(0, player, ##A_unlocking_keylessly, tmp_0, 0);
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U399));
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, player, ##A_unlocking_keylessly, tmp_0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
        }
        if (call_U399(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2053, 813, 2);
        }
    }
    rfalse;
];
[ call_U2054;
    ResponseViaActivity(response_id_U399);
];
[ call_U2055 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first unlocking [the sealed chest])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first unlocking ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2056 tmp_0;
    if ((((((action == ##Go)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),((((MStack-->(MstVON(var_id_U42, 2))) ofclass K4_door)) && (((call_U387((MStack-->(MstVON(var_id_U42, 2))))) && (((tmp_0 = (MStack-->(MstVON(var_id_U42, 2)))),1))))))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2056, 814, 0);
        }
        TryAction(0, actor, ##Open, tmp_0, 0);
        if (call_U387(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2056, 814, 2);
        }
    }
    rfalse;
];
[ call_U2057 tmp_0;
    if ((((((action == ##Lock)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U384(noun)) && (((tmp_0 = noun),1))))))) && ((second ofclass K2_thing)))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2057, 815, 0);
        }
        TryAction(0, actor, ##Close, tmp_0, 0);
        if (call_U384(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2057, 815, 2);
        }
    }
    rfalse;
];
[ call_U2058 tmp_0;
    if ((((((action == ##A_locking_keylessly)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U384(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2058, 816, 0);
        }
        TryAction(0, actor, ##Close, tmp_0, 0);
        if (call_U384(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2058, 816, 2);
        }
    }
    rfalse;
];
[ call_U2059 tmp_0;
    if ((((((action == ##Open)) && ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && (((tmp_0 = noun),(((noun ofclass K2_thing)) && (((call_U399(noun)) && (((tmp_0 = noun),1))))))))))) || (((tmp_0 = 0),0)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2059, 817, 0);
        }
        TryAction(0, actor, ##A_unlocking_keylessly, tmp_0, 0);
        if (call_U399(tmp_0)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2059, 817, 2);
        }
    }
    rfalse;
];
[ call_U2060 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2060, 818, 0);
    }
    if ((((call_U438(noun) ofclass K2_thing)) && (((((tmp_0 = call_U438(noun)),1)) && (IndirectlyContains(actor, call_U438(noun))))))) {
        (second = tmp_0);
        if (FollowRulebook(call_U2099)) {
            rtrue;
        }
    } else {
        if ((((call_U2038(noun) ofclass K16_passkey)) && (((call_U293(call_U2038(noun))) && (((tmp_0 = call_U2038(noun)),1)))))) {
            (second = tmp_0);
            if (FollowRulebook(call_U2099)) {
                rtrue;
            }
        } else {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                call_U2109(noun);
            }
            rtrue;
        }
    }
    rfalse;
];
[ call_U2061 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U2061, 820, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U400));
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2061, 820, 2);
        }
    }
    rfalse;
];
[ call_U2062;
    ResponseViaActivity(response_id_U400);
];
[ call_U2063 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lack] a key that fits [the locked-thing].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U253();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a key that fits ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2064;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2064, 822, 0);
        }
        if (FollowRulebook(call_U2099)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2064, 822, 3);
        }
    }
    rfalse;
];
[ call_U2065;
    if (debug_rules) {
        DB_Rule(call_U2065, 823, 0);
    }
    if ((~~((second == call_U438(noun))))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U401);
        print "^";
        rtrue;
    }
    rfalse;
];
[ call_U2066;
    ResponseViaActivity(response_id_U401);
];
[ call_U2067;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [do not fit] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb59(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2068;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2068, 824, 0);
        }
        if (FollowRulebook(call_U1562)) {
            rtrue;
        }
        if (FollowRulebook(call_U1565)) {
            rtrue;
        }
        if (FollowRulebook(call_U2060)) {
            rtrue;
        }
        ((MStack-->(MstVO(var_id_U114, 0))) = second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2068, 824, 2);
        }
    }
    rfalse;
];
[ call_U2069;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2069, 825, 0);
        }
        if (call_U150(use_option_id_U29)) {
        } else {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U402);
            }
        }
        TryAction(0, actor, ##Unlock, noun, (MStack-->(MstVO(var_id_U114, 0))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2069, 825, 2);
        }
    }
    rfalse;
];
[ call_U2070;
    ResponseViaActivity(response_id_U402);
];
[ call_U2071;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(with [the key unlocked with])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(with ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U114, 0))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2072;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2072, 826, 0);
        }
        if (FollowRulebook(call_U2099)) {
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2072, 826, 3);
        }
    }
    rfalse;
];
[ call_U2073;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2073, 827, 0);
        }
        if (FollowRulebook(call_U1544)) {
            rtrue;
        }
        if (FollowRulebook(call_U1547)) {
            rtrue;
        }
        if (FollowRulebook(call_U1550)) {
            rtrue;
        }
        if (FollowRulebook(call_U2060)) {
            rtrue;
        }
        ((MStack-->(MstVO(var_id_U115, 0))) = second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2073, 827, 2);
        }
    }
    rfalse;
];
[ call_U2074;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2074, 828, 0);
        }
        if (call_U150(use_option_id_U29)) {
        } else {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U403);
            }
        }
        TryAction(0, actor, ##Lock, noun, (MStack-->(MstVO(var_id_U115, 0))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2074, 828, 2);
        }
    }
    rfalse;
];
[ call_U2075;
    ResponseViaActivity(response_id_U403);
];
[ call_U2076;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(with [the key locked with])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(with ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U115, 0))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U2077 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K16_passkey)) && (((call_U2022(parameter_value)) && (((tmp_0 = parameter_value),1))))))) || (((tmp_0 = 0),0)))) {
        if ((((action == ##Inv)) && ((actor == player)))) {
            if (debug_rules) {
                DB_Rule(call_U2077, 830, 0);
            }
            (prior_named_noun = tmp_0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U404));
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2077, 830, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2077, 830, 2);
        }
    }
    rfalse;
];
[ call_U2078;
    ResponseViaActivity(response_id_U404);
];
[ call_U2079 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (which [open] [the list of things unbolted by the item])~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (which ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    objectloop (tmp_1 ofclass Object && (tmp_1 ofclass Object)) {
        if ((((tmp_1 ofclass K2_thing)) && ((tmp_0 == call_U2038(tmp_1))))) {
            give tmp_1 workflag2;
        } else {
            give tmp_1 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ")";
    rtrue;
];
[ call_U2080;
    if ((((action == ##Examine)) && ((((actor == player)) && ((((noun ofclass K16_passkey)) && (call_U2022(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2080, 831, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U405);
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2080, 831, 2);
        }
    }
    rfalse;
];
[ call_U2081;
    ResponseViaActivity(response_id_U405);
];
[ call_U2082 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [unlock] [the list of things unbolted by the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((noun == call_U2038(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2083;
    if ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2083, 832, 0);
        }
        if ((second == call_U438(noun))) {
            call_U2039(second, noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2083, 832, 2);
        }
    }
    rfalse;
];
[ call_U2084;
    if ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2084, 833, 0);
        }
        call_U2039(second, noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2084, 833, 2);
        }
    }
    rfalse;
];
[ call_U2085;
    if ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2085, 834, 0);
        }
        if ((second == call_U438(noun))) {
            call_U2039(second, noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2085, 834, 2);
        }
    }
    rfalse;
];
[ call_U2086;
    if ((((((actor ~= player)) && ((((actor ofclass K8_person)) && ((act_requester == 0)))))) && ((((noun ofclass K2_thing)) && ((second ofclass K16_passkey)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2086, 835, 0);
        }
        call_U2039(second, noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2086, 835, 2);
        }
    }
    rfalse;
];
[ call_U2087;
    if ((((action == ##PutOn)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((~~((noun ofclass K16_passkey)))))) && ((second ofclass K17_keychain)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2087, 836, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U406);
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2087, 836, 2);
        }
    }
    rfalse;
];
[ call_U2088;
    ResponseViaActivity(response_id_U406);
];
[ call_U2089;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] not a key.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " not a key.";
    rtrue;
];
[ call_U2090;
    if (debug_rules) {
        DB_Rule(call_U2090, 837, 0);
    }
    if ((((((action == ##Lock)) && ((actor == player)))) || ((((action == ##Unlock)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((((second ofclass K2_thing)) && ((((SupporterOf(second) ofclass K17_keychain)) && ((actor == CarrierOf(SupporterOf(second)))))))))))))))) {
        rfalse;
    }
    if (FollowRulebook(CARRYING_REQUIREMENTS_R)) {
        rtrue;
    }
    rfalse;
];
[ call_U2091;
    if ((((parameter_value ofclass K16_passkey)) && ((SupporterOf(parameter_value) ofclass K17_keychain)))) {
        if (debug_rules) {
            DB_Rule(call_U2091, 838, 0);
        }
        if ((~~((second ofclass K17_keychain)))) {
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2091, 838, 2);
        }
    }
    rfalse;
];
[ call_U2092;
    if (debug_rules) {
        DB_Rule(call_U2092, 839, 0);
    }
    if (call_U150(use_option_id_U29)) {
        if ((player == actor)) {
            TryAction(0, player, ##Take, noun, 0);
        } else {
            TryAction(0, actor, ##Take, noun, 0);
        }
    } else {
        CarryOutActivity(V28_implicitly_taking, noun);
    }
    rfalse;
];
[ call_U2093;
    if (debug_rules) {
        DB_Rule(call_U2093, 840, 0);
    }
    if (call_U150(use_option_id_U29)) {
        if ((player == actor)) {
            TryAction(0, player, ##Take, second, 0);
        } else {
            TryAction(0, actor, ##Take, second, 0);
        }
    } else {
        CarryOutActivity(V28_implicitly_taking, second);
    }
    rfalse;
];
[ call_U2094;
    if (debug_rules) {
        DB_Rule(call_U2094, 841, 0);
    }
    if ((~~((actor == OwnerOf(noun))))) {
        FollowRulebook(call_U2092);
    }
    if ((~~((actor == OwnerOf(noun))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2095;
    if (debug_rules) {
        DB_Rule(call_U2095, 842, 0);
    }
    if ((~~((actor == OwnerOf(second))))) {
        FollowRulebook(call_U2093);
    }
    if ((~~((actor == OwnerOf(second))))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2096 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2096, 843, 0);
    }
    if ((~~(call_U2021(noun)))) {
        if ((((SupporterOf(noun) ofclass K17_keychain)) && (((tmp_0 = SupporterOf(noun)),1)))) {
            (noun = tmp_0);
        }
        FollowRulebook(call_U2092);
    }
    if ((~~(call_U2021(noun)))) {
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U407));
            print "^";
        }
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2097;
    ResponseViaActivity(response_id_U407);
];
[ call_U2098 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Without holding [the noun], [we] [can] do nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Without holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ", ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " do nothing.";
    rtrue;
];
[ call_U2099 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U2099, 844, 0);
    }
    if ((~~(call_U2021(second)))) {
        (tmp_0 = second);
        if ((((SupporterOf(second) ofclass K17_keychain)) && (((tmp_1 = SupporterOf(second)),1)))) {
            (second = tmp_1);
        }
        FollowRulebook(call_U2093);
        (second = tmp_0);
    }
    if ((~~(call_U2021(second)))) {
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U408)));
            print "^";
        }
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2100;
    ResponseViaActivity(response_id_U408);
];
[ call_U2101 tmp_0 tmp_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Without holding [the second noun], [we] [can] do nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Without holding ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ", ";
    ParaContent();
    call_U248();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " do nothing.";
    rtrue;
];
[ call_U2102 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2102, 845, 0);
        }
        for (((tmp_0 = (call_U2103)(0)),(tmp_1 = (call_U2103)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U2103)(tmp_1)))) {
            call_U403(tmp_0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U409)));
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2102, 845, 3);
        }
    }
    rfalse;
];
[ call_U2103 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U399(x)) {
            return x;
        }
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U2104;
    ResponseViaActivity(response_id_U409);
];
[ call_U2105 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Unlocking [the item].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Unlocking ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2106;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2106, 846, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U410);
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2106, 846, 3);
        }
    }
    rfalse;
];
[ call_U2107;
    ResponseViaActivity(response_id_U410);
];
[ call_U2108;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~A loud stereophonic click assures you that everything in the game has been unlocked.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "A loud stereophonic click assures you that everything in the game has been unlocked.";
    rtrue;
];
[ call_U2109 t_0;
    CarryOutActivity(V35_refusing_keys, t_0);
    rfalse;
];
[ ConjugateVerb59 fn vp t modal_to;
    switch (fn) {
        1:
            print "fit";
            ;
        2:
            print "fitted";
            ;
        3:
            print "fitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "fits";
                    } else {
                        print "fit";
                    }
                    ;
                2:
                    print "fitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has fitted";
                    } else {
                        print "have fitted";
                    }
                    ;
                4:
                    print "had fitted";
                    ;
                5:
                    print "will fit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not fit";
                    } else {
                        print "do not fit";
                    }
                    ;
                2:
                    print "did not fit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not fitted";
                    } else {
                        print "have not fitted";
                    }
                    ;
                4:
                    print "had not fitted";
                    ;
                5:
                    print "will not fit";
                    ;
            }
            ;
    }
];
[ call_U2110 fn vp t modal_to;
    (t = ConjugateVerb59(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb53 fn vp t modal_to;
    switch (fn) {
        1:
            print "open";
            ;
        2:
            print "opened";
            ;
        3:
            print "opening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "opens";
                    } else {
                        print "open";
                    }
                    ;
                2:
                    print "opened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has opened";
                    } else {
                        print "have opened";
                    }
                    ;
                4:
                    print "had opened";
                    ;
                5:
                    print "will open";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not open";
                    } else {
                        print "do not open";
                    }
                    ;
                2:
                    print "did not open";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not opened";
                    } else {
                        print "have not opened";
                    }
                    ;
                4:
                    print "had not opened";
                    ;
                5:
                    print "will not open";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb54 fn vp t modal_to;
    switch (fn) {
        1:
            print "lack";
            ;
        2:
            print "lacked";
            ;
        3:
            print "lacking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "lacks";
                    } else {
                        print "lack";
                    }
                    ;
                2:
                    print "lacked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has lacked";
                    } else {
                        print "have lacked";
                    }
                    ;
                4:
                    print "had lacked";
                    ;
                5:
                    print "will lack";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lack";
                    } else {
                        print "do not lack";
                    }
                    ;
                2:
                    print "did not lack";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not lacked";
                    } else {
                        print "have not lacked";
                    }
                    ;
                4:
                    print "had not lacked";
                    ;
                5:
                    print "will not lack";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb55 fn vp t modal_to;
    switch (fn) {
        1:
            print "lock";
            ;
        2:
            print "locked";
            ;
        3:
            print "locking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "locks";
                    } else {
                        print "lock";
                    }
                    ;
                2:
                    print "locked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has locked";
                    } else {
                        print "have locked";
                    }
                    ;
                4:
                    print "had locked";
                    ;
                5:
                    print "will lock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lock";
                    } else {
                        print "do not lock";
                    }
                    ;
                2:
                    print "did not lock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not locked";
                    } else {
                        print "have not locked";
                    }
                    ;
                4:
                    print "had not locked";
                    ;
                5:
                    print "will not lock";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb56 fn vp t modal_to;
    switch (fn) {
        1:
            print "unlock";
            ;
        2:
            print "unlocked";
            ;
        3:
            print "unlocking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unlocks";
                    } else {
                        print "unlock";
                    }
                    ;
                2:
                    print "unlocked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unlocked";
                    } else {
                        print "have unlocked";
                    }
                    ;
                4:
                    print "had unlocked";
                    ;
                5:
                    print "will unlock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unlock";
                    } else {
                        print "do not unlock";
                    }
                    ;
                2:
                    print "did not unlock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unlocked";
                    } else {
                        print "have not unlocked";
                    }
                    ;
                4:
                    print "had not unlocked";
                    ;
                5:
                    print "will not unlock";
                    ;
            }
            ;
    }
];
[ ConjugateVerb102 fn vp t modal_to;
    switch (fn) {
        1:
            print "unbolt";
            ;
        2:
            print "unbolted";
            ;
        3:
            print "unbolting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record3;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unbolts";
                    } else {
                        print "unbolt";
                    }
                    ;
                2:
                    print "unbolted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unbolted";
                    } else {
                        print "have unbolted";
                    }
                    ;
                4:
                    print "had unbolted";
                    ;
                5:
                    print "will unbolt";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unbolt";
                    } else {
                        print "do not unbolt";
                    }
                    ;
                2:
                    print "did not unbolt";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unbolted";
                    } else {
                        print "have not unbolted";
                    }
                    ;
                4:
                    print "had not unbolted";
                    ;
                5:
                    print "will not unbolt";
                    ;
            }
            ;
    }
];
[ call_U2111 fn vp t modal_to;
    (t = ConjugateVerb102(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record3;
    }
];
[ Noun_Filter3 x;
    (x = noun);
    return (noun ofclass K16_passkey);
];
[ Noun_Filter4 x;
    (x = noun);
    return (noun ofclass K17_keychain);
];
[ Noun_Filter13 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U402(noun)) && (call_U396(noun)))));
];
[ Noun_Filter14 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U396(noun)));
];
[ Noun_Filter15 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U402(noun)) && (call_U396(noun)))));
];
[ Noun_Filter16 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U396(noun)));
];
[ Noun_Filter17 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U399(noun)) && (call_U396(noun)))));
];
[ Noun_Filter18 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U396(noun)));
];
[ Noun_Filter19 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U399(noun)) && (call_U396(noun)))));
];
[ Noun_Filter20 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U396(noun)));
];
[ Noun_Filter22 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (((call_U399(noun)) && (call_U396(noun)))));
];
[ Noun_Filter23 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U396(noun)));
];
[ call_U2113 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2119)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2119;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2115;
    if (debug_rules) {
        DB_Rule(call_U2115, 847, 0);
    }
    ((Global_Vars-->52) = ((Global_Vars-->52) - 1));
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U2116;
    if (debug_rules) {
        DB_Rule(call_U2116, 848, 0);
    }
    if (((Global_Vars-->56) < TableFilledRows((Global_Vars-->55)))) {
        ((Global_Vars-->56) = ((Global_Vars-->56) + 1));
    }
    call_U2125((Global_Vars-->55));
    rfalse;
    rfalse;
];
[ call_U2117;
    if (debug_rules) {
        DB_Rule(call_U2117, 849, 0);
    }
    if (((Global_Vars-->56) > 1)) {
        ((Global_Vars-->56) = ((Global_Vars-->56) - 1));
    }
    call_U2125((Global_Vars-->55));
    rfalse;
    rfalse;
];
[ call_U2118 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U23());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U23 ct_0 ct_1 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U2118, 850, 0);
    }
    (ct_0 = (Global_Vars-->55));
    (ct_1 = (Global_Vars-->56));
    if (ExistsTableLookUpEntry(ct_0, table_column_id_U11, ct_1)) {
        FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U11, ct_1));
        call_U2125((Global_Vars-->55));
    } else {
        if (ExistsTableLookUpEntry(ct_0, table_column_id_U9, ct_1)) {
            BlkValueCopy((Global_Vars-->54), TableLookUpEntry(ct_0, table_column_id_U8, ct_1));
            ((Global_Vars-->56) = 1);
            ((Global_Vars-->55) = TableLookUpEntry(ct_0, table_column_id_U9, ct_1));
            call_U2126();
        } else {
            (tmp_0 = I7SFRAME);
            BlkValueCopy(tmp_0, (Global_Vars-->54));
            BlkValueCopy((Global_Vars-->54), TableLookUpEntry(ct_0, table_column_id_U8, ct_1));
            ((Global_Vars-->53) = 1);
            DrawStatusLine();
            ((Global_Vars-->53) = 0);
            VM_ClearScreen(2);
            (say__p = 1);
            ParaContent();
            if (1) { font on; } else { font off; }ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
            ParaContent();
            DivideParagraphPoint();
            print "^";
            call_U2162();
            BlkValueCopy((Global_Vars-->54), tmp_0);
            call_U2125((Global_Vars-->55));
        }
    }
    rfalse;
];
[ call_U2119;
    if (debug_rules) {
        DB_Rule(call_U2119, 854, 0);
    }
    ((Global_Vars-->56) = 1);
    call_U2126();
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2120;
    if (TestActivity(V36_displaying)) {
        if (debug_rules) {
            DB_Rule(call_U2120, 855, 0);
        }
        if (((Global_Vars-->53) == 0)) {
            call_U2163(table_data_U6);
        } else {
            call_U2163(table_data_U5);
        }
        RulebookSucceeds();
        rtrue;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2120, 855, 4);
        }
    }
    rfalse;
];
[ call_U2121 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U24());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U24 ct_0 ct_1 tmp_0 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U2121, 858, 0);
    }
    (ct_0 = (Global_Vars-->55));
    (ct_1 = (Global_Vars-->56));
    (tmp_0 = I7SFRAME);
    BlkValueCopy(tmp_0, (Global_Vars-->54));
    BlkValueCopy((Global_Vars-->54), TableLookUpEntry(ct_0, table_column_id_U8, ct_1));
    ((Global_Vars-->53) = 1);
    DrawStatusLine();
    ((Global_Vars-->53) = 0);
    (say__p = 1);
    ParaContent();
    call_U2127(TableLookUpEntry(ct_0, table_column_id_U9, ct_1));
    (tmp_1 = 0);
    while ((tmp_1 < 1)) {
        (tmp_2 = VM_KeyChar());
        if ((((tmp_2 == 13)) || ((((tmp_2 == 31)) || ((tmp_2 == 32)))))) {
            (tmp_1 = 1);
        }
        if ((((tmp_2 == 72)) || ((tmp_2 == 104)))) {
            (say__p = 1);
            ParaContent();
            call_U2128(TableLookUpEntry(ct_0, table_column_id_U9, ct_1));
        }
    }
    BlkValueCopy((Global_Vars-->54), tmp_0);
    rfalse;
];
[ call_U2122;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[current menu title]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((Global_Vars-->54));
    rtrue;
];
[ call_U2123;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[current menu title]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((Global_Vars-->54));
    rtrue;
];
[ call_U2124;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Q = [if menu depth > 1]Last Menu[otherwise]Quit Menu[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Q = ";
    if ((~~(((Global_Vars-->52) > 1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Last Menu";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Quit Menu";
    .L_SayX0;
    rtrue;
];
[ call_U2125 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    DrawStatusLine();
    (say__p = 1);
    ParaContent();
    if (0) { font on; } else { font off; }(tmp_0 = 1);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((tmp_0 == (Global_Vars-->56))) {
                (say__p = 1);
                ParaContent();
                print " >";
            } else {
                (say__p = 1);
                ParaContent();
                print "  ";
            }
            (say__p = 1);
            ParaContent();
            print " ";
            ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U8, ct_1));
            ParaContent();
            print "^";
            (tmp_0 = (tmp_0 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    if (1) { font on; } else { font off; }rfalse;
];
[ call_U2126 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U25());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U25 tmp_0 tmp_1 tmp_2 tmp_3 tmp_4 tmp_5 ct_0 ct_1 tmp_6 tmp_7;
    ((Global_Vars-->52) = ((Global_Vars-->52) + 1));
    (tmp_0 = (Global_Vars-->52));
    (tmp_1 = (Global_Vars-->55));
    (tmp_2 = I7SFRAME);
    BlkValueCopy(tmp_2, (Global_Vars-->54));
    (tmp_3 = 0);
    (tmp_4 = 0);
    while ((~~((tmp_4 == 1)))) {
        ((Global_Vars-->55) = tmp_1);
        (tmp_5 = 0);
        @push ct_0;
        @push ct_1;
        for (((tmp_6 = (Global_Vars-->55)),((tmp_7 = 1),((ct_0 = tmp_6),(ct_1 = tmp_7)))):(tmp_7 <= TableRows(tmp_6)):((tmp_7)++,((ct_0 = tmp_6),(ct_1 = tmp_7)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                (tmp_5 = (tmp_5 + 1));
                if (((BlkValueCompare)(TableLookUpEntry(ct_0, table_column_id_U8, ct_1),(Global_Vars-->54)) == 0)) {
                    ((Global_Vars-->56) = tmp_5);
                }
            }
        }
        @pull ct_1;
        @pull ct_0;
        BlkValueCopy((Global_Vars-->54), tmp_2);
        call_U2125((Global_Vars-->55));
        (tmp_3 = VM_KeyChar());
        if (((1) && ((ct_1 = ExistsTableRowCorr((ct_0 = table_data_U4), table_column_id_U12, tmp_3))))) {
            FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U13, ct_1));
            if ((tmp_0 > (Global_Vars-->52))) {
                (tmp_4 = 1);
            }
        }
    }
    rfalse;
];
[ call_U2127 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    (tmp_0 = 0);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            (tmp_0 = (tmp_0 + 1));
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U18, ct_1)) {
                (say__p = 1);
                ParaContent();
                print (say__n = tmp_0);
                ParaContent();
                print "/";
                ParaContent();
                print (say__n = TableRows(t_0));
                ParaContent();
                print ": ";
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
            } else {
                if ((tmp_0 == 1)) {
                    (TableLookUpEntry)(ct_0,table_column_id_U18,ct_1,1,turns);
                    (say__p = 1);
                    ParaContent();
                    print (say__n = tmp_0);
                    ParaContent();
                    print "/";
                    ParaContent();
                    print (say__n = TableRows(t_0));
                    ParaContent();
                    print ": ";
                    ParaContent();
                    TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    print "Press SPACE to return to the menu or H to reveal another hint.";
    print "^";
    rfalse;
];
[ call_U2128 t_0 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    (tmp_0 = 0);
    VM_ClearScreen(2);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = t_0),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            (tmp_0 = (tmp_0 + 1));
            (say__p = 1);
            ParaContent();
            print (say__n = tmp_0);
            ParaContent();
            print "/";
            ParaContent();
            print (say__n = TableRows(t_0));
            ParaContent();
            print ": ";
            ParaContent();
            TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U17, ct_1));
            ParaContent();
            DivideParagraphPoint();
            print "^";
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U18, ct_1)) {
            } else {
                (TableLookUpEntry)(ct_0,table_column_id_U18,ct_1,1,turns);
                (say__p = 1);
                ParaContent();
                print "Press SPACE to return to the menu";
                ParaContent();
                if ((~~((tmp_0 < TableRows(t_0))))) {
                    jump L_Say1;
                }
                ParaContent();
                print " or H to reveal another hint";
                .L_Say1;
                ParaContent();
                print ".";
                print "^";
                rfalse;
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    print "Press SPACE to return to the menu";
    ParaContent();
    if ((~~((tmp_0 < TableRows(t_0))))) {
        jump L_Say3;
    }
    ParaContent();
    print " or H to reveal another hint";
    .L_Say3;
    ParaContent();
    print ".";
    print "^";
    rfalse;
];
[ call_U2129 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2748)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2748;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2749)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2749;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2130 forbid_breaks rv;
    (rv = (call_U2138)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2138;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_asking_for_helpSub;
    return GenericVerbSub(rulebook_id_U381, rulebook_id_U382, rulebook_id_U383);
];
[ A_asking_for_helpDbg n s for_say;
    print "asking for help";
];
[ call_U2132 sk;
    return I_brief_U1;
];
[ E8 value;
    switch (value) {
        I_brief_U1:
            print "brief";
            ;
        I_verbose_U1:
            print "verbose";
            ;
        I_superbrief_U1:
            print "superbrief";
            ;
        default:
            print "<illegal verbosity>";
            ;
    }
];
[ call_U2133 x;
    return ((x%3) + 1);
];
[ call_U2134 x;
    return (((x + 1)%3) + 1);
];
[ call_U2135 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2136;
    if (debug_rules) {
        DB_Rule(call_U2136, 860, 0);
    }
    if (notify_mode) {
        TryAction(0, player, ##NotifyOff, 0, 0);
    } else {
        TryAction(0, player, ##NotifyOn, 0, 0);
    }
    rfalse;
];
[ call_U2137;
    if (debug_rules) {
        DB_Rule(call_U2137, 861, 0);
    }
    if ((call_U2139() == I_verbose_U1)) {
        TryAction(0, player, ##LMode1, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    if ((call_U2139() == I_brief_U1)) {
        TryAction(0, player, ##LMode3, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    if ((call_U2139() == I_superbrief_U1)) {
        TryAction(0, player, ##LMode2, 0, 0);
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U2138;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2138, 864, 0);
        }
        ((Global_Vars-->55) = table_data_U8);
        CarryOutActivity(V36_displaying);
        VM_ClearScreen(0);
        TryAction(0, player, ##Look, 0, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2138, 864, 3);
        }
    }
    rfalse;
];
[ call_U2139 tmp_0;
    (tmp_0 = lookmode);
    if ((tmp_0 == 1)) {
        return I_brief_U1;
    }
    if ((tmp_0 == 2)) {
        return I_verbose_U1;
    }
    if ((tmp_0 == 3)) {
        return I_superbrief_U1;
    }
    return I_brief_U1;
];
[ call_U2140;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Introduction to [story title]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Introduction to ";
    ParaContent();
    TEXT_TY_Say(bc_U363);
    rtrue;
];
[ call_U2141;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is a simple demonstration [story genre] game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is a simple demonstration ";
    ParaContent();
    TEXT_TY_Say(bc_U374);
    ParaContent();
    print " game.";
    rtrue;
];
[ call_U2142;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~If you have any difficulties with [story title], please contact me at dmontgom22@@64@{67}mail.com~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "If you have any difficulties with ";
    ParaContent();
    TEXT_TY_Say(bc_U375);
    ParaContent();
    print ", please contact me at dmontgom22@@64@{67}mail.com";
    rtrue;
];
[ call_U2143;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What to do with [command prompt]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What to do with ";
    ParaContent();
    TEXT_TY_Say((Global_Vars-->24));
    rtrue;
];
[ call_U2144;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The [command prompt] sign is where the game says, 'Okay, what do you want to do now?'  You may respond by typing an instruction -- usually an imperative verb, possibly followed by prepositions and objects.  So, for instance, LOOK, LOOK AT FISH, TAKE FISH.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The ";
    ParaContent();
    TEXT_TY_Say((Global_Vars-->24));
    ParaContent();
    print " sign is where the game says, ~Okay, what do you want to do now?~  You may respond by typing an instruction -- usually an imperative verb, possibly followed by prepositions and objects.  So, for instance, LOOK, LOOK AT FISH, TAKE FISH.";
    rtrue;
];
[ call_U2145;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The first thing you want to do when starting a game is acquaint yourself with your surroundings and get a sense of your goal. To this end, you should read the introductory text carefully. Sometimes it contains clues. You will also want to look at the room you are in. Notice where the exits from the room are, and what objects are described here. If any of these seem interesting, you may want to EXAMINE them. [paragraph break]You might also want to examine yourself (EXAMINE ME) to see whether the author has left you any clues about your character. TAKE INVENTORY will tell you what you're carrying, as well.[paragraph break]Once you've gotten your bearings, you may want to explore. Move from room to room, and check out every location available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The first thing you want to do when starting a game is acquaint yourself with your surroundings and get a sense of your goal. To this end, you should read the introductory text carefully. Sometimes it contains clues. You will also want to look at the room you are in. Notice where the exits from the room are, and what objects are described here. If any of these seem interesting, you may want to EXAMINE them. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "You might also want to examine yourself (EXAMINE ME) to see whether the author has left you any clues about your character. TAKE INVENTORY will tell you what you're carrying, as well.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Once you've gotten your bearings, you may want to explore. Move from room to room, and check out every location available.";
    rtrue;
];
[ call_U2146;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~At any given time, you are in a specific location, or room. When you go into a room, the game will print a description of what you can see there. This description will contain two vital kinds of information: things in the room you can interact with or take, and a list of exits, or ways out. If you want to see the description again, you may just type LOOK. [paragraph break]When you want to leave a location and go to another one, you may communicate this to the game using compass directions: eg, GO NORTH. For simplicity's sake, you are allowed to omit the word GO, and to abbreviate the compass directions. So you may use NORTH, SOUTH, EAST, WEST, NORTHEAST, SOUTHEAST, NORTHWEST, SOUTHWEST, UP, and DOWN, or in short form N, S, E, W, NE, SE, NW, SW, U, and D.[paragraph break]In some locations, IN and OUT will also be useful.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "At any given time, you are in a specific location, or room. When you go into a room, the game will print a description of what you can see there. This description will contain two vital kinds of information: things in the room you can interact with or take, and a list of exits, or ways out. If you want to see the description again, you may just type LOOK. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "When you want to leave a location and go to another one, you may communicate this to the game using compass directions: eg, GO NORTH. For simplicity's sake, you are allowed to omit the word GO, and to abbreviate the compass directions. So you may use NORTH, SOUTH, EAST, WEST, NORTHEAST, SOUTHEAST, NORTHWEST, SOUTHWEST, UP, and DOWN, or in short form N, S, E, W, NE, SE, NW, SW, U, and D.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "In some locations, IN and OUT will also be useful.";
    rtrue;
];
[ call_U2147;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Throughout the game there will be assorted objects that you can do things with. Most importantly, you may TAKE or GET items, and (when you are tired of them) DROP them again. INVENTORY (abbreviated I) will list the items you are currently holding. [paragraph break]There are usually assorted things you may do with these objects. OPEN, CLOSE, WEAR, EAT, LOCK, and UNLOCK are especially common.[paragraph break]Occasionally, you will find that the game does not recognize the name of an object even though it has been described as being in the room with you. If this is the case, the object is just there for scenery, and you may assume that you do not need to interact with it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Throughout the game there will be assorted objects that you can do things with. Most importantly, you may TAKE or GET items, and (when you are tired of them) DROP them again. INVENTORY (abbreviated I) will list the items you are currently holding. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "There are usually assorted things you may do with these objects. OPEN, CLOSE, WEAR, EAT, LOCK, and UNLOCK are especially common.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Occasionally, you will find that the game does not recognize the name of an object even though it has been described as being in the room with you. If this is the case, the object is just there for scenery, and you may assume that you do not need to interact with it.";
    rtrue;
];
[ call_U2148;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~There are a few simple commands for controlling the game itself. These are: [paragraph break]SAVE saves a snapshot of the game as it is now. [line break]RESTORE puts the game back to a previous saved state. You may keep as many saved games as you like. [line break]RESTART puts the game back to the way it was at the beginning. [line break]QUIT ends the game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "There are a few simple commands for controlling the game itself. These are: ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "SAVE saves a snapshot of the game as it is now. ";
    ParaContent();
    print "^";
    ParaContent();
    print "RESTORE puts the game back to a previous saved state. You may keep as many saved games as you like. ";
    ParaContent();
    print "^";
    ParaContent();
    print "RESTART puts the game back to the way it was at the beginning. ";
    ParaContent();
    print "^";
    ParaContent();
    print "QUIT ends the game.";
    rtrue;
];
[ call_U2149;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the current verbosity mode is verbose]Verbose room descriptions[end if][if the current verbosity mode is brief]Brief room descriptions[end if][if the current verbosity mode is superbrief]Superbrief room descriptions[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((call_U2139() == I_verbose_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Verbose room descriptions";
    .L_Say0;
    if ((~~((call_U2139() == I_brief_U1)))) {
        jump L_Say1;
    }
    ParaContent();
    print "Brief room descriptions";
    .L_Say1;
    if ((~~((call_U2139() == I_superbrief_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print "Superbrief room descriptions";
    .L_Say2;
    rtrue;
];
[ call_U2150;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if notify mode is on]Score notification on[otherwise]Score notification off[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(notify_mode))) {
        jump L_Say0;
    }
    ParaContent();
    print "Score notification on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Score notification off";
    .L_SayX0;
    rtrue;
];
[ call_U2151;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Examine every object and look at everything in your inventory. Open all the doors you can find, and go through them. Look inside all closed containers. Make sure you've exhausted all the options in your environment. [paragraph break]Try out all your senses. If the game mentions texture, odor, or sound, try touching, smelling, listening to, or tasting objects.[paragraph break]Be thorough. If you still can't figure out what to do, try opening windows, looking under beds, etc. Sometimes objects are well-hidden.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Examine every object and look at everything in your inventory. Open all the doors you can find, and go through them. Look inside all closed containers. Make sure you've exhausted all the options in your environment. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Try out all your senses. If the game mentions texture, odor, or sound, try touching, smelling, listening to, or tasting objects.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Be thorough. If you still can't figure out what to do, try opening windows, looking under beds, etc. Sometimes objects are well-hidden.";
    rtrue;
];
[ call_U2152;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Reread. Look back at things you've already looked at. Sometimes this will trigger an idea you hadn't thought of. [paragraph break]Take hints from the prose of the game. Things that are described in great detail are probably more important than things that are given one-liners. Play with those objects. If a machine is described as having component parts, look at the parts, and try manipulating them.  Likewise, notice the verbs that the game itself uses. Try using those yourself. Games often include special verbs -- the names of magic spells, or other special commands. There's no harm in attempting something if the game mentions it.[paragraph break]Check the whole screen. Are there extra windows besides the main window?  What's going on in those?  Check out the status bar, if there is one -- it may contain the name of the room you're in, your score, the time of day, your character's state of health, or some other important information.  If there's something up there, it's worth paying attention to that, too.  When and where does it change?  Why is it significant?  If the bar is describing your character's health, you can bet there is probably a point at which that will be important.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Reread. Look back at things you've already looked at. Sometimes this will trigger an idea you hadn't thought of. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Take hints from the prose of the game. Things that are described in great detail are probably more important than things that are given one-liners. Play with those objects. If a machine is described as having component parts, look at the parts, and try manipulating them.  Likewise, notice the verbs that the game itself uses. Try using those yourself. Games often include special verbs -- the names of magic spells, or other special commands. There's no harm in attempting something if the game mentions it.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Check the whole screen. Are there extra windows besides the main window?  What's going on in those?  Check out the status bar, if there is one -- it may contain the name of the room you're in, your score, the time of day, your character's state of health, or some other important information.  If there's something up there, it's worth paying attention to that, too.  When and where does it change?  Why is it significant?  If the bar is describing your character's health, you can bet there is probably a point at which that will be important.";
    rtrue;
];
[ call_U2153;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Rephrase. If there's something you want to do, but the game doesn't seem to understand you, try alternative wordings. [paragraph break]Try variations. Sometimes an action doesn't work, but does produce some kind of unusual result. These are often indications that you're on the right track, even if you haven't figured out quite the right approach yet. Pressing the red button alone may only cause a grinding noise from inside the wall, so perhaps pressing the blue and then the red will open the secret door.[paragraph break]Consider the genre of the game. Mysteries, romances, and thrillers all have their own types of action and motivation. What are you trying to do, and how do conventional characters go about doing that? What's the right sort of behavior for a detective/romance heroine/spy?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Rephrase. If there's something you want to do, but the game doesn't seem to understand you, try alternative wordings. ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Try variations. Sometimes an action doesn't work, but does produce some kind of unusual result. These are often indications that you're on the right track, even if you haven't figured out quite the right approach yet. Pressing the red button alone may only cause a grinding noise from inside the wall, so perhaps pressing the blue and then the red will open the secret door.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Consider the genre of the game. Mysteries, romances, and thrillers all have their own types of action and motivation. What are you trying to do, and how do conventional characters go about doing that? What's the right sort of behavior for a detective/romance heroine/spy?";
    rtrue;
];
[ call_U2155 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2157)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2157;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2157;
    if (debug_rules) {
        DB_Rule(call_U2157, 871, 0);
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(as_block_constant_U411);
    print "^";
    SPACEPause();
    VM_ClearScreen(0);
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2158;
    ResponseViaActivity(response_id_U411);
];
[ call_U2159;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[paragraph break]Please press SPACE to continue.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Please press SPACE to continue.";
    rtrue;
];
[ call_U2160;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[location]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    PrintShortName(real_location);
    rtrue;
];
[ call_U2161;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[score]/[turn count]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print (say__n = score);
    ParaContent();
    print "/";
    ParaContent();
    print (say__n = turns);
    rtrue;
];
[ call_U2162;
    CarryOutActivity(V37_pausing_the_game);
    rfalse;
];
[ call_U2163 t_0 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U26(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U26 t_0 tmp_0 tmp_1 ct_0 ct_1 tmp_2 tmp_3;
    (tmp_0 = TableRows(t_0));
    DeepStatus(tmp_0);
    (tmp_1 = 1);
    @push ct_0;
    @push ct_1;
    for (((tmp_2 = t_0),((tmp_3 = 1),((ct_0 = tmp_2),(ct_1 = tmp_3)))):(tmp_3 <= TableRows(tmp_2)):((tmp_3)++,((ct_0 = tmp_2),(ct_1 = tmp_3)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            I7VM_MoveCursorInStatusLine(tmp_1);
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U14, ct_1)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U14, ct_1));
            }
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U15, ct_1)) {
                CenterPrint(BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0, table_column_id_U15, ct_1)), tmp_1);
            }
            if (ExistsTableLookUpEntry(ct_0, table_column_id_U16, ct_1)) {
                RightAlign(tmp_1);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U16, ct_1));
            }
            (tmp_1 = (tmp_1 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U2164 forbid_breaks rv;
    (rv = (call_U2167)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2167;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SingSub;
    return GenericVerbSub(rulebook_id_U387, rulebook_id_U388, rulebook_id_U389);
];
[ SingDbg n s for_say;
    print "singing";
];
[ call_U2167;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2167, 883, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Your singing is abominable.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2167, 883, 2);
        }
    }
    rfalse;
];
[ call_U2168 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (GProperty(OBJECT_TY, t_0, A_P_price) == 0);
    }
    rfalse;
];
[ call_U2169 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(call_U2168(t_0)));
    }
    rfalse;
];
[ call_U2170 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (PartOf(t_0) ofclass K26_electrical_panel);
    }
    rfalse;
];
[ call_U2171 t_0;
    if ((t_0 ofclass K27_socket)) {
        return call_U2172(t_0);
    }
    rfalse;
];
[ call_U2172 const_0 x x_ix;
    for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
        if ((x ofclass K29_fuse)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U2173 t_0;
    if ((t_0 ofclass K27_socket)) {
        return (~~(call_U2174(t_0)));
    }
    rfalse;
];
[ call_U2174 const_0 x x_ix;
    for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
        if ((x ofclass K29_fuse)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U2175 t_0;
    if ((t_0 ofclass K29_fuse)) {
        return (ContainerOf(t_0) ofclass K27_socket);
    }
    rfalse;
];
[ call_U2176 t_0;
    if ((t_0 ofclass K29_fuse)) {
        return (~~((ContainerOf(t_0) ofclass K27_socket)));
    }
    rfalse;
];
[ call_U2177 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (PartOf(t_0) ofclass K34_control_panel);
    }
    rfalse;
];
[ call_U2178 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 1);
    }
    rfalse;
];
[ call_U2179 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 1);
    }
    rfalse;
];
[ call_U2180 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 2);
    }
    rfalse;
];
[ call_U2181 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 2);
    }
    rfalse;
];
[ call_U2182 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 3);
    }
    rfalse;
];
[ call_U2183 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 3);
    }
    rfalse;
];
[ call_U2184 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 4);
    }
    rfalse;
];
[ call_U2185 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 4);
    }
    rfalse;
];
[ call_U2186 t_0;
    if (t_0) {
        return ((t_0.P_liquid) == 5);
    }
    rfalse;
];
[ call_U2187 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_liquid, 5);
    }
    rfalse;
];
[ call_U2188 t_0;
    if (t_0) {
        return (t_0 has P_indoors);
    }
    rfalse;
];
[ call_U2189 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 1);
    }
    rfalse;
];
[ call_U2190 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 0);
    }
    rfalse;
];
[ call_U2191 t_0;
    if (t_0) {
        return ((t_0 has P_indoors) == 0);
    }
    rfalse;
];
[ call_U2192 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 0);
    }
    rfalse;
];
[ call_U2193 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_indoors, 1);
    }
    rfalse;
];
[ call_U2194 t_0;
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    if (t_0) {
        return ((t_0.P_color) == 1);
    }
    rfalse;
];
[ call_U2195 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 1);
    }
    rfalse;
];
[ call_U2196 t_0;
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    if (t_0) {
        return ((t_0.P_color) == 2);
    }
    rfalse;
];
[ call_U2197 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 2);
    }
    rfalse;
];
[ call_U2198 t_0;
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    if (t_0) {
        return ((t_0.P_color) == 3);
    }
    rfalse;
];
[ call_U2199 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 3);
    }
    rfalse;
];
[ call_U2200 t_0;
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    if (t_0) {
        return ((t_0.P_color) == 4);
    }
    rfalse;
];
[ call_U2201 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 4);
    }
    rfalse;
];
[ call_U2202 t_0;
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    if (t_0) {
        return ((t_0.P_color) == 5);
    }
    rfalse;
];
[ call_U2203 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 5);
    }
    rfalse;
];
[ call_U2204 t_0;
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    if (t_0) {
        return ((t_0.P_color) == 6);
    }
    rfalse;
];
[ call_U2205 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 6);
    }
    rfalse;
];
[ call_U2206 t_0;
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    if (t_0) {
        return ((t_0.P_color) == 7);
    }
    rfalse;
];
[ call_U2207 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 7);
    }
    rfalse;
];
[ call_U2208 t_0;
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    if (t_0) {
        return ((t_0.P_color) == 8);
    }
    rfalse;
];
[ call_U2209 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 8);
    }
    rfalse;
];
[ call_U2210 t_0;
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    if (t_0) {
        return ((t_0.P_color) == 9);
    }
    rfalse;
];
[ call_U2211 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 9);
    }
    rfalse;
];
[ call_U2212 t_0;
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    if (t_0) {
        return ((t_0.P_color) == 10);
    }
    rfalse;
];
[ call_U2213 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_color, 10);
    }
    rfalse;
];
[ call_U2214 t_0;
    if (t_0) {
        return (t_0 has P_electromagnetic);
    }
    rfalse;
];
[ call_U2215 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_electromagnetic, 1);
    }
    rfalse;
];
[ call_U2216 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_electromagnetic, 0);
    }
    rfalse;
];
[ call_U2217 t_0;
    if (t_0) {
        return (t_0 has P_consumed);
    }
    rfalse;
];
[ call_U2218 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_consumed, 1);
    }
    rfalse;
];
[ call_U2219 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_consumed, 0);
    }
    rfalse;
];
[ call_U2220 t_0;
    if (t_0) {
        return ((t_0 has P_consumed) == 0);
    }
    rfalse;
];
[ call_U2221 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_consumed, 0);
    }
    rfalse;
];
[ call_U2222 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_P_consumed, 1);
    }
    rfalse;
];
[ call_U2223 t_0;
    if (t_0) {
        return (t_0 has mark_as_room);
    }
    rfalse;
];
[ call_U2224 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 1);
    }
    rfalse;
];
[ call_U2225 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 0);
    }
    rfalse;
];
[ call_U2226 t_0;
    if (t_0) {
        return (t_0 has mark_as_thing);
    }
    rfalse;
];
[ call_U2227 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 1);
    }
    rfalse;
];
[ call_U2228 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 0);
    }
    rfalse;
];
[ call_U2229 t_0;
    if (t_0) {
        return (t_0 has container);
    }
    rfalse;
];
[ call_U2230 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 1);
    }
    rfalse;
];
[ call_U2231 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 0);
    }
    rfalse;
];
[ call_U2232 t_0;
    if (t_0) {
        return (t_0 has supporter);
    }
    rfalse;
];
[ call_U2233 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 1);
    }
    rfalse;
];
[ call_U2234 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 0);
    }
    rfalse;
];
[ call_U2235 t_0;
    if (t_0) {
        return (t_0 has switchable);
    }
    rfalse;
];
[ call_U2236 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 1);
    }
    rfalse;
];
[ call_U2237 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 0);
    }
    rfalse;
];
[ call_U2238 t_0;
    if (t_0) {
        return (t_0 has animate);
    }
    rfalse;
];
[ call_U2239 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 1);
    }
    rfalse;
];
[ call_U2240 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 0);
    }
    rfalse;
];
[ ADJDEFN39 t_0;
    rfalse;
];
[ ADJDEFN40 t_0;
    rfalse;
];
[ ADJDEFN41 t_0;
    rfalse;
];
[ ADJDEFN42 t_0;
    rfalse;
];
[ ADJDEFN43 t_0;
    rfalse;
];
[ ADJDEFN44 t_0;
    rfalse;
];
[ ADJDEFN45 t_0;
    rfalse;
];
[ ADJDEFN46 t_0;
    rfalse;
];
[ call_U2241 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The carnival parking lot stretches across an open field, its gravel crunching under arriving cars. Temporary floodlights and the carnival[']s colorful glow light the area, while distant laughter, music, and the hum of rides fill the air.^^Cars park haphazardly, guided by makeshift signs and fluttering flags. Families unload strollers and blankets, their chatter mixing with the carnival sounds. Others linger in vehicles, preparing for the chilly evening.^^Shadows from nearby trees create dark pockets pierced by the occasional flashlight. Near the entrance, an attendant collects fees at a weathered booth, coins jingling in the cash box.^^Puddles from recent rain shimmer with reflected lights, while patches of mud cling to unwary shoes. At the far end, RVs and trailers sit quietly, their occupants watching the Ferris wheel spin lazily against the sky.^^Alive with anticipation, the parking lot marks the transition from the ordinary to the magic of the carnival.^^The midway is to the south. There is a blueberry bush here. [if blueberry bush contains blueberries]There are blueberries on the bush.[otherwise]The bush has been picked clean.[end if][paragraph break]Your car is here. It[']s a bit of a beater. Inside the car, you can see [the list of things which are part of the beater car].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The carnival parking lot stretches across an open field, its gravel crunching under arriving cars. Temporary floodlights and the carnival";
    ParaContent();
    print "'";
    ParaContent();
    print "s colorful glow light the area, while distant laughter, music, and the hum of rides fill the air.^^Cars park haphazardly, guided by makeshift signs and fluttering flags. Families unload strollers and blankets, their chatter mixing with the carnival sounds. Others linger in vehicles, preparing for the chilly evening.^^Shadows from nearby trees create dark pockets pierced by the occasional flashlight. Near the entrance, an attendant collects fees at a weathered booth, coins jingling in the cash box.^^Puddles from recent rain shimmer with reflected lights, while patches of mud cling to unwary shoes. At the far end, RVs and trailers sit quietly, their occupants watching the Ferris wheel spin lazily against the sky.^^Alive with anticipation, the parking lot marks the transition from the ordinary to the magic of the carnival.^^The midway is to the south. There is a blueberry bush here. ";
    if ((~~((I_blueberry_bush_U1 == ContainerOf(I_blueberries_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "There are blueberries on the bush.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "The bush has been picked clean.";
    .L_SayX0;
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Your car is here. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a bit of a beater. Inside the car, you can see ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((I_beater_car_U1 == PartOf(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2242;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[price of the money] in cash~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E6(GProperty(OBJECT_TY, (self = I_money_U1), A_P_price));
    @pull self;
    ParaContent();
    print " in cash";
    rtrue;
];
[ call_U2243;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a quarter. Two bits. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a quarter. Two bits. And very shiny.";
    rtrue;
];
[ call_U2244;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a quarter. Two bits. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a quarter. Two bits. And very shiny.";
    rtrue;
];
[ call_U2245;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a quarter. Two bits. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a quarter. Two bits. And very shiny.";
    rtrue;
];
[ call_U2246;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the location is outdoors]It[']s a beautiful evening. Not a cloud in the sky. The moon is out and there are so many stars to see. A shooting star streaks across the sky.[otherwise]You[']re indoors. You can[']t see the sky here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2191(real_location)))) {
        jump L_Say0;
    }
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a beautiful evening. Not a cloud in the sky. The moon is out and there are so many stars to see. A shooting star streaks across the sky.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "re indoors. You can";
    ParaContent();
    print "'";
    ParaContent();
    print "t see the sky here.";
    .L_SayX0;
    rtrue;
];
[ call_U2247;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2248;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2249;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2250;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2251;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2252;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet One. There[']s an electrical panel here and an exit to the south west.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet One. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the south west.";
    rtrue;
];
[ call_U2253 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_electrical_room_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_P_electromagnetic)) && ((t_0 has P_electromagnetic)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "electromagnetic";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2254;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The electrical room is a small but essential space hidden behind the carnival's bright attractions. The air vibrates with electric energy, carrying the acrid scent of overheated wires and metal. Metal panels line the walls, some polished, others worn and streaked with grease.^^A central breaker panel, labeled with destinations like 'Ferris Wheel Lights' and 'Carousel Motors,' dominates one wall. Colored indicator lights blink intermittently, reflecting off steel surfaces. Overhead, thick cable bundles snake across the ceiling, connecting to the carnival's power network.^^In a corner, an open junction box spills wires onto the wall, while a workbench holds scattered tools and a smudged wiring diagram pinned above. The dirt floor bears scratches, oil stains, and wire clippings. A faint vibration, carried from the generator or nearby rides, pulses through the room.^^An emergency shutdown panel painted bright red stands near a fire extinguisher and a faded safety poster. A small fan on the workbench oscillates weakly, barely cooling the room's warmth. Flickering fluorescent tubes overhead cast harsh, shifting shadows.^^The electrical room is raw and utilitarian, revealing the fragile systems behind the carnival's magic - a humbling reminder of the power sustaining the midway's enchantment.^^[if the location is electromagnetic]This room is oozing with electromagnetic energy. You can feel your hair stand on end and all your nerves twitching. This feels dangerous! There are exits in all directions.[otherwise]This room is eerily quiet, missing the ever present buzz of electricity. There are exits in all directions.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The electrical room is a small but essential space hidden behind the carnival's bright attractions. The air vibrates with electric energy, carrying the acrid scent of overheated wires and metal. Metal panels line the walls, some polished, others worn and streaked with grease.^^A central breaker panel, labeled with destinations like ~Ferris Wheel Lights~ and ~Carousel Motors,~ dominates one wall. Colored indicator lights blink intermittently, reflecting off steel surfaces. Overhead, thick cable bundles snake across the ceiling, connecting to the carnival's power network.^^In a corner, an open junction box spills wires onto the wall, while a workbench holds scattered tools and a smudged wiring diagram pinned above. The dirt floor bears scratches, oil stains, and wire clippings. A faint vibration, carried from the generator or nearby rides, pulses through the room.^^An emergency shutdown panel painted bright red stands near a fire extinguisher and a faded safety poster. A small fan on the workbench oscillates weakly, barely cooling the room's warmth. Flickering fluorescent tubes overhead cast harsh, shifting shadows.^^The electrical room is raw and utilitarian, revealing the fragile systems behind the carnival's magic - a humbling reminder of the power sustaining the midway's enchantment.^^";
    if ((~~(call_U2214(real_location)))) {
        jump L_Say0;
    }
    ParaContent();
    print "This room is oozing with electromagnetic energy. You can feel your hair stand on end and all your nerves twitching. This feels dangerous! There are exits in all directions.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "This room is eerily quiet, missing the ever present buzz of electricity. There are exits in all directions.";
    .L_SayX0;
    rtrue;
];
[ call_U2255;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet Three. There[']s an electrical panel here and an exit to the west.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet Three. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the west.";
    rtrue;
];
[ call_U2256;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet Five. There[']s an electrical panel here and an exit to the north west.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet Five. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the north west.";
    rtrue;
];
[ call_U2257;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet Seven. There[']s an electrical panel here and an exit to the north east.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet Seven. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the north east.";
    rtrue;
];
[ call_U2258;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet Nine. There[']s an electrical panel here and an exit to the east.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet Nine. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the east.";
    rtrue;
];
[ call_U2259;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is Electrical Closet Eleven. There[']s an electrical panel here and an exit to the south east.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is Electrical Closet Eleven. There";
    ParaContent();
    print "'";
    ParaContent();
    print "s an electrical panel here and an exit to the south east.";
    rtrue;
];
[ call_U2260 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the standard issue Swiss Army knife. It has [a list of things which are part of the item described].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the standard issue Swiss Army knife. It has ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((self == PartOf(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects(ENGLISH_BIT);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2261;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2262;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2263;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2264;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2265;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2266;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2267;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~At the square[']s center stand a row of crude wooden stocks, their heavy beams stained from years of weather and use. Iron clasps hold the unfortunate captives by their wrists and necks, their bodies forced into unnatural, humiliating postures.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "At the square";
    ParaContent();
    print "'";
    ParaContent();
    print "s center stand a row of crude wooden stocks, their heavy beams stained from years of weather and use. Iron clasps hold the unfortunate captives by their wrists and necks, their bodies forced into unnatural, humiliating postures.";
    rtrue;
];
[ call_U2268;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2269;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2270;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2271;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2272;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2273;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2274;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2275;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2276;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2277;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2278;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2279;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2280;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is a poster of Billie Eilish. Doesn[']t your sweetie like them?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is a poster of Billie Eilish. Doesn";
    ParaContent();
    print "'";
    ParaContent();
    print "t your sweetie like them?";
    rtrue;
];
[ call_U2281;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The carnival storage room is a cramped yet essential space, tucked away from the bustling grounds. Its rusted metal and peeling wooden walls bear the marks of years of use, while the air hangs heavy with grease, dust, damp canvas, and a faint trace of stale popcorn.^^Shelves overflow with supplies - boxes of light bulbs, spools of wire, and assorted ride parts - piled without order. Tangled flags and strings of lights dangle from hooks, while crates labeled 'GAME PRIZES' and 'RIDE PARTS' hold items like stuffed animals and plastic toys. Folded tarps and tent poles teeter in one corner.^^The room's center is dominated by larger objects: spare ride seats, unassembled booths, and faded attraction pieces like a scratched carousel horse, all hidden beneath protective tarps.^^Near the entrance, a battered desk is cluttered with maintenance logs, tools, and empty coffee cups. Above it, a cork board brims with ride schedules, repair requests, and notes. A flickering fluorescent bulb casts uneven shadows, adding an eerie atmosphere.^^The floor, a rough blend of concrete and dirt, is littered with bolts and wire scraps. In the dim corners, the scuttle of rats and the glint of cobwebs underline the room[']s gritty nature.^^Chaotic yet indispensable, this hidden space powers the carnival's magic, ensuring every ride and booth runs seamlessly.^^There is an exit to the north and a door to the west.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The carnival storage room is a cramped yet essential space, tucked away from the bustling grounds. Its rusted metal and peeling wooden walls bear the marks of years of use, while the air hangs heavy with grease, dust, damp canvas, and a faint trace of stale popcorn.^^Shelves overflow with supplies - boxes of light bulbs, spools of wire, and assorted ride parts - piled without order. Tangled flags and strings of lights dangle from hooks, while crates labeled ~GAME PRIZES~ and ~RIDE PARTS~ hold items like stuffed animals and plastic toys. Folded tarps and tent poles teeter in one corner.^^The room's center is dominated by larger objects: spare ride seats, unassembled booths, and faded attraction pieces like a scratched carousel horse, all hidden beneath protective tarps.^^Near the entrance, a battered desk is cluttered with maintenance logs, tools, and empty coffee cups. Above it, a cork board brims with ride schedules, repair requests, and notes. A flickering fluorescent bulb casts uneven shadows, adding an eerie atmosphere.^^The floor, a rough blend of concrete and dirt, is littered with bolts and wire scraps. In the dim corners, the scuttle of rats and the glint of cobwebs underline the room";
    ParaContent();
    print "'";
    ParaContent();
    print "s gritty nature.^^Chaotic yet indispensable, this hidden space powers the carnival's magic, ensuring every ride and booth runs seamlessly.^^There is an exit to the north and a door to the west.";
    rtrue;
];
[ call_U2282 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The ticket kiosk stands at the carnival entrance, a compact booth painted in bright red and yellow stripes with bold letters above the window reading 'Tickets Here!' Twinkling lights outline its edges, blinking rhythmically to draw attention.^^A single window serves visitors, where a smiling cashier dispenses colorful tickets from neatly arranged rolls. Beside the tickets, a cash drawer jingles as change is counted, and a digital payment system glows faintly for modern convenience. Too bad you don[']t have a debit card.^^Next to the kiosk, a vibrant signboard lists ticket prices with playful illustrations of rides and treats. Pennant flags flutter from the kiosk's roof, adding to the festive atmosphere, while the smell of popcorn and fried dough wafts from the southwest.^^The worn ground around the kiosk shows the passage of eager carnival-goers. Families, couples, and friends form a buzzing line, their excitement building as they approach this first step into the magic of the carnival.^^The midway continues in all directions from here. There is a cashier here. The prices of ride tickets are on the signboard. The cashier has [list of things carried by the cashier].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The ticket kiosk stands at the carnival entrance, a compact booth painted in bright red and yellow stripes with bold letters above the window reading ~Tickets Here!~ Twinkling lights outline its edges, blinking rhythmically to draw attention.^^A single window serves visitors, where a smiling cashier dispenses colorful tickets from neatly arranged rolls. Beside the tickets, a cash drawer jingles as change is counted, and a digital payment system glows faintly for modern convenience. Too bad you don";
    ParaContent();
    print "'";
    ParaContent();
    print "t have a debit card.^^Next to the kiosk, a vibrant signboard lists ticket prices with playful illustrations of rides and treats. Pennant flags flutter from the kiosk's roof, adding to the festive atmosphere, while the smell of popcorn and fried dough wafts from the southwest.^^The worn ground around the kiosk shows the passage of eager carnival-goers. Families, couples, and friends form a buzzing line, their excitement building as they approach this first step into the magic of the carnival.^^The midway continues in all directions from here. There is a cashier here. The prices of ride tickets are on the signboard. The cashier has ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((I_cashier_U1 == CarrierOf(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + NOARTICLE_BIT));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2283 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is in the beater car][bold type]Car Interior[roman type][line break][end if]This is your car. It[']s a 2002 Honda Civic and it[']s seen better days.[paragraph break][if the player is in the beater car]You[']re sitting inside your car. [end if]Even though it[']s old, it feels like an old friend. From the faux leather seats to the crack in the windshield. It[']s familiar and comforting. There are old fast food wrappers on the floor, dirty clothes and text books in the back seat. There is an air freshener hanging from the rear view mirror. You see [the list of things which are part of the beater car].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    if ((~~((I_beater_car_U1 == ContainerOf(player))))) {
        jump L_Say0;
    }
    ParaContent();
    style bold;
    ParaContent();
    print "Car Interior";
    ParaContent();
    style roman;
    ParaContent();
    print "^";
    .L_Say0;
    ParaContent();
    print "This is your car. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a 2002 Honda Civic and it";
    ParaContent();
    print "'";
    ParaContent();
    print "s seen better days.";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    if ((~~((I_beater_car_U1 == ContainerOf(player))))) {
        jump L_Say1;
    }
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "re sitting inside your car. ";
    .L_Say1;
    ParaContent();
    print "Even though it";
    ParaContent();
    print "'";
    ParaContent();
    print "s old, it feels like an old friend. From the faux leather seats to the crack in the windshield. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s familiar and comforting. There are old fast food wrappers on the floor, dirty clothes and text books in the back seat. There is an air freshener hanging from the rear view mirror. You see ";
    ParaContent();
    objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
        if ((((tmp_0 ofclass K2_thing)) && ((I_beater_car_U1 == PartOf(tmp_0))))) {
            give tmp_0 workflag2;
        } else {
            give tmp_0 ~workflag2;
        }
    }
    WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2284;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~McDonald's, Burger King, Jack In The Box, Taco Bell, Carls, Jr., Five Guys... You[']re a regular equal opportunity garbage gut.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "McDonald's, Burger King, Jack In The Box, Taco Bell, Carls, Jr., Five Guys... You";
    ParaContent();
    print "'";
    ParaContent();
    print "re a regular equal opportunity garbage gut.";
    rtrue;
];
[ call_U2285 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 == I_blueberries_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_P_consumed)) && ((t_0 has P_consumed)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "consumed";
                }
                if (((AllowInShowme(A_P_consumed)) && ((~~((t_0 has P_consumed)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "uneaten";
                }
            }
        }
        return na;
    #endif;
];
[ call_U2286;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~These are your car keys. It[']s a wonder you could even find them, your house is such a mess.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "These are your car keys. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a wonder you could even find them, your house is such a mess.";
    rtrue;
];
[ call_U2287;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~A nice set of fur-lined leather gloves. They[']re very warm.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "A nice set of fur-lined leather gloves. They";
    ParaContent();
    print "'";
    ParaContent();
    print "re very warm.";
    rtrue;
];
[ call_U2288;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Approaching the fortune teller[']s booth, you're drawn in by its mysterious allure. Draped in deep purple curtains adorned with golden moons and stars, the booth glows with the soft, inviting light of lanterns. The air is heavy with the scent of incense, mingling with the sweet aroma of carnival treats. A sign reading 'Fortunes Told - What Does Your Future Hold?' sways slightly in the evening breeze.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Approaching the fortune teller";
    ParaContent();
    print "'";
    ParaContent();
    print "s booth, you're drawn in by its mysterious allure. Draped in deep purple curtains adorned with golden moons and stars, the booth glows with the soft, inviting light of lanterns. The air is heavy with the scent of incense, mingling with the sweet aroma of carnival treats. A sign reading ~Fortunes Told - What Does Your Future Hold?~ sways slightly in the evening breeze.";
    rtrue;
];
[ call_U2289;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You are standing in front of a ticket taker with his hand open waiting for your ticket. The entrance to the ride is south of here. The ride operator tells you that you[']re lucky you showed up when you did because this will be the last trip through Hell Ride for the night. You notice that all the other cars are empty. The Ticket Kiosk is back the way you came.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You are standing in front of a ticket taker with his hand open waiting for your ticket. The entrance to the ride is south of here. The ride operator tells you that you";
    ParaContent();
    print "'";
    ParaContent();
    print "re lucky you showed up when you did because this will be the last trip through Hell Ride for the night. You notice that all the other cars are empty. The Ticket Kiosk is back the way you came.";
    rtrue;
];
[ call_U2290;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The carousel is a timeless carnival attraction, radiating charm and nostalgia with its brightly painted horses, vibrant lights, and cheerful music. The circular platform is adorned with a canopy of swirling colors, gold trim, and decorative mirrors that reflect the flickering bulbs lining its edges.^^Rows of hand-carved animals, most often horses with flowing manes, are arranged in a circle. Each is painted in vivid colors, detailed with golden saddles and ribbons. It also features exotic creatures like lions, tigers, and sea dragons, adding whimsy to the ride. The animals rise and fall gently as the carousel spins, mimicking a galloping motion.^^The carousel[']s warm, playful tunes drift across the midway, inviting riders of all ages to enjoy its simple delight. Children laugh as they choose their favorite animals, while adults savor the nostalgia of the spinning ride. As it rotates, the carousel becomes a moving work of art, blending motion, color, and music into an enchanting centerpiece of the carnival. The Ticket Kiosk is back to the southwest; the way you came.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The carousel is a timeless carnival attraction, radiating charm and nostalgia with its brightly painted horses, vibrant lights, and cheerful music. The circular platform is adorned with a canopy of swirling colors, gold trim, and decorative mirrors that reflect the flickering bulbs lining its edges.^^Rows of hand-carved animals, most often horses with flowing manes, are arranged in a circle. Each is painted in vivid colors, detailed with golden saddles and ribbons. It also features exotic creatures like lions, tigers, and sea dragons, adding whimsy to the ride. The animals rise and fall gently as the carousel spins, mimicking a galloping motion.^^The carousel";
    ParaContent();
    print "'";
    ParaContent();
    print "s warm, playful tunes drift across the midway, inviting riders of all ages to enjoy its simple delight. Children laugh as they choose their favorite animals, while adults savor the nostalgia of the spinning ride. As it rotates, the carousel becomes a moving work of art, blending motion, color, and music into an enchanting centerpiece of the carnival. The Ticket Kiosk is back to the southwest; the way you came.";
    rtrue;
];
[ call_U2291;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This area features a tall, eye-catching machine adorned with bright, colorful lights, typically red, yellow, and blue. A large sign at the top reads 'Test Your Strength!' in bold, playful lettering. The machine[']s base is made of polished wood, with a polished, vintage appearance. At the center is a sturdy metal pole, with a large bell hanging at the top, signaling when a successful attempt has been made. Along the length of the pole are markings indicating how strong you are.  A nearby sign says, 'Buy a mallet, strike the bell, win a prize.'[if the strongman attendant contains the mallet] You can see an over-sized mallet here.[end if]^^Spectators gather around, cheering on participants and offering lighthearted jabs and encouragement, creating a lively, competitive atmosphere. The sound of the mallet hitting the target is followed by the resonant clang of the bell (if struck), alongside the buzz of carnival music in the background. The Ticket Kiosk is back the way you came and other games are northeast and northwest of here. The Ferris Wheel lies to the east.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This area features a tall, eye-catching machine adorned with bright, colorful lights, typically red, yellow, and blue. A large sign at the top reads ~Test Your Strength!~ in bold, playful lettering. The machine";
    ParaContent();
    print "'";
    ParaContent();
    print "s base is made of polished wood, with a polished, vintage appearance. At the center is a sturdy metal pole, with a large bell hanging at the top, signaling when a successful attempt has been made. Along the length of the pole are markings indicating how strong you are.  A nearby sign says, ~Buy a mallet, strike the bell, win a prize.~";
    if ((~~((I_strongman_attendant_U1 == ContainerOf(I_mallet_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print " You can see an over-sized mallet here.";
    .L_Say0;
    ParaContent();
    print "^^Spectators gather around, cheering on participants and offering lighthearted jabs and encouragement, creating a lively, competitive atmosphere. The sound of the mallet hitting the target is followed by the resonant clang of the bell (if struck), alongside the buzz of carnival music in the background. The Ticket Kiosk is back the way you came and other games are northeast and northwest of here. The Ferris Wheel lies to the east.";
    rtrue;
];
[ call_U2292;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~A single window serves visitors, where a smiling cashier dispenses colorful tickets from neatly arranged rolls. Beside the tickets, a cash drawer jingles as change is counted, and a digital payment system glows faintly for modern convenience. Too bad you don[']t have a debit card.^^Next to the kiosk, a vibrant signboard lists ticket prices with playful illustrations of rides and treats.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "A single window serves visitors, where a smiling cashier dispenses colorful tickets from neatly arranged rolls. Beside the tickets, a cash drawer jingles as change is counted, and a digital payment system glows faintly for modern convenience. Too bad you don";
    ParaContent();
    print "'";
    ParaContent();
    print "t have a debit card.^^Next to the kiosk, a vibrant signboard lists ticket prices with playful illustrations of rides and treats.";
    rtrue;
];
[ call_U2293;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Admit One' to the Hell Ride.[line break]It[']s a real 'E' ticket, baby!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Admit One~ to the Hell Ride.";
    ParaContent();
    print "^";
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a real ~E~ ticket, baby!";
    rtrue;
];
[ call_U2294;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a sign displaying the prices of the various ride tickets~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a sign displaying the prices of the various ride tickets";
    rtrue;
];
[ call_U2295;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a sign display the prices of the various concession items for sale.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a sign display the prices of the various concession items for sale.";
    rtrue;
];
[ call_U2296;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The milk bottle ball toss is a classic carnival game that combines skill, strength, and a bit of luck. The setup features a pyramid of brightly colored milk bottles stacked on a sturdy platform - three on the bottom, two in the middle, and one on top. Players stand behind a marked line and toss baseballs, aiming to knock down as many bottles as possible. Clearing the entire stack wins a prize.^^The booth buzzes with energy, its colorful banners and flashing lights drawing a lively crowd. The satisfying clatter of falling bottles mixes with cheers and groans from players and spectators. A carnival barker calls out, 'Step right up and test your aim! Three balls for just a dime.' Prizes - ranging from small toys to giant stuffed animals - hang prominently, enticing players to take a shot. With every toss, the game delivers moments of suspense, joy, and fun, making it a favorite at the carnival.^^You[']re surprised to see that this game only costs a dime.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The milk bottle ball toss is a classic carnival game that combines skill, strength, and a bit of luck. The setup features a pyramid of brightly colored milk bottles stacked on a sturdy platform - three on the bottom, two in the middle, and one on top. Players stand behind a marked line and toss baseballs, aiming to knock down as many bottles as possible. Clearing the entire stack wins a prize.^^The booth buzzes with energy, its colorful banners and flashing lights drawing a lively crowd. The satisfying clatter of falling bottles mixes with cheers and groans from players and spectators. A carnival barker calls out, ~Step right up and test your aim! Three balls for just a dime.~ Prizes - ranging from small toys to giant stuffed animals - hang prominently, enticing players to take a shot. With every toss, the game delivers moments of suspense, joy, and fun, making it a favorite at the carnival.^^You";
    ParaContent();
    print "'";
    ParaContent();
    print "re surprised to see that this game only costs a dime.";
    rtrue;
];
[ call_U2297;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The Ferris wheel is the towering centerpiece of the carnival, its vibrant lights and graceful rotations drawing the attention of visitors from every corner of the fairgrounds. The wheel[']s massive steel frame arches high into the sky, its intricate network of beams glinting under the colorful glow of bulbs strung along its circumference. Each gondola, painted in bright hues like red, yellow, and blue, dangles from the wheel, swaying gently as it turns.^^At night, the Ferris wheel transforms into a dazzling spectacle, with hundreds of synchronized lights creating patterns and ripples that pulse outward like waves. The bulbs flash in bursts of red, green, and white, casting playful reflections on nearby attractions and the surrounding crowd.^^The air around the wheel is filled with a mix of excited chatter, the hum of its motor, and the occasional squeal of laughter or nervousness from riders high above. The ride operator, standing in a small booth at the base, keeps a steady rhythm of loading and unloading passengers, their voice occasionally calling out, 'Step right up! The best view of the carnival awaits!'^^The Ferris wheel offers an ever-changing perspective of the carnival below. From its peak, riders can see the entire fairground: the spinning lights of the rides, the colorful stripes of game booths, and the winding paths of visitors navigating the midway. Beyond the carnival, the view stretches to the horizon, with city lights adding to the magical experience.^^Whether it[']s a romantic ride for couples, a thrilling adventure for friends, or a calming retreat for families, the Ferris wheel captures the spirit of the carnival - an iconic blend of excitement, wonder, and timeless charm.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The Ferris wheel is the towering centerpiece of the carnival, its vibrant lights and graceful rotations drawing the attention of visitors from every corner of the fairgrounds. The wheel";
    ParaContent();
    print "'";
    ParaContent();
    print "s massive steel frame arches high into the sky, its intricate network of beams glinting under the colorful glow of bulbs strung along its circumference. Each gondola, painted in bright hues like red, yellow, and blue, dangles from the wheel, swaying gently as it turns.^^At night, the Ferris wheel transforms into a dazzling spectacle, with hundreds of synchronized lights creating patterns and ripples that pulse outward like waves. The bulbs flash in bursts of red, green, and white, casting playful reflections on nearby attractions and the surrounding crowd.^^The air around the wheel is filled with a mix of excited chatter, the hum of its motor, and the occasional squeal of laughter or nervousness from riders high above. The ride operator, standing in a small booth at the base, keeps a steady rhythm of loading and unloading passengers, their voice occasionally calling out, ~Step right up! The best view of the carnival awaits!~^^The Ferris wheel offers an ever-changing perspective of the carnival below. From its peak, riders can see the entire fairground: the spinning lights of the rides, the colorful stripes of game booths, and the winding paths of visitors navigating the midway. Beyond the carnival, the view stretches to the horizon, with city lights adding to the magical experience.^^Whether it";
    ParaContent();
    print "'";
    ParaContent();
    print "s a romantic ride for couples, a thrilling adventure for friends, or a calming retreat for families, the Ferris wheel captures the spirit of the carnival - an iconic blend of excitement, wonder, and timeless charm.";
    rtrue;
];
[ call_U2298;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game booth is adorned with vibrant colors - red-and-white striped awnings, twinkling lights, and eye-catching signage that reads 'TOSS A DIME - WIN A PRIZE!'. You can see prizes of all shapes and sizes hang around the booth, from stuffed animals and novelty toys to shiny trinkets and quirky collectibles. The larger prizes are prominently displayed to entice passersby. Rows of gleaming plates sparkle under overhead lights, their glass surfaces reflecting the surrounding glow.^^The distinctive 'ping' of dimes hitting plates creates a rhythmic soundtrack, punctuated by the occasional satisfying 'plop' when a dime lands perfectly. Victorious shouts mix with playful groans of near-misses, creating a symphony of excitement. Nearby, the hum of other booths, upbeat carnival music, and the distant laughter of children add to the lively backdrop. The booth operator calls out enthusiastically, 'Step right up! Test your skill! Win big!' Their energetic pitch draws in curious onlookers.[if a dime underlies the Dime Toss  booth] You thought you caught a flash of something coming from the area of the booth.[end if]^^You[']re surprised to see that this game only costs a dime.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game booth is adorned with vibrant colors - red-and-white striped awnings, twinkling lights, and eye-catching signage that reads ~TOSS A DIME - WIN A PRIZE!~. You can see prizes of all shapes and sizes hang around the booth, from stuffed animals and novelty toys to shiny trinkets and quirky collectibles. The larger prizes are prominently displayed to entice passersby. Rows of gleaming plates sparkle under overhead lights, their glass surfaces reflecting the surrounding glow.^^The distinctive ~ping~ of dimes hitting plates creates a rhythmic soundtrack, punctuated by the occasional satisfying ~plop~ when a dime lands perfectly. Victorious shouts mix with playful groans of near-misses, creating a symphony of excitement. Nearby, the hum of other booths, upbeat carnival music, and the distant laughter of children add to the lively backdrop. The booth operator calls out enthusiastically, ~Step right up! Test your skill! Win big!~ Their energetic pitch draws in curious onlookers.";
    if ((~~(call_U2299()))) {
        jump L_Say0;
    }
    ParaContent();
    print " You thought you caught a flash of something coming from the area of the booth.";
    .L_Say0;
    ParaContent();
    print "^^You";
    ParaContent();
    print "'";
    ParaContent();
    print "re surprised to see that this game only costs a dime.";
    rtrue;
];
[ call_U2299 x x_ix;
    for ((x = K23_dime_First):x:(x = (x.K23_dime_Next))) {
        if ((call_U2412(x) == I_dime_toss_booth_U1)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U2300;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a handy tool that[']s part of the Swiss Army knife.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a handy tool that";
    ParaContent();
    print "'";
    ParaContent();
    print "s part of the Swiss Army knife.";
    rtrue;
];
[ call_U2301;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a handy tool that[']s part of the Swiss Army knife.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a handy tool that";
    ParaContent();
    print "'";
    ParaContent();
    print "s part of the Swiss Army knife.";
    rtrue;
];
[ call_U2302;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a handy tool that[']s part of the Swiss Army knife.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a handy tool that";
    ParaContent();
    print "'";
    ParaContent();
    print "s part of the Swiss Army knife.";
    rtrue;
];
[ call_U2303;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a handy tool that[']s part of the Swiss Army knife.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a handy tool that";
    ParaContent();
    print "'";
    ParaContent();
    print "s part of the Swiss Army knife.";
    rtrue;
];
[ call_U2304;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a handy tool that[']s part of the Swiss Army knife.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a handy tool that";
    ParaContent();
    print "'";
    ParaContent();
    print "s part of the Swiss Army knife.";
    rtrue;
];
[ call_U2305;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is a poster of America[']s sweetheart, Taylor Swift.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is a poster of America";
    ParaContent();
    print "'";
    ParaContent();
    print "s sweetheart, Taylor Swift.";
    rtrue;
];
[ call_U2306;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the bell that will ring out when you prove to everyone that you[']re a 'Muscle Man'.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the bell that will ring out when you prove to everyone that you";
    ParaContent();
    print "'";
    ParaContent();
    print "re a ~Muscle Man~.";
    rtrue;
];
[ call_U2307;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game booth is adorned with vibrant colors - red-and-white striped awnings, twinkling lights, and eye-catching signage. [if a dime underlies the Dime Toss booth] You can see something shiny on the ground under the booth.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game booth is adorned with vibrant colors - red-and-white striped awnings, twinkling lights, and eye-catching signage. ";
    if ((~~(call_U2308()))) {
        jump L_Say0;
    }
    ParaContent();
    print " You can see something shiny on the ground under the booth.";
    .L_Say0;
    rtrue;
];
[ call_U2308 x x_ix;
    for ((x = K23_dime_First):x:(x = (x.K23_dime_Next))) {
        if ((call_U2412(x) == I_dime_toss_booth_U1)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U2309;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You are inside the Little Egypt Show. The attraction[']s facade is to the east. There are folding chairs organized neatly in rows. The show should start soon.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You are inside the Little Egypt Show. The attraction";
    ParaContent();
    print "'";
    ParaContent();
    print "s facade is to the east. There are folding chairs organized neatly in rows. The show should start soon.";
    rtrue;
];
[ call_U2310 ch;
    if (((scene_status-->(1)) == 1)) {
        if ((TableFilledRows(table_data_U16) == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Little Egypt AutoPlay' ends]^";
            }
            if (GProperty(SCENE_TY, 2, A_P_recurring)) {
                ((scene_status-->(1)) = 0);
            } else {
                ((scene_status-->(1)) = 2);
            }
            FollowRulebook(rulebook_id_U451);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 2);
            ((scene_ended-->(1)) = the_time);
            ((scene_endings-->(1)) = (((scene_endings-->(1)))|(2)));
            ((scene_latest_ending-->(1)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(1)) == 0)) {
        if ((((TestSinglePastState(0, ptc_id_U1, 0, 6) == 3)) || ((TestSinglePastState(0, ptc_id_U2, 0, 6) == 2)))) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Little Egypt AutoPlay' begins]^";
            }
            ((scene_status-->(1)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 2);
            FollowRulebook(rulebook_id_U450);
            ((scene_started-->(1)) = the_time);
            ((scene_endings-->(1)) = (((scene_endings-->(1)))|(1)));
            ((scene_latest_ending-->(1)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U2311;
    #ifdef DEBUG;
        if (((scene_status-->(1)) == 1)) {
            print "Scene 'Little Egypt AutoPlay' playing (for ";
            print (the_time - (scene_started-->(1)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(1)) > 0)) {
                print "Scene 'Little Egypt AutoPlay' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U2312;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Ride Entrance in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_ride_entrance_U1));
    rtrue;
];
[ call_U2313;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is a flashlight. It[']s a nice one.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is a flashlight. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a nice one.";
    rtrue;
];
[ call_U2314;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You[']re the safe choice for safety!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "re the safe choice for safety!";
    rtrue;
];
[ call_U2315;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The clock is wildly off the correct time. I guess it[']s broken.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The clock is wildly off the correct time. I guess it";
    ParaContent();
    print "'";
    ParaContent();
    print "s broken.";
    rtrue;
];
[ call_U2316;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s lubricant. It[']s slippery.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s lubricant. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s slippery.";
    rtrue;
];
[ call_U2317;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The manual is titled: 'Fixing Your Ferris Wheel. It[']s Easier Than You Think!'~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The manual is titled: ~Fixing Your Ferris Wheel. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s Easier Than You Think!~";
    rtrue;
];
[ call_U2318;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Who knows how long this has been sitting here. I wouldn[']t drink it if I were you.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Who knows how long this has been sitting here. I wouldn";
    ParaContent();
    print "'";
    ParaContent();
    print "t drink it if I were you.";
    rtrue;
];
[ call_U2319;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a desk. There are coffee stains and cigarette burns from years of abuse. The single drawer is [if the drawer is open]open[otherwise]shut[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a desk. There are coffee stains and cigarette burns from years of abuse. The single drawer is ";
    if ((~~(call_U384(I_drawer_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "shut";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2320;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if switched on]The radio burbles on[otherwise]The radio is off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "The radio burbles on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "The radio is off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ TSD_door_dir_value1 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value1 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_stocks_room_U1;
    }
    return I_maintenance_office_U1;
];
[ call_U2321;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [a printed name of item described]. It has the word 'Stocks' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Stocks~ written on it.";
    rtrue;
];
[ call_U2322 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U27());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U27;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2323;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2324;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Stocks Room in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_stocks_room_U1));
    rtrue;
];
[ TSD_door_dir_value2 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_up_U1;
    }
    return I_down_U1;
];
[ TSD_door_to_value2 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_maintenance_office_U1)) {
        return I_dark_hallway_U1;
    }
    return I_maintenance_office_U1;
];
[ call_U2325;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a typical 10 foot ladder.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a typical 10 foot ladder.";
    rtrue;
];
[ call_U2326 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U28());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U28;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ TSD_door_dir_value3 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_crawl_space_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value3 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_crawl_space_U1)) {
        return I_gallows_room_U1;
    }
    return I_crawl_space_U1;
];
[ call_U2327;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [a printed name of item described]. It has the word 'Gallows' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Gallows~ written on it.";
    rtrue;
];
[ call_U2328 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U29());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U29;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2329;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2330;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Gallows Room in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_gallows_room_U1));
    rtrue;
];
[ call_U2331;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s just an adjustable wrench. Nothing more.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s just an adjustable wrench. Nothing more.";
    rtrue;
];
[ TSD_door_dir_value4 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_north_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value4 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_north_U1)) {
        return I_stake_room_U1;
    }
    return I_mechanical_room_north_U1;
];
[ call_U2332;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [an printed name of item described]. It has the word 'Stake' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Stake~ written on it.";
    rtrue;
];
[ call_U2333 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U30());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U30;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2334;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2335;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Stake Room in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_stake_room_U1));
    rtrue;
];
[ call_U2336;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This grate leads down into the darkness. Too bad it[']s locked.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This grate leads down into the darkness. Too bad it";
    ParaContent();
    print "'";
    ParaContent();
    print "s locked.";
    rtrue;
];
[ call_U2337 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U31());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U31;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ TSD_door_dir_value5 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_south_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value5 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_mechanical_room_south_U1)) {
        return I_dungeon_U1;
    }
    return I_mechanical_room_south_U1;
];
[ call_U2338;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [a printed name of item described]. It has the word 'Dungeon' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Dungeon~ written on it.";
    rtrue;
];
[ call_U2339 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U32());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U32;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2340;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2341;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Dungeon in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_dungeon_U1));
    rtrue;
];
[ TSD_door_dir_value6 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_generator_room_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value6 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_generator_room_U1)) {
        return I_guillotine_room_U1;
    }
    return I_generator_room_U1;
];
[ call_U2342;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [an printed name of item described]. It has the word 'Guillotine' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Guillotine~ written on it.";
    rtrue;
];
[ call_U2343 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U33());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U33;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2344;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2345;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Guillotine Room in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_guillotine_room_U1));
    rtrue;
];
[ TSD_door_dir_value7 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_storage_room_U1)) {
        return I_west_U1;
    }
    return I_east_U1;
];
[ TSD_door_to_value7 loc;
    (loc = location);
    if ((loc == thedark)) {
        (loc = real_location);
    }
    if ((loc == I_storage_room_U1)) {
        return I_ride_exit_U1;
    }
    return I_storage_room_U1;
];
[ call_U2346;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s [a printed name of item described]. It has the word 'Ride Exit' written on it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". It has the word ~Ride Exit~ written on it.";
    rtrue;
];
[ call_U2347 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U34());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U34;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2348;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2349;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[description corresponding to the locale of Ride Exit in the Table of Hell Ride Events]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(TableLookUpCorr(table_data_U17, table_column_id_U10, table_column_id_U31, I_ride_exit_U1));
    rtrue;
];
[ call_U2350 ch;
    if (((scene_status-->(2)) == 1)) {
        if ((TableFilledRows(table_data_U17) == 1)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Hell Ride AutoPlay' ends]^";
            }
            if (GProperty(SCENE_TY, 3, A_P_recurring)) {
                ((scene_status-->(2)) = 0);
            } else {
                ((scene_status-->(2)) = 2);
            }
            FollowRulebook(rulebook_id_U453);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 3);
            ((scene_ended-->(2)) = the_time);
            ((scene_endings-->(2)) = (((scene_endings-->(2)))|(2)));
            ((scene_latest_ending-->(2)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(2)) == 0)) {
        if ((TestSinglePastState(0, ptc_id_U3, 0, 2) == 2)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Hell Ride AutoPlay' begins]^";
            }
            ((scene_status-->(2)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 3);
            FollowRulebook(rulebook_id_U452);
            ((scene_started-->(2)) = the_time);
            ((scene_endings-->(2)) = (((scene_endings-->(2)))|(1)));
            ((scene_latest_ending-->(2)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U2351;
    #ifdef DEBUG;
        if (((scene_status-->(2)) == 1)) {
            print "Scene 'Hell Ride AutoPlay' playing (for ";
            print (the_time - (scene_started-->(2)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(2)) > 0)) {
                print "Scene 'Hell Ride AutoPlay' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U2352;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The backstage control room is a plain, functional hub where the carnival's rides, lights, and attractions are managed. Gray industrial walls, scuffed and greasy, surround a large monitor streaming live carnival feeds. Beneath them, control panels with labeled dials, colored buttons, and lights oversee the systems scattered about the room. Glancing at the control panels, you can see they are [if the switch count is 6]lit up like a Christmas tree[otherwise]dark[end if].^^The hum of electronics fills the air, punctuated by the crackle of a radio: 'Maintenance to Bumper Cars - wrench needed!' The worn floor is scattered with papers, tools, and coffee cups. A cluttered desk holds logs and schedules, while a cork board above displays charts and red-marked notes like 'Check Zipper circuit breakers.'^^A flickering light casts cold shadows as the metallic tang of machinery mixes with dampness. Functional yet essential, this hidden space ensures the carnival's magic runs seamlessly. On one wall is a large switch[if the big switch is switched on] with sparks arcing out from it[end if].^^A dark hallway lies to the east.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The backstage control room is a plain, functional hub where the carnival's rides, lights, and attractions are managed. Gray industrial walls, scuffed and greasy, surround a large monitor streaming live carnival feeds. Beneath them, control panels with labeled dials, colored buttons, and lights oversee the systems scattered about the room. Glancing at the control panels, you can see they are ";
    if ((~~(((Global_Vars-->64) == 6)))) {
        jump L_Say0;
    }
    ParaContent();
    print "lit up like a Christmas tree";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "dark";
    .L_SayX0;
    ParaContent();
    print ".^^The hum of electronics fills the air, punctuated by the crackle of a radio: ~Maintenance to Bumper Cars - wrench needed!~ The worn floor is scattered with papers, tools, and coffee cups. A cluttered desk holds logs and schedules, while a cork board above displays charts and red-marked notes like ~Check Zipper circuit breakers.~^^A flickering light casts cold shadows as the metallic tang of machinery mixes with dampness. Functional yet essential, this hidden space ensures the carnival's magic runs seamlessly. On one wall is a large switch";
    if ((~~(call_U414(I_big_switch_U1)))) {
        jump L_Say2;
    }
    ParaContent();
    print " with sparks arcing out from it";
    .L_Say2;
    ParaContent();
    print ".^^A dark hallway lies to the east.";
    rtrue;
];
[ call_U2353;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is a large switch. It[']s the kind Dr. Frankenstein might push to route the lightning to his creature.[if the big switch is switched on] Currently there are sparks arcing out from the switch. It looks dangerous.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is a large switch. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s the kind Dr. Frankenstein might push to route the lightning to his creature.";
    if ((~~(call_U414(I_big_switch_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print " Currently there are sparks arcing out from the switch. It looks dangerous.";
    .L_Say0;
    rtrue;
];
[ call_U2354 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 == I_monitor_U1)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "figure id: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_figure_id));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ RFI_for_I1;
    if (TestRegionalContainment(location, I_midway_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I2;
    if (TestRegionalContainment(location, I_hellride_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I3;
    if (TestRegionalContainment(location, I_electrical_area_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I4;
    if (TestRegionalContainment(location, I_back_stage_U1)) {
        rtrue;
    }
    rfalse;
];
[ RFI_for_I5;
    if (TestRegionalContainment(location, I_second_floor_U1)) {
        rtrue;
    }
    rfalse;
];
[ call_U2355 forbid_breaks rv;
    (rv = (call_U2537)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2537;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2356 forbid_breaks rv;
    (rv = (call_U2538)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2538;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2357 forbid_breaks rv;
    (rv = (call_U2539)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2539;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_pouring_it_intoSub;
    return GenericVerbSub(rulebook_id_U390, rulebook_id_U391, rulebook_id_U392);
];
[ A_pouring_it_intoDbg n s for_say;
    print "pouring";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "into";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U2358 forbid_breaks rv;
    (rv = (call_U2544)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2544;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2359 forbid_breaks rv;
    (rv = (call_U2545)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2545;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2360 forbid_breaks rv;
    (rv = (call_U2546)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2546;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hiding_it_underSub;
    return GenericVerbSub(rulebook_id_U393, rulebook_id_U394, rulebook_id_U395);
];
[ A_hiding_it_underDbg n s for_say;
    print "hiding";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "under";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U2361 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U2564)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2564;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2565)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2565;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U2562)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2562;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2362 forbid_breaks rv;
    (rv = (call_U2563)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2563;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hi_speakingSub;
    return GenericVerbSub(rulebook_id_U396, rulebook_id_U397, rulebook_id_U398);
];
[ A_hi_speakingDbg n s for_say;
    print "hi-speaking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2365 forbid_breaks rv;
    (rv = (call_U2566)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2566;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_casting_xyzzySub;
    return GenericVerbSub(rulebook_id_U399, rulebook_id_U400, rulebook_id_U401);
];
[ A_casting_xyzzyDbg n s for_say;
    print "casting xyzzy";
];
[ call_U2368 forbid_breaks rv;
    (rv = (call_U2567)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2567;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_casting_plughSub;
    return GenericVerbSub(rulebook_id_U402, rulebook_id_U403, rulebook_id_U404);
];
[ A_casting_plughDbg n s for_say;
    print "casting plugh";
];
[ A_talking_randomly_abouSub;
    return GenericVerbSub(rulebook_id_U405, rulebook_id_U406, rulebook_id_U407);
];
[ A_talking_randomly_abouDbg n s for_say;
    print "talking randomly about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ A_talking_aboutSub;
    return GenericVerbSub(rulebook_id_U408, rulebook_id_U409, rulebook_id_U410);
];
[ A_talking_aboutDbg n s for_say;
    print "talking about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2376 forbid_breaks rv;
    (rv = (call_U2583)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2583;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2377 forbid_breaks rv;
    (rv = (call_U2584)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2584;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_requesting_the_compleSub;
    return GenericVerbSub(rulebook_id_U411, rulebook_id_U412, rulebook_id_U413);
];
[ A_requesting_the_compleDbg n s for_say;
    print "requesting the complete score";
];
[ call_U2379 forbid_breaks rv;
    (rv = (call_U2586)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2586;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ MildSub;
    return GenericVerbSub(rulebook_id_U414, rulebook_id_U415, rulebook_id_U416);
];
[ MildDbg n s for_say;
    print "swearing mildly";
];
[ A_fuckingSub;
    return GenericVerbSub(rulebook_id_U417, rulebook_id_U418, rulebook_id_U419);
];
[ A_fuckingDbg n s for_say;
    print "fucking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2385 forbid_breaks rv;
    (rv = (call_U2588)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2588;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ StrongSub;
    return GenericVerbSub(rulebook_id_U420, rulebook_id_U421, rulebook_id_U422);
];
[ StrongDbg n s for_say;
    print "swearing obscenely";
];
[ A_togglingSub;
    return GenericVerbSub(rulebook_id_U423, rulebook_id_U424, rulebook_id_U425);
];
[ A_togglingDbg n s for_say;
    print "toggling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ A_flippingSub;
    return GenericVerbSub(rulebook_id_U426, rulebook_id_U427, rulebook_id_U428);
];
[ A_flippingDbg n s for_say;
    print "flipping";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ A_readingSub;
    return GenericVerbSub(rulebook_id_U429, rulebook_id_U430, rulebook_id_U431);
];
[ A_readingDbg n s for_say;
    print "reading";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2397 forbid_breaks rv;
    (rv = (call_U2640)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2640;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2398 forbid_breaks rv;
    (rv = (call_U2641)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2641;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_hittingSub;
    return GenericVerbSub(rulebook_id_U432, rulebook_id_U433, rulebook_id_U434);
];
[ A_hittingDbg n s for_say;
    print "hitting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2400 forbid_breaks rv;
    (rv = (call_U2647)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2647;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_tossingSub;
    return GenericVerbSub(rulebook_id_U435, rulebook_id_U436, rulebook_id_U437);
];
[ A_tossingDbg n s for_say;
    print "tossing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ A_throwingSub;
    return GenericVerbSub(rulebook_id_U438, rulebook_id_U439, rulebook_id_U440);
];
[ A_throwingDbg n s for_say;
    print "throwing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U2406 forbid_breaks rv;
    (rv = (call_U2742)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2742;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2408 forbid_breaks rv;
    (rv = (call_U2743)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2743;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_spinning_it_toSub;
    return GenericVerbSub(rulebook_id_U441, rulebook_id_U442, rulebook_id_U443);
];
[ A_spinning_it_toDbg n s for_say;
    print "spinning";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Number)(parsed_number);
    }
];
[ call_U2411 forbid_breaks rv;
    (rv = (call_U2747)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2747;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ A_creditingSub;
    return GenericVerbSub(rulebook_id_U444, rulebook_id_U445, rulebook_id_U446);
];
[ A_creditingDbg n s for_say;
    print "crediting";
];
[ call_U2412 X;
    if ((X ofclass K2_thing)) {
        return (X.P_underlying_relation_storag);
    }
    rfalse;
];
[ call_U2413 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        ((L.P_underlying_relation_storag) = R);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record4);
];
[ call_U2414 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(L, A_P_underlying_relation_storag, R);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record4);
];
[ call_U2415 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((Y == call_U2412(X))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2415)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2415)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2415)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2415)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2415)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2415)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U2413(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U2414(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_ShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (VtoORelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((VtoORelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U2416 X;
    if ((X ofclass K2_thing)) {
        return (X.P_tossing_relation_storage);
    }
    rfalse;
];
[ call_U2417 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowS1to1(R, A_P_tossing_relation_storage, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record5);
];
[ call_U2418 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowSN1to1(R, A_P_tossing_relation_storage, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record5);
];
[ call_U2419 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U2416(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2419)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2419)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2419)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2419)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2419)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2419)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U2417(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U2418(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_ShowOtoO)(rr,1);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,1,(X == 1));
            ;
    }
    rfalse;
];
[ call_U2420 t_0 t_1;
    if ((~~((t_0 ofclass K1_room)))) {
        rfalse;
    }
    if ((~~((t_1 ofclass K1_room)))) {
        rfalse;
    }
    return (MapRouteTo(t_1, t_0, 0, 0, 1) < 2);
];
[ call_U2421 L R;
    if ((((L ofclass K1_room)) && ((((R ofclass K1_room)) && (call_U2420(L, R)))))) {
        rtrue;
    }
    rfalse;
];
[ call_U2422 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (call_U2421(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    if ((call_U2422)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    if ((call_U2422)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                if ((call_U2422)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                if ((call_U2422)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    for ((Z3 = K1_room_First):Z3:(Z3 = (Z3.K1_room_Next))) {
                        if ((call_U2422)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                        for ((Z3 = K1_room_First):Z3:(Z3 = (Z3.K1_room_Next))) {
                            if ((call_U2422)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2423 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == Y)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record7);
            ;
    }
    rfalse;
];
[ call_U2424 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((BlkValueCompare((X)(CV_MEANING), Y) == 0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record8);
            ;
    }
    rfalse;
];
[ call_U2425 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == OwnerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2426 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((RlnGetF(X, RR_HANDLER))(X,RELS_TEST,Y,0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record10);
            ;
    }
    rfalse;
];
[ call_U2427 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record11);
            ;
    }
    rfalse;
];
[ call_U2428 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == ContainerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2428)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2428)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2428)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2428)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U2428)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U2428)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2429 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == SupporterOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                    if ((call_U2429)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2429)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                if ((call_U2429)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2429)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2429)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K6_supporter_First):Z1:(Z1 = (Z1.K6_supporter_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2429)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2430 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == PartOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2430)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2430)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2430)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2430)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2430)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2430)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MakePart(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2431 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (IndirectlyContains(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2431)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U2431)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2431)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U2431)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U2431)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U2431)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2432 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == CarrierOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2432)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2432)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2432)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2432)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2432)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2432)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2433 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == HolderOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2433)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2433)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2433)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2433)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2433)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2433)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2434 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == WearerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U2434)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2434)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U2434)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2434)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2434)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2434)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            WearObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U2435 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestVisibility(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2435)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2435)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2435)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2435)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2435)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2435)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2436 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestTouchability(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2436)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2436)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2436)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2436)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2436)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2436)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2437 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestConcealment(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2437)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U2437)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2437)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U2437)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U2437)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U2437)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2438 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U2440 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U2701)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2701;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2554)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2554;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2550)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2550;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U2547)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2547;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2443 forbid_breaks rv;
    (rv = (call_U2674)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2674;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U2445 forbid_breaks rv;
    (rv = (call_U2705)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U2705;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ E6 value which;
    if ((value == 0)) {
        call_U2750(value);
        rtrue;
    }
    if ((NUMBER_TY_Abs(value) >= 1)) {
        call_U2750(value);
        rtrue;
    }
    call_U2750(value);
    rtrue;
    rtrue;
];
[ call_U2446 sk;
    rfalse;
];
[ call_U2447 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(MAX_POSITIVE_NUMBER);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2448 sk;
    rfalse;
];
[ E9 value which;
    if ((value == 0)) {
        call_U2752(value);
        rtrue;
    }
    if ((NUMBER_TY_Abs(value) >= 1)) {
        call_U2752(value);
        rtrue;
    }
    call_U2752(value);
    rtrue;
    rtrue;
];
[ call_U2449 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(MAX_POSITIVE_NUMBER);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2450 sk;
    rfalse;
];
[ call_U2451 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K18_fluid_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "fluid capacity: ";
                (E9)(GProperty(OBJECT_TY, t_0, A_P_fluid_capacity));
                print "^";
                print "current volume: ";
                (E9)(GProperty(OBJECT_TY, t_0, A_P_current_volume));
                print "^";
                print "liquid: ";
                (E10)(GProperty(OBJECT_TY, t_0, A_P_liquid));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ E10 value;
    switch (value) {
        I_water_U1:
            print "water";
            ;
        I_cola_U1:
            print "Cola";
            ;
        I_milk_U1:
            print "milk";
            ;
        I_lemonade_U1:
            print "lemonade";
            ;
        I_iced_tea_U1:
            print "iced tea";
            ;
        default:
            print "<illegal liquid>";
            ;
    }
];
[ call_U2452 sk;
    return I_water_U1;
];
[ call_U2453 x;
    return ((x%5) + 1);
];
[ call_U2454 x;
    return (((x + 3)%5) + 1);
];
[ call_U2455 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2456 original_wn group_wn v w rv;
    (original_wn = wn);
    if ((NextWordStopped() ~= 'iced')) {
        jump Failed_1;
    }
    if ((NextWordStopped() ~= 'tea')) {
        jump Failed_1;
    }
    (parsed_number = I_iced_tea_U1);
    return GPR_NUMBER;
    .Failed_1;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'water')) {
        jump Failed_2;
    }
    (parsed_number = I_water_U1);
    return GPR_NUMBER;
    .Failed_2;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'cola')) {
        jump Failed_3;
    }
    (parsed_number = I_cola_U1);
    return GPR_NUMBER;
    .Failed_3;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'milk')) {
        jump Failed_4;
    }
    (parsed_number = I_milk_U1);
    return GPR_NUMBER;
    .Failed_4;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'lemonade')) {
        jump Failed_5;
    }
    (parsed_number = I_lemonade_U1);
    return GPR_NUMBER;
    .Failed_5;
    (wn = original_wn);
    return GPR_FAIL;
];
[ call_U2457 instance original_wn group_wn v w rv;
    (original_wn = wn);
    if ((instance == I_iced_tea_U1)) {
        if ((NextWordStopped() ~= 'iced')) {
            jump Failed_1;
        }
        if ((NextWordStopped() ~= 'tea')) {
            jump Failed_1;
        }
        (parsed_number = I_iced_tea_U1);
        return GPR_NUMBER;
        .Failed_1;
        return GPR_FAIL;
    }
    if ((instance == I_water_U1)) {
        if ((NextWordStopped() ~= 'water')) {
            jump Failed_2;
        }
        (parsed_number = I_water_U1);
        return GPR_NUMBER;
        .Failed_2;
        return GPR_FAIL;
    }
    if ((instance == I_cola_U1)) {
        if ((NextWordStopped() ~= 'cola')) {
            jump Failed_3;
        }
        (parsed_number = I_cola_U1);
        return GPR_NUMBER;
        .Failed_3;
        return GPR_FAIL;
    }
    if ((instance == I_milk_U1)) {
        if ((NextWordStopped() ~= 'milk')) {
            jump Failed_4;
        }
        (parsed_number = I_milk_U1);
        return GPR_NUMBER;
        .Failed_4;
        return GPR_FAIL;
    }
    if ((instance == I_lemonade_U1)) {
        if ((NextWordStopped() ~= 'lemonade')) {
            jump Failed_5;
        }
        (parsed_number = I_lemonade_U1);
        return GPR_NUMBER;
        .Failed_5;
        return GPR_FAIL;
    }
    return GPR_FAIL;
];
[ call_U2458 sk;
    rfalse;
];
[ call_U2459 sk;
    rfalse;
];
[ call_U2460 sk;
    rfalse;
];
[ call_U2461 sk;
    rfalse;
];
[ call_U2462 sk;
    rfalse;
];
[ call_U2463;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Ten cents. One tenth of a dollar. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Ten cents. One tenth of a dollar. And very shiny.";
    rtrue;
];
[ call_U2464 sk;
    rfalse;
];
[ call_U2465;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a quarter. Two bits. And very shiny.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a quarter. Two bits. And very shiny.";
    rtrue;
];
[ call_U2466 sk;
    return I_nondescript_U1;
];
[ E11 value;
    switch (value) {
        I_nondescript_U1:
            print "nondescript";
            ;
        I_aqua_U1:
            print "aqua";
            ;
        I_crimson_U1:
            print "crimson";
            ;
        I_emerald_U1:
            print "emerald";
            ;
        I_gray_U1:
            print "gray";
            ;
        I_indigo_U1:
            print "indigo";
            ;
        I_khaki_U1:
            print "khaki";
            ;
        I_magenta_U1:
            print "magenta";
            ;
        I_orange_U1:
            print "orange";
            ;
        I_quartz_U1:
            print "quartz";
            ;
        default:
            print "<illegal color>";
            ;
    }
];
[ call_U2467 x;
    return ((x%10) + 1);
];
[ call_U2468 x;
    return (((x + 8)%10) + 1);
];
[ call_U2469 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(10);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2470 original_wn group_wn v w rv;
    (original_wn = wn);
    if ((NextWordStopped() ~= 'grey')) {
        jump Fail_1;
    }
    (parsed_number = I_gray_U1);
    return GPR_NUMBER;
    .Fail_1;
    (wn = original_wn);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'nondescript')) {
        jump Failed_1;
    }
    (parsed_number = I_nondescript_U1);
    return GPR_NUMBER;
    .Failed_1;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'aqua')) {
        jump Failed_2;
    }
    (parsed_number = I_aqua_U1);
    return GPR_NUMBER;
    .Failed_2;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'crimson')) {
        jump Failed_3;
    }
    (parsed_number = I_crimson_U1);
    return GPR_NUMBER;
    .Failed_3;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'emerald')) {
        jump Failed_4;
    }
    (parsed_number = I_emerald_U1);
    return GPR_NUMBER;
    .Failed_4;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'gray')) {
        jump Failed_5;
    }
    (parsed_number = I_gray_U1);
    return GPR_NUMBER;
    .Failed_5;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'indigo')) {
        jump Failed_6;
    }
    (parsed_number = I_indigo_U1);
    return GPR_NUMBER;
    .Failed_6;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'khaki')) {
        jump Failed_7;
    }
    (parsed_number = I_khaki_U1);
    return GPR_NUMBER;
    .Failed_7;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'magenta')) {
        jump Failed_8;
    }
    (parsed_number = I_magenta_U1);
    return GPR_NUMBER;
    .Failed_8;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'orange')) {
        jump Failed_9;
    }
    (parsed_number = I_orange_U1);
    return GPR_NUMBER;
    .Failed_9;
    (wn = original_wn);
    if ((NextWordStopped() ~= 'quartz')) {
        jump Failed_10;
    }
    (parsed_number = I_quartz_U1);
    return GPR_NUMBER;
    .Failed_10;
    (wn = original_wn);
    return GPR_FAIL;
];
[ call_U2471 instance original_wn group_wn v w rv;
    (original_wn = wn);
    if ((instance == I_gray_U1)) {
        if ((NextWordStopped() ~= 'grey')) {
            jump Fail_1;
        }
        (parsed_number = I_gray_U1);
        return GPR_NUMBER;
        .Fail_1;
        (wn = original_wn);
    }
    (wn = original_wn);
    if ((instance == I_nondescript_U1)) {
        if ((NextWordStopped() ~= 'nondescript')) {
            jump Failed_1;
        }
        (parsed_number = I_nondescript_U1);
        return GPR_NUMBER;
        .Failed_1;
        return GPR_FAIL;
    }
    if ((instance == I_aqua_U1)) {
        if ((NextWordStopped() ~= 'aqua')) {
            jump Failed_2;
        }
        (parsed_number = I_aqua_U1);
        return GPR_NUMBER;
        .Failed_2;
        return GPR_FAIL;
    }
    if ((instance == I_crimson_U1)) {
        if ((NextWordStopped() ~= 'crimson')) {
            jump Failed_3;
        }
        (parsed_number = I_crimson_U1);
        return GPR_NUMBER;
        .Failed_3;
        return GPR_FAIL;
    }
    if ((instance == I_emerald_U1)) {
        if ((NextWordStopped() ~= 'emerald')) {
            jump Failed_4;
        }
        (parsed_number = I_emerald_U1);
        return GPR_NUMBER;
        .Failed_4;
        return GPR_FAIL;
    }
    if ((instance == I_gray_U1)) {
        if ((NextWordStopped() ~= 'gray')) {
            jump Failed_5;
        }
        (parsed_number = I_gray_U1);
        return GPR_NUMBER;
        .Failed_5;
        return GPR_FAIL;
    }
    if ((instance == I_indigo_U1)) {
        if ((NextWordStopped() ~= 'indigo')) {
            jump Failed_6;
        }
        (parsed_number = I_indigo_U1);
        return GPR_NUMBER;
        .Failed_6;
        return GPR_FAIL;
    }
    if ((instance == I_khaki_U1)) {
        if ((NextWordStopped() ~= 'khaki')) {
            jump Failed_7;
        }
        (parsed_number = I_khaki_U1);
        return GPR_NUMBER;
        .Failed_7;
        return GPR_FAIL;
    }
    if ((instance == I_magenta_U1)) {
        if ((NextWordStopped() ~= 'magenta')) {
            jump Failed_8;
        }
        (parsed_number = I_magenta_U1);
        return GPR_NUMBER;
        .Failed_8;
        return GPR_FAIL;
    }
    if ((instance == I_orange_U1)) {
        if ((NextWordStopped() ~= 'orange')) {
            jump Failed_9;
        }
        (parsed_number = I_orange_U1);
        return GPR_NUMBER;
        .Failed_9;
        return GPR_FAIL;
    }
    if ((instance == I_quartz_U1)) {
        if ((NextWordStopped() ~= 'quartz')) {
            jump Failed_10;
        }
        (parsed_number = I_quartz_U1);
        return GPR_NUMBER;
        .Failed_10;
        return GPR_FAIL;
    }
    return GPR_FAIL;
];
[ call_U2472 sk;
    rfalse;
];
[ call_U2473 sk;
    rfalse;
];
[ call_U2474 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K26_electrical_panel)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "panel id: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_panel_id));
                print "^";
                print "color: ";
                (E11)(GProperty(OBJECT_TY, t_0, A_P_color));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2475;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U2476;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Electrical Panel [the panel id] is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is [if the item described is open]open. Inside the panel you see a switch, a socket, and an indicator light.[otherwise]closed.[end if] [if the item described is locked]There are screws holding it shut.[otherwise]The screws for the door are gone.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is a standard issue 200 amp electrical panel supplying 220 power throughout the ride. The electrical panel is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open. Inside the panel you see a switch, a socket, and an indicator light.";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed.";
    .L_SayX0;
    ParaContent();
    print " ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "There are screws holding it shut.";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "The screws for the door are gone.";
    .L_SayX1;
    rtrue;
];
[ call_U2477 sk;
    rfalse;
];
[ call_U2478;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~socket [Panel id of the holder of the item described]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    rtrue;
];
[ call_U2479;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Socket [the panel id of the holder of the the item described] is part of electrical panel [the panel id of the holder of the item described]. [if unfilled]A fuse probably goes in here.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Socket ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print " is part of electrical panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". ";
    if ((~~((~~(call_U2171(self)))))) {
        jump L_Say0;
    }
    ParaContent();
    print "A fuse probably goes in here.";
    .L_Say0;
    rtrue;
];
[ call_U2480 sk;
    rfalse;
];
[ call_U2481;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[Color of the holder of the item described] indicator~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " indicator";
    rtrue;
];
[ call_U2482 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U35());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U35;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The indicator [if the Corresponding switch of the noun is switched on]is glowing [color of the holder of the item described] and [end if]is currently [if the Corresponding switch of the noun is switched on]indicating something[otherwise]indicating nothing[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The indicator ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "is glowing ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " and ";
    .L_Say0;
    ParaContent();
    print "is currently ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = noun) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say1;
    }
    ParaContent();
    print "indicating something";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "indicating nothing";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2483 sk;
    rfalse;
];
[ call_U2484 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K29_fuse)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "fuse id: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_fuse_id));
                print "^";
                print "color: ";
                (E11)(GProperty(OBJECT_TY, t_0, A_P_color));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2485;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored fuse~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored fuse";
    rtrue;
];
[ call_U2486;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is [color of the item described] colored electrical fuse.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored electrical fuse.";
    rtrue;
];
[ call_U2487 sk;
    rfalse;
];
[ call_U2488 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U36());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U36;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Switch [switch id of the item described] is part of Electrical Panel [the panel id of the holder of the item described]. It[']s a big switch. You could probably turn it [if the item described is switched off]on[otherwise]off[end if] if you wanted to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Switch ";
    ParaContent();
    print (say__n = (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K30_switch)) && ((formal_par0 ofclass K30_switch)))) && ((((formal_rv = call_U2843(formal_par0)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    ParaContent();
    print " is part of Electrical Panel ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_panel_id));
    @pull self;
    ParaContent();
    print ". It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a big switch. You could probably turn it ";
    if ((~~(call_U417(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print " if you wanted to.";
    rtrue;
];
[ call_U2489 sk;
    rfalse;
];
[ call_U2490 sk;
    return I_weakling_U1;
];
[ E12 value;
    switch (value) {
        I_weakling_U1:
            print "Weakling";
            ;
        I_getting_stronger_U1:
            print "Getting Stronger";
            ;
        I_average_U1:
            print "Average";
            ;
        I_almost_there_U1:
            print "Almost There";
            ;
        I_muscle_man_U1:
            print "Muscle Man";
            ;
        default:
            print "<illegal strength pattern>";
            ;
    }
];
[ call_U2491 x;
    return ((x%5) + 1);
];
[ call_U2492 x;
    return (((x + 3)%5) + 1);
];
[ call_U2493 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2494 sk;
    rfalse;
];
[ call_U2495 sk;
    rfalse;
];
[ call_U2496 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K33_wooden_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "color: ";
                (E11)(GProperty(OBJECT_TY, t_0, A_P_color));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2497;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[color of the item described] colored door~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " colored door";
    rtrue;
];
[ call_U2498;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The [color of the item described] door is [if the item described is open]open[otherwise]closed[end if]. It is [if the item described is locked]locked[otherwise]unlocked[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = self), A_P_color));
    @pull self;
    ParaContent();
    print " door is ";
    if ((~~(call_U384(self)))) {
        jump L_Say0;
    }
    ParaContent();
    print "open";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "closed";
    .L_SayX0;
    ParaContent();
    print ". It is ";
    if ((~~(call_U399(self)))) {
        jump L_Say2;
    }
    ParaContent();
    print "locked";
    jump L_SayX1;
    .L_Say2;
    ParaContent();
    print "unlocked";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2499 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U37());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U37;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nearby [an item described] leads [if the other side of the item described is visited][direction of the item described from the location] to [the other side of the item described][otherwise][direction of the item described from the location][end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nearby ";
    ParaContent();
    IndefArt(self);
    ParaContent();
    print " leads ";
    if ((~~(call_U321((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    ParaContent();
    print " to ";
    ParaContent();
    DefArt((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, location)))|(1))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = self)))
    )
    );
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    PrintShortName((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = DirectionDoorLeadsIn(formal_par0, formal_par1)))|(1))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = real_location) + (formal_par0 = self))))
    )
    );
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2500 sk;
    rfalse;
];
[ call_U2501 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K34_control_panel)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "panel id: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_panel_id));
                print "^";
                print "color: ";
                (E11)(GProperty(OBJECT_TY, t_0, A_P_color));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2502 sk;
    rfalse;
];
[ call_U2503;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] button~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " button";
    rtrue;
];
[ call_U2504;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a color of the holder of the item described] colored button.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored button.";
    rtrue;
];
[ call_U2505 sk;
    rfalse;
];
[ call_U2506 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K36_dial)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "dial setting: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_P_dial_setting));
                print "^";
            }
        } else {
        }
        return na;
    #endif;
];
[ call_U2507;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [color of the holder of the item described] dial~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " dial";
    rtrue;
];
[ call_U2508;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [color of the holder of the item described] colored dial. It is currently set to [dial setting of the item described]. I bet you could SPIN it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored dial. It is currently set to ";
    ParaContent();
    @push self;
    print (say__n = GProperty(OBJECT_TY, (self = self), A_P_dial_setting));
    @pull self;
    ParaContent();
    print ". I bet you could SPIN it.";
    rtrue;
];
[ call_U2509 sk;
    rfalse;
];
[ call_U2510;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~the [a color of the holder of the item described] colored light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "the ";
    ParaContent();
    @push self;
    E11(GProperty(OBJECT_TY, (self = HolderOf(self)), A_P_color));
    @pull self;
    ParaContent();
    print " colored light";
    rtrue;
];
[ call_U2511 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U38());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U38;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This is the [a printed name of the item described]. The light is [if the corresponding button of the item described is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This is the ";
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(OBJECT_TY, (self = self), A_short_name));
    @pull self;
    ParaContent();
    print ". The light is ";
    if ((~~(call_U414((
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
            ))
        +
            ! This evaluate first
            (((formal_par1 = self) + (formal_par0 = 0))))
    )
    )))) {
        jump L_Say0;
    }
    ParaContent();
    print "on";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "off";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U2512 sk;
    return I_allowed_U1;
];
[ E13 value;
    switch (value) {
        I_allowed_U1:
            print "allowed";
            ;
        I_denied_U1:
            print "denied";
            ;
        default:
            print "<illegal permission>";
            ;
    }
];
[ call_U2513 x;
    return ((x%2) + 1);
];
[ call_U2514 x;
    return ((x%2) + 1);
];
[ call_U2515 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(2);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U2516;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == player)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2516, 884, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Oh, stop fussing. You look fine.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2516, 884, 2);
        }
    }
    rfalse;
];
[ call_U2517;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_coupon_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2517, 885, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_coupon_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2517, 885, 2);
        }
    }
    rfalse;
];
[ call_U2518;
    if (debug_rules) {
        DB_Rule(call_U2518, 886, 0);
    }
    if ((matched_text = SnippetIncludes(Consult_Grammar9, players_command))) {
        (say__p = 1);
        ParaContent();
        print "Please do not say ~please.~";
        print "^";
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ call_U2519;
    if (debug_rules) {
        DB_Rule(call_U2519, 887, 0);
    }
    if (SnippetMatches(players_command, Consult_Grammar10)) {
        TryAction(0, player, ##Restore, 0, 0);
        rtrue;
    }
    rfalse;
];
[ call_U2520;
    if (debug_rules) {
        DB_Rule(call_U2520, 888, 0);
    }
    if (((call_U414(I_control_panel_nine_s_butto_U1)) && (call_U2856(I_control_panel_nine_s_dial_U1)))) {
        (say__p = 1);
        ParaContent();
        print "As you push the indigo button, the monitor switches to a view of the guillotine room. You can still see the blade rising and falling over the cars. Suddenly, you see the blade slowing down, taking longer and longer to fall. Until it finally comes to a complete rest.^^The room is heavy with uneasy silence. The Hell Ride, once a thrilling spectacle, now looms motionless, as the guillotine blade is frozen halfway down its track. Moments ago, chaos erupted as the malfunctioning mechanism sent the blade crashing unpredictably, ripping through the roofs of cars on the track.^^A single car, its roof gashed open, sits under the still blade - a grim reminder of the disaster narrowly averted. Above, a black crow lands on the guillotine's frame, its sharp caw cutting through the murmurs of anger and fear.^^Two mechanics climb the scaffolding with tools in hand, their appearance met with wary hope. The crowd watches, holding their breath, as the cursed ride's fate hangs in the balance.^^As you exit the ride, the carnival owner and the mayor are present and extending their undying gratitude for saving the day, not to mention lives!";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        (say__p = 1);
        ParaContent();
        print "*** You have won! ***";
        (say__p = 1);
        ParaContent();
        DivideParagraphPoint();
        print "^";
        RulebookSucceeds();
        rtrue;
    } else {
        if (((Global_Vars-->58) == 1)) {
            (say__p = 1);
            ParaContent();
            print "^";
            ParaContent();
            print "*** You start the long walk home. ***";
            ParaContent();
            print "^";
        } else {
            if (((Global_Vars-->69) == 1)) {
                (say__p = 1);
                ParaContent();
                print "The sparks arc onto your unprotected hands electrocuting you on the spot.";
                print "^";
                (say__p = 1);
                ParaContent();
                print "^";
                ParaContent();
                print "*** You have died! ***";
                ParaContent();
                print "^";
            } else {
                if (call_U318(real_location)) {
                    (say__p = 1);
                    ParaContent();
                    print "Oh no! You walked directly into the slavering fangs of a lurking grue!";
                    print "^";
                    (say__p = 1);
                    ParaContent();
                    print "^";
                    ParaContent();
                    print "*** You have died! ***";
                    (say__p = 1);
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "*** You have died! ***";
                    ParaContent();
                    print "^";
                }
            }
        }
    }
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2521;
    if (debug_rules) {
        DB_Rule(call_U2521, 889, 0);
    }
    TryAction(0, player, ##A_requesting_the_comple, 0, 0);
    rfalse;
];
[ call_U2522;
    if ((((action == ##Examine)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2169(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2522, 890, 0);
        }
        (say__p = 1);
        ParaContent();
        print "It can be yours for ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = noun), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2522, 890, 2);
        }
    }
    rfalse;
];
[ call_U2523;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2169(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2523, 893, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "ll have to pay for that.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2523, 893, 2);
        }
    }
    rfalse;
];
[ call_U2524;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2169(noun)))) && (((((self = actor),1)) && ((~~((I_wallet_U1 == ContainerOf(I_money_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2524, 894, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "re broke.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2524, 894, 2);
        }
    }
    rfalse;
];
[ call_U2525;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2169(noun)))) && (((((self = actor),1)) && (call_U2168(I_money_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2525, 895, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "re broke.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2525, 895, 2);
        }
    }
    rfalse;
];
[ call_U2526;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2169(noun)))) && (((((self = actor),1)) && ((GProperty(OBJECT_TY, I_money_U1, A_P_price) < GProperty(OBJECT_TY, noun, A_P_price))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2526, 896, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You don";
        ParaContent();
        print "'";
        ParaContent();
        print "t have enough money to cover the price of ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ".";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2526, 896, 2);
        }
    }
    rfalse;
];
[ call_U2527;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U2168(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2527, 897, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That";
        ParaContent();
        print "'";
        ParaContent();
        print "s not for sale.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2527, 897, 2);
        }
    }
    rfalse;
];
[ call_U2528;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2528, 898, 0);
        }
        WriteGProperty(OBJECT_TY, I_money_U1, A_P_price, (GProperty(OBJECT_TY, I_money_U1, A_P_price) - GProperty(OBJECT_TY, noun, A_P_price)));
        (say__p = 1);
        ParaContent();
        print "You fork over ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = noun), A_P_price));
        @pull self;
        ParaContent();
        print " for ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ", leaving yourself with ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = I_money_U1), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        if (call_U2168(I_money_U1)) {
            RemoveFromPlay(I_money_U1);
        }
        WriteGProperty(OBJECT_TY, noun, A_P_price, 0);
        MoveObject(noun, real_location);
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, player, ##Take, noun, 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
        RulebookSucceeds();
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2528, 898, 2);
        }
    }
    rfalse;
];
[ call_U2529;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_money_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2529, 899, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Best to leave it alone until you need to buy something.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2529, 899, 2);
        }
    }
    rfalse;
];
[ call_U2530;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((((noun ofclass K2_thing)) && (call_U2168(noun)))) && (((((self = actor),1)) && ((player == CarrierOf(noun))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2530, 900, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " is yours already.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2530, 900, 2);
        }
    }
    rfalse;
];
[ call_U2531;
    if ((((action == ##Buy)) && ((((actor == player)) && ((noun == I_money_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2531, 901, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The money belongs to you; you buy things with it.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2531, 901, 2);
        }
    }
    rfalse;
];
[ call_U2532;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun ofclass K18_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2532, 902, 0);
        }
        if (call_U133(noun)) {
            (say__p = 1);
            ParaContent();
            print "You catch just a hint of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " at the bottom.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(noun);
            ParaContent();
            print " contains ";
            ParaContent();
            @push self;
            call_U2833(GProperty(OBJECT_TY, (self = noun), A_P_current_volume));
            @pull self;
            ParaContent();
            print " of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2532, 902, 2);
        }
    }
    rfalse;
];
[ call_U2533 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K18_fluid_container)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if ((~~((((action == ##Drink)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U2533, 904, 0);
            }
            if (call_U133(tmp_0)) {
                (say__p = 1);
                ParaContent();
                print "empty ";
            } else {
            }
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2533, 904, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2533, 904, 2);
        }
    }
    rfalse;
];
[ call_U2534 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K18_fluid_container)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if ((~~((((action == ##Examine)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U2534, 905, 0);
            }
            if ((~~(call_U133(tmp_0)))) {
                (say__p = 1);
                ParaContent();
                print " of ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = tmp_0), A_P_liquid));
                @pull self;
                (c_style = ((c_style)&((~(((RECURSE_BIT + FULLINV_BIT) + PARTINV_BIT))))));
            }
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2534, 905, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2534, 905, 2);
        }
    }
    rfalse;
];
[ call_U2535;
    if ((((action == ##Insert)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K18_fluid_container)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2535, 906, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(second);
        ParaContent();
        print " has too narrow a mouth to accept anything but liquids.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2535, 906, 2);
        }
    }
    rfalse;
];
[ call_U2536;
    if ((((action == ##Drink)) && ((((actor == player)) && ((noun ofclass K18_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2536, 909, 0);
        }
        if (call_U133(noun)) {
            (say__p = 1);
            ParaContent();
            print "There is no more ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " within.";
            print "^";
            rtrue;
        } else {
            WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - 2));
            if ((GProperty(OBJECT_TY, noun, A_P_current_volume) < 0)) {
                WriteGProperty(OBJECT_TY, noun, A_P_current_volume, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You take a sip of ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            if ((~~(call_U133(noun)))) {
                jump L_Say1;
            }
            ParaContent();
            print ", leaving ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " empty";
            .L_Say1;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2536, 909, 2);
        }
    }
    rfalse;
];
[ call_U2537;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2537, 910, 0);
        }
        if ((~~((noun ofclass K18_fluid_container)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t pour ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if ((~~((second ofclass K18_fluid_container)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t pour liquids into ";
            ParaContent();
            DefArt(second);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if ((noun == second)) {
            (say__p = 1);
            ParaContent();
            print "You can hardly pour ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " into itself.";
            print "^";
            rtrue;
        }
        if ((~~((GProperty(OBJECT_TY, noun, A_P_liquid) == GProperty(OBJECT_TY, second, A_P_liquid))))) {
            if (call_U133(second)) {
                WriteGProperty(OBJECT_TY, second, A_P_liquid, GProperty(OBJECT_TY, noun, A_P_liquid));
            } else {
                (say__p = 1);
                ParaContent();
                print "Mixing ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
                @pull self;
                ParaContent();
                print " with ";
                ParaContent();
                @push self;
                E10(GProperty(OBJECT_TY, (self = second), A_P_liquid));
                @pull self;
                ParaContent();
                print " would give unsavory results.";
                print "^";
                rtrue;
            }
        }
        if (call_U133(noun)) {
            (say__p = 1);
            ParaContent();
            print "No more ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print " remains in ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
        if (call_U147(second)) {
            (say__p = 1);
            ParaContent();
            CDefArt(second);
            ParaContent();
            print " cannot contain any more than it already holds.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2537, 910, 3);
        }
    }
    rfalse;
];
[ call_U2538 tmp_0;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2538, 911, 0);
        }
        (tmp_0 = (GProperty(OBJECT_TY, second, A_P_fluid_capacity) - GProperty(OBJECT_TY, second, A_P_current_volume)));
        if ((tmp_0 > GProperty(OBJECT_TY, noun, A_P_current_volume))) {
            (tmp_0 = GProperty(OBJECT_TY, noun, A_P_current_volume));
        }
        WriteGProperty(OBJECT_TY, second, A_P_current_volume, (GProperty(OBJECT_TY, second, A_P_current_volume) + tmp_0));
        WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - tmp_0));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2538, 911, 3);
        }
    }
    rfalse;
];
[ call_U2539;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2539, 912, 0);
        }
        (say__p = 1);
        if ((~~(call_U133(noun)))) {
            jump L_Say0;
        }
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " is now empty;";
        jump L_SayX0;
        .L_Say0;
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " now contains ";
        ParaContent();
        @push self;
        call_U2833(GProperty(OBJECT_TY, (self = noun), A_P_current_volume));
        @pull self;
        ParaContent();
        print " of ";
        ParaContent();
        @push self;
        E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
        @pull self;
        ParaContent();
        print "; ";
        .L_SayX0;
        (say__p = 1);
        ParaContent();
        DefArt(second);
        ParaContent();
        print " contains ";
        ParaContent();
        @push self;
        call_U2833(GProperty(OBJECT_TY, (self = second), A_P_current_volume));
        @pull self;
        ParaContent();
        print " of ";
        ParaContent();
        @push self;
        E10(GProperty(OBJECT_TY, (self = second), A_P_liquid));
        @pull self;
        if ((~~(call_U147(second)))) {
            jump L_Say3;
        }
        ParaContent();
        print ", and is now full";
        .L_Say3;
        ParaContent();
        print ".";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2539, 912, 3);
        }
    }
    rfalse;
];
[ call_U2540 tmp_0;
    if ((((action == ##LookUnder)) && ((((actor == player)) && (call_U2541(noun)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2540, 913, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find ";
        ParaContent();
        objectloop (tmp_0 ofclass Object && (tmp_0 ofclass Object)) {
            if ((((tmp_0 ofclass K2_thing)) && ((call_U2412(tmp_0) == noun)))) {
                give tmp_0 workflag2;
            } else {
                give tmp_0 ~workflag2;
            }
        }
        WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
        ParaContent();
        print "!";
        print "^";
        call_U2542();
        call_U2543();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2540, 913, 2);
        }
    }
    rfalse;
];
[ call_U2541 x x_ix y y_ix;
    if ((x ofclass K2_thing)) {
        for ((y = K2_thing_First):y:(y = (y.K2_thing_Next))) {
            if ((call_U2412(y) == x)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2542 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2412(x) == noun)) {
            (qcn_0)++;
            MoveObject(x, real_location);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2543 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if ((call_U2412(x) == noun)) {
            (qcn_0)++;
            call_U2414(x, noun);
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2544;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2544, 914, 0);
        }
        if ((~~(call_U339(second)))) {
            (say__p = 1);
            ParaContent();
            CDefArt(second);
            ParaContent();
            print " wouldn";
            ParaContent();
            print "'";
            ParaContent();
            print "t be a very effective place of concealment.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2544, 914, 3);
        }
    }
    rfalse;
];
[ call_U2545;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2545, 915, 0);
        }
        RemoveFromPlay(noun);
        call_U2413(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2545, 915, 3);
        }
    }
    rfalse;
];
[ call_U2546;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2546, 916, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You shove ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " out of sight beneath ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2546, 916, 3);
        }
    }
    rfalse;
];
[ call_U2547 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U2547, 917, 0);
        }
        if (call_U414(tmp_0)) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is switched on.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is switched off.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2547, 917, 2);
        }
    }
    rfalse;
];
[ call_U2548;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2548, 918, 0);
        }
        if ((noun ofclass K13_device)) {
            CarryOutActivity(V38_showing_action, noun);
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2548, 918, 3);
        }
    }
    rfalse;
];
[ call_U2549;
    if ((((actor == player)) && ((noun ofclass K19_electric_lamp)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2549, 919, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You flip a switch. ";
        CarryOutActivity(V38_showing_action, noun);
        rtrue;
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2549, 919, 2);
        }
    }
    rfalse;
];
[ call_U2550 tmp_0 tmp_1;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K19_electric_lamp)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U2550, 920, 0);
        }
        if (call_U414(tmp_0)) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is lit";
            if ((~~(((call_U2551)() > 1)))) {
                jump L_Say0;
            }
            ParaContent();
            print ", competing with ";
            ParaContent();
            objectloop (tmp_1 ofclass Object && (tmp_1 ofclass Object)) {
                if ((((tmp_1 ofclass K2_thing)) && (((call_U293(tmp_1)) && (((call_U327(tmp_1)) && ((~~((tmp_1 == tmp_0)))))))))) {
                    give tmp_1 workflag2;
                } else {
                    give tmp_1 ~workflag2;
                }
            }
            WriteListOfMarkedObjects((ENGLISH_BIT + DEFART_BIT));
            .L_Say0;
            ParaContent();
            print ".";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print " is dark.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2550, 920, 2);
        }
    }
    rfalse;
];
[ call_U2551 x x_ix counter;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (((call_U293(x)) && (call_U327(x)))) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U2552;
    if ((((actor == player)) && ((noun ofclass K19_electric_lamp)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2552, 921, 0);
        }
        call_U328(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2552, 921, 2);
        }
    }
    rfalse;
];
[ call_U2553;
    if ((((actor == player)) && ((noun ofclass K19_electric_lamp)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2553, 922, 0);
        }
        call_U331(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2553, 922, 2);
        }
    }
    rfalse;
];
[ call_U2554;
    if ((parameter_value == noun)) {
        if (debug_rules) {
            DB_Rule(call_U2554, 923, 0);
        }
        if (((call_U414(noun)) && ((noun ofclass K19_electric_lamp)))) {
            (say__p = 1);
            ParaContent();
            print "A strong, narrow beam of light shines from ";
            ParaContent();
            DefArt(self);
            ParaContent();
            print ".";
            print "^";
        } else {
            if (((call_U414(noun)) && ((~~((noun ofclass K19_electric_lamp)))))) {
                (say__p = 1);
                ParaContent();
                print "It is currently switched on.";
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                print "It is currently switched off.";
                print "^";
            }
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2554, 923, 2);
        }
    }
    rfalse;
];
[ call_U2555;
    if ((((parameter_value ofclass K19_electric_lamp)) && (call_U327(parameter_value)))) {
        if (debug_rules) {
            DB_Rule(call_U2555, 924, 0);
        }
        (say__p = 1);
        ParaContent();
        print "lit ";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2555, 924, 2);
        }
    }
    rfalse;
];
[ call_U2556;
    if ((((parameter_value ofclass K19_electric_lamp)) && (((call_U330(parameter_value)) && (call_U327(parameter_value)))))) {
        if (debug_rules) {
            DB_Rule(call_U2556, 925, 0);
        }
        (say__p = 1);
        ParaContent();
        print "extinguished ";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2556, 925, 2);
        }
    }
    rfalse;
];
[ call_U2557;
    if (debug_rules) {
        DB_Rule(call_U2557, 926, 0);
    }
    if ((turns == 100)) {
        (say__p = 1);
        ParaContent();
        print "Over the loud speaker, an announcement blares: Attention please. There is a vehicle being towed from the parking lot for parking illegally. The license plate of the car is ~862901~.";
        ParaContent();
        RunParagraphOn();
        if ((I_dashboard_U1 == SupporterOf(I_parking_stub_U1))) {
            (say__p = 1);
            ParaContent();
            print " You breathe a sigh of relief as you realize that";
            ParaContent();
            print "'";
            ParaContent();
            print "s not your license plate. I guess it";
            ParaContent();
            print "'";
            ParaContent();
            print "s a good thing you remembered to place the parking stub on the dashboard.";
            print "^";
        }
        if ((~~((I_dashboard_U1 == SupporterOf(I_parking_stub_U1))))) {
            (say__p = 1);
            ParaContent();
            print " Your heart sinks as you realize that is your license plate. You race to the parking lot in time to see the tow truck pull away with your car in tow";
            ((Global_Vars-->58) = 1);
            (deadflag = 3);
            (story_complete = 1);
        }
    }
    rfalse;
];
[ call_U2558;
    if (debug_rules) {
        DB_Rule(call_U2558, 927, 0);
    }
    (say__p = 1);
    ParaContent();
    print "It is pitch black.  You are likely to be eaten by a grue.";
    print "^";
    rtrue;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2559;
    if (debug_rules) {
        DB_Rule(call_U2559, 928, 0);
    }
    (say__p = 1);
    ParaContent();
    print "It is too dark in here to see.";
    print "^";
    rtrue;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U2560;
    if ((location == thedark)) {
        if (debug_rules) {
            DB_Rule(call_U2560, 929, 0);
        }
        ((Global_Vars-->59) = ((Global_Vars-->59) + 1));
        if (((Global_Vars-->59) == 3)) {
            (deadflag = 3);
            (story_complete = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2560, 929, 4);
        }
    }
    rfalse;
];
[ call_U2561;
    if ((~~((location == thedark)))) {
        if (debug_rules) {
            DB_Rule(call_U2561, 930, 0);
        }
        ((Global_Vars-->59) = 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2561, 930, 4);
        }
    }
    rfalse;
];
[ call_U2562;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2562, 931, 0);
        }
        if ((noun == I_sailor_U1)) {
            (say__p = 1);
            ParaContent();
            print "Nothing happens here.";
            print "^";
            rtrue;
        }
        if ((~~((noun ofclass K8_person)))) {
            (say__p = 1);
            ParaContent();
            print "I think that only schizophrenics say ~Hello~ to ";
            ParaContent();
            IndefArt(noun);
            ParaContent();
            print ".";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2562, 931, 3);
        }
    }
    rfalse;
];
[ call_U2563;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2563, 932, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " bows his head to you in greeting.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2563, 932, 3);
        }
    }
    rfalse;
];
[ call_U2564;
    if ((((PAPR1)()) && (((((TimesActionHasHappened-->(ahc_id_U1)) == 10)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U1))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2564, 933, 0);
        }
        (say__p = 1);
        ParaContent();
        print "I think that phrase is getting a bit worn out.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2564, 933, 2);
        }
    }
    rfalse;
];
[ call_U2565;
    if ((((PAPR2)()) && (((((TimesActionHasHappened-->(ahc_id_U2)) == 20)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U2))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2565, 934, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You seem to be repeating yourself.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2565, 934, 2);
        }
    }
    rfalse;
];
[ call_U2566;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2566, 935, 0);
        }
        (say__p = 1);
        ParaContent();
        print "A  hollow voice says ~Plugh~.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2566, 935, 3);
        }
    }
    rfalse;
];
[ call_U2567;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2567, 936, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Nothing happens.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2567, 936, 3);
        }
    }
    rfalse;
];
[ call_U2568;
    if ((((action == ##A_talking_randomly_abou)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2568, 937, 0);
        }
        (say__p = 1);
        ParaContent();
        print "No one wants to hear you prattle on about ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ".";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2568, 937, 2);
        }
    }
    rfalse;
];
[ call_U2569;
    if ((((action == ##A_talking_about)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2569, 938, 0);
        }
        (say__p = 1);
        ParaContent();
        print "No one wants to hear you prattle on about ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ".";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2569, 938, 2);
        }
    }
    rfalse;
];
[ call_U2570;
    if ((((action == ##Ask)) && ((((actor == player)) && ((((noun ofclass K20_attendant)) && (((Consult_Grammar11)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2570, 940, 0);
        }
        (say__p = 1);
        ParaContent();
        call_U2834();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2570, 940, 2);
        }
    }
    rfalse;
];
[ call_U2571;
    if ((((action == ##Ask)) && ((((actor == player)) && ((((noun ofclass K20_attendant)) && (((Consult_Grammar12)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2571, 941, 0);
        }
        (say__p = 1);
        ParaContent();
        call_U2834();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2571, 941, 2);
        }
    }
    rfalse;
];
[ call_U2572;
    if ((((action == ##Ask)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2572, 942, 0);
        }
        (say__p = 1);
        ParaContent();
        print "~";
        ParaContent();
        if (((label_associated_storage_U1864-->(0)) == 0)) {
            ((label_associated_storage_U1863-->(0)) = (I7_SOO_RAN)((label_associated_storage_U1863-->(0)),3));
            ((label_associated_storage_U1864-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1864-->(0)) = 0);
        }
        switch ((((label_associated_storage_U1863-->(0))%(3 + 1)) - 1)) {
            0:
                ParaContent();
                print "Sorry,";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "I'm afraid";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "Hmm,";
                ParaContent();
                ;
        }
        ParaContent();
        print " ";
        ParaContent();
        if (((label_associated_storage_U1864-->(1)) == 0)) {
            ((label_associated_storage_U1863-->(1)) = (I7_SOO_RAN)((label_associated_storage_U1863-->(1)),3));
            ((label_associated_storage_U1864-->(1)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1864-->(1)) = 0);
        }
        switch ((((label_associated_storage_U1863-->(1))%(3 + 1)) - 1)) {
            0:
                ParaContent();
                print "I don't know much about that";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "you've got me there";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "I haven't the faintest";
                ParaContent();
                ;
        }
        ParaContent();
        print ",~ ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " ";
        ParaContent();
        if (((label_associated_storage_U1864-->(2)) == 0)) {
            ((label_associated_storage_U1863-->(2)) = (I7_SOO_RAN)((label_associated_storage_U1863-->(2)),4));
            ((label_associated_storage_U1864-->(2)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1864-->(2)) = 0);
        }
        switch ((((label_associated_storage_U1863-->(2))%(4 + 1)) - 1)) {
            0:
                ParaContent();
                print "drawls";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "replies";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "comments";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "exclaims";
                ParaContent();
                ;
        }
        ParaContent();
        print ".";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2572, 942, 2);
        }
    }
    rfalse;
];
[ call_U2573;
    if ((((action == ##Show)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K20_attendant)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2573, 943, 0);
        }
        (say__p = 1);
        ParaContent();
        print "~";
        ParaContent();
        if (((label_associated_storage_U1868-->(0)) == 0)) {
            ((label_associated_storage_U1867-->(0)) = (I7_SOO_RAN)((label_associated_storage_U1867-->(0)),3));
            ((label_associated_storage_U1868-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1868-->(0)) = 0);
        }
        switch ((((label_associated_storage_U1867-->(0))%(3 + 1)) - 1)) {
            0:
                ParaContent();
                print "Sorry,";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "I'm afraid";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "Hmm,";
                ParaContent();
                ;
        }
        ParaContent();
        print " ";
        ParaContent();
        if (((label_associated_storage_U1868-->(1)) == 0)) {
            ((label_associated_storage_U1867-->(1)) = (I7_SOO_RAN)((label_associated_storage_U1867-->(1)),3));
            ((label_associated_storage_U1868-->(1)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1868-->(1)) = 0);
        }
        switch ((((label_associated_storage_U1867-->(1))%(3 + 1)) - 1)) {
            0:
                ParaContent();
                print "I don't know much about that";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "you've got me there";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "I haven't the faintest";
                ParaContent();
                ;
        }
        ParaContent();
        print ",~ ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " ";
        ParaContent();
        if (((label_associated_storage_U1868-->(2)) == 0)) {
            ((label_associated_storage_U1867-->(2)) = (I7_SOO_RAN)((label_associated_storage_U1867-->(2)),4));
            ((label_associated_storage_U1868-->(2)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1868-->(2)) = 0);
        }
        switch ((((label_associated_storage_U1867-->(2))%(4 + 1)) - 1)) {
            0:
                ParaContent();
                print "drawls";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "replies";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "comments";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "exclaims";
                ParaContent();
                ;
        }
        ParaContent();
        print ".";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2573, 943, 2);
        }
    }
    rfalse;
];
[ call_U2574;
    if ((((action == ##Tell)) && ((((actor == player)) && ((((noun ofclass K20_attendant)) && (((Consult_Grammar13)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2574, 944, 0);
        }
        (say__p = 1);
        ParaContent();
        call_U2834();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2574, 944, 2);
        }
    }
    rfalse;
];
[ call_U2575;
    if ((((action == ##Tell)) && ((((actor == player)) && ((((noun ofclass K20_attendant)) && (((Consult_Grammar14)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2575, 945, 0);
        }
        (say__p = 1);
        ParaContent();
        call_U2834();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2575, 945, 2);
        }
    }
    rfalse;
];
[ call_U2576;
    if ((((action == ##Tell)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2576, 946, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(noun);
        ParaContent();
        print " looks ";
        ParaContent();
        if (((label_associated_storage_U1876-->(0)) == 0)) {
            ((label_associated_storage_U1875-->(0)) = (I7_SOO_RAN)((label_associated_storage_U1875-->(0)),3));
            ((label_associated_storage_U1876-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1876-->(0)) = 0);
        }
        switch ((((label_associated_storage_U1875-->(0))%(3 + 1)) - 1)) {
            0:
                ParaContent();
                print "surprised";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "intrigued";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "nonplussed";
                ParaContent();
                ;
        }
        ParaContent();
        print ". ~";
        ParaContent();
        if (((label_associated_storage_U1876-->(1)) == 0)) {
            ((label_associated_storage_U1875-->(1)) = (I7_SOO_RAN)((label_associated_storage_U1875-->(1)),4));
            ((label_associated_storage_U1876-->(1)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1876-->(1)) = 0);
        }
        switch ((((label_associated_storage_U1875-->(1))%(4 + 1)) - 1)) {
            0:
                ParaContent();
                print "You don't say";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "That's very interesting";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "Do go on";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "I wish I'd known that sooner";
                ParaContent();
                ;
        }
        ParaContent();
        print "!~";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2576, 946, 2);
        }
    }
    rfalse;
];
[ call_U2577;
    if ((((action == ##Go)) && ((((actor ~= player)) && ((((actor ofclass K20_attendant)) && (act_requester))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2577, 947, 0);
        }
        (say__p = 1);
        ParaContent();
        CDefArt(actor);
        ParaContent();
        print " says, ~I can't leave my post or I";
        ParaContent();
        print "'";
        ParaContent();
        print "ll get fired!";
        print "^";
        RulebookFails(RULEBOOK_OUTCOME_TY, outcome_persuasion_fails_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2577, 947, 2);
        }
    }
    rfalse;
];
[ call_U2578 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U39());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U39 ct_0 ct_1 tmp_0;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2578, 948, 0);
        }
        (ct_0 = table_data_U26);
        (ct_1 = TableRandomRow(ct_0));
        (tmp_0 = I7SFRAME);
        BlkValueCopy(tmp_0, TableLookUpEntry(ct_0, table_column_id_U22, ct_1));
        (say__p = 1);
        ParaContent();
        print "This is another bored teenager. ";
        ParaContent();
        TEXT_TY_Say(tmp_0);
        ParaContent();
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2578, 948, 2);
        }
    }
    rfalse;
];
[ call_U2579;
    if ((((action == ##Smell)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2579, 949, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You get close to ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print ". They smell like angst and regret.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2579, 949, 2);
        }
    }
    rfalse;
];
[ call_U2580;
    if ((((action == ##Listen)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2580, 950, 0);
        }
        (say__p = 1);
        ParaContent();
        print "All you can hear is ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " whining about working at the carnival.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2580, 950, 2);
        }
    }
    rfalse;
];
[ call_U2581;
    if ((((action == ##Touch)) && ((((actor == player)) && ((noun ofclass K20_attendant)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2581, 951, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Touching ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " without consent is likely to get you punched in the face! Better not.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2581, 951, 2);
        }
    }
    rfalse;
];
[ call_U2582;
    if (debug_rules) {
        DB_Rule(call_U2582, 952, 0);
    }
    call_U2835();
    rfalse;
];
[ call_U2583;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2583, 954, 0);
        }
        if ((score == 0)) {
            (say__p = 1);
            ParaContent();
            print "You have not yet achieved anything of note.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2583, 954, 3);
        }
    }
    rfalse;
];
[ call_U2584 ct_0 ct_1 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2584, 955, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Wow, you";
        ParaContent();
        print "'";
        ParaContent();
        print "ve received ";
        ParaContent();
        print (say__n = score);
        ParaContent();
        print " point";
        ParaContent();
        STextSubstitution();
        ParaContent();
        print " out of a possible ";
        ParaContent();
        print (say__n = MAX_SCORE);
        ParaContent();
        print " in ";
        ParaContent();
        print (say__n = turns);
        ParaContent();
        print " moves! I'm very proud of you. This was a triumph. I'm being so sincere right now.";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        (say__p = 1);
        ParaContent();
        print "You have received points for the following: ";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        TableSort(table_data_U25, table_column_id_U21, 1);
        @push ct_0;
        @push ct_1;
        for (((tmp_0 = table_data_U25),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                if ((TableLookUpEntry(ct_0, table_column_id_U21, ct_1) > 0)) {
                    (say__p = 1);
                    ParaContent();
                    (unicode_temp = 8226);
                    @streamunichar unicode_temp;
                    ParaContent();
                    print "  ";
                    ParaContent();
                    TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
                    ParaContent();
                    print ": ";
                    ParaContent();
                    print (say__n = TableLookUpEntry(ct_0, table_column_id_U20, ct_1));
                    ParaContent();
                    print " points.";
                    print "^";
                }
            }
        }
        @pull ct_1;
        @pull ct_0;
        (say__p = 1);
        ParaContent();
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2584, 955, 3);
        }
    }
    rfalse;
];
[ call_U2585;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2585, 956, 0);
        }
        TryAction(0, player, ##A_requesting_the_comple, 0, 0);
        rtrue;
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2585, 956, 3);
        }
    }
    rfalse;
];
[ call_U2586;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2586, 958, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Said with such force!";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2586, 958, 2);
        }
    }
    rfalse;
];
[ call_U2587;
    if ((((action == ##A_fucking)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2587, 959, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(bc_U1854);
        ParaContent();
        print " isn";
        ParaContent();
        print "'";
        ParaContent();
        print "t that kind of game!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2587, 959, 2);
        }
    }
    rfalse;
];
[ call_U2588;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2588, 960, 0);
        }
        (say__p = 1);
        ParaContent();
        if (((label_associated_storage_U1898-->(0)) == 0)) {
            ((label_associated_storage_U1897-->(0)) = (I7_SOO_RAN)((label_associated_storage_U1897-->(0)),4));
            ((label_associated_storage_U1898-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U1898-->(0)) = 0);
        }
        switch ((((label_associated_storage_U1897-->(0))%(4 + 1)) - 1)) {
            0:
                ParaContent();
                print "I can certainly understand your frustration but swearing is not the answer.";
                print "^";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "Real adventurers don";
                ParaContent();
                print "'";
                ParaContent();
                print "t use that sort of language!";
                print "^";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "And you kiss your mother with that mouth?";
                print "^";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "Shhh! Someone will hear you!";
                print "^";
                ParaContent();
                ;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2588, 960, 2);
        }
    }
    rfalse;
];
[ call_U2589;
    if ((((actor == player)) && ((noun == I_hell_ride_U1)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2589, 961, 0);
        }
        if (TestRegionalContainment(real_location, I_midway_U1)) {
            (say__p = 1);
            ParaContent();
            print "Through the lights and excitement of the carnival, you can see the facade for Hell Ride looming ominously over the midway.";
            print "^";
            rtrue;
        } else {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print " see that here.";
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2589, 961, 2);
        }
    }
    rfalse;
];
[ call_U2590;
    if ((((action == ##Kiss)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2590, 962, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Oh, my! Why would you want to kiss ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print "? Your sweetie wouldn't like that!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2590, 962, 2);
        }
    }
    rfalse;
];
[ call_U2591;
    if ((((action == ##Touch)) && ((((actor == player)) && ((noun ofclass K8_person)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2591, 963, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Touching ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " without consent is likely to get you punched in the face! Better not.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2591, 963, 2);
        }
    }
    rfalse;
];
[ call_U2592;
    if ((((action == ##Touch)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2592, 964, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You notice nothing unusual abou the way ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " feels.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2592, 964, 2);
        }
    }
    rfalse;
];
[ call_U2593;
    if ((((action == ##Smell)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2593, 965, 0);
        }
        if (TestRegionalContainment(real_location, I_midway_U1)) {
            (say__p = 1);
            ParaContent();
            print "You smell the smells of the carnival. As you smell, you can discern fresh, hot buttered popcorn, the sweet aroma of cotton candy, and the warm doughy scent of pretzels.";
            print "^";
        } else {
            if (TestRegionalContainment(real_location, I_back_stage_U1)) {
                (say__p = 1);
                ParaContent();
                print "You smell grease, oil, and the other scents that linger back stage.";
                print "^";
            } else {
                if (TestRegionalContainment(real_location, I_second_floor_U1)) {
                    (say__p = 1);
                    ParaContent();
                    print "You smell grease, oil, and the other scents that linger back stage.";
                    print "^";
                } else {
                    if (TestRegionalContainment(real_location, I_hellride_U1)) {
                        (say__p = 1);
                        ParaContent();
                        print "You smell incense as it permeates through ";
                        ParaContent();
                        TEXT_TY_Say(bc_U1855);
                        ParaContent();
                        print ".";
                        print "^";
                    }
                }
            }
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2593, 965, 2);
        }
    }
    rfalse;
];
[ call_U2594;
    if ((((action == ##Listen)) && ((actor == player)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2594, 966, 0);
        }
        if (TestRegionalContainment(real_location, I_midway_U1)) {
            (say__p = 1);
            ParaContent();
            print "You can hear all the sounds of the carnival. The sounds of a calliope waft across the thoroughfare from the carousel. You can hear the laughter and screams as other patrons ride the rides and play the games.";
            print "^";
        } else {
            if (TestRegionalContainment(real_location, I_back_stage_U1)) {
                (say__p = 1);
                ParaContent();
                print "You hear mechanical sounds: the screech metal upon metal, gears turning in precision, and the thump of the cars as they traverse the tracks through the ride.";
                print "^";
            } else {
                if (TestRegionalContainment(real_location, I_second_floor_U1)) {
                    (say__p = 1);
                    ParaContent();
                    print "You hear mechanical sounds: the screech metal upon metal, gears turning in precision, and the thump of the cars as they traverse the tracks through the ride.";
                    print "^";
                } else {
                    if (TestRegionalContainment(real_location, I_hellride_U1)) {
                        (say__p = 1);
                        ParaContent();
                        print "As you travel through ";
                        ParaContent();
                        TEXT_TY_Say(bc_U1856);
                        ParaContent();
                        print ", you hear ominous music, the murmurs of the crowd, and the occasional scream in the distance.";
                        print "^";
                    }
                }
            }
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2594, 966, 2);
        }
    }
    rfalse;
];
[ call_U2595;
    if ((((action == ##Taste)) && ((((actor == player)) && ((noun ofclass K8_person)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2595, 967, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Ew! You";
        ParaContent();
        print "'";
        ParaContent();
        print "re weird!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2595, 967, 2);
        }
    }
    rfalse;
];
[ call_U2596;
    if ((((action == ##Taste)) && ((((actor == player)) && ((noun ofclass K2_thing)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2596, 968, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Ew! You";
        ParaContent();
        print "'";
        ParaContent();
        print "re weird!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2596, 968, 2);
        }
    }
    rfalse;
];
[ call_U2597;
    if (debug_rules) {
        DB_Rule(call_U2597, 969, 0);
    }
    VM_Seed_RNG(4321);
    rfalse;
];
[ call_U2598;
    if ((((action == ##Unlock)) && ((((actor == player)) && ((((noun ofclass K26_electrical_panel)) && ((second ofclass K2_thing)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2598, 973, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Using the screwdriver on the Swiss Army knife, you remove the screws holding the electrical panel shut.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2598, 973, 2);
        }
    }
    rfalse;
];
[ call_U2599;
    if ((((actor == player)) && ((((((noun ofclass K2_thing)) && ((second ofclass K27_socket)))) && (((((self = actor),1)) && ((~~(call_U384(HolderOf(second))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2599, 977, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You should probably open the electrical panel first.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2599, 977, 2);
        }
    }
    rfalse;
];
[ call_U2600;
    if ((((actor == player)) && ((((noun ofclass K2_thing)) && ((second ofclass K27_socket)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2600, 978, 0);
        }
        if ((~~((noun ofclass K29_fuse)))) {
            (say__p = 1);
            ParaContent();
            print "That won";
            ParaContent();
            print "'";
            ParaContent();
            print "t fit in the socket.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2600, 978, 2);
        }
    }
    rfalse;
];
[ call_U2601 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U40());
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U40;
    if ((((action == ##Insert)) && ((((actor == player)) && ((((((noun ofclass K29_fuse)) && ((second ofclass K27_socket)))) && (((((self = actor),1)) && ((((GProperty(OBJECT_TY, noun, A_P_color) == (
        ! This evaluates last
        formal_rv+
        0*(
            ! This evaluates second
            ((
                (((((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2170(formal_par0)))))) && ((((formal_rv = call_U2838(formal_par0)))|(1))))) || ((((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2170(formal_par0)))))) && ((((formal_rv = call_U2838(formal_par0)))|(1))))) || ((((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2177(formal_par0)))))) && ((((formal_rv = call_U2853(formal_par0)))|(1))))) || ((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2177(formal_par0)))))) && ((((formal_rv = call_U2853(formal_par0)))|(1))))))))))) || (ArgumentTypeFailed(751)))
            ))
        +
            ! This evaluate first
            ((formal_par0 = second)))
    )
    )) && (call_U384(HolderOf(second))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2601, 979, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hear a satisfying snick as the ";
        ParaContent();
        @push self;
        E11(GProperty(OBJECT_TY, (self = noun), A_P_color));
        @pull self;
        ParaContent();
        print " fuse slides into place.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2601, 979, 2);
        }
    }
    rfalse;
];
[ call_U2602;
    if ((action == ##Take)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2602, 983, 0);
        }
        ((MStack-->(MstVO(var_id_U36, 0))) = HolderOf(noun));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2602, 983, 2);
        }
    }
    rfalse;
];
[ call_U2603 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U41());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U41;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K29_fuse)) && (((((self = actor),1)) && (((MStack-->(MstVO(var_id_U36, 0))) ofclass K27_socket)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2603, 984, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        if (call_U414((
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(806)))
                ))
            +
                ! This evaluate first
                (((formal_par1 = (MStack-->(MstVO(var_id_U36, 0)))) + (formal_par0 = 0))))
        )
        )) {
            call_U418((
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2863(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2873(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2883(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(807)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U36, 0)))) + (formal_par0 = 0))))
            )
            );
            (say__p = 1);
            ParaContent();
            print "The ";
            ParaContent();
            (formal_par0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U36, 0)))) + (formal_par0 = 0))))
            )
            );
            if (1) {
                PrintShortName(formal_par0);
            } else {
                ArgumentTypeFailed(1);
            }
            ParaContent();
            print " just went out.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2603, 984, 2);
        }
    }
    rfalse;
];
[ call_U2604;
    if ((((action == ##Push)) && ((((actor == player)) && ((((noun ofclass K30_switch)) && (call_U417(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2604, 988, 0);
        }
        TryAction(0, player, ##SwitchOn, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2604, 988, 2);
        }
    }
    rfalse;
];
[ call_U2605;
    if ((((action == ##Push)) && ((((actor == player)) && ((((noun ofclass K30_switch)) && (call_U414(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2605, 989, 0);
        }
        TryAction(0, player, ##SwitchOff, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2605, 989, 2);
        }
    }
    rfalse;
];
[ call_U2606;
    if ((((actor == player)) && ((((((noun ofclass K30_switch)) && (call_U417(noun)))) && (((((self = actor),1)) && ((~~(call_U384(HolderOf(noun))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2606, 990, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You should probably open the electrical panel first.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2606, 990, 2);
        }
    }
    rfalse;
];
[ call_U2607 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U42());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U42;
    if ((((actor == player)) && ((((noun ofclass K30_switch)) && (call_U417(noun)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2607, 991, 0);
        }
        if ((~~((
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((formal_par0 ofclass K27_socket)) && ((formal_par0 ofclass K27_socket)))) && ((((formal_rv = call_U2845(formal_par0)))|(1))))) || (ArgumentTypeFailed(852)))
                ))
            +
                ! This evaluate first
                ((formal_par0 = (
                    ! This evaluates last
                    formal_rv+
                    0*(
                        ! This evaluates second
                        ((
                            (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2869(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2869(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2879(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2879(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2889(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2889(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(852)))
                        ))
                    +
                        ! This evaluate first
                        (((formal_par1 = noun) + (formal_par0 = 0))))
                )
                )))
        )
        ))) {
            (say__p = 1);
            ParaContent();
            print "Nothing obvious happens.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2607, 991, 2);
        }
    }
    rfalse;
];
[ call_U2608 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U43());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U43;
    if ((((actor == player)) && ((noun ofclass K30_switch)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2608, 992, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The ";
        ParaContent();
        (formal_par0 = (
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
                ))
            +
                ! This evaluate first
                (((formal_par1 = noun) + (formal_par0 = 0))))
        )
        );
        if (1) {
            PrintShortName(formal_par0);
        } else {
            ArgumentTypeFailed(1);
        }
        ParaContent();
        print "'s light goes on.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2608, 992, 2);
        }
    }
    rfalse;
];
[ call_U2609 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U44());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U44;
    if ((((actor == player)) && ((noun ofclass K30_switch)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2609, 993, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The ";
        ParaContent();
        (formal_par0 = (
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2867(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2877(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2887(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
                ))
            +
                ! This evaluate first
                (((formal_par1 = noun) + (formal_par0 = 0))))
        )
        );
        if (1) {
            PrintShortName(formal_par0);
        } else {
            ArgumentTypeFailed(1);
        }
        ParaContent();
        print "'s light turns off.";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2609, 993, 2);
        }
    }
    rfalse;
];
[ call_U2610;
    if ((((action == ##Go)) && ((((actor == player)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_electrical_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2610, 995, 0);
        }
        if (call_U414(I_big_switch_U1)) {
            MoveObject(player, (call_U2611)(), 0, 0);
        } else {
            rfalse;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2610, 995, 2);
        }
    }
    rfalse;
];
[ call_U2611 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K1_room_First):x:(x = (x.K1_room_Next))) {
            if (call_U307(x)) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2612;
    if (debug_rules) {
        DB_Rule(call_U2612, 996, 0);
    }
    DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hell_ride_U1)), 0);
    (say__p = 1);
    ParaContent();
    print "The carnival is in town and you and your sweetie had a date to visit it. After dinner and just as you arrive at the carnival, you and your date have a terrible fight. They storm off leaving you alone. You decide to stay at the carnival anyway.";
    print "^";
    rfalse;
];
[ call_U2613;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_parking_lot_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2613, 997, 0);
        }
        (say__p = 1);
        if ((~~((I_parking_attendant_U1 == CarrierOf(I_parking_ticket_U1))))) {
            jump L_Say0;
        }
        ParaContent();
        print "The attendant has a parking ticket. The price of a parking ticket is ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = I_parking_ticket_U1), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        .L_Say0;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2613, 997, 2);
        }
    }
    rfalse;
];
[ call_U2614;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((I_beater_car_U1 == ContainerOf(player))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2614, 998, 0);
        }
        TryAction(0, player, ##Examine, I_beater_car_U1, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2614, 998, 2);
        }
    }
    rfalse;
];
[ call_U2615;
    if ((((action == ##Eat)) && ((((actor == player)) && ((noun == I_blueberries_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2615, 999, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The blueberries were delicious. A true taste of summer!";
        print "^";
        call_U2218(I_blueberries_U1);
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2615, 999, 2);
        }
    }
    rfalse;
];
[ call_U2616;
    if ((((actor == player)) && ((((noun == I_coupon_U1)) && ((second == I_parking_attendant_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2616, 1000, 0);
        }
        if ((I_parking_attendant_U1 == CarrierOf(I_parking_ticket_U1))) {
            WriteGProperty(OBJECT_TY, I_parking_ticket_U1, A_P_price, 300);
            MoveObject(I_coupon_U1, I_parking_attendant_U1);
            (say__p = 1);
            ParaContent();
            print "Done. The price of a parking ticket is now ";
            ParaContent();
            @push self;
            E6(GProperty(OBJECT_TY, (self = I_parking_ticket_U1), A_P_price));
            @pull self;
            ParaContent();
            print ".";
            print "^";
            rtrue;
        } else {
            if ((player == CarrierOf(I_parking_ticket_U1))) {
                (say__p = 1);
                ParaContent();
                print "Done. But you already bought a parking ticket.";
                print "^";
                MoveObject(I_coupon_U1, I_parking_attendant_U1);
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2616, 1000, 2);
        }
    }
    rfalse;
];
[ call_U2617;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((noun == I_parking_ticket_U1)) && (((((self = actor),1)) && ((~~((I_beater_car_U1 == ContainerOf(player))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2617, 1001, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The attendant mumbles something about the stub.";
        print "^";
        MoveObject(I_parking_ticket_U1, player);
        MoveObject(I_parking_stub_U1, player);
        rfalse;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2617, 1001, 2);
        }
    }
    rfalse;
];
[ call_U2618;
    if ((((action == ##Buy)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (((((self = actor),1)) && ((I_beater_car_U1 == ContainerOf(player))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2618, 1002, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You don";
        ParaContent();
        print "'";
        ParaContent();
        print "t see that here.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2618, 1002, 2);
        }
    }
    rfalse;
];
[ call_U2619;
    if ((((action == ##Show)) && ((((actor == player)) && ((((noun == I_parking_stub_U1)) && ((second == I_parking_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2619, 1003, 0);
        }
        (say__p = 1);
        ParaContent();
        print "He replies, ~Put the ticket stub on your dashboard or your car will get towed.~";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2619, 1003, 2);
        }
    }
    rfalse;
];
[ call_U2620;
    if ((((action == ##Ask)) && ((((actor == player)) && ((((noun == I_parking_attendant_U1)) && (((Consult_Grammar15)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2620, 1004, 0);
        }
        (say__p = 1);
        ParaContent();
        print "He replies, ~Put the ticket stub on your dashboard or your car will get towed.~";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2620, 1004, 2);
        }
    }
    rfalse;
];
[ call_U2621;
    if ((((action == ##Tell)) && ((((actor == player)) && ((((noun == I_parking_attendant_U1)) && (((Consult_Grammar16)(consult_from,consult_words) ~= GPR_FAIL)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2621, 1005, 0);
        }
        (say__p = 1);
        ParaContent();
        print "He replies, ~Put the ticket stub on your dashboard or your car will get towed.~";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2621, 1005, 2);
        }
    }
    rfalse;
];
[ call_U2622;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_parking_lot_U1)) && ((~~((player == CarrierOf(I_parking_ticket_U1))))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2622, 1006, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You need a parking ticket to leave your car here.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2622, 1006, 2);
        }
    }
    rfalse;
];
[ call_U2623 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U45());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U45;
    if ((real_location == I_parking_lot_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2623, 1007, 0);
        }
        BlkValueCopy(left_hand_status_line, TEXT_TY_ExpandIfPerishable(I7SFRAME, ts_array_U635));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2623, 1007, 4);
        }
    }
    rfalse;
];
[ call_U2624;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[the player's surroundings]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    SL_Location(1);
    rtrue;
];
[ call_U2625;
    if ((I_beater_car_U1 == ContainerOf(player))) {
        if (debug_rules) {
            DB_Rule(call_U2625, 1008, 0);
        }
        BlkValueCopy(left_hand_status_line, bc_U1857);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2625, 1008, 4);
        }
    }
    rfalse;
];
[ call_U2626;
    if ((((action == ##Turn)) && ((((actor == player)) && ((((noun == I_your_keys_U1)) && (((((self = actor),1)) && ((I_beater_car_U1 == ContainerOf(player))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2626, 1009, 0);
        }
        (say__p = 1);
        ParaContent();
        print "If you left now you would just end up in a bar, crying over a beer about your fight. You decide to stay and enjoy the carnival after all.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2626, 1009, 2);
        }
    }
    rfalse;
];
[ call_U2627;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_parking_lot_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (((call_U324(I_ticket_booth_U1)) && ((player == CarrierOf(I_parking_ticket_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2627, 1010, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ticketbooth_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2627, 1010, 2);
        }
    }
    rfalse;
];
[ call_U2628;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_ticket_booth_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2628, 1011, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ticketbooth_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2628, 1011, 2);
        }
    }
    rfalse;
];
[ call_U2629;
    if ((((((action == ##Examine)) || ((action == ##A_reading)))) && ((((actor == player)) && ((noun == I_signboard_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2629, 1013, 0);
        }
        ((Global_Vars-->65) = table_data_U15);
        call_U2848();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2629, 1013, 2);
        }
    }
    rfalse;
];
[ call_U2630;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_southwest_U1)) && (((((self = actor),1)) && ((((real_location == I_ticket_booth_U1)) && (call_U324(I_concession_stand_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2630, 1014, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_concessionstand_U1)), 0);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2630, 1014, 2);
        }
    }
    rfalse;
];
[ call_U2631;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_concession_stand_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2631, 1015, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_concessionstand_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2631, 1015, 2);
        }
    }
    rfalse;
];
[ call_U2632;
    if ((((action == ##Drink)) && ((((actor == player)) && ((noun ofclass K18_fluid_container)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2632, 1016, 0);
        }
        if (call_U133(I_soda_can_U1)) {
            (say__p = 1);
            ParaContent();
            CDefArt(actor);
            ParaContent();
            print " tip the can again only to find it empty.";
            print "^";
        } else {
            WriteGProperty(OBJECT_TY, noun, A_P_current_volume, (GProperty(OBJECT_TY, noun, A_P_current_volume) - 20));
            if ((GProperty(OBJECT_TY, noun, A_P_current_volume) < 0)) {
                WriteGProperty(OBJECT_TY, noun, A_P_current_volume, 0);
            }
            (say__p = 1);
            ParaContent();
            CDefArt(actor);
            ParaContent();
            print " gulp down some ";
            ParaContent();
            @push self;
            E10(GProperty(OBJECT_TY, (self = noun), A_P_liquid));
            @pull self;
            ParaContent();
            print ".";
            print "^";
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2632, 1016, 2);
        }
    }
    rfalse;
];
[ call_U2633;
    if ((((((action == ##Examine)) || ((action == ##A_reading)))) && ((((actor == player)) && ((noun == I_menu_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2633, 1017, 0);
        }
        ((Global_Vars-->65) = table_data_U31);
        call_U2848();
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2633, 1017, 2);
        }
    }
    rfalse;
];
[ call_U2634;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_east_U1)) && (((((self = actor),1)) && ((((real_location == I_ticket_booth_U1)) && (call_U324(I_high_striker_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2634, 1018, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_highstriker_U1)), 0);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2634, 1018, 2);
        }
    }
    rfalse;
];
[ call_U2635;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_high_striker_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2635, 1019, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_highstriker_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2635, 1019, 2);
        }
    }
    rfalse;
];
[ call_U2636;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_high_striker_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2636, 1020, 0);
        }
        (say__p = 1);
        if ((~~((I_strongman_attendant_U1 == CarrierOf(I_mallet_U1))))) {
            jump L_Say0;
        }
        ParaContent();
        print "The attendant is holding a mallet.";
        print "^";
        .L_Say0;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2636, 1020, 2);
        }
    }
    rfalse;
];
[ call_U2637;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_strongman_attendant_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2637, 1021, 0);
        }
        if (((Global_Vars-->66) == 1)) {
            call_U2849();
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2637, 1021, 2);
        }
    }
    rfalse;
];
[ call_U2638;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && (((((Global_Vars-->66) == 1)) && ((real_location == I_high_striker_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2638, 1022, 0);
        }
        call_U2849();
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2638, 1022, 2);
        }
    }
    rfalse;
];
[ call_U2639;
    if ((((action == ##Take)) && ((((actor == player)) && (((((self = actor),1)) && ((I_swiss_army_knife_U1 == PartOf(noun))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2639, 1023, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That";
        ParaContent();
        print "'";
        ParaContent();
        print "s part of the Swiss Army knife. You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t take that!";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2639, 1023, 2);
        }
    }
    rfalse;
];
[ call_U2640;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2640, 1024, 0);
        }
        if ((~~((noun == I_lever_U1)))) {
            (say__p = 1);
            ParaContent();
            print "Nothing happens.";
            print "^";
            rtrue;
        }
        if ((~~((second == I_mallet_U1)))) {
            (say__p = 1);
            ParaContent();
            print "You can";
            ParaContent();
            print "'";
            ParaContent();
            print "t hit ";
            ParaContent();
            DefArt(noun);
            ParaContent();
            print " with that!";
            print "^";
            rtrue;
        }
        if ((~~((player == CarrierOf(I_mallet_U1))))) {
            (say__p = 1);
            ParaContent();
            print "You";
            ParaContent();
            print "'";
            ParaContent();
            print "re not holding the mallet.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2640, 1024, 3);
        }
    }
    rfalse;
];
[ call_U2641;
    if ((actor == player)) {
        if ((player == CarrierOf(I_mallet_U1))) {
            if (debug_rules) {
                DB_Rule(call_U2641, 1026, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You lift the mallet high and bring it down on the lever with all your might! The striker rises towards the bell stopping at ~";
            ParaContent();
            E12((call_U2493)(I_weakling_U1,I_almost_there_U1));
            ParaContent();
            print "~.  C";
            ParaContent();
            print "'";
            ParaContent();
            print "mon! You can do better than that!";
            print "^";
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2641, 1026, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2641, 1026, 3);
        }
    }
    rfalse;
];
[ call_U2642;
    if ((((PAPR3)()) && (((((TimesActionHasHappened-->(ahc_id_U3)) == 5)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U3))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2642, 1027, 0);
        }
        PlaySound((ResourceIDsOfSounds-->(I_sound_of_bell_U1)), 0);
        ((Global_Vars-->66) = 1);
        (say__p = 1);
        ParaContent();
        print "You swing the mallet one more time. The bell rings as the striker reaches the top of the pole. The attendant says, ~You";
        ParaContent();
        print "'";
        ParaContent();
        print "re a Muscle Man. Here";
        ParaContent();
        print "'";
        ParaContent();
        print "s a prize for you.~";
        print "^";
        call_U2849();
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2642, 1027, 2);
        }
    }
    rfalse;
];
[ call_U2643;
    if ((((real_location == I_high_striker_U1)) && (((Global_Vars-->66) == 1)))) {
        if (debug_rules) {
            DB_Rule(call_U2643, 1028, 0);
        }
        ((Global_Vars-->60) = table_data_U14);
        call_U2836();
        if (((Global_Vars-->61) == 1)) {
            ((Global_Vars-->66) = 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2643, 1028, 4);
        }
    }
    rfalse;
];
[ call_U2644;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_northeast_U1)) && (((((self = actor),1)) && ((((real_location == I_high_striker_U1)) && (call_U324(I_dime_toss_game_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2644, 1029, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_dimetoss_U1)), 0);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2644, 1029, 2);
        }
    }
    rfalse;
];
[ call_U2645;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_dime_toss_game_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2645, 1030, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_dimetoss_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2645, 1030, 2);
        }
    }
    rfalse;
];
[ call_U2646;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_mercury_dime_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2646, 1031, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_mercurydime_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2646, 1031, 2);
        }
    }
    rfalse;
];
[ call_U2647;
    if ((((actor == player)) && ((((noun ofclass K23_dime)) && (((((self = actor),1)) && ((real_location == I_dime_toss_game_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2647, 1032, 0);
        }
        if (call_U2648()) {
            rfalse;
        } else {
            (say__p = 1);
            ParaContent();
            print "That seems futile to me.";
            print "^";
            RulebookFails();
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2647, 1032, 2);
        }
    }
    rfalse;
];
[ call_U2648 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K23_dime)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2649 tmp_0;
    if ((((action == ##A_tossing)) && ((((actor == player)) && ((((noun ofclass K23_dime)) && (((((self = actor),1)) && ((((second == I_plate_U1)) && ((player == CarrierOf(noun))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2649, 1034, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You toss the dime. ";
        ParaContent();
        RunParagraphOn();
        if ((GenerateRandomNumber(1, 5) <= 3)) {
            ((Global_Vars-->67) = 1);
            RemoveFromPlay(noun);
            (say__p = 1);
            ParaContent();
            print "The dime hits the plate, starts to spins, and lands in the center of the plate. The attendant shouts out, ~Winner! Winner! ";
            ParaContent();
            RunParagraphOn();
            call_U2850();
        } else {
            (tmp_0 = (GenerateRandomNumber)(1,3));
            switch (tmp_0) {
                1:
                    (say__p = 1);
                    ParaContent();
                    print "The dime hits the plate and bounces straight off.";
                    print "^";
                    ;
                2:
                    (say__p = 1);
                    ParaContent();
                    print "Like skipping a stone in water, the dime skitters off the plate.";
                    print "^";
                    ;
                3:
                    (say__p = 1);
                    ParaContent();
                    print "The dime lands on the edge of the plate. You watch in anticipation until the dime falls off the plate.";
                    print "^";
                    ;
            }
            RemoveFromPlay(noun);
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2649, 1034, 2);
        }
    }
    rfalse;
];
[ call_U2650;
    if ((((real_location == I_dime_toss_game_U1)) && (((Global_Vars-->67) == 1)))) {
        if (debug_rules) {
            DB_Rule(call_U2650, 1035, 0);
        }
        ((Global_Vars-->60) = table_data_U29);
        call_U2836();
        if (((Global_Vars-->61) == 1)) {
            ((Global_Vars-->67) = 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2650, 1035, 4);
        }
    }
    rfalse;
];
[ call_U2651;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_dime_toss_attendant_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2651, 1036, 0);
        }
        if (((Global_Vars-->67) == 1)) {
            call_U2850();
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2651, 1036, 2);
        }
    }
    rfalse;
];
[ call_U2652;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && (((((Global_Vars-->67) == 1)) && ((real_location == I_dime_toss_game_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2652, 1037, 0);
        }
        call_U2850();
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2652, 1037, 2);
        }
    }
    rfalse;
];
[ call_U2653;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_southeast_U1)) && (((((self = actor),1)) && ((((real_location == I_high_striker_U1)) && (call_U324(I_pitcher_s_mound_U1)))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2653, 1038, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_milkbottles_U1)), 0);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2653, 1038, 2);
        }
    }
    rfalse;
];
[ call_U2654;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_pitcher_s_mound_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2654, 1039, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_milkbottles_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2654, 1039, 2);
        }
    }
    rfalse;
];
[ call_U2655;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun ofclass K23_dime)) && ((second == I_pitcher_s_mound_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2655, 1040, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The attendant gives you three baseballs in return.";
        print "^";
        MoveObject(noun, I_pitcher_s_mound_attendant_U1);
        call_U2656();
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2655, 1040, 2);
        }
    }
    rfalse;
];
[ call_U2656 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K32_baseball_First):x:(x = (x.K32_baseball_Next))) {
        (qcn_0)++;
        MoveObject(x, player);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2657;
    if ((((action == ##ThrowAt)) && ((((actor == player)) && ((((noun ofclass K32_baseball)) && ((second == I_milk_bottles_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2657, 1041, 0);
        }
        if (call_U2658()) {
            rfalse;
        } else {
            (say__p = 1);
            ParaContent();
            print "That seems futile to me.";
            print "^";
            RulebookFails();
            rtrue;
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2657, 1041, 2);
        }
    }
    rfalse;
];
[ call_U2658 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K32_baseball)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2659 tmp_0;
    if ((((action == ##ThrowAt)) && ((((actor == player)) && ((((((noun ofclass K32_baseball)) && ((second == I_milk_bottles_U1)))) && (((((self = actor),1)) && ((player == CarrierOf(noun))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2659, 1043, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You wind up and throw the baseball at the milk bottles. ";
        ParaContent();
        RunParagraphOn();
        if ((GenerateRandomNumber(1, 5) <= 3)) {
            ((Global_Vars-->68) = 1);
            (say__p = 1);
            ParaContent();
            print "The ball hits the bottles in the sweet spot and they go flying off the platform. The attendant shouts out, ~Winner! Winner! ";
            ParaContent();
            RunParagraphOn();
            call_U2851();
            RemoveFromPlay(noun);
        } else {
            (tmp_0 = (GenerateRandomNumber)(1,5));
            switch (tmp_0) {
                1:
                    (say__p = 1);
                    ParaContent();
                    print "You knocked over one bottle. You can do better than that.";
                    print "^";
                    ;
                2:
                    (say__p = 1);
                    ParaContent();
                    print "You knocked over two bottles. Too bad.";
                    print "^";
                    ;
                3:
                    (say__p = 1);
                    ParaContent();
                    print "You knocked over three bottles. So close.";
                    print "^";
                    ;
                4:
                    (say__p = 1);
                    ParaContent();
                    print "You knocked over four bottles. So sad.";
                    print "^";
                    ;
                5:
                    (say__p = 1);
                    ParaContent();
                    print "You knocked over five bottles. Better luck next time.";
                    print "^";
                    ;
            }
            RemoveFromPlay(noun);
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2659, 1043, 2);
        }
    }
    rfalse;
];
[ call_U2660;
    if ((((real_location == I_pitcher_s_mound_U1)) && (((Global_Vars-->68) == 1)))) {
        if (debug_rules) {
            DB_Rule(call_U2660, 1044, 0);
        }
        ((Global_Vars-->60) = table_data_U30);
        call_U2836();
        if (((Global_Vars-->61) == 1)) {
            ((Global_Vars-->68) = 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2660, 1044, 4);
        }
    }
    rfalse;
];
[ call_U2661;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_pitcher_s_mound_attendant_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2661, 1045, 0);
        }
        if (((Global_Vars-->68) == 1)) {
            call_U2851();
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2661, 1045, 2);
        }
    }
    rfalse;
];
[ call_U2662;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && (((((Global_Vars-->68) == 1)) && ((real_location == I_pitcher_s_mound_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2662, 1046, 0);
        }
        call_U2851();
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2662, 1046, 2);
        }
    }
    rfalse;
];
[ call_U2663;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_show_facade_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2663, 1047, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptfacad_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2663, 1047, 2);
        }
    }
    rfalse;
];
[ call_U2664;
    if ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && (call_U324(real_location)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2664, 1049, 0);
        }
        TryAction(0, player, ##Look, 0, 0);
        (say__p = 1);
        ParaContent();
        call_U2852();
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2664, 1049, 2);
        }
    }
    rfalse;
];
[ call_U2665;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_barker_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2665, 1050, 0);
        }
        (say__p = 1);
        ParaContent();
        call_U2852();
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2665, 1050, 2);
        }
    }
    rfalse;
];
[ call_U2666;
    if ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && (call_U2667()))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2666, 1051, 0);
        }
        (say__p = 1);
        ParaContent();
        print "It";
        ParaContent();
        print "'";
        ParaContent();
        print "ll cost you a dime to go that way.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2666, 1051, 2);
        }
    }
    rfalse;
];
[ call_U2667 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K23_dime_First):x:(x = (x.K23_dime_Next))) {
        (qcn_0)++;
        if ((I_barker_U1 == CarrierOf(x))) {
            (qcy_0)++;
        }
    }
    if ((qcy_0 == 0)) {
        rtrue;
    }
    rfalse;
];
[ call_U2668;
    if ((((action == ##Give)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun ofclass K23_dime)) && ((second == I_barker_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2668, 1052, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You hand over a dime, and the barker nods, waving you through. As you step past the entrance, the air feels thicker, almost humid, and the sounds of the carnival fade away. You've entered an entirely different world now - one filled with the scents of incense and exotic spices, and the low, hypnotic music of a faraway land. Before you, a series of dimly lit tents stretch out, their flaps slightly swaying in the breeze. Intrigued, you take your first step into the Little Egypt Show. You can now head west into the show.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2668, 1052, 2);
        }
    }
    rfalse;
];
[ call_U2669;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_west_U1)) && (((((self = actor),1)) && ((((real_location == I_show_facade_U1)) && (((call_U324(I_show_tent_U1)) && (call_U2670()))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2669, 1053, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptshow_U1)), 0);
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2669, 1053, 2);
        }
    }
    rfalse;
];
[ call_U2670 x x_ix;
    objectloop (x in I_barker_U1) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K23_dime)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2671;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_show_tent_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2671, 1054, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_littleegyptshow_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2671, 1054, 2);
        }
    }
    rfalse;
];
[ call_U2672;
    if ((((action == ##Wear)) && ((((actor == player)) && ((noun == I_sheer_veil_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2672, 1055, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You wrap the veil around your head, shrouding your eyes. The world is a lovely color pink as you look through the veil while her perfume fills your nostrils in the most delightful way. You look pretty!";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2672, 1055, 2);
        }
    }
    rfalse;
];
[ call_U2673 ct_0 ct_1 tmp_0 tmp_1;
    if ((((PAPR4)()) && (((((TimesActionHasHappened-->(ahc_id_U4)) == 1)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U4))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2673, 1056, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        if ((I_pile_of_junk_U1 == ContainerOf(I_flashlight_U1))) {
            @push ct_0;
            @push ct_1;
            for (((tmp_0 = table_data_U25),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
                if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                    if (((BlkValueCompare)(TableLookUpEntry(ct_0, table_column_id_U10, ct_1),bc_U1858) == 0)) {
                        TableBlankOutRow(ct_0, ct_1);
                    }
                }
            }
            @pull ct_1;
            @pull ct_0;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2673, 1056, 2);
        }
    }
    rfalse;
];
[ call_U2674;
    if (debug_rules) {
        DB_Rule(call_U2674, 1057, 0);
    }
    (say__p = 1);
    ParaContent();
    print "You applaud until your hands are sore. Did she just wink at you?";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "As she leaves the stage, Little Egypt tosses one of her veils to you!";
    print "^";
    MoveObject(I_sheer_veil_U1, player);
    rfalse;
];
[ call_U2675 ct_0 ct_1 tmp_0 tmp_1;
    if (((scene_status-->(1)) == 1)) {
        if (debug_rules) {
            DB_Rule(call_U2675, 1058, 0);
        }
        @push ct_0;
        @push ct_1;
        for (((tmp_0 = table_data_U16),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
                TableBlankOutRow(ct_0, ct_1);
                RulebookSucceeds();
                rtrue;
            }
        }
        @pull ct_1;
        @pull ct_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2675, 1058, 1);
        }
    }
    rfalse;
];
[ call_U2676;
    if (((scene_status-->(1)) == 1)) {
        if ((((actor == player)) && ((~~((((action == ##Examine)) || ((((action == ##Listen)) || ((((action == ##Look)) || ((action == ##Wait)))))))))))) {
            (self = noun);
            if (debug_rules) {
                DB_Rule(call_U2676, 1059, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You";
            ParaContent();
            print "'";
            ParaContent();
            print "re much too entranced by the show to do anything other than watch the show. You are riveted";
            ParaContent();
            if ((~~((I_folding_chair_U1 == ContainerOf(player))))) {
                jump L_Say0;
            }
            ParaContent();
            print " to your seat";
            .L_Say0;
            ParaContent();
            print "!";
            print "^";
            RulebookFails(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2676, 1059, 2);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2676, 1059, 1);
        }
    }
    rfalse;
];
[ call_U2677;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_east_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_high_striker_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_ferris_wheel_ride_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2677, 1060, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ferriswheel_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2677, 1060, 2);
        }
    }
    rfalse;
];
[ call_U2678;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_ferris_wheel_ride_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2678, 1061, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ferriswheel_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2678, 1061, 2);
        }
    }
    rfalse;
];
[ call_U2679;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_ferris_wheel_ticket_U1)) && ((second == I_ferris_wheel_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2679, 1062, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You give ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " to ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
        MoveObject(I_ferris_wheel_ticket_U1, I_ferris_wheel_attendant_U1);
        (say__p = 1);
        ParaContent();
        print "^";
        ParaContent();
        print "As you step into the gently swaying gondola, a faint creak accompanies the safety bar locking into place. The Ferris wheel begins its slow ascent, the hum of its machinery blending with the distant sounds of carnival games and laughter below. A soft breeze brushes against your face as the gondola rises higher, offering an ever-expanding view of the fairgrounds.^^With each rotation, the world transforms. At the peak, the carnival sprawls beneath you like a miniature village, its vibrant lights twinkling against the twilight sky. The sound of the midway fades into a soft murmur, replaced by the serene quiet of being high above the bustling crowd. Beyond the fair, the horizon stretches endlessly, framed by the glow of distant city lights.^^The gondola sways gently, adding a hint of thrill to the tranquil ride. You exchange smiles with your companions, pointing out tiny figures darting between booths and the dizzying motion of other rides below. The Ferris wheel begins its descent, and the lively carnival sounds grow louder once again, bringing you back into the heart of the action.^^Whether you're seeking a moment of calm, a romantic view, or the sheer wonder of seeing the world from above, the Ferris wheel delivers an unforgettable ride that captures the magic of the carnival.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2679, 1062, 2);
        }
    }
    rfalse;
];
[ call_U2680;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_northwest_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_ticket_booth_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_bumper_cars_ride_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2680, 1063, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_bumpercars_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2680, 1063, 2);
        }
    }
    rfalse;
];
[ call_U2681;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_bumper_cars_ride_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2681, 1064, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_bumpercars_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2681, 1064, 2);
        }
    }
    rfalse;
];
[ call_U2682;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_bumper_cars_ticket_U1)) && ((second == I_bumper_cars_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2682, 1065, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You give ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " to ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
        MoveObject(I_bumper_cars_ticket_U1, I_bumper_cars_attendant_U1);
        (say__p = 1);
        ParaContent();
        print "^";
        ParaContent();
        print "Sliding into the snug seat of the bumper car, your hands grip the steering wheel, anticipation buzzing in the air. Around you, the arena is alive with flashing lights, bursts of laughter, and the hum of electric currents running through the overhead poles. A quick glance shows other riders locking eyes, playful grins spreading as everyone braces for the chaos about to unfold.^^As the ride starts, your car jolts forward, and you steer into the fray. The slick metal floor beneath makes every turn feel smooth yet unpredictable. Suddenly, bam! - another car collides into you from the side, sending your car into a spin. You laugh, recovering quickly to aim your vehicle at a friend across the arena.^^The thrill of the bumper cars is in the collisions - every thud and jolt accompanied by squeals of delight or mock indignation. The impact is cushioned by the padded bumpers, keeping the fun safe but exhilarating. You swerve, dodge, and sometimes reverse in a desperate attempt to avoid being cornered, all while plotting your next playful crash.^^The ride is a whirlwind of laughter, harmless competition, and shared joy. As the music fades and the cars slow to a stop, you climb out with a wide grin, already looking forward to your next turn in the driver's seat.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2682, 1065, 2);
        }
    }
    rfalse;
];
[ call_U2683;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_two_dollar_bill_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2683, 1066, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Taken.";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        WriteGProperty(OBJECT_TY, I_money_U1, A_P_price, (GProperty(OBJECT_TY, I_money_U1, A_P_price) + 200));
        (say__p = 1);
        ParaContent();
        print "You now have ";
        ParaContent();
        @push self;
        E6(GProperty(OBJECT_TY, (self = I_money_U1), A_P_price));
        @pull self;
        ParaContent();
        print ".";
        print "^";
        RemoveFromPlay(I_two_dollar_bill_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2683, 1066, 2);
        }
    }
    rfalse;
];
[ call_U2684;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_adjustable_wrench_U1)) && ((second == I_bumper_cars_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2684, 1067, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Hey! Thanks, I really appreciate it. Usually no one ever responds to the radio in the Control Room.";
        print "^";
        MoveObject(I_adjustable_wrench_U1, I_bumper_cars_attendant_U1);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2684, 1067, 2);
        }
    }
    rfalse;
];
[ call_U2685;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_southeast_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_ticket_booth_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_fortune_teller_booth_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2685, 1068, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_fortuneteller_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2685, 1068, 2);
        }
    }
    rfalse;
];
[ call_U2686;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_fortune_teller_booth_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2686, 1069, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_fortuneteller_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2686, 1069, 2);
        }
    }
    rfalse;
];
[ call_U2687;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_fortune_teller_ticket_U1)) && ((second == I_mysterious_woman_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2687, 1070, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You give ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " to ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
        MoveObject(I_fortune_teller_ticket_U1, I_mysterious_woman_U1);
        (say__p = 1);
        ParaContent();
        print "^";
        ParaContent();
        print "Stepping inside, you're greeted by the fortune teller, a figure cloaked in flowing robes with a jeweled headpiece catching the flickering light. Their piercing eyes seem to look right through you as they gesture for you to sit at a small round table covered in an ornate cloth. At its center rests a glowing crystal ball, surrounded by tarot cards and mysterious trinkets.^^The fortune teller";
        ParaContent();
        print "'";
        ParaContent();
        print "s voice is low and melodic, weaving an air of intrigue as they ask you to focus on a question or offer your palm for a reading. The room seems to shrink, the bustling carnival outside fading into the background as they reveal your fate. Each card turned or line traced feels significant, as though unlocking a secret you didn't know you carried.^^As the reading concludes, the fortune teller gazes into your eyes with a cryptic smile and delivers their final words of wisdom. Whether you leave with a sense of wonder, excitement, or unease, the encounter lingers with you - a touch of magic amid the carnival's chaos, as if you've glimpsed something beyond the ordinary.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2687, 1070, 2);
        }
    }
    rfalse;
];
[ call_U2688;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_northeast_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_ticket_booth_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_carousel_ride_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2688, 1071, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_carousel_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2688, 1071, 2);
        }
    }
    rfalse;
];
[ call_U2689;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_carousel_ride_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2689, 1072, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_carousel_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2689, 1072, 2);
        }
    }
    rfalse;
];
[ call_U2690;
    if ((((action == ##Give)) && ((((actor == player)) && ((((noun == I_carousel_ticket_U1)) && ((second == I_carousel_attendant_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2690, 1073, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You give ";
        ParaContent();
        DefArt(noun);
        ParaContent();
        print " to ";
        ParaContent();
        DefArt(second);
        ParaContent();
        print ".";
        print "^";
        MoveObject(I_carousel_ticket_U1, I_carousel_attendant_U1);
        (say__p = 1);
        ParaContent();
        print "^";
        ParaContent();
        print "Stepping onto the carousel";
        ParaContent();
        print "'";
        ParaContent();
        print "s spinning platform, you're greeted by a kaleidoscope of color - brightly painted horses, glittering lights, and golden trim. The cheerful melody of calliope music fills the air. What will you choose as your mount, perhaps a galloping horse with a flowing mane, a majestic lion, or a whimsical giraffe. Gripping the polished pole, you settle onto the saddle, feeling the smooth rise and fall as the carousel begins to turn.^^As the ride picks up speed, the world outside becomes a blur of glowing carnival lights and swirling colors. The gentle up-and-down motion mimics a playful gallop, and the rhythmic whir of the carousel's machinery adds a soothing backdrop to the cheerful atmosphere. Laughter and the sound of children's chatter mix with the music, creating a sense of nostalgia and joy.^^For a few moments, you're transported into a magical world, the worries of the day fading away with each graceful rotation. Whether you're enjoying the ride alone, with friends, or sharing a special moment with family, the carousel";
        ParaContent();
        print "'";
        ParaContent();
        print "s charm captures a timeless blend of whimsy and wonder. As it slows to a stop, you step off with a smile, the music lingering in your ears as you rejoin the bustling carnival.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2690, 1073, 2);
        }
    }
    rfalse;
];
[ call_U2691;
    if ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((((real_location == I_head_of_the_line_U1)) && ((~~((I_hell_ride_attendant_U1 == OwnerOf(I_hell_ride_ticket_U1))))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2691, 1074, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You";
        ParaContent();
        print "'";
        ParaContent();
        print "ll need a ticket to go that way.";
        print "^";
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2691, 1074, 2);
        }
    }
    rfalse;
];
[ call_U2692;
    if ((((action == ##LookUnder)) && ((((actor == player)) && (((((self = actor),1)) && ((noun == I_pile_of_junk_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2692, 1075, 0);
        }
        TryAction(0, player, ##Examine, I_pile_of_junk_U1, 0);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2692, 1075, 2);
        }
    }
    rfalse;
];
[ call_U2693;
    if ((((action == ##Examine)) && ((((actor == player)) && (((((self = actor),1)) && ((((noun == I_pile_of_junk_U1)) && ((I_pile_of_junk_U1 == ContainerOf(I_flashlight_U1))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2693, 1076, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You find a flashlight here.";
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2693, 1076, 2);
        }
    }
    rfalse;
];
[ call_U2694 ct_0 ct_1 tmp_0 tmp_1;
    if ((((PAPR5)()) && (((((TimesActionHasHappened-->(ahc_id_U5)) == 1)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U5))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2694, 1077, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Taken.";
        print "^";
        if ((I_wall_U1 == ContainerOf(I_lantern_U1))) {
            @push ct_0;
            @push ct_1;
            for (((tmp_0 = table_data_U25),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
                if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                    if (((BlkValueCompare)(TableLookUpEntry(ct_0, table_column_id_U10, ct_1),bc_U1859) == 0)) {
                        TableBlankOutRow(ct_0, ct_1);
                    }
                }
            }
            @pull ct_1;
            @pull ct_0;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2694, 1077, 2);
        }
    }
    rfalse;
];
[ call_U2695;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_dark_passage_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (((call_U324(I_maintenance_office_U1)) && (call_U2696()))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2695, 1078, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_maintenanceoffic_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2695, 1078, 2);
        }
    }
    rfalse;
];
[ call_U2696 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K19_electric_lamp)) && (call_U327(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2697;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((((real_location == I_maintenance_office_U1)) && (call_U2698()))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2697, 1079, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_maintenanceoffic_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2697, 1079, 2);
        }
    }
    rfalse;
];
[ call_U2698 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K19_electric_lamp)) && (call_U327(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2699;
    if ((((action == ##Drink)) && ((((actor == player)) && ((noun == I_coffee_mug_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2699, 1080, 0);
        }
        (say__p = 1);
        ParaContent();
        print "That looks nasty. You decide against drinking the coffee.";
        print "^";
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2699, 1080, 2);
        }
    }
    rfalse;
];
[ call_U2700 RV;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(0, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    (RV = kernel1_U46());
    BlkValueFreeOnStack(0);
    BlkValueFreeOnStack(2);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U46 ct_0 ct_1 tmp_0 tmp_1 tmp_2;
    if (((call_U414(I_radio_U1)) && (call_U2421(real_location, I_maintenance_office_U1)))) {
        if (debug_rules) {
            DB_Rule(call_U2700, 1081, 0);
        }
        (ct_0 = table_data_U27);
        (ct_1 = TableRandomRow(ct_0));
        (tmp_0 = I7SFRAME);
        BlkValueCopy(tmp_0, TableLookUpEntry(ct_0, table_column_id_U23, ct_1));
        (tmp_1 = (I7SFRAME + (WORDSIZE*2)));
        BlkValueCopy(tmp_1, TableLookUpEntry(ct_0, table_column_id_U24, ct_1));
        (tmp_2 = TableLookUpEntry(ct_0, table_column_id_U25, ct_1));
        (say__p = 1);
        ParaContent();
        if (((label_associated_storage_U2020-->(0)) == 0)) {
            ((label_associated_storage_U2019-->(0)) = (I7_SOO_RAN)((label_associated_storage_U2019-->(0)),6));
            ((label_associated_storage_U2020-->(0)) = 1);
        }
        if ((say__comp == 0)) {
            ((label_associated_storage_U2020-->(0)) = 0);
        }
        switch ((((label_associated_storage_U2019-->(0))%(6 + 1)) - 1)) {
            0:
                ParaContent();
                print "You hear ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print "'";
                ParaContent();
                print "s ~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~ playing on the radio.";
                print "^";
                ParaContent();
                @nop;
                ;
            1:
                ParaContent();
                print "~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~ by ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print " plays on the radio.";
                print "^";
                ParaContent();
                @nop;
                ;
            2:
                ParaContent();
                print "You sing along to ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print "'";
                ParaContent();
                print "s ~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~.";
                print "^";
                ParaContent();
                @nop;
                ;
            3:
                ParaContent();
                print "The DJ announces that ~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~ by ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print " will be up next.";
                print "^";
                ParaContent();
                @nop;
                ;
            4:
                ParaContent();
                print "Nearby, you can hear ~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~ by ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print ".";
                print "^";
                ParaContent();
                @nop;
                ;
            5:
                ParaContent();
                print "You whistle along to ~";
                ParaContent();
                TEXT_TY_Say(tmp_1);
                ParaContent();
                print "~ by ";
                ParaContent();
                TEXT_TY_Say(tmp_0);
                ParaContent();
                print ".";
                print "^";
                ParaContent();
                ;
        }
        if ((~~((tmp_2 == 1)))) {
            jump L_Say0;
        }
        ParaContent();
        print " Yes, you have been Rick Rolled!";
        print "^";
        .L_Say0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2700, 1081, 4);
        }
    }
    rfalse;
];
[ call_U2701;
    if ((parameter_value == I_radio_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2701, 1082, 0);
        }
        if (call_U414(I_radio_U1)) {
            (say__p = 1);
            ParaContent();
            print "Through the static, you pick up hear bits of the latest number one hit.";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            print "The radio is silent. You";
            ParaContent();
            print "'";
            ParaContent();
            print "re saving the batteries.";
            print "^";
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2701, 1082, 2);
        }
    }
    rfalse;
];
[ call_U2702;
    if ((((action == ##Listen)) && ((((actor == player)) && ((((((I_radio_U1 == I_radio_U1)) && (call_U414(I_radio_U1)))) && (TestScope(I_radio_U1, actor)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2702, 1083, 0);
        }
        CarryOutActivity(V38_showing_action, I_radio_U1);
        rtrue;
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2702, 1083, 2);
        }
    }
    rfalse;
];
[ call_U2703;
    if ((((action == ##Climb)) && ((((actor == player)) && ((noun == I_ladder_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2703, 1084, 0);
        }
        TryAction(0, player, ##Enter, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2703, 1084, 2);
        }
    }
    rfalse;
];
[ call_U2704;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_graffiti_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2704, 1085, 0);
        }
        (say__p = 1);
        ParaContent();
        print "The graffiti is varied, from ~Peace, Love, Goodwill on Earth~ to ~Anarchy Rules~.";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2704, 1085, 2);
        }
    }
    rfalse;
];
[ call_U2705;
    if (debug_rules) {
        DB_Rule(call_U2705, 1086, 0);
    }
    (deadflag = 3);
    (story_complete = 1);
    rfalse;
];
[ call_U2706;
    if (((scene_status-->(2)) == 1)) {
        if ((((actor == player)) && ((~~((((action == ##Examine)) || ((((action == ##Listen)) || ((((action == ##Look)) || ((action == ##Wait)))))))))))) {
            (self = noun);
            if (debug_rules) {
                DB_Rule(call_U2706, 1087, 0);
            }
            (say__p = 1);
            ParaContent();
            print "You";
            ParaContent();
            print "'";
            ParaContent();
            print "re enjoying the ride so much that you don";
            ParaContent();
            print "'";
            ParaContent();
            print "t want to do anything but sit and watch the ride go by.";
            print "^";
            RulebookFails(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U2706, 1087, 2);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2706, 1087, 1);
        }
    }
    rfalse;
];
[ call_U2707 ct_0 ct_1 tmp_0 tmp_1;
    if (((scene_status-->(2)) == 1)) {
        if (debug_rules) {
            DB_Rule(call_U2707, 1088, 0);
        }
        @push ct_0;
        @push ct_1;
        for (((tmp_0 = table_data_U17),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
            if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
                DisplayFigure((ResourceIDsOfFigures-->(TableLookUpEntry(ct_0, table_column_id_U33, ct_1))), 0);
                (say__p = 1);
                ParaContent();
                style bold;
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U32, ct_1));
                ParaContent();
                style roman;
                ParaContent();
                print "^";
                ParaContent();
                TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
                ParaContent();
                DivideParagraphPoint();
                print "^";
                ParaContent();
                print "Mist fills the area as you move to the next room... ";
                ParaContent();
                DivideParagraphPoint();
                print "^";
                TableBlankOutRow(ct_0, ct_1);
                RulebookSucceeds();
                rtrue;
            }
        }
        @pull ct_1;
        @pull ct_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2707, 1088, 1);
        }
    }
    rfalse;
];
[ call_U2708;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_head_of_the_line_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_ride_entrance_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2708, 1089, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hell_ride_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2708, 1089, 2);
        }
    }
    rfalse;
];
[ call_U2709;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_ride_entrance_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2709, 1090, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_hell_ride_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2709, 1090, 2);
        }
    }
    rfalse;
];
[ call_U2710;
    if ((((action == ##Go)) && ((((actor == player)) && ((((noun == I_south_U1)) && (((((self = actor),1)) && ((I_ride_entrance_U1 == ContainerOf(player))))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2710, 1091, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can";
        ParaContent();
        print "'";
        ParaContent();
        print "t go that way.";
        print "^";
        rtrue;
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2710, 1091, 2);
        }
    }
    rfalse;
];
[ call_U2711;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_ride_entrance_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_stocks_room_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2711, 1092, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridestocks_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2711, 1092, 2);
        }
    }
    rfalse;
];
[ call_U2712;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_stocks_room_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2712, 1093, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridestocks_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2712, 1093, 2);
        }
    }
    rfalse;
];
[ call_U2713;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_stocks_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_gallows_room_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2713, 1094, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridegallows_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2713, 1094, 2);
        }
    }
    rfalse;
];
[ call_U2714;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_gallows_room_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2714, 1095, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridegallows_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2714, 1095, 2);
        }
    }
    rfalse;
];
[ call_U2715;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_gallows_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_stake_room_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2715, 1096, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridestake_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2715, 1096, 2);
        }
    }
    rfalse;
];
[ call_U2716;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_stake_room_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2716, 1097, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridestake_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2716, 1097, 2);
        }
    }
    rfalse;
];
[ call_U2717;
    if ((parameter_value == I_pyre_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2717, 1098, 0);
        }
        (c_style = ((c_style)&((~(((RECURSE_BIT + FULLINV_BIT) + PARTINV_BIT))))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2717, 1098, 2);
        }
    }
    rfalse;
];
[ call_U2718;
    if ((((parameter_value ofclass K5_container)) && (((call_U387(parameter_value)) && (call_U393(parameter_value)))))) {
        if (debug_rules) {
            DB_Rule(call_U2718, 1099, 0);
        }
        (c_style = ((c_style)&((~(((RECURSE_BIT + FULLINV_BIT) + PARTINV_BIT))))));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2718, 1099, 2);
        }
    }
    rfalse;
];
[ call_U2719;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_stake_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_dungeon_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2719, 1100, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridedungeon_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2719, 1100, 2);
        }
    }
    rfalse;
];
[ call_U2720;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_dungeon_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2720, 1101, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_ridedungeon_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2720, 1101, 2);
        }
    }
    rfalse;
];
[ call_U2721;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_dungeon_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_guillotine_room_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2721, 1102, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_rideguillotine_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2721, 1102, 2);
        }
    }
    rfalse;
];
[ call_U2722;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_guillotine_room_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2722, 1103, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_rideguillotine_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2722, 1103, 2);
        }
    }
    rfalse;
];
[ call_U2723;
    if ((((action == ##Go)) && ((((actor == player)) && ((((((noun == I_south_U1)) && (((((((MStack-->(MstVON(var_id_U42, 0))) == I_guillotine_room_U1)) && (((MStack-->(MstVON(var_id_U42, 0))) ofclass K1_room)))) && (((MStack-->(MstVON(var_id_U42, 1))) ~= 0)))))) && (((((self = actor),1)) && (call_U324(I_ride_exit_U1)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2723, 1104, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_rideexit_U1)), 0);
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2723, 1104, 2);
        }
    }
    rfalse;
];
[ call_U2724;
    if ((((action == ##Look)) && ((((actor == player)) && (((((self = actor),1)) && ((real_location == I_ride_exit_U1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2724, 1105, 0);
        }
        DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_rideexit_U1)), 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2724, 1105, 2);
        }
    }
    rfalse;
];
[ call_U2725;
    if ((real_location == I_holding_room_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2725, 1106, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Danger, Will Robinson! This can never happen!";
        print "^";
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2725, 1106, 4);
        }
    }
    rfalse;
];
[ call_U2726;
    if ((((action == ##SwitchOff)) && ((((actor == player)) && ((noun == I_big_switch_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2726, 1107, 0);
        }
        if ((player == WearerOf(I_pair_of_gloves_U1))) {
            call_U2216(I_electrical_room_U1);
            rfalse;
        } else {
            ((Global_Vars-->69) = 1);
            (deadflag = 3);
            (story_complete = 1);
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2726, 1107, 2);
        }
    }
    rfalse;
];
[ call_U2727;
    if ((((((action == ##A_toggling)) || ((((action == ##A_flipping)) || ((action == ##Push)))))) && ((((actor == player)) && ((((noun == I_big_switch_U1)) && (call_U417(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2727, 1108, 0);
        }
        call_U2216(I_electrical_room_U1);
        TryAction(0, player, ##SwitchOn, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2727, 1108, 2);
        }
    }
    rfalse;
];
[ call_U2728;
    if ((((((action == ##A_toggling)) || ((((action == ##A_flipping)) || ((action == ##Push)))))) && ((((actor == player)) && ((((noun == I_big_switch_U1)) && (call_U414(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2728, 1109, 0);
        }
        call_U2215(I_electrical_room_U1);
        TryAction(0, player, ##SwitchOff, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2728, 1109, 2);
        }
    }
    rfalse;
];
[ call_U2729 tmp_0 tmp_1;
    if ((real_location == I_control_room_U1)) {
        if (debug_rules) {
            DB_Rule(call_U2729, 1110, 0);
        }
        call_U2847();
        call_U2860();
        if ((~~(((Global_Vars-->64) == 6)))) {
            call_U2730();
            for (((tmp_0 = (call_U2731)(0)),(tmp_1 = (call_U2731)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U2731)(tmp_1)))) {
                WriteGProperty(OBJECT_TY, tmp_0, A_P_dial_setting, 0);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2729, 1110, 4);
        }
    }
    rfalse;
];
[ call_U2730 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
        (qcn_0)++;
        call_U418(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2731 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K36_dial_First):x:(x = (x.K36_dial_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U2732 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U47());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U47 tmp_0 ct_0 ct_1;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun ofclass K34_control_panel)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2732, 1111, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Each control panel is populated with a dial, a button, and a light. From left to right, the colors are aqua, crimson, emerald, gray, indigo, and khaki. Below the lights is a row of similarly colored dials and below that is a row of buttons. The control panels are ";
        if ((~~(((Global_Vars-->64) == 6)))) {
            jump L_Say0;
        }
        ParaContent();
        print "lit up like a Christmas tree";
        jump L_SayX0;
        .L_Say0;
        ParaContent();
        print "dark";
        .L_SayX0;
        ParaContent();
        print ".";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        (say__p = 1);
        ParaContent();
        PrintShortName(noun);
        ParaContent();
        print " is ";
        if ((~~(((Global_Vars-->64) == 6)))) {
            jump L_Say3;
        }
        ParaContent();
        print "lit";
        jump L_SayX2;
        .L_Say3;
        ParaContent();
        print "dark";
        .L_SayX2;
        ParaContent();
        print ". The ";
        ParaContent();
        @push self;
        E11(GProperty(OBJECT_TY, (self = noun), A_P_color));
        @pull self;
        ParaContent();
        print " dial is set to ";
        ParaContent();
        (formal_par0 = GProperty(OBJECT_TY, (self = (
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2871(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2871(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2881(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2881(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2891(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2891(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
                ))
            +
                ! This evaluate first
                (((formal_par1 = noun) + (formal_par0 = 0))))
        )
        ), A_P_dial_setting));
        if (1) {
            @push self;
            print (say__n = formal_par0);
            @pull self;
        } else {
            ArgumentTypeFailed(1);
        }
        ParaContent();
        print ". The ";
        ParaContent();
        @push self;
        E11(GProperty(OBJECT_TY, (self = noun), A_P_color));
        @pull self;
        ParaContent();
        print " light is now ";
        if ((~~(call_U414((
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(1)))
                ))
            +
                ! This evaluate first
                (((formal_par1 = noun) + (formal_par0 = 0))))
        )
        )))) {
            jump L_Say5;
        }
        ParaContent();
        print "on";
        jump L_SayX3;
        .L_Say5;
        ParaContent();
        print "off";
        .L_SayX3;
        ParaContent();
        print ".";
        print "^";
        if (((((Global_Vars-->64) == 6)) && (call_U2733()))) {
            DisplayFigure((ResourceIDsOfFigures-->(I_figure_of_controlpanel_U1)), 0);
            rtrue;
            WriteGProperty(OBJECT_TY, I_monitor_U1, A_P_figure_id, 0);
            rtrue;
        } else {
            (tmp_0 = GProperty(OBJECT_TY, noun, A_P_panel_id));
            WriteGProperty(OBJECT_TY, I_monitor_U1, A_P_figure_id, tmp_0);
            (ct_0 = table_data_U28);
            (ct_1 = TableRowCorr(ct_0, table_column_id_U26, tmp_0));
            ((Global_Vars-->71) = TableLookUpEntry(ct_0, table_column_id_U27, ct_1));
            if ((((
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K36_dial)) && ((formal_par0 ofclass K36_dial)))) && ((((formal_rv = call_U2856(formal_par0)))|(1))))) || (ArgumentTypeFailed(2028)))
                    ))
                +
                    ! This evaluate first
                    ((formal_par0 = (
                        ! This evaluates last
                        formal_rv+
                        0*(
                            ! This evaluates second
                            ((
                                (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2871(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2871(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2881(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2881(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2891(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2891(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(2028)))
                            ))
                        +
                            ! This evaluate first
                            (((formal_par1 = noun) + (formal_par0 = 0))))
                    )
                    )))
            )
            ) && (call_U414((
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2170(formal_par1)))))) && ((((formal_rv = call_U2865(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((((formal_par1 ofclass K2_thing)) && (call_U2177(formal_par1)))))) && ((((formal_rv = call_U2875(formal_par0, formal_par1)))|(1))))) || ((((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))) || ((((((formal_par1 ofclass K2_thing)) && ((formal_par1 ofclass K2_thing)))) && ((((formal_rv = call_U2885(formal_par0, formal_par1)))|(1))))))))))))))) || (ArgumentTypeFailed(2028)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = noun) + (formal_par0 = 0))))
            )
            )))) {
                DisplayFigure((ResourceIDsOfFigures-->(TableLookUpEntry(ct_0, table_column_id_U27, ct_1))), 0);
            }
        }
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2732, 1111, 2);
        }
    }
    rfalse;
];
[ call_U2733 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
        (qcn_0)++;
        if (call_U417(x)) {
            (qcy_0)++;
        }
    }
    if ((qcy_0 == qcn_0)) {
        rtrue;
    }
    rfalse;
];
[ call_U2734;
    if ((((action == ##Push)) && ((((actor == player)) && ((((noun ofclass K35_button)) && (call_U417(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2734, 1118, 0);
        }
        TryAction(0, player, ##SwitchOn, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2734, 1118, 2);
        }
    }
    rfalse;
];
[ call_U2735;
    if ((((action == ##Push)) && ((((actor == player)) && ((((noun ofclass K35_button)) && (call_U414(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2735, 1119, 0);
        }
        TryAction(0, player, ##SwitchOff, noun, 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2735, 1119, 2);
        }
    }
    rfalse;
];
[ call_U2736 tmp_0 ct_0 ct_1;
    if ((((actor == player)) && ((((noun ofclass K35_button)) && (((((self = actor),1)) && (((((Global_Vars-->64) == 6)) && (((Global_Vars-->70) == 6)))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2736, 1120, 0);
        }
        (tmp_0 = GProperty(OBJECT_TY, HolderOf(noun), A_P_panel_id));
        (ct_0 = table_data_U28);
        (ct_1 = TableRowCorr(ct_0, table_column_id_U26, tmp_0));
        ((Global_Vars-->71) = TableLookUpEntry(ct_0, table_column_id_U27, ct_1));
        (say__p = 1);
        ParaContent();
        print "The monitor flickers for a second and the scene it displays changes to something different.";
        print "^";
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        print "The ";
        ParaContent();
        @push self;
        E11(GProperty(OBJECT_TY, (self = HolderOf(noun)), A_P_color));
        @pull self;
        ParaContent();
        print " light is now on.";
        print "^";
        DisplayFigure((ResourceIDsOfFigures-->((Global_Vars-->71))), 0);
        call_U2737();
        call_U415(noun);
        WriteGProperty(OBJECT_TY, I_monitor_U1, A_P_figure_id, tmp_0);
        if ((GProperty(OBJECT_TY, HolderOf(noun), A_P_color) == I_indigo_U1)) {
            (deadflag = 3);
            (story_complete = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2736, 1120, 2);
        }
    }
    rfalse;
];
[ call_U2737 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
        (qcn_0)++;
        call_U418(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2738 ct_0 ct_1;
    if ((((actor == player)) && ((noun ofclass K35_button)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2738, 1121, 0);
        }
        (ct_0 = table_data_U28);
        (ct_1 = TableRowCorr(ct_0, table_column_id_U26, 0));
        ((Global_Vars-->71) = TableLookUpEntry(ct_0, table_column_id_U27, ct_1));
        (say__p = 1);
        ParaContent();
        print "The monitor turns off and the screen goes black.";
        print "^";
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        print "The ";
        ParaContent();
        @push self;
        E11(GProperty(OBJECT_TY, (self = HolderOf(noun)), A_P_color));
        @pull self;
        ParaContent();
        print " light is now off.";
        print "^";
        DisplayFigure((ResourceIDsOfFigures-->((Global_Vars-->71))), 0);
        WriteGProperty(OBJECT_TY, I_monitor_U1, A_P_figure_id, 0);
        call_U2739();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2738, 1121, 2);
        }
    }
    rfalse;
];
[ call_U2739 x x_ix qcy_0 qcn_0;
    (qcy_0 = 0);
    (qcn_0 = 0);
    for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
        (qcn_0)++;
        call_U418(x);
        (qcy_0)++;
    }
    if ((qcy_0 == qcn_0)) {
    }
];
[ call_U2740;
    if ((((action == ##A_spinning_it_to)) && ((((actor == player)) && ((noun ofclass K36_dial)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2740, 1126, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_likely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2740, 1126, 2);
        }
    }
    rfalse;
];
[ call_U2741;
    if ((((action == ##A_spinning_it_to)) && ((((actor == player)) && ((noun ofclass K34_control_panel)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2741, 1127, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_unlikely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2741, 1127, 2);
        }
    }
    rfalse;
];
[ call_U2742;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2742, 1128, 0);
        }
        if ((~~((noun ofclass K36_dial)))) {
            (say__p = 1);
            ParaContent();
            CDefArt(noun);
            ParaContent();
            print " does not spin.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2742, 1128, 3);
        }
    }
    rfalse;
];
[ call_U2743;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2743, 1129, 0);
        }
        if ((((parsed_number < 0)) || ((parsed_number > 20)))) {
            (say__p = 1);
            ParaContent();
            print "The ";
            ParaContent();
            @push self;
            E11(GProperty(OBJECT_TY, (self = HolderOf(noun)), A_P_color));
            @pull self;
            ParaContent();
            print " colored dial can only be set from 0 to 20.";
            print "^";
            rtrue;
        } else {
            (say__p = 1);
            ParaContent();
            print "The ";
            ParaContent();
            @push self;
            E11(GProperty(OBJECT_TY, (self = HolderOf(noun)), A_P_color));
            @pull self;
            ParaContent();
            print " colored dial is now set to ";
            ParaContent();
            print (say__n = parsed_number);
            ParaContent();
            print ".";
            print "^";
            if ((~~(((Global_Vars-->64) == 6)))) {
                (say__p = 1);
                ParaContent();
                print "Before your eyes, the dial spins back to 0.";
                print "^";
                WriteGProperty(OBJECT_TY, noun, A_P_dial_setting, 0);
            } else {
                WriteGProperty(OBJECT_TY, noun, A_P_dial_setting, parsed_number);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2743, 1129, 3);
        }
    }
    rfalse;
];
[ call_U2744 tmp_0 ct_0 ct_1;
    if ((((action == ##Examine)) && ((((actor == player)) && ((noun == I_monitor_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2744, 1133, 0);
        }
        (tmp_0 = GProperty(OBJECT_TY, I_monitor_U1, A_P_figure_id));
        (ct_0 = table_data_U28);
        (ct_1 = TableRowCorr(ct_0, table_column_id_U26, tmp_0));
        (say__p = 1);
        ParaContent();
        print "The monitor flickers for a second and the scene it displays changes to something different.";
        print "^";
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
        ParaContent();
        print "^";
        ((Global_Vars-->71) = TableLookUpEntry(ct_0, table_column_id_U27, ct_1));
        DisplayFigure((ResourceIDsOfFigures-->((Global_Vars-->71))), 0);
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2744, 1133, 2);
        }
    }
    rfalse;
];
[ call_U2745 RV;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    (RV = kernel1_U48());
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U48 ct_0 ct_1;
    if (debug_rules) {
        DB_Rule(call_U2745, 1134, 0);
    }
    (ct_0 = table_data_U8);
    (ct_1 = 1);
    BlkValueCopy((TableLookUpEntry)(ct_0,table_column_id_U10,ct_1,5), (((LocalParking-->(0)) = ct_0),(((LocalParking-->(1)) = ct_1),TEXT_TY_ExpandIfPerishable(I7SFRAME, ts_array_U636))));
    rfalse;
];
[ call_U2746 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Hell Ride - A Ride to remember...^^In the early 1980[']s, I had an Apple II Plus computer with 64K of RAM, dual 5.25[quotation mark] floppy disks, and a color monitor as big as a television. And the very first game I ever bought was Infocom[']s Zork I: The Great Underground Empire. This was cool. It was all text-based. The game described your surroundings and you interacted with commands that say what you wanted to do. This 'Interactive Fiction' really evoked in a game what I appreciated most about reading: rich descriptions, colorful characters, and the like. After Zork I, there was Zork II and III. Enchanter, Moonmist, Suspect, and so many^more. I played them all with my best friend Andy.^^Andy and I were software developers at the time and we thought, 'We can do this!' So we set out to do this. We developed a game engine with a natural language parser. And it was pretty good. We could support most of the kinds of things they did, certainly less graceful but pretty good. In fact, our parser was better than Infocom[']s in one case where the sentence was ambiguous. e.g. 'Walk into the room with the lamp.' Is the player carrying the lamp? Or is the lamp in the room?^^For fun, we reverse engineered parts of Infocom[']s game format. We found the dictionary, certain text tokens used for text substitution, the game text. We also discovered the first example of compression I had ever seen and it just about made my head explode. They stored all ASCII characters in five bits! Pow! Mind blown. I had never considered anything like that. Just another hook.^^We developed two prototypes: Diner and Hell Ride. Diner was about bank robbers coming into the diner where you are a short order cook and you have to save the day. Hell Ride was pretty close to what you find here. I decided to implement it using modern tools. It[']s pretty good. Maybe.^^I hope you enjoy it.^^d.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Hell Ride - A Ride to remember...^^In the early 1980";
    ParaContent();
    print "'";
    ParaContent();
    print "s, I had an Apple II Plus computer with 64K of RAM, dual 5.25";
    ParaContent();
    print "~";
    ParaContent();
    print " floppy disks, and a color monitor as big as a television. And the very first game I ever bought was Infocom";
    ParaContent();
    print "'";
    ParaContent();
    print "s Zork I: The Great Underground Empire. This was cool. It was all text-based. The game described your surroundings and you interacted with commands that say what you wanted to do. This ~Interactive Fiction~ really evoked in a game what I appreciated most about reading: rich descriptions, colorful characters, and the like. After Zork I, there was Zork II and III. Enchanter, Moonmist, Suspect, and so many more. I played them all with my best friend Andy.^^Andy and I were software developers at the time and we thought, ~We can do this!~ So we set out to do this. We developed a game engine with a natural language parser. And it was pretty good. We could support most of the kinds of things they did, certainly less graceful but pretty good. In fact, our parser was better than Infocom";
    ParaContent();
    print "'";
    ParaContent();
    print "s in one case where the sentence was ambiguous. e.g. ~Walk into the room with the lamp.~ Is the player carrying the lamp? Or is the lamp in the room?^^For fun, we reverse engineered parts of Infocom";
    ParaContent();
    print "'";
    ParaContent();
    print "s game format. We found the dictionary, certain text tokens used for text substitution, the game text. We also discovered the first example of compression I had ever seen and it just about made my head explode. They stored all ASCII characters in five bits! Pow! Mind blown. I had never considered anything like that. Just another hook.^^We developed two prototypes: Diner and Hell Ride. Diner was about bank robbers coming into the diner where you are a short order cook and you have to save the day. Hell Ride was pretty close to what you find here. I decided to implement it using modern tools. It";
    ParaContent();
    print "'";
    ParaContent();
    print "s pretty good. Maybe.^^I hope you enjoy it.^^d.";
    rtrue;
];
[ call_U2747;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2747, 1135, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(bc_U1860);
        ParaContent();
        print ", Copyright 2025 by Dana Montgomery and 1988 by No Shoes.";
        ParaContent();
        DivideParagraphPoint();
        print "^";
        (say__p = 1);
        ParaContent();
        print "Extensions used in ";
        ParaContent();
        TEXT_TY_Say(bc_U1861);
        ParaContent();
        print ":";
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        ShowFullExtensionVersions();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2747, 1135, 3);
        }
    }
    rfalse;
];
[ call_U2748;
    if ((((PAPR6)()) && (((((TimesActionHasHappened-->(ahc_id_U6)) == 1)) && ((ActionCurrentlyHappeningFlag->(ahc_id_U6))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U2748, 1136, 0);
        }
        (say__p = 1);
        ParaContent();
        print "Sometimes the temptation to rely on hints becomes overwhelming, and you may prefer to turn off hints now. If you do so, your further requests for guidance will be denied. Turn off hints? >";
        if (YesOrNo()) {
            ((Global_Vars-->72) = I_denied_U1);
            (say__p = 1);
            ParaContent();
            print "^";
            ParaContent();
            print "Truly, a real adventurer does not need hints.";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2748, 1136, 2);
        }
    }
    rfalse;
];
[ call_U2749;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U2749, 1137, 0);
        }
        if (((Global_Vars-->72) == I_denied_U1)) {
            (say__p = 1);
            ParaContent();
            print "You have chosen to forego hints in this game. Be strong! Persevere!";
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U2749, 1137, 3);
        }
    }
    rfalse;
];
[ call_U2750 value rem S;
    print "$";
    print (value/100);
    print ".";
    if (((value%100) < 10)) {
        print "0";
    }
    print (value%100);
    rtrue;
];
[ call_U2751 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (wpos = 0);
    (mid_word = 0);
    (matched_number = 0);
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 36)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    (sgn = 1);
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((sgn == 1)) {
        if ((((tot > 21474836)) || ((((tot == 21474836)) && ((matched_number > 21474836)))))) {
            jump Failed;
        }
    } else {
        if ((((tot > 21474836)) || ((((tot == 21474836)) && ((matched_number > 21474836)))))) {
            jump Failed;
        }
    }
    (tot = ((100*tot) + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 46)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((tot >= 100)) {
        jump Failed;
    }
    (tot = (tot + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if (mid_word) {
        jump Failed;
    }
    if ((sgn < 0)) {
        (matched_number = (-1*matched_number));
    }
    (parsed_number = matched_number);
    (parsed_number = (parsed_number + x));
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "  [parsed value ";
            print parsed_number;
            print " by: $10.99]^";
        }
    #endif;
    return GPR_NUMBER;
    .Failed;
    return GPR_FAIL;
];
[ call_U2752 value rem S;
    print (value/10);
    if (((value%10) == 0)) {
        rtrue;
    }
    print ".";
    print (value%10);
    print " ";
    print "fl";
    print " ";
    print "oz";
    rtrue;
];
[ call_U2753 original_wn group_wn v w rv wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f x;
    (wpos = 0);
    (mid_word = 0);
    (matched_number = 0);
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    (sgn = 1);
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((sgn == 1)) {
        if ((((tot > 214748364)) || ((((tot == 214748364)) && ((matched_number > 214748364)))))) {
            jump Failed;
        }
    } else {
        if ((((tot > 214748364)) || ((((tot == 214748364)) && ((matched_number > 214748364)))))) {
            jump Failed;
        }
    }
    (tot = ((10*tot) + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Succeeded;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->((wpos)++)) ~= 46)) {
        jump Failed;
    }
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if ((mid_word == 0)) {
        (mid_word = 1);
        (wpos = 0);
        (cur_addr = WordAddress(wn));
        (cur_len = WordLength(wn));
    }
    if (((cur_addr->(wpos)) == 45)) {
        jump Failed;
    }
    (tot = 0);
    (f = 0);
    while ((((wpos < cur_len)) && ((DigitToValue((cur_addr->(wpos))) >= 0)))) {
        (f = DigitToValue((cur_addr->(wpos))));
        if ((sgn == 1)) {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        } else {
            if ((((tot > 214748364)) || ((((tot == 214748364)) && ((f > 214748364)))))) {
                jump Failed;
            }
        }
        (tot = ((10*tot) + f));
        (f = 1);
        (wpos)++;
    }
    if ((f == 0)) {
        jump Failed;
    }
    if ((tot >= 10)) {
        jump Failed;
    }
    (tot = (tot + matched_number));
    (matched_number = tot);
    if ((wpos == cur_len)) {
        (wn)++;
        (mid_word = 0);
    }
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if (mid_word) {
        jump Failed;
    }
    if ((cur_word ~= 'fl')) {
        jump Failed;
    }
    (wn)++;
    if ((mid_word == 0)) {
        (cur_word = NextWordStopped());
        (wn)--;
        if ((cur_word == -1)) {
            jump Failed;
        }
    }
    if (mid_word) {
        jump Failed;
    }
    if ((cur_word ~= 'oz')) {
        jump Failed;
    }
    (wn)++;
    .Succeeded;
    if (mid_word) {
        jump Failed;
    }
    if ((sgn < 0)) {
        (matched_number = (-1*matched_number));
    }
    (parsed_number = matched_number);
    (parsed_number = (parsed_number + x));
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "  [parsed value ";
            print parsed_number;
            print " by: 15.9 fl oz]^";
        }
    #endif;
    return GPR_NUMBER;
    .Failed;
    return GPR_FAIL;
];
[ call_U2754;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The music alternates between hauntingly slow melodies and rapid, energetic drum beats, creating an emotional arc that keeps you entranced. Little Egypt relies on the music[']s dynamic changes to tell a story with movements reflecting joy, sorrow, seduction, and celebration.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The music alternates between hauntingly slow melodies and rapid, energetic drum beats, creating an emotional arc that keeps you entranced. Little Egypt relies on the music";
    ParaContent();
    print "'";
    ParaContent();
    print "s dynamic changes to tell a story with movements reflecting joy, sorrow, seduction, and celebration.";
    rtrue;
];
[ call_U2755;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The dungeon is a dark, suffocating chamber carved into the earth, its stone walls slick with moisture and grime. The air reeks of sweat, blood, mildew, and burning oil from flickering torches mounted on rusted sconces. Shadows twist on the walls, creating grotesque, unsettling shapes in the dim light.^^Chains hang from walls and ceilings, their faint clinking blending with the moans and occasional screams of prisoners. Water drips rhythmically from a cracked ceiling, adding to the chamber[']s eerie ambiance.^^The room is littered with instruments of torment: a splintered rack, a glowing brazier holding bloodstained tools, and a spiked chair gleaming faintly in the light. Prisoners endure their own horrors - one stretched on the rack, another hanging limply from manacles, and a third gasping weakly in the spiked chair.^^The hooded torturer moves with detached precision, their leather apron stained with the evidence of countless victims. They work silently, indifferent to the agony surrounding them.^^Above, rats scuttle in the shadows, and the low ceiling presses down like the weight of despair. The sole exit, a riveted iron-bound door, feels more like a barrier to hope than a path to freedom.^^This is a realm of suffering and hopelessness, where life and death blur, and torment is the only certainty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The dungeon is a dark, suffocating chamber carved into the earth, its stone walls slick with moisture and grime. The air reeks of sweat, blood, mildew, and burning oil from flickering torches mounted on rusted sconces. Shadows twist on the walls, creating grotesque, unsettling shapes in the dim light.^^Chains hang from walls and ceilings, their faint clinking blending with the moans and occasional screams of prisoners. Water drips rhythmically from a cracked ceiling, adding to the chamber";
    ParaContent();
    print "'";
    ParaContent();
    print "s eerie ambiance.^^The room is littered with instruments of torment: a splintered rack, a glowing brazier holding bloodstained tools, and a spiked chair gleaming faintly in the light. Prisoners endure their own horrors - one stretched on the rack, another hanging limply from manacles, and a third gasping weakly in the spiked chair.^^The hooded torturer moves with detached precision, their leather apron stained with the evidence of countless victims. They work silently, indifferent to the agony surrounding them.^^Above, rats scuttle in the shadows, and the low ceiling presses down like the weight of despair. The sole exit, a riveted iron-bound door, feels more like a barrier to hope than a path to freedom.^^This is a realm of suffering and hopelessness, where life and death blur, and torment is the only certainty.";
    rtrue;
];
[ call_U2756;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The public square buzzes with tense anticipation, a crowd gathered under gray skies that cast a somber light on the cobblestones. At the center, a stark wooden platform looms, its purpose grim and unavoidable.^^A lone figure stands on the scaffold, bound hands behind their back and head bowed low, avoiding the crowd's gaze. Their tattered clothing, once fine, reflects the fall that led them to this moment.^^The crowd encircles the platform, emotions ranging from jeers and curses to silent, grim observation. Children sit on shoulders, their curious eyes unaware of the event's gravity. Near the edge of the platform, the town crier proclaims the crime: 'High treason against the crown. Let this be a warning to all who defy the realm!'^^The condemned flinches but remains silent as the executioner - a hooded figure in black - stands ready beside the guillotine, its blade gleaming faintly in the dim light. The murmurs of the crowd fall into silence at the executioner's signal, leaving only the rustle of wind and the creak of the scaffold.^^As the condemned approaches the guillotine, a crow caws sharply from a nearby rooftop, its cry echoing through the square like an omen. The crowd leans forward, breath held, as justice and mortality converge on the scene.^^There is just one problem: the guillotine is being raised and lowered by some mechanism. It appears that the timing of the guillotine is off and it is being lowered onto the cars instead of between them. If a person were to be in a car as it passed under the guillotine, they would be decapitated.^[if the player is in the hell ride car]^^Looks like your goose is cooked. Say 'Goodnight, Gracie!'^^You are stupefied as you sit watching guillotine rising and falling, dropping like a stone on the cars in front of you. Thank goodness they are empty. As your turn comes, you raise your hands in a feeble attempt to stop the inevitable.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The public square buzzes with tense anticipation, a crowd gathered under gray skies that cast a somber light on the cobblestones. At the center, a stark wooden platform looms, its purpose grim and unavoidable.^^A lone figure stands on the scaffold, bound hands behind their back and head bowed low, avoiding the crowd's gaze. Their tattered clothing, once fine, reflects the fall that led them to this moment.^^The crowd encircles the platform, emotions ranging from jeers and curses to silent, grim observation. Children sit on shoulders, their curious eyes unaware of the event's gravity. Near the edge of the platform, the town crier proclaims the crime: ~High treason against the crown. Let this be a warning to all who defy the realm!~^^The condemned flinches but remains silent as the executioner - a hooded figure in black - stands ready beside the guillotine, its blade gleaming faintly in the dim light. The murmurs of the crowd fall into silence at the executioner's signal, leaving only the rustle of wind and the creak of the scaffold.^^As the condemned approaches the guillotine, a crow caws sharply from a nearby rooftop, its cry echoing through the square like an omen. The crowd leans forward, breath held, as justice and mortality converge on the scene.^^There is just one problem: the guillotine is being raised and lowered by some mechanism. It appears that the timing of the guillotine is off and it is being lowered onto the cars instead of between them. If a person were to be in a car as it passed under the guillotine, they would be decapitated. ";
    ParaContent();
    if ((~~((I_hell_ride_car_U1 == ContainerOf(player))))) {
        jump L_Say0;
    }
    ParaContent();
    print "^^Looks like your goose is cooked. Say ~Goodnight, Gracie!~^^You are stupefied as you sit watching guillotine rising and falling, dropping like a stone on the cars in front of you. Thank goodness they are empty. As your turn comes, you raise your hands in a feeble attempt to stop the inevitable.";
    .L_Say0;
    rtrue;
];
[ call_U2757;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The exit of Hell Ride is designed to leave riders with lingering unease. Emerging from a dark corridor with peeling black and red-streaked walls, flickering lights cast erratic shadows on the uneven floor. The air is cool and damp, carrying a faint metallic tang, while faint whispers and distant screams echo softly in the background.^^Riders step into a small courtyard enclosed by jagged, rusted fencing draped with cobwebs and plastic bones. Overhead, a weathered sign reads, 'You[']ve Survived[unicode 8230] For Now.' Nearby, carnival workers in tattered costumes watch silently, occasionally muttering cryptic remarks like, 'Not everyone makes it out.'^^A merchandise stand glows red, selling items like Hell Ride Survivor t-shirts and devil horns. Beyond the fencing, the cheerful carnival lights and sounds feel jarring, contrasting sharply with the ride's oppressive atmosphere.^^The exit ensures Hell Ride isn't just an experience - it lingers, blurring the line between thrill and fear.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The exit of Hell Ride is designed to leave riders with lingering unease. Emerging from a dark corridor with peeling black and red-streaked walls, flickering lights cast erratic shadows on the uneven floor. The air is cool and damp, carrying a faint metallic tang, while faint whispers and distant screams echo softly in the background.^^Riders step into a small courtyard enclosed by jagged, rusted fencing draped with cobwebs and plastic bones. Overhead, a weathered sign reads, ~You";
    ParaContent();
    print "'";
    ParaContent();
    print "ve Survived";
    ParaContent();
    (unicode_temp = 8230);
    @streamunichar unicode_temp;
    ParaContent();
    print " For Now.~ Nearby, carnival workers in tattered costumes watch silently, occasionally muttering cryptic remarks like, ~Not everyone makes it out.~^^A merchandise stand glows red, selling items like Hell Ride Survivor t-shirts and devil horns. Beyond the fencing, the cheerful carnival lights and sounds feel jarring, contrasting sharply with the ride's oppressive atmosphere.^^The exit ensures Hell Ride isn't just an experience - it lingers, blurring the line between thrill and fear.";
    rtrue;
];
[ call_U2758;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Why can[']t I leave the parking lot?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Why can";
    ParaContent();
    print "'";
    ParaContent();
    print "t I leave the parking lot?";
    rtrue;
];
[ call_U2759;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I[']ve found a Mercury dime. What is it?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I";
    ParaContent();
    print "'";
    ParaContent();
    print "ve found a Mercury dime. What is it?";
    rtrue;
];
[ call_U2760;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What[']s going on in the Electrical Room?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What";
    ParaContent();
    print "'";
    ParaContent();
    print "s going on in the Electrical Room?";
    rtrue;
];
[ call_U2761;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the blueberries are handled]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U354(I_blueberries_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2762;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the blueberries are consumed]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2217(I_blueberries_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2763;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the keys are visible]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U293(I_your_keys_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2764;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the Hell Ride ticket]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_hell_ride_ticket_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2765;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is wearing the sheer veil]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == WearerOf(I_sheer_veil_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2766;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the lantern]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_lantern_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2767;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the flashlight]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_flashlight_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2768;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the mercury dime]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_mercury_dime_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2769;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the big switch is switched off]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U417(I_big_switch_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2770;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the location is the Control Room]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((real_location == I_control_room_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2771;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the location is the Dark Passage]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((real_location == I_dark_passage_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2772;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the bumper cars attendant is carrying the adjustable wrench]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((I_bumper_cars_attendant_U1 == CarrierOf(I_adjustable_wrench_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2773;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the aqua fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2774()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2774 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2196(x)) && (call_U2196(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2775;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the emerald fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2776()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2776 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2200(x)) && (call_U2200(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2777;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the gray fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2778()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2778 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2202(x)) && (call_U2202(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2779;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the indigo fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2780()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2780 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2204(x)) && (call_U2204(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2781;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the khaki fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2782()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2782 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2206(x)) && (call_U2206(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2783;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet one's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_one_s_el_U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2784;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet three's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_three_s__U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2785;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet five's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_five_s_e_U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2786;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet seven's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_seven_s__U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2787;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet nine's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_nine_s_e_U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2788;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if electrical closet eleven's electrical panel's switch is switched on]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U414(I_electrical_closet_eleven_s_U4)))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2789;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the teddy bear]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_teddy_bear_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2790;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the Swiss Army knife]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_swiss_army_knife_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2791;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the poster of Taylor Swift]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_poster_of_taylor_swift_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2792;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the magenta fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2793()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2793 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2208(x)) && (call_U2208(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2794;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the small plush monkey]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_small_plush_monkey_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2795;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the orange fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2796()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2796 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2210(x)) && (call_U2210(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2797;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the poster of Billie Eilish]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_poster_of_billie_eilish_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2798;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the pocket mirror]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_small_pocket_mirror_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2799;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the crimson fuse]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~(call_U2800()))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2800 x x_ix;
    objectloop (x in player) {
        if ((CarrierOf(x) == parent(x))) {
            if ((((x ofclass K29_fuse)) && (((call_U2198(x)) && (call_U2198(x)))))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U2801;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the small plush donkey]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_small_plush_donkey_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2802;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the goldfish]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_goldfish_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2803;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the player is carrying the poster of Lourde]Y[otherwise]N[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((player == CarrierOf(I_poster_of_lourde_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "Y";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "N";
    .L_SayX0;
    rtrue;
];
[ call_U2804;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~He[']s just trying to earn enough money to take his sweetie to the movies next week.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "He";
    ParaContent();
    print "'";
    ParaContent();
    print "s just trying to earn enough money to take his sweetie to the movies next week.";
    rtrue;
];
[ call_U2805;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~He[']s thinking about having a brewski with his bros after work.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "He";
    ParaContent();
    print "'";
    ParaContent();
    print "s thinking about having a brewski with his bros after work.";
    rtrue;
];
[ call_U2806;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~He[']s thinking about the big game on Friday night.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "He";
    ParaContent();
    print "'";
    ParaContent();
    print "s thinking about the big game on Friday night.";
    rtrue;
];
[ call_U2807;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~He[']s wondering if his SAT scores are good enough to get into college.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "He";
    ParaContent();
    print "'";
    ParaContent();
    print "s wondering if his SAT scores are good enough to get into college.";
    rtrue;
];
[ call_U2808;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~He[']s wondering why he took this stupid job in the first place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "He";
    ParaContent();
    print "'";
    ParaContent();
    print "s wondering why he took this stupid job in the first place.";
    rtrue;
];
[ call_U2809;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Old Time Rock[']N[']Roll~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Old Time Rock";
    ParaContent();
    print "'";
    ParaContent();
    print "N";
    ParaContent();
    print "'";
    ParaContent();
    print "Roll";
    rtrue;
];
[ call_U2810;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s locked.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s locked.";
    rtrue;
];
[ call_U2811;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Isn[']t macrame the art of tying?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Isn";
    ParaContent();
    print "'";
    ParaContent();
    print "t macrame the art of tying?";
    rtrue;
];
[ call_U2812;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You[']ll need a ticket.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "ll need a ticket.";
    rtrue;
];
[ call_U2813;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a small carnival, what do you expect?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a small carnival, what do you expect?";
    rtrue;
];
[ call_U2814;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Important? That[']s a matter of opinion.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Important? That";
    ParaContent();
    print "'";
    ParaContent();
    print "s a matter of opinion.";
    rtrue;
];
[ call_U2815;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I[']d go with my instincts on this one if I were you.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I";
    ParaContent();
    print "'";
    ParaContent();
    print "d go with my instincts on this one if I were you.";
    rtrue;
];
[ call_U2816;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime.";
    rtrue;
];
[ call_U2817;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a Mercury Dime.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a Mercury Dime.";
    rtrue;
];
[ call_U2818;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s a dime. Geez.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s a dime. Geez.";
    rtrue;
];
[ call_U2819;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Only if you want to know what[']s on the other side.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Only if you want to know what";
    ParaContent();
    print "'";
    ParaContent();
    print "s on the other side.";
    rtrue;
];
[ call_U2820;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Have you tried checking what[']s on the other side?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Have you tried checking what";
    ParaContent();
    print "'";
    ParaContent();
    print "s on the other side?";
    rtrue;
];
[ call_U2821;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You[']ll need a key~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You";
    ParaContent();
    print "'";
    ParaContent();
    print "ll need a key";
    rtrue;
];
[ call_U2822;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s in Electrical Closet One~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s in Electrical Closet One";
    rtrue;
];
[ call_U2823;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~So, you[']ve ridden Hell Ride.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "So, you";
    ParaContent();
    print "'";
    ParaContent();
    print "ve ridden Hell Ride.";
    rtrue;
];
[ call_U2824;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Aren[']t the animatronics and wax figures amazing?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Aren";
    ParaContent();
    print "'";
    ParaContent();
    print "t the animatronics and wax figures amazing?";
    rtrue;
];
[ call_U2825;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Aren[']t the animatronics and wax figures amazing?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Aren";
    ParaContent();
    print "'";
    ParaContent();
    print "t the animatronics and wax figures amazing?";
    rtrue;
];
[ call_U2826;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~There[']s the Stocks, the Gallows, the Stake, the Dungeon, and the Guillotine.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "There";
    ParaContent();
    print "'";
    ParaContent();
    print "s the Stocks, the Gallows, the Stake, the Dungeon, and the Guillotine.";
    rtrue;
];
[ call_U2827;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Maybe that[']s causing the problem.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Maybe that";
    ParaContent();
    print "'";
    ParaContent();
    print "s causing the problem.";
    rtrue;
];
[ call_U2828;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Maybe you can make it so it[']s not electromagnetic.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Maybe you can make it so it";
    ParaContent();
    print "'";
    ParaContent();
    print "s not electromagnetic.";
    rtrue;
];
[ call_U2829;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~There[']s a socket, a switch, and an indictor in each one.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "There";
    ParaContent();
    print "'";
    ParaContent();
    print "s a socket, a switch, and an indictor in each one.";
    rtrue;
];
[ call_U2830;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I[']d put a fuse in the socket and flip the switch.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I";
    ParaContent();
    print "'";
    ParaContent();
    print "d put a fuse in the socket and flip the switch.";
    rtrue;
];
[ call_U2831;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s big~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s big";
    rtrue;
];
[ call_U2832;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~It[']s in the Control Room.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "It";
    ParaContent();
    print "'";
    ParaContent();
    print "s in the Control Room.";
    rtrue;
];
[ call_U2833 t_0 tmp_0;
    if ((t_0 < 5)) {
        (say__p = 1);
        ParaContent();
        print "a swallow or two";
    } else {
        if (((((t_0%10) > 3)) && (((t_0%10) < 7)))) {
            (tmp_0 = (t_0/10));
            (say__p = 1);
            ParaContent();
            LanguageNumber((say__n = tmp_0));
            ParaContent();
            print " or ";
            ParaContent();
            LanguageNumber((say__n = (tmp_0 + 1)));
            ParaContent();
            print " fluid ounces";
        } else {
            if (((t_0%10) > 6)) {
                (t_0 = (t_0 + 10));
            }
            (say__p = 1);
            ParaContent();
            print "about ";
            ParaContent();
            LanguageNumber((say__n = (t_0/10)));
            ParaContent();
            print " fluid ounce";
            ParaContent();
            STextSubstitution();
        }
    }
    rfalse;
];
[ call_U2834;
    (say__p = 1);
    ParaContent();
    if (((label_associated_storage_U2200-->(0)) == 0)) {
        ((label_associated_storage_U2199-->(0)) = (I7_SOO_RAN)((label_associated_storage_U2199-->(0)),4));
        ((label_associated_storage_U2200-->(0)) = 1);
    }
    if ((say__comp == 0)) {
        ((label_associated_storage_U2200-->(0)) = 0);
    }
    switch ((((label_associated_storage_U2199-->(0))%(4 + 1)) - 1)) {
        0:
            ParaContent();
            print "That ride is scary. You won";
            ParaContent();
            print "'";
            ParaContent();
            print "t catch me on it!";
            print "^";
            ParaContent();
            @nop;
            ;
        1:
            ParaContent();
            print "Last time I rode Hell Ride I heard strange noises.";
            print "^";
            ParaContent();
            @nop;
            ;
        2:
            ParaContent();
            print "Hell ride is so old that It's falling apart. I wouldn";
            ParaContent();
            print "'";
            ParaContent();
            print "t ride it.";
            print "^";
            ParaContent();
            @nop;
            ;
        3:
            ParaContent();
            print "Hell Ride is behind on it";
            ParaContent();
            print "'";
            ParaContent();
            print "s maintenance schedule. Might want to skip that one.";
            print "^";
            ParaContent();
            ;
    }
    rfalse;
];
[ call_U2835 ct_0 ct_1 tmp_0 tmp_1;
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U25),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((TableLookUpEntry(ct_0, table_column_id_U21, ct_1) == -1)) {
                if (((BlkValueCompare)(TableLookUpEntry(ct_0, table_column_id_U19, ct_1),bc_U2134) == 0)) {
                    (TableLookUpEntry)(ct_0,table_column_id_U21,ct_1,1,turns);
                    (score = (score + TableLookUpEntry(ct_0, table_column_id_U20, ct_1)));
                    FollowRulebook(call_U1078);
                    PlaySound((ResourceIDsOfSounds-->(I_sound_of_bell_U1)), 0);
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U2836 RV;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(0, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    (RV = kernel1_U49());
    BlkValueFreeOnStack(0);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(4);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U49 tmp_0 ct_0 ct_1;
    (tmp_0 = I7SFRAME);
    BlkValueCopy(tmp_0, (((LocalParking-->(0)) = tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*2)), ts_array_U708)));
    if (ExistsTableLookUpCorr((Global_Vars-->60), table_column_id_U28, table_column_id_U28, tmp_0)) {
        (ct_0 = (Global_Vars-->60));
        (ct_1 = TableRowCorr(ct_0, table_column_id_U28, BlkValueCopy((I7SFRAME + (WORDSIZE*4)), tmp_0)));
        (say__p = 1);
        ParaContent();
        print "You are now holding ";
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U10, ct_1));
        ParaContent();
        print ".";
        print "^";
        MoveObject(TableLookUpEntry(ct_0, table_column_id_U29, ct_1), real_location);
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, player, ##Take, TableLookUpEntry(ct_0, table_column_id_U29, ct_1), 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
        ((Global_Vars-->61) = 1);
        call_U2835();
        RulebookFails();
        rtrue;
    } else {
        ((Global_Vars-->61) = 0);
        rfalse;
    }
    rfalse;
];
[ call_U2837 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[the player's command]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    PrintSnippet(players_command);
    rtrue;
];
[ call_U2838 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2839 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2840 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2841 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2842 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2843 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2844 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2845 t_0 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    (RV = kernel1_U50(t_0));
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U50 t_0 tmp_0;
    if (call_U2171(t_0)) {
        (tmp_0 = (call_U2846)(t_0));
        if ((GProperty(OBJECT_TY, tmp_0, A_P_color) == (
            ! This evaluates last
            formal_rv+
            0*(
                ! This evaluates second
                ((
                    (((((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2170(formal_par0)))))) && ((((formal_rv = call_U2838(formal_par0)))|(1))))) || ((((((formal_par0 ofclass K2_thing)) && ((((formal_par0 ofclass K2_thing)) && (call_U2177(formal_par0)))))) && ((((formal_rv = call_U2853(formal_par0)))|(1))))))) || (ArgumentTypeFailed(827)))
                ))
            +
                ! This evaluate first
                ((formal_par0 = t_0)))
        )
        )) {
            rtrue;
        }
    }
    rfalse;
    rfalse;
];
[ call_U2846 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
            if ((x ofclass K29_fuse)) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2847;
    ((Global_Vars-->64) = 0);
    if (((call_U414(I_electrical_closet_one_s_el_U4)) && (call_U2845(I_electrical_closet_one_s_el_U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if (((call_U414(I_electrical_closet_three_s__U4)) && (call_U2845(I_electrical_closet_three_s__U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if (((call_U414(I_electrical_closet_five_s_e_U4)) && (call_U2845(I_electrical_closet_five_s_e_U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if (((call_U414(I_electrical_closet_seven_s__U4)) && (call_U2845(I_electrical_closet_seven_s__U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if (((call_U414(I_electrical_closet_nine_s_e_U4)) && (call_U2845(I_electrical_closet_nine_s_e_U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    if (((call_U414(I_electrical_closet_eleven_s_U4)) && (call_U2845(I_electrical_closet_eleven_s_U2)))) {
        ((Global_Vars-->64) = ((Global_Vars-->64) + 1));
    }
    rfalse;
];
[ call_U2848 ct_0 ct_1 tmp_0 tmp_1;
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = (Global_Vars-->65)),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            (say__p = 1);
            ParaContent();
            E6(TableLookUpEntry(ct_0, table_column_id_U30, ct_1));
            ParaContent();
            print " ";
            ParaContent();
            PrintShortName(TableLookUpEntry(ct_0, table_column_id_U29, ct_1));
            ParaContent();
            print "^";
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U2849 tmp_0;
    (say__p = 1);
    ParaContent();
    print "Which prize would you like? ";
    ParaContent();
    RunParagraphOn();
    for ((tmp_0 = 1):(tmp_0 <= TableRows(table_data_U14)):(tmp_0)++) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U14, table_column_id_U28, tmp_0));
        ParaContent();
        print ") ";
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U14, table_column_id_U10, tmp_0));
        ParaContent();
        if ((~~((tmp_0 < TableRows(table_data_U14))))) {
            jump L_Say1;
        }
        ParaContent();
        print ", ";
        jump L_SayX1;
        .L_Say1;
        ParaContent();
        print "?";
        print "^";
        .L_SayX1;
    }
    rfalse;
];
[ call_U2850 tmp_0;
    (say__p = 1);
    ParaContent();
    print "Which prize would you like? ";
    ParaContent();
    RunParagraphOn();
    for ((tmp_0 = 1):(tmp_0 <= TableRows(table_data_U29)):(tmp_0)++) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U29, table_column_id_U28, tmp_0));
        ParaContent();
        print ") ";
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U29, table_column_id_U10, tmp_0));
        ParaContent();
        if ((~~((tmp_0 < TableRows(table_data_U29))))) {
            jump L_Say1;
        }
        ParaContent();
        print ", ";
        jump L_SayX1;
        .L_Say1;
        ParaContent();
        print "?";
        print "^";
        .L_SayX1;
    }
    rfalse;
];
[ call_U2851 tmp_0;
    (say__p = 1);
    ParaContent();
    print "Which prize would you like? ";
    ParaContent();
    RunParagraphOn();
    for ((tmp_0 = 1):(tmp_0 <= TableRows(table_data_U30)):(tmp_0)++) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U30, table_column_id_U28, tmp_0));
        ParaContent();
        print ") ";
        ParaContent();
        TEXT_TY_Say(TableLookUpEntry(table_data_U30, table_column_id_U10, tmp_0));
        ParaContent();
        if ((~~((tmp_0 < TableRows(table_data_U30))))) {
            jump L_Say1;
        }
        ParaContent();
        print ", ";
        jump L_SayX1;
        .L_Say1;
        ParaContent();
        print "?";
        print "^";
        .L_SayX1;
    }
    rfalse;
];
[ call_U2852;
    (say__p = 1);
    ParaContent();
    print "The barker cries:";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    print "Ladies and gentlemen, boys and girls, gather ";
    ParaContent();
    print "'";
    ParaContent();
    print "round! ";
    ParaContent();
    print "^";
    ParaContent();
    print "Step right up and witness the spectacle that";
    ParaContent();
    print "'";
    ParaContent();
    print "s taken the world by storm! ";
    ParaContent();
    print "^";
    ParaContent();
    print "She walks, she talks, she crawls on her belly like a reptile. ";
    ParaContent();
    print "^";
    ParaContent();
    print "Behold the one, the only Little Egypt, performing her legendary Dance of the Pyramids - a dazzling display of mystery, grace, and exotic allure! ";
    ParaContent();
    print "^";
    ParaContent();
    print "For just a dime, a mere one tenth of a dollar, prepare to be transported to the sands of Cairo, where enchantment and wonder await!";
    print "^";
    rfalse;
];
[ call_U2853 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2854 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2855 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2856 t_0;
    if ((GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id) == GProperty(OBJECT_TY, t_0, A_P_dial_setting))) {
        rtrue;
    }
    rfalse;
    rfalse;
];
[ call_U2857 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2858 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2859 t_0;
    return GProperty(OBJECT_TY, t_0, A_P_dial_setting);
    rfalse;
];
[ call_U2860;
    ((Global_Vars-->70) = 0);
    if (call_U2856(I_control_panel_one_s_dial_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    if (call_U2856(I_control_panel_three_s_dial_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    if (call_U2856(I_control_panel_five_s_dial_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    if (call_U2856(I_control_panel_seven_s_dial_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    if (call_U2856(I_control_panel_nine_s_dial_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    if (call_U2856(I_control_panel_eleven_s_dia_U1)) {
        ((Global_Vars-->70) = ((Global_Vars-->70) + 1));
    }
    rfalse;
];
[ call_U2861 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_panel_id);
    rfalse;
];
[ call_U2862 t_0;
    return GProperty(OBJECT_TY, HolderOf(t_0), A_P_color);
    return I_nondescript_U1;
];
[ call_U2863 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2864)(tmp_0);
    return selfobj;
];
[ call_U2864 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K30_switch_First):x:(x = (x.K30_switch_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2865 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2866)(tmp_0);
    return selfobj;
];
[ call_U2866 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2867 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2868)(tmp_0);
    return selfobj;
];
[ call_U2868 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K28_indicator_First):x:(x = (x.K28_indicator_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2869 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2870)(tmp_0);
    return selfobj;
];
[ call_U2870 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K27_socket_First):x:(x = (x.K27_socket_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2871 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2872)(tmp_0);
    return selfobj;
];
[ call_U2872 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K36_dial_First):x:(x = (x.K36_dial_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2873 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2874)(tmp_0);
    return selfobj;
];
[ call_U2874 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K30_switch_First):x:(x = (x.K30_switch_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2875 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2876)(tmp_0);
    return selfobj;
];
[ call_U2876 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2877 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2878)(tmp_0);
    return selfobj;
];
[ call_U2878 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K28_indicator_First):x:(x = (x.K28_indicator_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2879 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2880)(tmp_0);
    return selfobj;
];
[ call_U2880 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K27_socket_First):x:(x = (x.K27_socket_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2881 t_0 t_1 tmp_0;
    (tmp_0 = HolderOf(t_1));
    return (call_U2882)(tmp_0);
    return selfobj;
];
[ call_U2882 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K36_dial_First):x:(x = (x.K36_dial_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2883 t_0 t_1;
    return (call_U2884)(t_1);
    return selfobj;
];
[ call_U2884 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K30_switch_First):x:(x = (x.K30_switch_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2885 t_0 t_1;
    return (call_U2886)(t_1);
    return selfobj;
];
[ call_U2886 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K35_button_First):x:(x = (x.K35_button_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2887 t_0 t_1;
    return (call_U2888)(t_1);
    return selfobj;
];
[ call_U2888 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K28_indicator_First):x:(x = (x.K28_indicator_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2889 t_0 t_1;
    return (call_U2890)(t_1);
    return selfobj;
];
[ call_U2890 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K27_socket_First):x:(x = (x.K27_socket_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ call_U2891 t_0 t_1;
    return (call_U2892)(t_1);
    return selfobj;
];
[ call_U2892 const_0 x x_ix counter selection;
    (selection = -1);
    while (1) {
        (counter = 0);
        for ((x = K36_dial_First):x:(x = (x.K36_dial_Next))) {
            if ((const_0 == PartOf(x))) {
                (counter)++;
                if ((counter == selection)) {
                    return x;
                }
                jump NextOuterLoop_8;
            }
            .NextOuterLoop_8;
        }
        if ((((counter == 0)) || ((selection >= 0)))) {
            rfalse;
        }
        (selection = random(counter));
    }
];
[ ConjugateVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record7;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U2893 fn vp t modal_to;
    (t = ConjugateVerb1(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record7;
    }
];
[ ConjugateModalVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "auxiliary-have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has not";
                    } else {
                        print "have not";
                    }
                    ;
                2:
                    print "had not";
                    ;
            }
            ;
    }
];
[ ConjugateVerb60 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record8;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ call_U2894 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb61 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ call_U2895 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2896 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2897 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U2898 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb103 fn vp t modal_to;
    switch (fn) {
        1:
            print "underlie";
            ;
        2:
            print "underlaid";
            ;
        3:
            print "underlying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record4;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "underlies";
                    } else {
                        print "underlie";
                    }
                    ;
                2:
                    print "underlaid";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has underlaid";
                    } else {
                        print "have underlaid";
                    }
                    ;
                4:
                    print "had underlaid";
                    ;
                5:
                    print "will underlie";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not underlie";
                    } else {
                        print "do not underlie";
                    }
                    ;
                2:
                    print "did not underlie";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not underlaid";
                    } else {
                        print "have not underlaid";
                    }
                    ;
                4:
                    print "had not underlaid";
                    ;
                5:
                    print "will not underlie";
                    ;
            }
            ;
    }
];
[ call_U2899 fn vp t modal_to;
    (t = ConjugateVerb103(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record4;
    }
];
[ ConjugateModalVerb57 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb58 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb104 fn vp t modal_to;
    switch (fn) {
        1:
            print "toss";
            ;
        2:
            print "tossed";
            ;
        3:
            print "tossing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record5;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tosses";
                    } else {
                        print "toss";
                    }
                    ;
                2:
                    print "tossed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tossed";
                    } else {
                        print "have tossed";
                    }
                    ;
                4:
                    print "had tossed";
                    ;
                5:
                    print "will toss";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not toss";
                    } else {
                        print "do not toss";
                    }
                    ;
                2:
                    print "did not toss";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tossed";
                    } else {
                        print "have not tossed";
                    }
                    ;
                4:
                    print "had not tossed";
                    ;
                5:
                    print "will not toss";
                    ;
            }
            ;
    }
];
[ call_U2900 fn vp t modal_to;
    (t = ConjugateVerb104(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record5;
    }
];
[ ConjugateModalVerb59 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ PCONR1;
    return (I_show_tent_U1 == ContainerOf(player));
];
[ PCONR2;
    return (I_folding_chair_U1 == SupporterOf(player));
];
[ PCONR3;
    return (I_hell_ride_car_U1 == ContainerOf(player));
];
[ PAPR1;
    if ((((action == ##A_hi_speaking)) && ((((actor == player)) && ((noun == I_sailor_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR2;
    if ((((action == ##A_hi_speaking)) && ((((actor == player)) && ((noun == I_sailor_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR3;
    if ((((action == ##A_hitting)) && ((((actor == player)) && ((((noun == I_lever_U1)) && (((((self = actor),1)) && ((second == I_mallet_U1)))))))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR4;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_lantern_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR5;
    if ((((action == ##Take)) && ((((actor == player)) && ((noun == I_flashlight_U1)))))) {
        rtrue;
    }
    rfalse;
];
[ PAPR6;
    if ((((action == ##A_asking_for_help)) && ((actor == player)))) {
        rtrue;
    }
    rfalse;
];
[ Noun_Filter2 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && ((noun == I_blueberries_U1)));
];
[ Noun_Filter6 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter10 x;
    (x = noun);
    return (noun ofclass K30_switch);
];
[ Noun_Filter12 x;
    (x = noun);
    return (noun ofclass K30_switch);
];
[ Noun_Filter21 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter24 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter25 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter26 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter27 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter28 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter29 x;
    (x = noun);
    return (noun ofclass K18_fluid_container);
];
[ Noun_Filter30 x;
    (x = noun);
    return (((noun ofclass K13_device)) && ((noun == I_big_switch_U1)));
];
[ Noun_Filter31 x;
    (x = noun);
    return (noun ofclass K30_switch);
];
[ Noun_Filter32 x;
    (x = noun);
    return (((noun ofclass K13_device)) && ((noun == I_big_switch_U1)));
];
[ Noun_Filter33 x;
    (x = noun);
    return (noun ofclass K30_switch);
];
[ parse_name1 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name2 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name3 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name4 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name5 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name6 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name7 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name8 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name9 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name10 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name11 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name12 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name13 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((Cond_Token1() == GPR_FAIL)) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'your')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((Cond_Token2() == GPR_FAIL)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'my')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            if ((Cond_Token3() == GPR_FAIL)) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_3;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_3;
            (wn = try_from_wn);
            if ((Cond_Token4() == GPR_FAIL)) {
                jump Fail_4;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_4;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_4;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name17 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name20 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'seat')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name26 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name41 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name61 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name67 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name69 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name71 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name77 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name96 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'the')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'ticket')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'stub')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((NextWordStopped() ~= 'the')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'stub')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            if ((NextWordStopped() ~= 'ticket')) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'stub')) {
                jump Fail_3;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_3;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name97 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name99 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name102 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name105 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name106 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'key')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'keys')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name107 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'glove')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'compartment')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name116 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name121 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'bumper')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'car')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'ticket')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name123 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name124 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name125 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name126 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2457((self.P_liquid)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name135 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name143 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name144 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name148 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name151 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name152 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name154 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name158 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name161 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name166 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name170 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name176 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name177 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name178 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name192 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name193 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name209 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'tool')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'box')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name217 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name270 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name300 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name323 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                if ((parser_action == ##TheSame)) {
                    #ifdef DEBUG;
                        if ((parser_trace >= 4)) {
                            print "p1, p2 = ";
                            print parser_one;
                            print ", ";
                            print parser_two;
                            print "^";
                        }
                    #endif;
                    (ss = self);
                    if (((parser_one.P_liquid) ~= (parser_two.P_liquid))) {
                        return -2;
                    }
                    (self = ss);
                    rfalse;
                }
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2457((self.P_liquid)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name325 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name326 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name331 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                if ((parser_action == ##TheSame)) {
                    #ifdef DEBUG;
                        if ((parser_trace >= 4)) {
                            print "p1, p2 = ";
                            print parser_one;
                            print ", ";
                            print parser_two;
                            print "^";
                        }
                    #endif;
                    (ss = self);
                    if (((parser_one.P_panel_id) ~= (parser_two.P_panel_id))) {
                        return -2;
                    }
                    if (((parser_one.P_color) ~= (parser_two.P_color))) {
                        return -2;
                    }
                    (self = ss);
                    rfalse;
                }
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((((DECIMAL_TOKEN() == GPR_NUMBER)) && (((self.P_panel_id) == parsed_number)))) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2471((self.P_color)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name332 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'socket')) {
                jump Fail_1;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'socket')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name333 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'indicator')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'light')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((NextWordStopped() ~= 'indicator')) {
                jump Fail_2;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'indicator')) {
                jump Fail_3;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_3;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name334 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                if ((parser_action == ##TheSame)) {
                    #ifdef DEBUG;
                        if ((parser_trace >= 4)) {
                            print "p1, p2 = ";
                            print parser_one;
                            print ", ";
                            print parser_two;
                            print "^";
                        }
                    #endif;
                    (ss = self);
                    if (((parser_one.P_fuse_id) ~= (parser_two.P_fuse_id))) {
                        return -2;
                    }
                    if (((parser_one.P_color) ~= (parser_two.P_color))) {
                        return -2;
                    }
                    (self = ss);
                    rfalse;
                }
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((((DECIMAL_TOKEN() == GPR_NUMBER)) && (((self.P_fuse_id) == parsed_number)))) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2471((self.P_color)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name335 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'switch')) {
                jump Fail_1;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'switch')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name337 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name339 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
                if ((parser_action == ##TheSame)) {
                    #ifdef DEBUG;
                        if ((parser_trace >= 4)) {
                            print "p1, p2 = ";
                            print parser_one;
                            print ", ";
                            print parser_two;
                            print "^";
                        }
                    #endif;
                    (ss = self);
                    if (((parser_one.P_panel_id) ~= (parser_two.P_panel_id))) {
                        return -2;
                    }
                    if (((parser_one.P_color) ~= (parser_two.P_color))) {
                        return -2;
                    }
                    (self = ss);
                    rfalse;
                }
                (try_from_wn = wn);
                (g = 1);
                while (g) {
                    (g = 0);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((((DECIMAL_TOKEN() == GPR_NUMBER)) && (((self.P_panel_id) == parsed_number)))) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                    (wn = try_from_wn);
                    (spn = parsed_number);
                    (ss = etype);
                    if ((call_U2471((self.P_color)) == GPR_NUMBER)) {
                        (try_from_wn = wn);
                        (g = 1);
                        (f = 1);
                    }
                    (parsed_number = spn);
                    (etype = ss);
                }
                (wn = try_from_wn);
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name340 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'button')) {
                jump Fail_1;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'button')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name341 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'dial')) {
                jump Fail_1;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'dial')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name342 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((NextWordStopped() ~= 'light')) {
                jump Fail_1;
            }
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            ArticleDescriptors();
            (w = wn);
            (rv = (self.component_parent));
            (wn = w);
            (wn = (w + TryGivenObject(rv, 1)));
            if ((wn == w)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'light')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ Cond_Token1;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token2;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token3;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token4;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Consult_Grammar1 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restart')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar2 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restore')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar3 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'amusing')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar4 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'quit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar5 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'undo')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar6 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'stand')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar7 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'sit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar8 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'lie')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar9 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'please')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar10 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'load')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar11 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'hell')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar12 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'hell')) {
        jump Fail_1;
    }
    if ((NextWordStopped() ~= 'ride')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar13 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'hell')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar14 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'hell')) {
        jump Fail_1;
    }
    if ((NextWordStopped() ~= 'ride')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar15 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    (w = ParseTokenStopped(GPR_TT, GPR_Line2));
    if ((w == GPR_FAIL)) {
        jump Fail_1;
    }
    if ((w ~= GPR_PREPOSITION)) {
        (rv = w);
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar16 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    (w = ParseTokenStopped(GPR_TT, GPR_Line2));
    if ((w == GPR_FAIL)) {
        jump Fail_1;
    }
    if ((w ~= GPR_PREPOSITION)) {
        (rv = w);
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ MistakeActionSub RV;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(0, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    (RV = kernel1_U51());
    BlkValueFreeOnStack(0);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(4);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U51;
    switch (understand_as_mistake_number) {
        321:
            ParserError(TEXT_TY_ExpandIfPerishable(I7SFRAME, ts_array_U709));
            ;
        322:
            ParserError(TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*2)), ts_array_U710));
            ;
        358:
            ParserError(bc_U2138);
            ;
        359:
            ParserError(bc_U2139);
            ;
        379:
            ParserError(TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*4)), ts_array_U711));
            ;
        default:
            print "I didn't understand that sentence.^";
            rtrue;
            ;
    }
    (say__p = 1);
];
[ call_U2901;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To start a conversation, try to ASK [the noun] ABOUT something or TELL [the noun] ABOUT something.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To start a conversation, try to ASK ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ABOUT something or TELL ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ABOUT something.";
    rtrue;
];
[ call_U2902;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To start a conversation, try to ASK [the noun] ABOUT something or TELL [the noun] ABOUT something.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To start a conversation, try to ASK ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ABOUT something or TELL ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ABOUT something.";
    rtrue;
];
[ call_U2903;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Please try 'go [noun]' or just '[noun]' as a direction isn[']t necessarily an exit here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Please try ~go ";
    ParaContent();
    PrintShortName(noun);
    ParaContent();
    print "~ or just ~";
    ParaContent();
    PrintShortName(noun);
    ParaContent();
    print "~ as a direction isn";
    ParaContent();
    print "'";
    ParaContent();
    print "t necessarily an exit here.";
    rtrue;
];
[ GPR_Line1 original_wn group_wn v w rv;
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'fuck')) {
        jump Fail_1;
    }
    return rv;
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'shit')) {
        jump Fail_2;
    }
    return rv;
    .Fail_2;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'motherfucker')) {
        jump Fail_3;
    }
    return rv;
    .Fail_3;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'cocksucker')) {
        jump Fail_4;
    }
    return rv;
    .Fail_4;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'cunt')) {
        jump Fail_5;
    }
    return rv;
    .Fail_5;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'prick')) {
        jump Fail_6;
    }
    return rv;
    .Fail_6;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'cock')) {
        jump Fail_7;
    }
    return rv;
    .Fail_7;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'piss')) {
        jump Fail_8;
    }
    return rv;
    .Fail_8;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'tits')) {
        jump Fail_9;
    }
    return rv;
    .Fail_9;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'damn')) {
        jump Fail_10;
    }
    return rv;
    .Fail_10;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ GPR_Line2 original_wn group_wn v w rv;
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'the')) {
        jump Fail_1;
    }
    if ((NextWordStopped() ~= 'ticket')) {
        jump Fail_1;
    }
    if ((NextWordStopped() ~= 'stub')) {
        jump Fail_1;
    }
    return rv;
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'the')) {
        jump Fail_2;
    }
    if ((NextWordStopped() ~= 'stub')) {
        jump Fail_2;
    }
    return rv;
    .Fail_2;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'ticket')) {
        jump Fail_3;
    }
    if ((NextWordStopped() ~= 'stub')) {
        jump Fail_3;
    }
    return rv;
    .Fail_3;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    if ((NextWordStopped() ~= 'stub')) {
        jump Fail_4;
    }
    return rv;
    .Fail_4;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Prop_Falsity reason obj;
    rfalse;
];
[ FINAL_CODE_STARTUP_R addr res;
    #ifdef TARGET_GLULX;
    @gestalt 9 0 res;
    if (res == 0) rfalse;
    addr = #classes_table;
    @accelparam 0 addr;
    @accelparam 1 INDIV_PROP_START;
    @accelparam 2 Class;
    @accelparam 3 Object;
    @accelparam 4 Routine;
    @accelparam 5 String;
    addr = #globals_array + WORDSIZE * #g$self;
    @accelparam 6 addr;
    @accelparam 7 NUM_ATTR_BYTES;
    addr = #cpv__start;
    @accelparam 8 addr;
    @accelfunc 1 Z__Region;
    @accelfunc 2 CP__Tab;
    @accelfunc 3 RA__Pr;
    @accelfunc 4 RL__Pr;
    @accelfunc 5 OC__Cl;
    @accelfunc 6 RV__Pr;
    @accelfunc 7 OP__Pr;
    #endif;
    rfalse;
];
[ DebugAction a anames str;
    #ifdef TARGET_GLULX;
    if (a < 4096) {
        if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
        else {
            str = #identifiers_table-->6;
            str = str-->a;
            if (str) print (string) str; else print "<unnamed action ", a, ">";
            return;
        }
    }
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 4096) {
        anames = #identifiers_table;
        anames = anames + 2*(anames-->0) + 2*48;
        print (string) anames-->a;
        return;
    }
    #endif;
    if ((a >= 4096)) {
        print "<fake action ";
        print (a - 4096);
        print ">";
    } else {
        print "<action ";
        print a;
        print ">";
    }
];
[ DebugAttribute a anames str;
    #ifdef TARGET_GLULX;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
    return;
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
    return;
    #endif;
    print "<attribute ";
    print a;
    print ">";
];
[ DebugProperty p pnames str;
    print (property) p;
    return;
    print "<property ";
    print p;
    print ">";
];
[ DecimalNumber num;
    print num;
];
[ PrintI6Text x;
    if ((x ofclass String)) {
        print (string) x;
    }
    if ((x ofclass Routine)) {
        return (x)();
    }
    if ((x == EMPTY_TEXT_PACKED)) {
        rfalse;
    }
    rtrue;
];
[ I7_String x;
    TEXT_TY_Say(x);
];
[ PrintOrRun obj prop no_break pv st routine_return_value;
    @push self;
    (self = obj);
    if ((prop == 0)) {
        PrintShortName(prop);
        (routine_return_value = 1);
    } else {
        (routine_return_value = TEXT_TY_Say(_final_propertyvalue(OBJECT_TY, obj, prop)));
    }
    @pull self;
    if (routine_return_value) {
        (say__p = 1);
        if ((no_break == 0)) {
            print "^";
            DivideParagraphPoint();
        }
    }
    return routine_return_value;
];
[ DA_Number n;
    print n;
];
[ DA_TruthState n;
    if ((n == 0)) {
        print "false";
    } else {
        print "true";
    }
];
[ SayPhraseName closure;
    if ((closure == 0)) {
        print "nothing";
    } else {
        print (string) (closure-->(2));
    }
];
[ KindAtomic kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return kind;
    }
    return (kind-->(0));
];
[ KindBaseArity kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        rfalse;
    }
    return (kind-->(1));
];
[ KindBaseTerm kind n;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return UNKNOWN_TY;
    }
    return (kind-->((2 + n)));
];
[ GenerateRandomNumber n m s;
    if ((n == m)) {
        return n;
    }
    if ((n > m)) {
        (s = n);
        (n = m);
        (m = s);
    }
    (n)--;
    return (random((m - n)) + n);
];
[ PrintSpaces n;
    while ((n > 0)) {
        print " ";
        (n = (n - 1));
    }
];
[ SwapWorkflags obj lst;
    objectloop (obj ofclass Object && (obj ofclass Object)) {
        (lst = 0);
        if ((obj has workflag2)) {
            (lst = 1);
        }
        give obj ~workflag2;
        if ((obj has workflag)) {
            give obj workflag2;
        }
        give obj ~workflag;
        if (lst) {
            give obj workflag;
        }
    }
];
[ ZRegion addr;
    switch (metaclass(addr)) {
        0:
            rfalse;
            ;
        Object, Class:
            rtrue;
            ;
        Routine:
            return 2;
            ;
        String:
            return 3;
            ;
    }
];
[ Memcpy to_addr from_addr size n;
    @mcopy size from_addr to_addr;
];
[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries n val;
    if ((to_entry_size == from_entry_size)) {
        Memcpy(to_array, from_array, (to_entry_size*no_entries));
    } else {
        if ((((to_entry_size == 2)) && ((from_entry_size == 4)))) {
            for ((n = 0):(n < no_entries):(n)++) {
                (val = (from_array-->(n)));
                ((to_array->(0)) = ((val/256)%256));
                ((to_array->(1)) = (val%256));
                (to_array = (to_array + 2));
            }
        } else {
            print "*** Arrcpy doesn't support this ***";
            new_line;
            rtrue;
        }
    }
];
[ PrintVerbAsValue vb;
    if ((vb == 0)) {
        print "(no verb)";
    } else {
        print "verb ";
        (vb)(1);
    }
];
[ VerbIsMeaningful vb;
    if (((vb) && ((BlkValueCompare((vb)(CV_MEANING), MEANINGLESS_RR) ~= 0)))) {
        rtrue;
    }
    rfalse;
];
[ VerbIsModal vb;
    if (((vb) && ((vb)(CV_MODAL)))) {
        rtrue;
    }
    rfalse;
];
[ SEED_RANDOM_NUMBER_GENERATOR_R i;
    if (RNG_SEED_AT_START_OF_PLAY) {
        VM_Seed_RNG(RNG_SEED_AT_START_OF_PLAY);
    }
    for ((i = 1):(i <= 100):(i)++) {
        random(i);
    }
    rfalse;
];
[ DictionaryWordToVerbNum dword verbnum i;
    (dword = ((dword + #dict_par2) - 1));
    @aloads dword 0 verbnum;
    (verbnum = (65535 - verbnum));
    return verbnum;
];
[ RegardingSingleObject obj;
    (prior_named_list = 1);
    (prior_named_list_gender = -1);
    (prior_named_noun = obj);
];
[ RegardingNumber n;
    (prior_named_list = n);
    (prior_named_list_gender = -1);
    (prior_named_noun = 0);
];
[ I7_SOO_PAR oldval count;
    if ((count <= 1)) {
        return count;
    }
    return random(count);
];
[ I7_SOO_RAN oldval count v;
    if ((count <= 1)) {
        return count;
    }
    (v = oldval);
    while ((v == oldval)) {
        (v = random(count));
    }
    return v;
];
[ I7_SOO_STI oldval count v;
    if (oldval) {
        return oldval;
    }
    return I7_SOO_PAR(oldval, count);
];
[ I7_SOO_CYC oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = 1);
    }
    return oldval;
];
[ I7_SOO_STOP oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = count);
    }
    return oldval;
];
[ I7_SOO_TAP oldval count tn rn c;
    if ((count <= 1)) {
        return count;
    }
    (tn = ((count*(count + 1))/2));
    (rn = random(tn));
    for ((c = 1):(c <= count):(c)++) {
        (rn = (rn - c));
        if ((rn <= 0)) {
            return ((count - c) + 1);
        }
    }
];
[ I7_SOO_TRAN oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_RAN((oldval%(count + 1)), count));
];
[ I7_SOO_TPAR oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_PAR((oldval%(count + 1)), count));
];
[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
    (base = (count + 1));
    (v = (oldval%base));
    (oldval = (oldval/base));
    (ct = (oldval%base));
    (sd = (oldval/base));
    if ((count > 32)) {
        return I7_SOO_PAR(oldval, count);
    }
    if ((count <= 1)) {
        (v = count);
    } else {
        (cc = (base*base));
        (scope = ((MAX_POSITIVE_NUMBER - 1)/cc));
        if ((sd == 0)) {
            (sd = random(scope));
            (ct = 0);
        }
        for ((i = 0):(i < count):(i)++) {
            ((I7_SOO_SHUF->(i)) = i);
        }
        (ssd = sd);
        for ((i = 0):(i < (count - 1)):(i)++) {
            (j = ((sd%(count - i)) + i));
            (sd = ((sd*31973) + 17));
            if ((sd < 0)) {
                (sd = (-(sd)));
            }
            (s = (I7_SOO_SHUF->(j)));
            ((I7_SOO_SHUF->(j)) = (I7_SOO_SHUF->(i)));
            ((I7_SOO_SHUF->(i)) = s);
        }
        (v = ((I7_SOO_SHUF->(ct)) + 1));
        (ct)++;
        if ((ct >= count)) {
            (ct = 0);
            (ssd = 0);
        }
    }
    return ((v + (ct*base)) + ((ssd*base)*base));
];
[ RoundOffValue t1 t2;
    if ((t1 >= 0)) {
        return (((t1 + (t2/2))/t2)*t2);
    }
    return (-(((((-(t1)) + (t2/2))/t2)*t2)));
];
[ glk_exit _vararg_count;
    @glk 1 _vararg_count 0;
    rfalse;
];
[ glk_tick _vararg_count;
    @glk 3 _vararg_count 0;
    rfalse;
];
[ glk_gestalt _vararg_count ret;
    @glk 4 _vararg_count ret;
    return ret;
];
[ glk_gestalt_ext _vararg_count ret;
    @glk 5 _vararg_count ret;
    return ret;
];
[ glk_window_iterate _vararg_count ret;
    @glk 32 _vararg_count ret;
    return ret;
];
[ glk_window_get_rock _vararg_count ret;
    @glk 33 _vararg_count ret;
    return ret;
];
[ glk_window_get_root _vararg_count ret;
    @glk 34 _vararg_count ret;
    return ret;
];
[ glk_window_open _vararg_count ret;
    @glk 35 _vararg_count ret;
    return ret;
];
[ glk_window_close _vararg_count;
    @glk 36 _vararg_count 0;
    rfalse;
];
[ glk_window_get_size _vararg_count;
    @glk 37 _vararg_count 0;
    rfalse;
];
[ glk_window_set_arrangement _vararg_count;
    @glk 38 _vararg_count 0;
    rfalse;
];
[ glk_window_get_arrangement _vararg_count;
    @glk 39 _vararg_count 0;
    rfalse;
];
[ glk_window_get_type _vararg_count ret;
    @glk 40 _vararg_count ret;
    return ret;
];
[ glk_window_get_parent _vararg_count ret;
    @glk 41 _vararg_count ret;
    return ret;
];
[ glk_window_clear _vararg_count;
    @glk 42 _vararg_count 0;
    rfalse;
];
[ glk_window_move_cursor _vararg_count;
    @glk 43 _vararg_count 0;
    rfalse;
];
[ glk_window_get_stream _vararg_count ret;
    @glk 44 _vararg_count ret;
    return ret;
];
[ glk_window_set_echo_stream _vararg_count;
    @glk 45 _vararg_count 0;
    rfalse;
];
[ glk_window_get_echo_stream _vararg_count ret;
    @glk 46 _vararg_count ret;
    return ret;
];
[ glk_set_window _vararg_count;
    @glk 47 _vararg_count 0;
    rfalse;
];
[ glk_window_get_sibling _vararg_count ret;
    @glk 48 _vararg_count ret;
    return ret;
];
[ glk_stream_iterate _vararg_count ret;
    @glk 64 _vararg_count ret;
    return ret;
];
[ glk_stream_get_rock _vararg_count ret;
    @glk 65 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file _vararg_count ret;
    @glk 66 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory _vararg_count ret;
    @glk 67 _vararg_count ret;
    return ret;
];
[ glk_stream_close _vararg_count;
    @glk 68 _vararg_count 0;
    rfalse;
];
[ glk_stream_set_position _vararg_count;
    @glk 69 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_position _vararg_count ret;
    @glk 70 _vararg_count ret;
    return ret;
];
[ glk_stream_set_current _vararg_count;
    @glk 71 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_current _vararg_count ret;
    @glk 72 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource _vararg_count ret;
    @glk 73 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_temp _vararg_count ret;
    @glk 96 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_name _vararg_count ret;
    @glk 97 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_prompt _vararg_count ret;
    @glk 98 _vararg_count ret;
    return ret;
];
[ glk_fileref_destroy _vararg_count;
    @glk 99 _vararg_count 0;
    rfalse;
];
[ glk_fileref_iterate _vararg_count ret;
    @glk 100 _vararg_count ret;
    return ret;
];
[ glk_fileref_get_rock _vararg_count ret;
    @glk 101 _vararg_count ret;
    return ret;
];
[ glk_fileref_delete_file _vararg_count;
    @glk 102 _vararg_count 0;
    rfalse;
];
[ glk_fileref_does_file_exist _vararg_count ret;
    @glk 103 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_from_fileref _vararg_count ret;
    @glk 104 _vararg_count ret;
    return ret;
];
[ glk_put_char _vararg_count;
    @glk 128 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream _vararg_count;
    @glk 129 _vararg_count 0;
    rfalse;
];
[ glk_put_string _vararg_count;
    @glk 130 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream _vararg_count;
    @glk 131 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer _vararg_count;
    @glk 132 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream _vararg_count;
    @glk 133 _vararg_count 0;
    rfalse;
];
[ glk_set_style _vararg_count;
    @glk 134 _vararg_count 0;
    rfalse;
];
[ glk_set_style_stream _vararg_count;
    @glk 135 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream _vararg_count ret;
    @glk 144 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream _vararg_count ret;
    @glk 145 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream _vararg_count ret;
    @glk 146 _vararg_count ret;
    return ret;
];
[ glk_char_to_lower _vararg_count ret;
    @glk 160 _vararg_count ret;
    return ret;
];
[ glk_char_to_upper _vararg_count ret;
    @glk 161 _vararg_count ret;
    return ret;
];
[ glk_stylehint_set _vararg_count;
    @glk 176 _vararg_count 0;
    rfalse;
];
[ glk_stylehint_clear _vararg_count;
    @glk 177 _vararg_count 0;
    rfalse;
];
[ glk_style_distinguish _vararg_count ret;
    @glk 178 _vararg_count ret;
    return ret;
];
[ glk_style_measure _vararg_count ret;
    @glk 179 _vararg_count ret;
    return ret;
];
[ glk_select _vararg_count;
    @glk 192 _vararg_count 0;
    rfalse;
];
[ glk_select_poll _vararg_count;
    @glk 193 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event _vararg_count;
    @glk 208 _vararg_count 0;
    rfalse;
];
[ glk_cancel_line_event _vararg_count;
    @glk 209 _vararg_count 0;
    rfalse;
];
[ glk_request_char_event _vararg_count;
    @glk 210 _vararg_count 0;
    rfalse;
];
[ glk_cancel_char_event _vararg_count;
    @glk 211 _vararg_count 0;
    rfalse;
];
[ glk_request_mouse_event _vararg_count;
    @glk 212 _vararg_count 0;
    rfalse;
];
[ glk_cancel_mouse_event _vararg_count;
    @glk 213 _vararg_count 0;
    rfalse;
];
[ glk_request_timer_events _vararg_count;
    @glk 214 _vararg_count 0;
    rfalse;
];
[ glk_image_get_info _vararg_count ret;
    @glk 224 _vararg_count ret;
    return ret;
];
[ glk_image_draw _vararg_count ret;
    @glk 225 _vararg_count ret;
    return ret;
];
[ glk_image_draw_scaled _vararg_count ret;
    @glk 226 _vararg_count ret;
    return ret;
];
[ glk_window_flow_break _vararg_count;
    @glk 232 _vararg_count 0;
    rfalse;
];
[ glk_window_erase_rect _vararg_count;
    @glk 233 _vararg_count 0;
    rfalse;
];
[ glk_window_fill_rect _vararg_count;
    @glk 234 _vararg_count 0;
    rfalse;
];
[ glk_window_set_background_color _vararg_count;
    @glk 235 _vararg_count 0;
    rfalse;
];
[ glk_schannel_iterate _vararg_count ret;
    @glk 240 _vararg_count ret;
    return ret;
];
[ glk_schannel_get_rock _vararg_count ret;
    @glk 241 _vararg_count ret;
    return ret;
];
[ glk_schannel_create _vararg_count ret;
    @glk 242 _vararg_count ret;
    return ret;
];
[ glk_schannel_destroy _vararg_count;
    @glk 243 _vararg_count 0;
    rfalse;
];
[ glk_schannel_create_ext _vararg_count ret;
    @glk 244 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_multi _vararg_count ret;
    @glk 247 _vararg_count ret;
    return ret;
];
[ glk_schannel_play _vararg_count ret;
    @glk 248 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_ext _vararg_count ret;
    @glk 249 _vararg_count ret;
    return ret;
];
[ glk_schannel_stop _vararg_count;
    @glk 250 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume _vararg_count;
    @glk 251 _vararg_count 0;
    rfalse;
];
[ glk_sound_load_hint _vararg_count;
    @glk 252 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume_ext _vararg_count;
    @glk 253 _vararg_count 0;
    rfalse;
];
[ glk_schannel_pause _vararg_count;
    @glk 254 _vararg_count 0;
    rfalse;
];
[ glk_schannel_unpause _vararg_count;
    @glk 255 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink _vararg_count;
    @glk 256 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink_stream _vararg_count;
    @glk 257 _vararg_count 0;
    rfalse;
];
[ glk_request_hyperlink_event _vararg_count;
    @glk 258 _vararg_count 0;
    rfalse;
];
[ glk_cancel_hyperlink_event _vararg_count;
    @glk 259 _vararg_count 0;
    rfalse;
];
[ glk_buffer_to_lower_case_uni _vararg_count ret;
    @glk 288 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_upper_case_uni _vararg_count ret;
    @glk 289 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_title_case_uni _vararg_count ret;
    @glk 290 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_decompose_uni _vararg_count ret;
    @glk 291 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_normalize_uni _vararg_count ret;
    @glk 292 _vararg_count ret;
    return ret;
];
[ glk_put_char_uni _vararg_count;
    @glk 296 _vararg_count 0;
    rfalse;
];
[ glk_put_string_uni _vararg_count;
    @glk 297 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_uni _vararg_count;
    @glk 298 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream_uni _vararg_count;
    @glk 299 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream_uni _vararg_count;
    @glk 300 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream_uni _vararg_count;
    @glk 301 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream_uni _vararg_count ret;
    @glk 304 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream_uni _vararg_count ret;
    @glk 305 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream_uni _vararg_count ret;
    @glk 306 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file_uni _vararg_count ret;
    @glk 312 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory_uni _vararg_count ret;
    @glk 313 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource_uni _vararg_count ret;
    @glk 314 _vararg_count ret;
    return ret;
];
[ glk_request_char_event_uni _vararg_count;
    @glk 320 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event_uni _vararg_count;
    @glk 321 _vararg_count 0;
    rfalse;
];
[ glk_set_echo_line_event _vararg_count;
    @glk 336 _vararg_count 0;
    rfalse;
];
[ glk_set_terminators_line_event _vararg_count;
    @glk 337 _vararg_count 0;
    rfalse;
];
[ glk_current_time _vararg_count;
    @glk 352 _vararg_count 0;
    rfalse;
];
[ glk_current_simple_time _vararg_count ret;
    @glk 353 _vararg_count ret;
    return ret;
];
[ glk_time_to_date_utc _vararg_count;
    @glk 360 _vararg_count 0;
    rfalse;
];
[ glk_time_to_date_local _vararg_count;
    @glk 361 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_utc _vararg_count;
    @glk 362 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_local _vararg_count;
    @glk 363 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_utc _vararg_count;
    @glk 364 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_local _vararg_count;
    @glk 365 _vararg_count 0;
    rfalse;
];
[ glk_date_to_simple_time_utc _vararg_count ret;
    @glk 366 _vararg_count ret;
    return ret;
];
[ glk_date_to_simple_time_local _vararg_count ret;
    @glk 367 _vararg_count ret;
    return ret;
];
[ HandleGlkEvent x1 x2 x3;
    rfalse;
];
[ IdentifyGlkObject x1 x2 x3 x4;
    rfalse;
];
[ InitGlkWindow x1;
    rfalse;
];
[ VM_PreInitialise res;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    (unicode_gestalt_ok = 0);
    if (glk_gestalt(gestalt_Unicode, 0)) {
        (unicode_gestalt_ok = 1);
    }
    @setiosys 2 0;
];
[ VM_Initialise res sty i;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    GGRecoverObjects();
    if (glk_gestalt(gestalt_Sound, 0)) {
        if ((gg_foregroundchan == 0)) {
            (gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK));
        }
        if ((gg_backgroundchan == 0)) {
            (gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK));
        }
    }
    if (((KIT_CONFIGURATION_BITMAP)&(FIX_RNG_TCBIT))) {
        @random 10000 i;
        (i = ((-(i)) - 2000));
        @setrandom i;
    }
    (res = InitGlkWindow(0));
    if ((res ~= 0)) {
        rtrue;
    }
    if ((gg_mainwin == 0)) {
        (res = InitGlkWindow(GG_MAINWIN_ROCK));
        if ((res == 0)) {
            glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
        }
        if ((gg_mainwin == 0)) {
            quit;
        }
    } else {
        glk_window_clear(gg_mainwin);
    }
    if ((gg_statuswin == 0)) {
        (res = InitGlkWindow(GG_STATUSWIN_ROCK));
        if ((res == 0)) {
            (statuswin_cursize = statuswin_size);
            for ((sty = 0):(sty < style_NUMSTYLES):(sty)++) {
                glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            }
            (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        }
    }
    glk_set_window(gg_mainwin);
    InitGlkWindow(1);
    ((buffer3-->(0)) = 0);
];
[ GGRecoverObjects id;
    (gg_mainwin = 0);
    (gg_statuswin = 0);
    (gg_quotewin = 0);
    (gg_scriptfref = 0);
    (gg_scriptstr = 0);
    (gg_savestr = 0);
    (statuswin_cursize = 0);
    (gg_foregroundchan = 0);
    (gg_backgroundchan = 0);
    (gg_commandstr = 0);
    (gg_command_reading = 0);
    IdentifyGlkObject(0);
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SAVESTR_ROCK:
                (gg_savestr = id);
                ;
            GG_SCRIPTSTR_ROCK:
                (gg_scriptstr = id);
                ;
            GG_COMMANDWSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 0);
                ;
            GG_COMMANDRSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 1);
                ;
            default:
                IdentifyGlkObject(1, 1, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_MAINWIN_ROCK:
                (gg_mainwin = id);
                ;
            GG_STATUSWIN_ROCK:
                (gg_statuswin = id);
                ;
            GG_QUOTEWIN_ROCK:
                (gg_quotewin = id);
                ;
            default:
                IdentifyGlkObject(1, 0, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SCRIPTFREF_ROCK:
                (gg_scriptfref = id);
                ;
            default:
                IdentifyGlkObject(1, 2, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            switch ((gg_arguments-->(0))) {
                GG_FOREGROUNDCHAN_ROCK:
                    (gg_foregroundchan = id);
                    ;
                GG_BACKGROUNDCHAN_ROCK:
                    (gg_backgroundchan = id);
                    ;
                default:
                    IdentifyGlkObject(1, 3, id, (gg_arguments-->(0)));
                    ;
            }
            (id = glk_schannel_iterate(id, gg_arguments));
        }
        if ((gg_foregroundchan ~= 0)) {
            glk_schannel_stop(gg_foregroundchan);
        }
        if ((gg_backgroundchan ~= 0)) {
            glk_schannel_stop(gg_backgroundchan);
        }
    }
    IdentifyGlkObject(2);
];
[ VM_Describe_Release i;
    print "Release ";
    @aloads ROM_GAMERELEASE 0 i;
    print i;
    print " / Serial number ";
    for ((i = 0):(i < 6):(i)++) {
        print (char) (ROM_GAMESERIAL->(i));
    }
];
[ VM_KeyChar win nostat done res ix jx ch;
    (jx = ch);
    if ((win == 0)) {
        (win = gg_mainwin);
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, gg_arguments, 31));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if (((gg_arguments->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            (res = (gg_arguments->(0)));
            if ((res == 92)) {
                (res = 0);
                for ((ix = 1):(ix < done):(ix)++) {
                    (ch = (gg_arguments->(ix)));
                    if ((((ch >= 48)) && ((ch <= 57)))) {
                        @shiftl res 4 res;
                        (res = (res + (ch - 48)));
                    } else {
                        if ((((ch >= 97)) && ((ch <= 102)))) {
                            @shiftl res 4 res;
                            (res = (res + ((ch + 10) - 97)));
                        } else {
                            if ((((ch >= 65)) && ((ch <= 70)))) {
                                @shiftl res 4 res;
                                (res = (res + ((ch + 10) - 65)));
                            }
                        }
                    }
                }
            }
            jump KCPContinue;
        }
    }
    (done = 0);
    glk_request_char_event(win);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                if (nostat) {
                    glk_cancel_char_event(win);
                    (res = -2147483648);
                    (done = 1);
                    break;
                }
                DrawStatusLine();
                ;
            2:
                if (((gg_event-->(1)) == win)) {
                    (res = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (res = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        if ((((((res < 32)) || ((res >= 256)))) || ((res == 92 or 32)))) {
            glk_put_char_stream(gg_commandstr, 92);
            (done = 0);
            (jx = res);
            for ((ix = 0):(ix < 8):(ix)++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                (ch = ((ch)&(15)));
                if ((((ch ~= 0)) || ((ix == 7)))) {
                    (done = 1);
                }
                if (done) {
                    if ((((ch >= 0)) && ((ch <= 9)))) {
                        (ch = (ch + 48));
                    } else {
                        (ch = ((ch - 10) + 65));
                    }
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KCPContinue;
    return res;
];
[ VM_KeyDelay tenths key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events((tenths*100));
    while ((~~(done))) {
        glk_select(gg_event);
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (key = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((((ix >= 0)) && (((gg_event-->(0)) == 1 or 2)))) {
                (key = (gg_event-->(2)));
                (done = 1);
            }
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];
[ VM_ReadKeyboard a_buffer a_table done ix;
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, (a_buffer + WORDSIZE), ((INPUT_BUFFER_LEN - WORDSIZE) - 1)));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if ((((a_buffer + WORDSIZE)->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            ((a_buffer-->(0)) = done);
            VM_Style(INPUT_VMSTY);
            glk_put_buffer((a_buffer + WORDSIZE), done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    (done = 0);
    glk_request_line_event(gg_mainwin, (a_buffer + WORDSIZE), (INPUT_BUFFER_LEN - WORDSIZE), 0);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                DrawStatusLine();
                ;
            3:
                if (((gg_event-->(1)) == gg_mainwin)) {
                    ((a_buffer-->(0)) = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 0, a_buffer));
        if ((ix == 2)) {
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        glk_put_buffer_stream(gg_commandstr, (a_buffer + WORDSIZE), (a_buffer-->(0)));
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KPContinue;
    VM_Tokenise(a_buffer, a_table);
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        (gg_quotewin = 0);
    }
    if (((KIT_CONFIGURATION_BITMAP)&(ECHO_COMMANDS_TCBIT))) {
        print "** ";
        for ((ix = WORDSIZE):(ix < ((a_buffer-->(0)) + WORDSIZE)):(ix)++) {
            print (char) (a_buffer->(ix));
        }
        print "^";
    }
];
[ VM_CopyBuffer bto bfrom i;
    for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
        ((bto->(i)) = (bfrom->(i)));
    }
];
[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if ((((((metaclass(a) == Object)) && (((_final_propertylength(OBJECT_TY, a, b)) == WORDSIZE)))) && ((metaclass(_final_propertyvalue(OBJECT_TY, a, b)) == String)))) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, _final_propertyvalue(OBJECT_TY, a, b)));
        } else {
            if ((metaclass(a) == Routine)) {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
            } else {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b));
            }
        }
    } else {
        if ((metaclass(a) == Routine)) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
        } else {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a));
        }
    }
    if (((buf-->(0)) > len)) {
        ((buf-->(0)) = len);
    }
    return (buf-->(0));
];
[ VM_Tokenise buf tab cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    (len = (buf-->(0)));
    (buf = (buf + WORDSIZE));
    (cx = 0);
    (numwords = 0);
    while ((cx < len)) {
        while ((((cx < len)) && (((buf->(cx)) == 32)))) {
            (cx)++;
        }
        if ((cx >= len)) {
            break;
        }
        (bx = cx);
        if (((buf->(cx)) == 46 or 44 or 34)) {
            (cx)++;
        } else {
            while ((((cx < len)) && (((buf->(cx)) ~= 32 or 46 or 44 or 34)))) {
                (cx)++;
            }
        }
        ((tab-->(((numwords*3) + 2))) = (cx - bx));
        ((tab-->(((numwords*3) + 3))) = (WORDSIZE + bx));
        (numwords)++;
        if ((numwords >= MAX_BUFFER_WORDS)) {
            break;
        }
    }
    ((tab-->(0)) = numwords);
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((wx = 0):(wx < numwords):(wx)++) {
        (wlen = (tab-->(((wx*3) + 2))));
        (wpos = (tab-->(((wx*3) + 3))));
        if ((wlen > DICT_WORD_SIZE)) {
            (wlen = DICT_WORD_SIZE);
        }
        (cx = (wpos - WORDSIZE));
        for ((ix = 0):(ix < wlen):(ix)++) {
            ((gg_tokenbuf->(ix)) = VM_UpperToLowerCase((buf->((cx + ix)))));
        }
        for (:(ix < DICT_WORD_SIZE):(ix)++) {
            ((gg_tokenbuf->(ix)) = 0);
        }
        (val = (#dictionary_table + WORDSIZE));
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        ((tab-->(((wx*3) + 1))) = res);
    }
];
[ LTI_Insert i ch b y;
    (b = buffer);
    (y = (b-->(0)));
    if ((y > INPUT_BUFFER_LEN)) {
        (y = INPUT_BUFFER_LEN);
    }
    for ((y = (y + WORDSIZE)):(y > i):(y)--) {
        ((b->(y)) = (b->((y - 1))));
    }
    ((b->(i)) = ch);
    if (((b-->(0)) < INPUT_BUFFER_LEN)) {
        ((b-->(0)))++;
    }
];
[ VM_InvalidDictionaryAddress addr;
    if ((addr < 0)) {
        rtrue;
    }
    rfalse;
];
[ VM_DictionaryAddressToNumber w;
    return w;
];
[ VM_NumberToDictionaryAddress n;
    return n;
];
[ GGWordCompare str1 str2 ix jx;
    for ((ix = 0):(ix < DICT_WORD_SIZE):(ix)++) {
        (jx = ((str1->(ix)) - (str2->(ix))));
        if ((jx ~= 0)) {
            return jx;
        }
    }
    rfalse;
];
[ VM_CommandTableAddress i;
    return (#grammar_table-->((i + 1)));
];
[ VM_PrintCommandWords i wd j dictlen entrylen;
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((j = 0):(j < dictlen):(j)++) {
        (wd = ((#dictionary_table + WORDSIZE) + (entrylen*j)));
        if ((DictionaryWordToVerbNum(wd) == i)) {
            print "'";
            print (address) wd;
            print "' ";
        }
    }
];
[ VM_Seed_RNG n;
    @setrandom n;
];
[ VM_AllocateMemory amount i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        return i;
    }
    @malloc amount i;
    return i;
];
[ VM_FreeMemory address i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        rtrue;
    }
    @mfree address;
];
[ VM_Picture resource_ID;
    if (glk_gestalt(gestalt_Graphics, 0)) {
        glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
    } else {
        print "[Picture number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_SoundEffect resource_ID;
    if (glk_gestalt(gestalt_Sound, 0)) {
        glk_schannel_play(gg_foregroundchan, resource_ID);
    } else {
        print "[Sound effect number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_Style sty;
    switch (sty) {
        NORMAL_VMSTY:
            glk_set_style(style_Normal);
            ;
        HEADER_VMSTY:
            glk_set_style(style_Header);
            ;
        SUBHEADER_VMSTY:
            glk_set_style(style_Subheader);
            ;
        NOTE_VMSTY:
            glk_set_style(style_Note);
            ;
        ALERT_VMSTY:
            glk_set_style(style_Alert);
            ;
        BLOCKQUOTE_VMSTY:
            glk_set_style(style_BlockQuote);
            ;
        INPUT_VMSTY:
            glk_set_style(style_Input);
            ;
    }
];
[ VM_UpperToLowerCase c;
    return glk_char_to_lower(c);
];
[ VM_LowerToUpperCase c;
    return glk_char_to_upper(c);
];
[ Glulx_PrintAnything _vararg_count obj mclass;
    if ((_vararg_count == 0)) {
        rtrue;
    }
    @copy sp obj;
    (_vararg_count)--;
    if ((obj == 0)) {
        rtrue;
    }
    if (((obj->(0)) == 96)) {
        print (address) obj;
        rtrue;
    }
    (mclass = metaclass(obj));
    switch (mclass) {
        0:
            rtrue;
            ;
        String:
            print (string) obj;
            rtrue;
            ;
        Routine:
            @call obj _vararg_count 0;
            rtrue;
            ;
        Object:
            if ((_vararg_count == 0)) {
                PrintShortName(obj);
            } else {
                @copy obj sp;
                (_vararg_count)++;
                @call PrintOrRun _vararg_count 0;
            }
            rtrue;
            ;
    }
];
[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    (_vararg_count = (_vararg_count - 2));
    (oldstr = glk_stream_get_current());
    (str = glk_stream_open_memory(arr, arrlen, 1, 0));
    if ((str == 0)) {
        rfalse;
    }
    glk_stream_set_current(str);
    @call Glulx_PrintAnything _vararg_count 0;
    glk_stream_set_current(oldstr);
    @copy -1 sp;
    @copy str sp;
    @glk 68 2 0;
    @copy sp len;
    @copy sp 0;
    return len;
];
[ Glulx_ChangeAnyToCString _vararg_count ix len;
    (ix = (GG_ANYTOSTRING_LEN - 2));
    @copy ix sp;
    (ix = (AnyToStrArr + 1));
    @copy ix sp;
    (ix = (_vararg_count + 2));
    @call Glulx_PrintAnyToArray ix len;
    ((AnyToStrArr->(0)) = 224);
    if ((len >= GG_ANYTOSTRING_LEN)) {
        (len = (GG_ANYTOSTRING_LEN - 1));
    }
    ((AnyToStrArr->((len + 1))) = 0);
    return AnyToStrArr;
];
[ VM_ClearScreen window;
    if ((window == WIN_ALL or WIN_MAIN)) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            (gg_quotewin = 0);
        }
    }
    if (((gg_statuswin) && ((window == WIN_ALL or WIN_STATUS)))) {
        glk_window_clear(gg_statuswin);
    }
];
[ VM_ScreenWidth id;
    (id = gg_mainwin);
    if (((gg_statuswin) && (statuswin_current))) {
        (id = gg_statuswin);
    }
    glk_window_get_size(id, gg_arguments, 0);
    return (gg_arguments-->(0));
];
[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return (gg_arguments-->(0));
];
[ VM_SetWindowColours f b window doclear i fwd bwd swin;
    if (((((clr_on) && (f))) && (b))) {
        if (window) {
            (swin = (5 - window));
        }
        (fwd = MakeColourWord(f));
        (bwd = MakeColourWord(b));
        for ((i = 0):(i < style_NUMSTYLES):(i)++) {
            if ((((f == CLR_DEFAULT)) || ((b == CLR_DEFAULT)))) {
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }
        if (gg_statuswin) {
            glk_window_close(gg_statuswin, 0);
        }
        (gg_statuswin = 0);
        if (((doclear) || ((((window ~= 1)) && ((((clr_fg ~= f)) || ((clr_bg ~= b)))))))) {
            glk_window_close(gg_mainwin, 0);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
            if ((gg_scriptstr ~= 0)) {
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
            }
        }
        (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        if (((statuswin_current) && (gg_statuswin))) {
            VM_MoveCursorInStatusLine();
        } else {
            VM_MainWindow();
        }
        if ((window ~= 2)) {
            (clr_fgstatus = f);
            (clr_bgstatus = b);
        }
        if ((window ~= 1)) {
            (clr_fg = f);
            (clr_bg = b);
        }
    }
];
[ VM_RestoreWindowColours;
    if (clr_on) {
        VM_SetWindowColours(clr_fg, clr_bg, 2);
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, 1);
        VM_ClearScreen();
    }
];
[ MakeColourWord c;
    if ((c > 9)) {
        return c;
    }
    (c = (c - 2));
    return (((16711680*((c)&(1))) + (65280*(((c)&(2)) ~= 0))) + (255*(((c)&(4)) ~= 0)));
];
[ VM_MainWindow;
    glk_set_window(gg_mainwin);
    (statuswin_current = 0);
];
[ VM_StatusLineHeight hgt;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    if ((hgt == statuswin_cursize)) {
        rtrue;
    }
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), 18, hgt, 0);
    (statuswin_cursize = hgt);
];
[ VM_MoveCursorInStatusLine line column;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    glk_set_window(gg_statuswin);
    if ((line == 0)) {
        (line = 1);
        (column = 1);
    }
    glk_window_move_cursor(gg_statuswin, (column - 1), (line - 1));
    (statuswin_current = 1);
];
[ Box__Routine maxwid arr ix lines lastnl parwin;
    (maxwid = 0);
    (lines = (arr-->(0)));
    if ((gg_quotewin == 0)) {
        ((gg_arguments-->(0)) = lines);
        (ix = InitGlkWindow(GG_QUOTEWIN_ROCK));
        if ((ix == 0)) {
            (gg_quotewin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK));
        }
    } else {
        (parwin = glk_window_get_parent(gg_quotewin));
        glk_window_set_arrangement(parwin, 18, lines, 0);
    }
    (lastnl = 1);
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        (lastnl = 0);
    }
    VM_Style(BLOCKQUOTE_VMSTY);
    for ((ix = 0):(ix < lines):(ix)++) {
        print (string) (arr-->((ix + 1)));
        if ((((ix < (lines - 1))) || (lastnl))) {
            print "^";
        }
    }
    VM_Style(NORMAL_VMSTY);
    if (gg_quotewin) {
        glk_set_window(gg_mainwin);
    }
];
[ Unsigned__Compare x y;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ RT__ChLDW x y;
    @aload x y sp;
    @return sp;
];
[ RT__ChLDB x y;
    @aloadb x y sp;
    @return sp;
];
[ ClearParagraphing r;
    (say__p = 0);
    (say__pc = 0);
];
[ DivideParagraphPoint;
    if (say__p) {
        print "^";
        (say__p = 0);
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
        (say__pc_save = 1);
        if (((say__pc)&(PARA_PROMPTSKIP))) {
            (say__pc = (say__pc - PARA_PROMPTSKIP));
        }
        if (((say__pc)&(PARA_SUPPRESSPROMPTSKIP))) {
            (say__pc = (say__pc - PARA_SUPPRESSPROMPTSKIP));
        }
    }
    (say__pc = ((say__pc)|(PARA_CONTENTEXPECTED)));
    (say__pc_save = ((say__pc)&(PARA_COMPLETED)));
];
[ AdjustParagraphPoint;
    if (say__pc_save) {
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
    }
];
[ ParaContent;
    if (((say__pc)&(PARA_CONTENTEXPECTED))) {
        (say__pc = (say__pc - PARA_CONTENTEXPECTED));
        (say__p = 1);
    }
];
[ GoingLookBreak;
    if ((((say__pc)&(PARA_COMPLETED)) == 0)) {
        print "^";
    }
    ClearParagraphing(10);
];
[ CommandClarificationBreak;
    print "^";
    ClearParagraphing(11);
];
[ RunParagraphOn;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
    (say__pc = ((say__pc)|(PARA_SUPPRESSPROMPTSKIP)));
];
[ SpecialLookSpacingBreak;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
];
[ EnsureBreakBeforePrompt;
    if (((say__p) || (((((say__pc)&(PARA_PROMPTSKIP))) && ((((say__pc)&(PARA_SUPPRESSPROMPTSKIP)) == 0)))))) {
        print "^";
    }
    ClearParagraphing(12);
];
[ PrintSingleParagraph matter;
    (say__p = 1);
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    TEXT_TY_Say(matter);
    DivideParagraphPoint();
    (say__pc = 0);
];
[ STextSubstitution;
    if ((say__n ~= 1)) {
        print "s";
    }
];
[ EnglishNumber n;
    LanguageNumber(n);
];
[ LanguageNumber n f;
    if ((n == 0)) {
        print "zero";
        rfalse;
    }
    if ((n == MIN_NEGATIVE_NUMBER)) {
        print "minus two billion";
        (n = 147483648);
        (f = 1);
    }
    if ((n < 0)) {
        print "minus ";
        (n = (-(n)));
    }
    if ((n >= 1000000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000000));
        print " billion";
        (n = (n%1000000000));
        (f = 1);
    }
    if ((n >= 1000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000));
        print " million";
        (n = (n%1000000));
        (f = 1);
    }
    if ((n >= 1000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000));
        print " thousand";
        (n = (n%1000));
        (f = 1);
    }
    if ((n >= 100)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/100));
        print " hundred";
        (n = (n%100));
        (f = 1);
    }
    if ((n == 0)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(DIALECT_US_TCBIT))) {
        if ((f == 1)) {
            print " ";
        }
    } else {
        if ((f == 1)) {
            print " and ";
        }
    }
    if ((((n >= 20)) && ((n < 100)))) {
        switch ((n/10)) {
            2:
                print "twenty";
                ;
            3:
                print "thirty";
                ;
            4:
                print "forty";
                ;
            5:
                print "fifty";
                ;
            6:
                print "sixty";
                ;
            7:
                print "seventy";
                ;
            8:
                print "eighty";
                ;
            9:
                print "ninety";
                ;
        }
        if (((n%10) ~= 0)) {
            print "-";
            LanguageNumber((n%10));
        }
    } else {
        switch (n) {
            1:
                print "one";
                ;
            2:
                print "two";
                ;
            3:
                print "three";
                ;
            4:
                print "four";
                ;
            5:
                print "five";
                ;
            6:
                print "six";
                ;
            7:
                print "seven";
                ;
            8:
                print "eight";
                ;
            9:
                print "nine";
                ;
            10:
                print "ten";
                ;
            11:
                print "eleven";
                ;
            12:
                print "twelve";
                ;
            13:
                print "thirteen";
                ;
            14:
                print "fourteen";
                ;
            15:
                print "fifteen";
                ;
            16:
                print "sixteen";
                ;
            17:
                print "seventeen";
                ;
            18:
                print "eighteen";
                ;
            19:
                print "nineteen";
                ;
        }
    }
];
[ SquareRoot num op res one n x;
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
    (op = num);
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    for ((one = WORD_NEXTTOHIGHBIT):(one > op):(one = (one/4))) {
    }
    while ((one ~= 0)) {
        if ((op >= (res + one))) {
            (op = ((op - res) - one));
            (res = ((res/2) + one));
        } else {
            (res = (res/2));
        }
        (one = (one/4));
    }
    return res;
];
[ CubeRoot num neg x y n;
    @gestalt 11 0 n;
    if (n) {
        if ((num < 0)) {
            (neg = 1);
            (num = (-(num)));
        }
        @numtof num x;
        @pow x 1051372203 x;
        @ftonumz x num;
        if (neg) {
            return (-(num));
        } else {
            return num;
        }
    }
    if ((num < 0)) {
        (x = (-(SquareRoot((-(num))))));
    } else {
        (x = SquareRoot(num));
    }
    for ((n = 0):(((y ~= x)) && (((n)++ < 100))):((y = x),(x = (((2*x) + ((num/x)/x))/3)))) {
    }
    return x;
];
[ NUMBER_TY_Abs x;
    if ((x < 0)) {
        return (-(x));
    }
    return x;
];
[ IntegerDivide A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A/B);
];
[ IntegerRemainder A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A%B);
];
[ UnsignedCompare x y u v;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ SignedCompare x y;
    if ((x > y)) {
        rtrue;
    }
    if ((x == y)) {
        rfalse;
    }
    return (-(1));
];
[ REAL_NUMBER_TY_Say fp;
    Float(fp);
];
[ REAL_NUMBER_TY_Compare r1 r2;
    @jflt r1 r2 ?less;
    @jfeq r1 r2 0 ?same;
    rtrue;
    .same;
    rfalse;
    .less;
    return (-(1));
];
[ NUMBER_TY_to_REAL_NUMBER_TY int real;
    @numtof int real;
    return real;
];
[ REAL_NUMBER_TY_to_NUMBER_TY real int;
    @ftonumn real int;
    return int;
];
[ REAL_NUMBER_TY_Sin in out;
    @sin in out;
    return out;
];
[ REAL_NUMBER_TY_Cos in out;
    @cos in out;
    return out;
];
[ REAL_NUMBER_TY_Tan in out;
    @tan in out;
    return out;
];
[ REAL_NUMBER_TY_Arcsin in out;
    @asin in out;
    return out;
];
[ REAL_NUMBER_TY_Arccos in out;
    @acos in out;
    return out;
];
[ REAL_NUMBER_TY_Arctan in out;
    @atan in out;
    return out;
];
[ REAL_NUMBER_TY_Sinh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fadd tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Cosh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fsub tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Tanh in s c t;
    (s = REAL_NUMBER_TY_Sinh(in));
    (c = REAL_NUMBER_TY_Cosh(in));
    @fdiv s c t;
    return t;
];
[ REAL_NUMBER_TY_Reciprocal in out;
    @fdiv M_1 in out;
    return out;
];
[ REAL_NUMBER_TY_Negate in out;
    @fsub M_0 in out;
    return out;
];
[ REAL_NUMBER_TY_Plus x y out;
    @fadd x y out;
    return out;
];
[ REAL_NUMBER_TY_Minus x y out;
    @fsub x y out;
    return out;
];
[ REAL_NUMBER_TY_Times x y out;
    @fmul x y out;
    return out;
];
[ REAL_NUMBER_TY_Divide x y out;
    @fdiv x y out;
    return out;
];
[ REAL_NUMBER_TY_Remainder x y r q;
    @fmod x y r q;
    return r;
];
[ REAL_NUMBER_TY_Approximate x y quotient out;
    @fdiv x y quotient;
    @fadd quotient M_HALF quotient;
    @floor quotient quotient;
    @fmul quotient y out;
    return out;
];
[ REAL_NUMBER_TY_Root x out;
    @sqrt x out;
    return out;
];
[ REAL_NUMBER_TY_Cube_Root x out;
    @pow x M_THIRD out;
    return out;
];
[ REAL_NUMBER_TY_Pow x y out;
    @pow x y out;
    return out;
];
[ REAL_NUMBER_TY_Exp x out;
    @exp x out;
    return out;
];
[ REAL_NUMBER_TY_Log x out;
    @log x out;
    return out;
];
[ REAL_NUMBER_TY_BLog x n d out;
    @log x out;
    if ((n == 10)) {
        (d = M_LOG10);
    } else {
        @numtof n d;
        @log d d;
    }
    @fdiv out d out;
    return out;
];
[ REAL_NUMBER_TY_Floor x out;
    @floor x out;
    return out;
];
[ REAL_NUMBER_TY_Ceiling x out;
    @ceil x out;
    return out;
];
[ REAL_NUMBER_TY_Abs x;
    return ((x)&(2147483647));
];
[ REAL_NUMBER_TY_Nan x;
    @jisnan x ?Nan;
    rfalse;
    .Nan;
    rtrue;
];
[ FloatParse buf len useall res ix val ch ten negative intpart fracpart fracdiv expon expnegative count;
    if ((len == 0)) {
        return FLOAT_NAN;
    }
    (ix = 0);
    (negative = 0);
    (intpart = 0);
    (fracpart = 0);
    @numtof 10 ten;
    (ch = (buf->(ix)));
    if ((ch == 45)) {
        (negative = 1);
        (ix)++;
    } else {
        if ((ch == 43)) {
            (ix)++;
        }
    }
    for ((count = 0):(ix < len):((ix)++,(count)++)) {
        (ch = (buf->(ix)));
        if ((((ch < 48)) || ((ch > 57)))) {
            break;
        }
        (val = (ch - 48));
        @numtof val val;
        @fmul intpart ten intpart;
        @fadd intpart val intpart;
    }
    if ((((ix < len)) && (((buf->(ix)) == 46)))) {
        (ix)++;
        @numtof 1 fracdiv;
        for (:(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (val = (ch - 48));
            @numtof val val;
            @fmul fracpart ten fracpart;
            @fadd fracpart val fracpart;
            @fmul fracdiv ten fracdiv;
        }
        @fdiv fracpart fracdiv fracpart;
    }
    if ((count == 0)) {
        return FLOAT_NAN;
    }
    @fadd intpart fracpart res;
    if ((((ix < len)) && (((buf->(ix)) == 101 or 69 or 32 or 42 or 120 or 88 or 215)))) {
        if (((buf->(ix)) == 101 or 69)) {
            (ix)++;
            if ((ix == len)) {
                return FLOAT_NAN;
            }
        } else {
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 42 or 120 or 88 or 215)) {
                return FLOAT_NAN;
            }
            (ix)++;
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 49)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 48)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 94)) {
                return FLOAT_NAN;
            }
            (ix)++;
        }
        (expnegative = 0);
        (ch = (buf->(ix)));
        if ((ch == 45)) {
            (expnegative = 1);
            (ix)++;
        } else {
            if ((ch == 43)) {
                (ix)++;
            }
        }
        (expon = 0);
        for ((count = 0):(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (expon = ((10*expon) + (ch - 48)));
        }
        if ((count == 0)) {
            return FLOAT_NAN;
        }
        if (expnegative) {
            (expon = (-(expon)));
        }
        if (expon) {
            @numtof expon expon;
            @pow ten expon val;
            @fmul res val res;
        }
    }
    if (negative) {
        (res = ((-2147483648)|(res)));
    }
    if (((useall) && ((ix ~= len)))) {
        return FLOAT_NAN;
    }
    return res;
];
[ Float val prec pval;
    (pval = ((val)&(2147483647)));
    @jz pval ?UseFloatDec;
    @jfge pval 1232348160 ?UseFloatExp;
    @jflt pval 953267991 ?UseFloatExp;
    .UseFloatDec;
    return FloatDec(val, prec);
    .UseFloatExp;
    return FloatExp(val, prec);
];
[ FloatExp val prec log10val expo fexpo idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    if ((val == 0)) {
        (expo = 0);
        (idig = 0);
        jump DoPrint;
    }
    @log val sp;
    @fdiv sp 1075010958 log10val;
    @floor log10val fexpo;
    @ftonumn fexpo expo;
    @fsub log10val fexpo sp;
    @numtof prec sp;
    @fadd sp sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    .DoPrint;
    if ((idig >= (10*pow10))) {
        (expo)++;
        @div idig 10 idig;
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    for ((ix = 0):(ix <= prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        if ((ix == 0)) {
            @streamchar 46;
        }
        @div pow10 10 pow10;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(PROGRAMMING_EXPONENTS_TCBIT)) == 0)) {
        PrintMultiplicationSign();
        @streamchar 49;
        @streamchar 48;
        @streamchar 94;
        @streamnum expo;
    } else {
        @streamchar 101;
        if ((expo < 0)) {
            @streamchar 45;
            @neg expo expo;
        } else {
            @streamchar 43;
        }
        if ((expo < 10)) {
            @streamchar 48;
        }
        @streamnum expo;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ FloatDec val prec log10val int fint extra0 frac idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    (extra0 = 0);
    @fmod val 1065353216 frac fint;
    @ftonumz fint int;
    if ((int == 2147483647)) {
        @log fint sp;
        @fdiv sp 1075010958 log10val;
        @ftonumz log10val extra0;
        @sub extra0 8 extra0;
        @numtof extra0 sp;
        @fsub log10val sp sp;
        @fmul sp 1075010958 sp;
        @exp sp sp;
        @ftonumz sp int;
    }
    @streamnum int;
    for ((ix = 0):(ix < extra0):(ix)++) {
        @streamchar 48;
    }
    @streamchar 46;
    @log frac sp;
    @fdiv sp 1075010958 log10val;
    @numtof prec sp;
    @fadd log10val sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    if ((idig >= pow10)) {
        (idig = (pow10 - 1));
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    @div pow10 10 pow10;
    for ((ix = 0):(ix < prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        @div pow10 10 pow10;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ PrintInfinity;
    @streamunichar 8734;
];
[ PrintNan;
    @streamunichar 9888;
];
[ PrintMultiplicationSign;
    print " ";
    @streamunichar 215;
    print " ";
];
[ FileIO_Error extf err_text struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        print "^*** Error on unknown file: ";
        print (string) err_text;
        print " ***^";
    } else {
        (struc = (TableOfExternalFiles-->(extf)));
        print "^*** Error on file '";
        print (string) (struc-->(AUXF_FILENAME));
        print "': ";
        print (string) err_text;
        print " ***^";
    }
    RunTimeProblem(RTP_FILEIOERROR);
    rfalse;
];
[ FileIO_Exists extf fref struc rv usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    (rv = glk_fileref_does_file_exist(fref));
    glk_fileref_destroy(fref);
    return rv;
];
[ FileIO_Ready extf struc fref usage str ch;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        rfalse;
    }
    (str = glk_stream_open_file(fref, filemode_Read, 0));
    (ch = glk_get_char_stream(str));
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
    if ((ch ~= 42)) {
        rfalse;
    }
    rtrue;
];
[ FileIO_MarkReady extf readiness struc fref str ch usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only existing files can be marked");
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only closed files can be marked");
    }
    (str = glk_stream_open_file(fref, filemode_ReadWrite, 0));
    glk_stream_set_position(str, 0, 0);
    if (readiness) {
        (ch = 42);
    } else {
        (ch = 45);
    }
    glk_put_char_stream(str, ch);
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
];
[ FileIO_Open extf write_flag append_flag struc fref str mode ix ch not_this_ifid owner force_header usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        return FileIO_Error(extf, "tried to open a file already open");
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if (write_flag) {
        if (append_flag) {
            (mode = filemode_WriteAppend);
            if ((glk_fileref_does_file_exist(fref) == 0)) {
                (force_header = 1);
            }
        } else {
            (mode = filemode_Write);
        }
    } else {
        (mode = filemode_Read);
        if ((glk_fileref_does_file_exist(fref) == 0)) {
            glk_fileref_destroy(fref);
            return FileIO_Error(extf, "tried to open a file which does not exist");
        }
    }
    (str = glk_stream_open_file(fref, mode, 0));
    glk_fileref_destroy(fref);
    if ((str == 0)) {
        return FileIO_Error(extf, "tried to open a file but failed");
    }
    ((struc-->(AUXF_STREAM)) = str);
    if (write_flag) {
        if (append_flag) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_APPEND);
        } else {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_WRITE);
        }
        glk_stream_set_current(str);
        if ((((append_flag == 0)) || (force_header))) {
            print "- ";
            for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
                print (char) (UUID_ARRAY->(ix));
            }
            print " ";
            print (string) (struc-->(AUXF_FILENAME));
            print "^";
        }
    } else {
        ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_READ);
        (ch = FileIO_GetC(extf));
        if ((ch ~= 45 or 42)) {
            jump BadFile;
        }
        if ((ch == 45)) {
            return FileIO_Error(extf, "tried to open a file which was incomplete");
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 32)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (owner = (struc-->(AUXF_IFID_OF_OWNER)));
        (ix = 3);
        if ((owner == UUID_ARRAY)) {
            (ix = 8);
        }
        if ((owner ~= NULL)) {
            for (:(ix <= (owner->(0))):(ix)++) {
                (ch = FileIO_GetC(extf));
                if ((ch == -1)) {
                    jump BadFile;
                }
                if ((ch ~= (owner->(ix)))) {
                    (not_this_ifid = 1);
                }
                if ((ch == 32)) {
                    break;
                }
            }
            if ((not_this_ifid == 0)) {
                (ch = FileIO_GetC(extf));
                if ((ch ~= 32)) {
                    jump BadFile;
                }
            }
        }
        while ((ch ~= -1)) {
            (ch = FileIO_GetC(extf));
            if ((ch == 10 or 13)) {
                break;
            }
        }
        if (not_this_ifid) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
            glk_stream_close(str, 0);
            return FileIO_Error(extf, "tried to open a file owned by another project");
        }
    }
    return (struc-->(AUXF_STREAM));
    .BadFile;
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
    glk_stream_close(str, 0);
    return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];
[ FileIO_Close extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ or AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to close a file which is not open");
    }
    if (((struc-->(AUXF_STATUS)) == AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        glk_stream_set_position((struc-->(AUXF_STREAM)), 0, 0);
        glk_put_char_stream((struc-->(AUXF_STREAM)), 42);
    }
    glk_stream_close((struc-->(AUXF_STREAM)), 0);
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
];
[ FileIO_GetC extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return (-(1));
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ)) {
        return (-(1));
    }
    return glk_get_char_stream((struc-->(AUXF_STREAM)));
];
[ FileIO_PutC extf char struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to write to a file which is not open for writing");
    }
    return glk_put_char_stream((struc-->(AUXF_STREAM)), char);
];
[ FileIO_PrintLine extf ch struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    for (:1:) {
        (ch = FileIO_GetC(extf));
        if ((ch == -1)) {
            rfalse;
        }
        if ((ch == 10 or 13)) {
            print "^";
            rtrue;
        }
        print (char) ch;
    }
];
[ FileIO_PrintContents extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "printing text will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    while (FileIO_PrintLine(extf)) {
    }
    FileIO_Close(extf);
    rtrue;
];
[ FileIO_PutContents extf text append_flag struc str ch oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing text will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    (str = FileIO_Open(extf, 1, append_flag));
    if ((str == 0)) {
        rfalse;
    }
    @push say__p;
    @push say__pc;
    ClearParagraphing(19);
    TEXT_TY_Say(text);
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    @pull say__pc;
    @pull say__p;
    rfalse;
];
[ FileIO_PutTable extf tab rv struc oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write table to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing a table will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    if ((FileIO_Open(extf, 1) == 0)) {
        rfalse;
    }
    (rv = TablePrint(tab));
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    if (rv) {
        return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
    }
    rtrue;
];
[ FileIO_GetTable extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to read table from a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "reading a table will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    TableRead(tab, extf);
    FileIO_Close(extf);
    rtrue;
];
[ SetSortDomain swapf compf;
    (I7S_Swap = swapf);
    (I7S_Comp = compf);
];
[ SortArray tab col dir size algorithm;
    (I7S_Tab = tab);
    (I7S_Col = col);
    (I7S_Dir = dir);
    SortRange(0, size, algorithm);
];
[ SortRange x y algorithm;
    if (((y - x) < 2)) {
        rtrue;
    }
    if (algorithm) {
        (algorithm)(x,y);
    } else {
        InPlaceMergeSortAlgorithm(x, y);
    }
];
[ CompareFields x y;
    return (I7S_Dir*(I7S_Comp)(I7S_Tab,I7S_Col,(x + 1),(y + 1),I7S_Dir));
];
[ ExchangeFields x y r;
    (r = (I7S_Swap)(I7S_Tab,(x + 1),(y + 1)));
    return r;
];
[ OldSortAlgorithm x y f i j;
    if (((y - x) < 2)) {
        rtrue;
    }
    (f = 1);
    while (f) {
        (f = 0);
        for ((i = x):(i < y):(i)++) {
            for ((j = (i + 1)):(j < y):(j)++) {
                if ((CompareFields(i, j) > 0)) {
                    ExchangeFields(i, j);
                    (f = 1);
                    break;
                }
            }
        }
    }
];
[ InsertionSortAlgorithm from to i j;
    if ((to > (from + 1))) {
        for ((i = (from + 1)):(i < to):(i)++) {
            for ((j = i):(j > from):(j)--) {
                if ((CompareFields(j, (j - 1)) < 0)) {
                    ExchangeFields(j, (j - 1));
                } else {
                    break;
                }
            }
        }
    }
];
[ InPlaceMergeSortAlgorithm from to middle;
    if (((to - from) < 12)) {
        if (((to - from) < 2)) {
            rtrue;
        }
        InsertionSortAlgorithm(from, to);
        rtrue;
    }
    (middle = ((from + to)/2));
    InPlaceMergeSortAlgorithm(from, middle);
    InPlaceMergeSortAlgorithm(middle, to);
    IPMS_Merge(from, middle, to, (middle - from), (to - middle));
];
[ IPMS_Lower from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(mid, val) < 0)) {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        } else {
            (len = half);
        }
    }
    return from;
];
[ IPMS_Upper from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(val, mid) < 0)) {
            (len = half);
        } else {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        }
    }
    return from;
];
[ IPMS_Reverse from to;
    while ((from < to)) {
        ExchangeFields((from)++, (to)--);
    }
];
[ IPMS_Rotate from mid to n val shift p1 p2;
    if ((((from == mid)) || ((mid == to)))) {
        rtrue;
    }
    IPMS_Reverse(from, (mid - 1));
    IPMS_Reverse(mid, (to - 1));
    IPMS_Reverse(from, (to - 1));
];
[ IPMS_Merge from pivot to len1 len2 first_cut second_cut len11 len22 new_mid;
    if ((((len1 == 0)) || ((len2 == 0)))) {
        rtrue;
    }
    if (((len1 + len2) == 2)) {
        if ((CompareFields(pivot, from) < 0)) {
            ExchangeFields(pivot, from);
        }
        rtrue;
    }
    if ((len1 > len2)) {
        (len11 = (len1/2));
        (first_cut = (from + len11));
        (second_cut = IPMS_Lower(pivot, to, first_cut));
        (len22 = (second_cut - pivot));
    } else {
        (len22 = (len2/2));
        (second_cut = (pivot + len22));
        (first_cut = IPMS_Upper(from, pivot, second_cut));
        (len11 = (first_cut - from));
    }
    IPMS_Rotate(first_cut, pivot, second_cut);
    (new_mid = (first_cut + len22));
    IPMS_Merge(from, first_cut, new_mid, len11, len22);
    IPMS_Merge(new_mid, second_cut, to, (len1 - len11), (len2 - len22));
];
[ TableFindCol tab col f i no_cols n;
    (no_cols = (tab-->(0)));
    for ((i = 1):(i <= no_cols):(i)++) {
        if ((col == ((((tab-->(i))-->(1)))&(TB_COLUMN_NUMBER)))) {
            return i;
        }
    }
    if (f) {
        RunTimeProblem(RTP_TABLE_NOCOL, tab);
        rfalse;
    }
    rfalse;
];
[ TableRows tab first_col;
    (first_col = (tab-->(1)));
    if ((first_col == 0)) {
        rfalse;
    }
    return ((first_col-->(0)) - COL_HSIZE);
];
[ CheckTableEntryIsBlank tab col row i at;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if ((((tab-->(col))-->((row + COL_HSIZE))) ~= TABLE_NOVALUE)) {
        print "*** CTEIB on nonblank value ";
        print tab;
        print " ";
        print col;
        print " ";
        print row;
        print " ***^";
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    if ((((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row%8)))))) {
        rtrue;
    }
    rfalse;
];
[ ForceTableEntryBlank tab col row i at oldv flags;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv ~= 0 or TABLE_NOVALUE)))) {
        BlkValueFree(oldv);
    }
    (((tab-->(col))-->((row + COL_HSIZE))) = TABLE_NOVALUE);
    if (((flags)&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row%8))))));
];
[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv == 0 or TABLE_NOVALUE)))) {
        (kov = UNKNOWN_TY);
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        if ((kov ~= UNKNOWN_TY)) {
            (((tab-->(col))-->((row + COL_HSIZE))) = BlkValueCreate(kov));
        }
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row%8))))));
];
[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (at1 = (((tab-->(col))-->(2)) + (row1/8)));
    (row2)--;
    (at2 = (((tab-->(col))-->(2)) + (row2/8)));
    (bit1 = (((TB_Blanks->(at1)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    (bit2 = (((TB_Blanks->(at2)))&((CheckTableEntryIsBlank_LU->((row2%8))))));
    if (bit1) {
        (bit1 = 1);
    }
    if (bit2) {
        (bit2 = 1);
    }
    if ((bit1 == bit2)) {
        rtrue;
    }
    if (bit1) {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))&((CheckTableEntryIsNonBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))|((CheckTableEntryIsBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (row2)--;
    (at = (((tab-->(col))-->(2)) + (row1/8)));
    (bit = (((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    if (bit) {
        (bit = 1);
    }
    for ((rx = row1):(rx < row2):(rx)++) {
        (atp1 = (((tab-->(col))-->(2)) + ((rx + 1)/8)));
        (at = (((tab-->(col))-->(2)) + (rx/8)));
        if ((((TB_Blanks->(atp1)))&((CheckTableEntryIsBlank_LU->(((rx + 1)%8)))))) {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((rx%8))))));
        } else {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((rx%8))))));
        }
    }
    (at = (((tab-->(col))-->(2)) + (row2/8)));
    if (bit) {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableRowCorr tab col lookup_value lookup_col i j f v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    (lookup_col = (tab-->(col)));
    (j = ((lookup_col-->(0)) - COL_HSIZE));
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (f) {
        for ((i = 1):(i <= j):(i)++) {
            (v = (lookup_col-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if ((BlkValueCompare(v, lookup_value) == 0)) {
                return i;
            }
        }
    } else {
        for ((i = 1):(i <= j):(i)++) {
            if ((((lookup_value == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (((lookup_col-->((i + COL_HSIZE))) == lookup_value)) {
                return i;
            }
        }
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableRowCorr tab col entry i k v f kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    (f = 0);
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 1);
    } else {
        if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
            (f = 2);
        }
    }
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            continue;
        }
        switch (f) {
            1:
                if (((v)((entry/100),(entry%100)) ~= GPR_FAIL)) {
                    return i;
                }
                ;
            2:
                if ((BlkValueCompare(v, entry) == 0)) {
                    return i;
                }
                ;
            default:
                if ((v == entry)) {
                    return i;
                }
                ;
        }
    }
    rfalse;
];
[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 1));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 1));
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        (v = (cola2-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col2, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare(v, lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if (((v)((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if ((v ~= lookup_value)) {
                    continue;
                }
            }
        }
        if (write_flag) {
            if ((write_flag == 4)) {
                ForceTableEntryBlank(tab, col1, (i - COL_HSIZE));
            } else {
                ForceTableEntryNonBlank(tab, col1, (i - COL_HSIZE));
            }
            switch (write_flag) {
                1:
                    ((cola1-->(i)) = write_value);
                    ;
                2:
                    ((cola1-->(i)) = ((cola1-->(i)) + write_value));
                    ;
                3:
                    ((cola1-->(i)) = ((cola1-->(i)) - write_value));
                    ;
                5:
                    return (cola1-->(i));
                    ;
            }
            rfalse;
        }
        (v = (cola1-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        return v;
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 0));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 0));
    }
    if (((col1*col2) == 0)) {
        rfalse;
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        if (((((cola1-->(i)) == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare((cola2-->(i)), lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if ((((cola2-->(i)))((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if (((cola2-->(i)) ~= lookup_value)) {
                    continue;
                }
            }
        }
        rtrue;
    }
    rfalse;
];
[ TableLookUpEntry tab col index write_flag write_value v;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE2);
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        RunTimeProblem(RTP_TABLE_NOROW, tab, index);
        (index = 1);
    }
    if (write_flag) {
        switch (write_flag) {
            1:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = write_value);
                ;
            2:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) + write_value));
                ;
            3:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) - write_value));
                ;
            4:
                ForceTableEntryBlank(tab, col, index);
                ;
            5:
                ForceTableEntryNonBlank(tab, col, index);
                return ((tab-->(col))-->((index + COL_HSIZE)));
                ;
        }
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
        rfalse;
    }
    return v;
];
[ ExistsTableLookUpEntry tab col index v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        rfalse;
    }
    rtrue;
];
[ TableRowIsBlank tab j k;
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        if ((((tab-->(k))-->((j + COL_HSIZE))) ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((CheckTableEntryIsBlank(tab, k, j) == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ TableBlankOutRow tab row k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        ForceTableEntryBlank(tab, k, row);
    }
];
[ TableBlankOutColumn tab col n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        ForceTableEntryBlank(tab, col, k);
    }
];
[ TableBlankOutAll tab n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        TableBlankOutRow(tab, k);
    }
];
[ TableBlankRows tab i j c;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            (c)++;
        }
    }
    return c;
];
[ TableFilledRows tab;
    return (TableRows(tab) - TableBlankRows(tab));
];
[ TableBlankRow tab i j;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            return j;
        }
    }
    RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
    return i;
];
[ TableRandomRow tab i j k;
    (i = TableRows(tab));
    (j = TableFilledRows(tab));
    if ((j == 0)) {
        return RunTimeProblem(RTP_TABLE_NOROWS, tab);
    }
    if ((j > 1)) {
        (j = random(j));
    }
    for ((k = 1):(k <= i):(k)++) {
        if ((TableRowIsBlank(tab, k) == 0)) {
            (j)--;
        }
        if ((j == 0)) {
            return k;
        }
    }
];
[ TableSwapRows tab i j k l v1 v2;
    if ((i == j)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (v1 = ((tab-->(k))-->((i + COL_HSIZE))));
        (v2 = ((tab-->(k))-->((j + COL_HSIZE))));
        (((tab-->(k))-->((i + COL_HSIZE))) = v2);
        (((tab-->(k))-->((j + COL_HSIZE))) = v1);
        if ((((v1 == TABLE_NOVALUE)) || ((v2 == TABLE_NOVALUE)))) {
            TableSwapBlankBits(tab, i, j, k);
        }
    }
];
[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (val1 = ((tab-->(col))-->((row1 + COL_HSIZE))));
    (val2 = ((tab-->(col))-->((row2 + COL_HSIZE))));
    if ((val1 == TABLE_NOVALUE)) {
        (bl1 = CheckTableEntryIsBlank(tab, col, row1));
    }
    if ((val2 == TABLE_NOVALUE)) {
        (bl2 = CheckTableEntryIsBlank(tab, col, row2));
    }
    if ((((val1 == val2)) && ((bl1 == bl2)))) {
        if ((val1 ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((bl1 == 0)) {
            rfalse;
        }
        if (TableRowIsBlank(tab, row1)) {
            if (TableRowIsBlank(tab, row2)) {
                rfalse;
            }
            return (-(dir));
        }
        if (TableRowIsBlank(tab, row2)) {
            return dir;
        }
        rfalse;
    }
    if (bl1) {
        return dir;
    }
    if (bl2) {
        return (-(dir));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        if ((BlkValueCompare(val2, val1) < 0)) {
            rtrue;
        }
        return (-(1));
    } else {
        if (((f)&(TB_COLUMN_REAL))) {
            if ((REAL_NUMBER_TY_Compare(val1, val2) > 0)) {
                rtrue;
            }
            return (-(1));
        } else {
            if (((f)&(TB_COLUMN_SIGNED))) {
                if ((val1 > val2)) {
                    rtrue;
                }
                return (-(1));
            } else {
                if ((UnsignedCompare(val1, val2) > 0)) {
                    rtrue;
                }
                return (-(1));
            }
        }
    }
];
[ TableMoveRowDown tab r1 r2 rx k l m v f;
    if ((r1 == r2)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (f = 0);
        (m = ((tab-->(k))-->((r1 + COL_HSIZE))));
        if ((m == TABLE_NOVALUE)) {
            (f = 1);
        }
        for ((rx = r1):(rx < r2):(rx)++) {
            (v = ((tab-->(k))-->(((rx + COL_HSIZE) + 1))));
            (((tab-->(k))-->((rx + COL_HSIZE))) = v);
            if ((v == TABLE_NOVALUE)) {
                (f = 1);
            }
        }
        (((tab-->(k))-->((r2 + COL_HSIZE))) = m);
        if (f) {
            TableMoveBlankBitsDown(tab, r1, r2, k);
        }
    }
];
[ TableShuffle tab i to;
    TableMoveBlanksToBack(tab, 1, TableRows(tab));
    (to = TableFilledRows(tab));
    for ((i = 2):(i <= to):(i)++) {
        TableSwapRows(tab, i, random(i));
    }
];
[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        (blk = 1);
    }
    (signed_arithmetic = ((f)&(TB_COLUMN_SIGNED)));
    if ((row == 0)) {
        if (signed_arithmetic) {
            if ((dir == 1)) {
                (val = -2147483648);
            } else {
                (val = 2147483647);
            }
        } else {
            if ((dir == 1)) {
                (val = 0);
            } else {
                (val = -1);
            }
        }
    } else {
        (val = ((tab-->(col))-->((row + COL_HSIZE))));
    }
    if (signed_arithmetic) {
        (min_dv = 2147483647);
    } else {
        (min_dv = -1);
    }
    (k = TableRows(tab));
    if ((dir == 1)) {
        for ((i = 1):(i <= k):(i)++) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = 1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z > 0)) || ((((z == 0)) && ((i > row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) < 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i > row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i > row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    } else {
        for ((i = k):(i >= 1):(i)--) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = -1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z < 0)) || ((((z == 0)) && ((i < row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) > 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i < row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i < row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    }
    return min_at;
];
[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
    if ((torow < fromrow)) {
        rtrue;
    }
    (fbl = 0);
    (lnbl = 0);
    for ((i = fromrow):(i <= torow):(i)++) {
        if (TableRowIsBlank(tab, i)) {
            if ((fbl == 0)) {
                (fbl = i);
            }
            (blc)++;
        } else {
            (lnbl = i);
        }
    }
    if ((((((fbl > 0)) && ((lnbl > 0)))) && ((fbl < lnbl)))) {
        TableMoveRowDown(tab, fbl, lnbl);
        TableMoveBlanksToBack(tab, fbl, (lnbl - 1));
    }
    return (torow - blc);
];
[ TableSort tab col dir algorithm i j k f;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if ((((j-->(1)))&(TB_COLUMN_DONTSORTME))) {
            return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
        }
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    SetSortDomain(TableSwapRows, TableCompareRows);
    SortArray(tab, col, dir, k, algorithm);
];
[ TablePrint tab i j k row col v tc kov;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            rtrue;
        }
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    print "! ";
    PrintTableName(tab);
    print " (";
    print k;
    print ")^";
    for ((row = 1):(row <= k):(row)++) {
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (v = ((tab-->(col))-->((row + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, row)))) {
                print "-- ";
            } else {
                if ((BlkValueWriteToFile(v, kov) == 0)) {
                    print v;
                }
                print " ";
            }
        }
        print "^";
    }
    rfalse;
];
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        (j = (tab-->(col)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
        }
    }
    (maxrow = TableRows(tab));
    for ((row = 1):(row <= maxrow):(row)++) {
        TableBlankOutRow(tab, row);
    }
    for ((row = 1):(row <= maxrow):(row)++) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 33)) {
            while ((ch ~= -1 or 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
            while ((ch == 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            if ((ch == -1)) {
                (row)++;
                jump NoMore;
            }
            if ((ch == 10 or 13)) {
                break;
            }
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (sgn = 1);
            if ((ch == 45)) {
                (ch = FileIO_GetC(auxf));
                if ((ch == -1)) {
                    jump NotTable;
                }
                if ((ch == 45)) {
                    (ch = FileIO_GetC(auxf));
                    jump EntryDone;
                }
                (sgn = -1);
            }
            if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                ForceTableEntryNonBlank(tab, col, row);
            }
            (v = BlkValueReadFromFile(0, 0, (-(1)), kov));
            if (v) {
                if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                    (v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row), auxf, ch, kov));
                } else {
                    (v = BlkValueReadFromFile(0, auxf, ch, kov));
                }
                (ch = 32);
            } else {
                (dg = (ch - 48));
                if ((((dg < 0)) || ((dg > 9)))) {
                    jump NotTable;
                }
                (v = dg);
                for (:1:) {
                    (ch = FileIO_GetC(auxf));
                    (dg = (ch - 48));
                    if ((((dg < 0)) || ((dg > 9)))) {
                        break;
                    }
                    (v = ((10*v) + dg));
                }
                (v = (v*sgn));
            }
            if ((((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED)) == 0)) {
                TableLookUpEntry(tab, col, row, 1, v);
            }
            .EntryDone;
            while ((ch == 9 or 32)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        while ((ch ~= -1 or 10 or 13)) {
            if ((((ch ~= 45)) && (((((ch - 48) < 0)) || (((ch - 48) > 9)))))) {
                jump NotTable;
            }
            if ((ch ~= 9 or 32)) {
                jump WontFit;
            }
            (ch = FileIO_GetC(auxf));
        }
    }
    .NoMore;
    while ((ch == 9 or 32 or 10 or 13)) {
        (ch = FileIO_GetC(auxf));
    }
    if ((ch == -1)) {
        rtrue;
    }
    .WontFit;
    return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
    .NotTable;
    return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
[ TableColumnDebug tab col k i v tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
    (kov = TC_KOV(tc));
    for ((i = 1):(i <= k):(i)++) {
        if ((i > 1)) {
            print ", ";
        }
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "--";
        } else {
            PrintKindValuePair(kov, v);
        }
    }
    (say__p = 1);
];
[ TableRowDebug tab i col k v tc kov;
    (k = TableRows(tab));
    if ((((i < 1)) || ((i > k)))) {
        print "No such row";
        new_line;
        rtrue;
    }
    print "(row ";
    print i;
    print ")  |";
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        print " ";
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "-- ";
        } else {
            PrintKindValuePair(kov, v);
            print " |";
        }
    }
    (say__p = 1);
];
[ TableDebug tab i k;
    PrintTableName(tab);
    print "^";
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        TableRowDebug(tab, i);
        print "^";
    }
];
[ Mstack_Create_Frame creator id extent;
    if ((creator == 0)) {
        rfalse;
    }
    (extent = (creator)((MStack_Top + 2),1));
    if ((extent == 0)) {
        rfalse;
    }
    if (((MStack_Top + MAX_MSTACK_FRAME) >= (MSTACK_SIZE + 2))) {
        RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
        Mstack_Backtrace();
        rfalse;
    }
    (MStack_Top)++;
    ((MStack-->(MStack_Top)) = id);
    (MStack_Top)++;
    (MStack_Top = (MStack_Top + extent));
    ((MStack-->(MStack_Top)) = (-((extent + 2))));
    rtrue;
];
[ Mstack_Destroy_Frame creator id pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    (MStack_Top = (pos - 2));
    if (creator) {
        (creator)(pos,(-(1)));
    }
    rtrue;
];
[ Mstack_Seek_Frame id pos;
    (pos = MStack_Top);
    while ((((pos > 0)) && (((MStack-->(pos)) ~= 0)))) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        if (((MStack-->((pos + 1))) == id)) {
            return (pos + 2);
        }
    }
    (MStack_Frame_Extent = 0);
    rfalse;
];
[ Mstack_Backtrace pos k;
    print "Mstack backtrace: size ";
    print (MStack_Top + 1);
    print " words^";
    (pos = MStack_Top);
    while (((MStack-->(pos)) ~= 0)) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        print "Block at ";
        print (pos + 2);
        print " owner ID ";
        print (MStack-->((pos + 1)));
        print " size ";
        print MStack_Frame_Extent;
        print "^";
        for ((k = 0):(k < MStack_Frame_Extent):(k)++) {
            print (MStack-->(((pos + 2) + k)));
            print " ";
        }
        print "^";
    }
];
[ MstVO id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        print "Variable unavailable for this action, activity or rulebook: ";
        print "internal ID number ";
        print id;
        print "/";
        print off;
        print "^";
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MstVON id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MStack_CreateRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Create_Frame(cr, rb);
    }
];
[ MStack_DestroyRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Destroy_Frame(cr, rb);
    }
];
[ MStack_CreateAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Create_Frame(cr, (av + 10000));
];
[ MStack_DestroyAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Destroy_Frame(cr, (av + 10000));
];
[ RecordRuleOutcome usage strong_kind val;
    if (((((latest_rule_result-->(0)) == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue((latest_rule_result-->(1)))))) {
        BlkValueFree((latest_rule_result-->(2)));
    }
    if ((((usage == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue(strong_kind)))) {
        (val = BlkValueCopy(BlkValueCreate(strong_kind), val));
    }
    ((latest_rule_result-->(0)) = usage);
    ((latest_rule_result-->(1)) = strong_kind);
    ((latest_rule_result-->(2)) = val);
];
[ FollowRulebook rulebook parameter no_paragraph_skips rv ss spv;
    (ss = self);
    if (((((Protect_I7_Arrays-->(0)) ~= 16339)) || (((Protect_I7_Arrays-->(1)) ~= 12345)))) {
        print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
        @quit;
    }
    if (parameter) {
        (self = parameter);
        (parameter_object = parameter);
    }
    (spv = parameter_value);
    (parameter_value = parameter);
    (parameter = debugging_rules);
    if (debugging_rules) {
        DebugRulebooks(rulebook, parameter);
        (process_rulebook_count = (process_rulebook_count + debugging_rules));
    }
    if ((((rulebook >= 0)) && ((rulebook < NUMBER_RULEBOOKS_CREATED)))) {
        (rv = (rulebooks_array-->(rulebook)));
        if ((rv ~= EMPTY_RULEBOOK)) {
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_CreateRBVars(rulebook);
            }
            if (say__p) {
                RulebookParBreak(no_paragraph_skips);
            }
            (rv = (rv)(no_paragraph_skips));
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_DestroyRBVars(rulebook);
            }
        } else {
            (rv = 0);
        }
    } else {
        if (say__p) {
            RulebookParBreak(no_paragraph_skips);
        }
        (rv = (rulebook)());
        if ((rv == 2)) {
            (rv = reason_the_action_failed);
        } else {
            if (rv) {
                (rv = rulebook);
            }
        }
    }
    if (rv) {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
            if ((process_rulebook_count < 0)) {
                (process_rulebook_count = 0);
            }
            spaces (2*process_rulebook_count);
            if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
                print "[stopped: success]^";
            }
            if (((latest_rule_result-->(0)) == RS_FAILS)) {
                print "[stopped: fail]^";
            }
        }
    } else {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
        }
        ((latest_rule_result-->(0)) = RS_NEITHER);
    }
    (debugging_rules = parameter);
    (self = ss);
    (parameter_value = spv);
    return rv;
];
[ RulebookParBreak no_paragraph_skips;
    if ((((no_paragraph_skips == 0)) && ((((say__pc)&(PARA_NORULEBOOKBREAKS)) == 0)))) {
        DivideParagraphPoint();
    }
];
[ ActRulebookSucceeds rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookSucceeds();
];
[ ActRulebookFails rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookFails();
];
[ RulebookSucceeds strong_kind value;
    RecordRuleOutcome(RS_SUCCEEDS, strong_kind, value);
];
[ RulebookFails strong_kind value;
    RecordRuleOutcome(RS_FAILS, strong_kind, value);
];
[ RuleHasNoOutcome;
    RecordRuleOutcome(RS_NEITHER, 0, 0);
];
[ SetRulebookOutcome a;
    ((latest_rule_result-->(0)) = a);
];
[ RulebookOutcome a;
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        return a;
    }
    return RS_NEITHER;
];
[ RulebookFailed;
    if (((latest_rule_result-->(0)) == RS_FAILS)) {
        rtrue;
    }
    rfalse;
];
[ RulebookSucceeded;
    if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ResultOfRule RB V F K a;
    if (RB) {
        FollowRulebook(RB, V, F);
    }
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        (a = (latest_rule_result-->(1)));
        if (a) {
            return (latest_rule_result-->(2));
        }
    }
    if (K) {
        return DefaultValueOfKOV(K);
    }
    rfalse;
];
[ RULEBOOK_TY_to_RULE_TY r;
    return r;
];
[ DebugRulebooks subs parameter i;
    spaces (2*process_rulebook_count);
    print "[";
    RulePrintingRule(subs);
    if (parameter) {
        print " / on O";
        print parameter;
    }
    print "]^";
];
[ DB_Rule R N blocked;
    if ((R == 0)) {
        rtrue;
    }
    print "[Rule ~";
    RulePrintingRule(R);
    print "~ ";
    if ((blocked == 0)) {
        print "applies.]";
        new_line;
        rtrue;
    }
    print "does not apply (wrong ";
    if ((blocked == 1)) {
        print "scene";
    }
    if ((blocked == 2)) {
        print "action";
    }
    if ((blocked == 3)) {
        print "actor";
    }
    if ((blocked == 4)) {
        print "context";
    }
    print ").]^";
];
[ LITTLE_USED_DO_NOTHING_R;
    rfalse;
];
[ EMPTY_RULEBOOK forbid_breaks;
    rfalse;
];
[ HeapInitialise n bsize blk2;
    (blk2 = (Flex_Heap + BLK_DATA_MULTI_OFFSET));
    ((Flex_Heap->(BLK_HEADER_N)) = 4);
    ((Flex_Heap-->(BLK_HEADER_KOV)) = 0);
    ((Flex_Heap-->(BLK_HEADER_RCOUNT)) = MAX_POSITIVE_NUMBER);
    ((Flex_Heap->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((Flex_Heap-->(BLK_NEXT)) = blk2);
    ((Flex_Heap-->(BLK_PREV)) = NULL);
    for ((bsize = 1):(bsize < MEMORY_HEAP_SIZE):(bsize = (bsize*2))) {
        (n)++;
    }
    ((blk2->(BLK_HEADER_N)) = n);
    ((blk2-->(BLK_HEADER_KOV)) = 0);
    ((blk2-->(BLK_HEADER_RCOUNT)) = 0);
    ((blk2->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((blk2-->(BLK_NEXT)) = NULL);
    ((blk2-->(BLK_PREV)) = Flex_Heap);
];
[ HeapNetFreeSpace multiple txb asize;
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = (asize + FlexSize(txb)));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
    }
    return asize;
];
[ HeapMakeSpace size multiple newblocksize newblock B n hsize;
    for (:1:) {
        if (multiple) {
            (hsize = BLK_DATA_MULTI_OFFSET);
            if ((HeapNetFreeSpace(multiple) >= size)) {
                rtrue;
            }
        } else {
            (hsize = BLK_DATA_OFFSET);
            if ((HeapLargestFreeBlock(0) >= size)) {
                rtrue;
            }
        }
        (newblocksize = 1);
        for ((n = 0):(((n < SMALLEST_BLK_WORTH_ALLOCATING)) || ((newblocksize < (size + hsize)))):(n)++) {
            (newblocksize = (newblocksize*2));
        }
        (newblock = VM_AllocateMemory(newblocksize));
        if ((newblock == 0)) {
            rfalse;
        }
        ((newblock->(BLK_HEADER_N)) = n);
        ((newblock-->(BLK_HEADER_KOV)) = 0);
        ((newblock-->(BLK_HEADER_RCOUNT)) = 0);
        ((newblock->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((newblock-->(BLK_NEXT)) = NULL);
        ((newblock-->(BLK_PREV)) = NULL);
        for ((B = (Flex_Heap-->(BLK_NEXT))):(B ~= NULL):(B = (B-->(BLK_NEXT)))) {
            if (((B-->(BLK_NEXT)) == NULL)) {
                ((B-->(BLK_NEXT)) = newblock);
                ((newblock-->(BLK_PREV)) = B);
                jump Linked;
            }
        }
        ((Flex_Heap-->(BLK_NEXT)) = newblock);
        ((newblock-->(BLK_PREV)) = Flex_Heap);
        .Linked;
    }
    rtrue;
];
[ HeapLargestFreeBlock multiple txb asize best;
    (best = 0);
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = FlexSize(txb));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
        if ((asize > best)) {
            (best = asize);
        }
    }
    return best;
];
[ HeapDebug full;
    if (full) {
        print "Managing a heap of initially ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes.^";
        print HeapNetFreeSpace(0);
        print " bytes currently free.^";
        print "Free space decomposition: ";
        FlexDebugDecomposition(Flex_Heap);
        print "Free space map: ";
        FlexDebug(Flex_Heap);
    } else {
        print HeapNetFreeSpace(0);
        print " of ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes free.^";
    }
];
[ FlexAllocate size kov flags dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
    if ((HeapMakeSpace(size, ((flags)&(BLK_FLAG_MULTIPLE))) == 0)) {
        FlexError("ran out");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (hsize = BLK_DATA_MULTI_OFFSET);
    } else {
        (hsize = BLK_DATA_OFFSET);
    }
    (n = 0);
    for ((dsize = 1):(((dsize < (hsize + size))) || ((n < (3 + (WORDSIZE/2))))):(dsize = (dsize*2))) {
        (n)++;
    }
    (min_m = 10000);
    (max_m = 0);
    for ((free_block = (Flex_Heap-->(BLK_NEXT))):(free_block ~= NULL):(free_block = (free_block-->(BLK_NEXT)))) {
        (m = (free_block->(BLK_HEADER_N)));
        if ((m == n)) {
            jump CorrectSizeFound;
        }
        if ((m > n)) {
            if ((min_m > m)) {
                (min_m = m);
                (smallest_oversized_block = free_block);
            }
        }
        if ((m < n)) {
            if ((max_m < m)) {
                (max_m = m);
            }
        }
    }
    if ((min_m == 10000)) {
        if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
            FlexError("too fragmented");
        }
        for ((dsize = 1):(max_m > 0):(dsize = (dsize*2))) {
            (max_m)--;
        }
        (head = FlexAllocate((dsize - hsize), kov, flags));
        if ((head == 0)) {
            FlexError("for head block not available");
        }
        (tail = FlexAllocate((size - (dsize - hsize)), kov, flags));
        if ((tail == 0)) {
            FlexError("for tail block not available");
        }
        ((head-->(BLK_NEXT)) = tail);
        ((tail-->(BLK_PREV)) = head);
        return head;
    }
    for (((dsize = 1),(m = 1)):(m <= min_m):(dsize = (dsize*2))) {
        (m)++;
    }
    (free_block = smallest_oversized_block);
    while ((min_m > n)) {
        (dsize = (dsize/2));
        (secondhalf = (free_block + dsize));
        ((secondhalf-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        if (((secondhalf-->(BLK_NEXT)) ~= NULL)) {
            (((secondhalf-->(BLK_NEXT))-->(BLK_PREV)) = secondhalf);
        }
        ((secondhalf-->(BLK_PREV)) = free_block);
        ((free_block-->(BLK_NEXT)) = secondhalf);
        ((free_block->(BLK_HEADER_N)) = ((free_block->(BLK_HEADER_N)) - 1));
        ((secondhalf->(BLK_HEADER_N)) = (free_block->(BLK_HEADER_N)));
        ((secondhalf-->(BLK_HEADER_KOV)) = (free_block-->(BLK_HEADER_KOV)));
        ((secondhalf-->(BLK_HEADER_RCOUNT)) = 0);
        ((secondhalf->(BLK_HEADER_FLAGS)) = (free_block->(BLK_HEADER_FLAGS)));
        (min_m)--;
    }
    .CorrectSizeFound;
    if (((free_block-->(BLK_NEXT)) == NULL)) {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
    } else {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        (((free_block-->(BLK_NEXT))-->(BLK_PREV)) = (free_block-->(BLK_PREV)));
    }
    ((free_block-->(BLK_HEADER_KOV)) = KindAtomic(kov));
    ((free_block-->(BLK_HEADER_RCOUNT)) = 1);
    ((free_block->(BLK_HEADER_FLAGS)) = flags);
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        ((free_block-->(BLK_NEXT)) = NULL);
        ((free_block-->(BLK_PREV)) = NULL);
    }
    for ((i = hsize):(i < dsize):(i)++) {
        ((free_block->(i)) = 0);
    }
    return free_block;
];
[ FlexError reason;
    print "*** Memory ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ FlexMergeInternal block first last pv nx;
    (first = block);
    (last = block);
    while (((last-->(BLK_NEXT)) == (last + FlexSize(last)))) {
        (last = (last-->(BLK_NEXT)));
    }
    while ((((((first-->(BLK_PREV)) + FlexSize((first-->(BLK_PREV)))) == first)) && (((first-->(BLK_PREV)) ~= Flex_Heap)))) {
        (first = (first-->(BLK_PREV)));
    }
    (pv = (first-->(BLK_PREV)));
    (nx = (last-->(BLK_NEXT)));
    if (FlexRecutInternal(first, last)) {
    }
];
[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
    if ((first == last)) {
        rfalse;
    }
    (mfrom = first);
    (mto = (last + FlexSize(last)));
    (bnext = (last-->(BLK_NEXT)));
    (fine_so_far = 1);
    for (:(mto > mfrom):(mto = (mto - backsize))) {
        for (((n = 0),(backsize = 1)):((backsize*2) <= (mto - mfrom)):(n)++) {
            (backsize = (backsize*2));
        }
        if (((fine_so_far) && ((backsize == FlexSize(last))))) {
            (bnext = last);
            (last = (last-->(BLK_PREV)));
            ((bnext-->(BLK_PREV)) = last);
            ((last-->(BLK_NEXT)) = bnext);
            continue;
        }
        (fine_so_far = 0);
        (backend = (mto - backsize));
        ((backend->(BLK_HEADER_N)) = n);
        ((backend-->(BLK_HEADER_KOV)) = 0);
        ((backend-->(BLK_HEADER_RCOUNT)) = 0);
        ((backend->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((backend-->(BLK_NEXT)) = bnext);
        if ((bnext ~= NULL)) {
            ((bnext-->(BLK_PREV)) = backend);
            (bnext = backend);
        }
    }
    if (fine_so_far) {
        rfalse;
    }
    rtrue;
];
[ FlexFree block fromtxb ptxb;
    if ((block == 0)) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_RESIDENT))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_N)))&(128))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE))) {
        if (((block-->(BLK_PREV)) ~= NULL)) {
            (((block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
        }
        (fromtxb = block);
        for (:((block-->(BLK_NEXT)) ~= NULL):(block = (block-->(BLK_NEXT)))) {
        }
        while ((block ~= fromtxb)) {
            (ptxb = (block-->(BLK_PREV)));
            FlexFreeSingleBlockInternal(block);
            (block = ptxb);
        }
    }
    FlexFreeSingleBlockInternal(block);
];
[ FlexFreeSingleBlockInternal block free nx;
    ((block-->(BLK_HEADER_KOV)) = 0);
    ((block-->(BLK_HEADER_RCOUNT)) = 0);
    ((block->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    for ((free = Flex_Heap):(free ~= NULL):(free = (free-->(BLK_NEXT)))) {
        (nx = (free-->(BLK_NEXT)));
        if ((nx == NULL)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = NULL);
            FlexMergeInternal(block);
            rtrue;
        }
        if ((UnsignedCompare(nx, block) == 1)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = nx);
            ((nx-->(BLK_PREV)) = block);
            FlexMergeInternal(block);
            rtrue;
        }
    }
];
[ FlexResize block req newsize dsize newblk kov n i otxb flags;
    if ((block == 0)) {
        FlexError("failed resizing null block");
    }
    (kov = (block-->(BLK_HEADER_KOV)));
    (flags = (block->(BLK_HEADER_FLAGS)));
    if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
        FlexError("failed resizing inextensible block");
    }
    (otxb = block);
    (newsize = req);
    for (:1:(block = (block-->(BLK_NEXT)))) {
        (n = (block->(BLK_HEADER_N)));
        for ((dsize = 1):(n > 0):(n)--) {
            (dsize = (dsize*2));
        }
        (i = (dsize - BLK_DATA_MULTI_OFFSET));
        (newsize = (newsize - i));
        if ((newsize > 0)) {
            if (((block-->(BLK_NEXT)) ~= NULL)) {
                continue;
            }
            (newblk = FlexAllocate(newsize, kov, flags));
            if ((newblk == 0)) {
                rfalse;
            }
            ((block-->(BLK_NEXT)) = newblk);
            ((newblk-->(BLK_PREV)) = block);
            rtrue;
        }
        if (((block-->(BLK_NEXT)) ~= NULL)) {
            FlexFree((block-->(BLK_NEXT)));
            ((block-->(BLK_NEXT)) = NULL);
        }
        rtrue;
    }
];
[ FlexSize txb bsize n m;
    if ((txb == 0)) {
        rfalse;
    }
    (m = (txb->(BLK_HEADER_N)));
    for ((bsize = 1):(n < m):(bsize = (bsize*2))) {
        (n)++;
    }
    return bsize;
];
[ FlexTotalSize txb size_in_bytes;
    if ((txb == 0)) {
        rfalse;
    }
    if (((((txb->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE)) == 0)) {
        return (FlexSize(txb) - BLK_DATA_OFFSET);
    }
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (size_in_bytes = ((size_in_bytes + FlexSize(txb)) - BLK_DATA_MULTI_OFFSET));
    }
    return size_in_bytes;
];
[ FlexDebug txb n k i bsize tot dtot kov;
    if ((txb == 0)) {
        print "Block never created.";
        new_line;
        rtrue;
    }
    (kov = (txb-->(BLK_HEADER_KOV)));
    print "Block ";
    print txb;
    print " (kov ";
    print kov;
    print "): ";
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        if (((k)++ == 100)) {
            print " ... and so on.";
            new_line;
            rtrue;
        }
        if (((txb-->(BLK_HEADER_KOV)) ~= kov)) {
            print "*Wrong kov=";
            print (txb-->(BLK_HEADER_KOV));
            print "* ";
        }
        (n = (txb->(BLK_HEADER_N)));
        for ((bsize = 1):(n > 0):(n)--) {
            (bsize = (bsize*2));
        }
        (i = (bsize - BLK_DATA_OFFSET));
        (dtot = (dtot + i));
        (tot = (tot + bsize));
        print txb;
        print "(";
        print bsize;
        print ") > ";
    }
    print dtot;
    print " data in ";
    print tot;
    print " bytes^";
];
[ FlexDebugDecomposition from to txb pf;
    if ((to == 0)) {
        (to = NULL);
    }
    for ((txb = from):(((txb ~= to)) && ((txb ~= NULL))):(txb = (txb-->(BLK_NEXT)))) {
        if (pf) {
            print "+";
        }
        print FlexSize(txb);
        (pf = 1);
    }
    print "^";
];
[ BlkValueGetLongBlock bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv + WORDSIZE);
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_LONGBLOCK))) {
                return (bv-->(1));
            }
            rfalse;
        }
        return o;
    }
    return bv;
];
[ BlkValueWeakKind bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv-->((BLK_HEADER_KOV + 1)));
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_TEXT))) {
                return TEXT_TY;
            }
            (o = (bv-->(1)));
        }
        return (o-->(BLK_HEADER_KOV));
    }
    return NIL_TY;
];
[ BlkValueGetRefCountPrimitive bv long_block;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        return (long_block-->(BLK_HEADER_RCOUNT));
    }
    return RC_INFINITY;
];
[ BlkValueIncRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            ((long_block-->(BLK_HEADER_RCOUNT)) = (refc + 1));
        }
    }
];
[ BlkValueDecRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            (refc)--;
            if ((refc < 0)) {
                BlkValueError("reference count negative");
            }
            ((long_block-->(BLK_HEADER_RCOUNT)) = refc);
        }
        return refc;
    }
    return RC_INFINITY;
];
[ BlkValueLBCapacity bv long_block array_size_in_bytes entry_size_in_bytes flags;
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (array_size_in_bytes = FlexTotalSize(long_block));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    return (array_size_in_bytes/entry_size_in_bytes);
];
[ BlkValueSetLBCapacity bv new_capacity long_block flags entry_size_in_bytes;
    if ((bv == 0)) {
        rfalse;
    }
    BlkMakeMutable(bv);
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    FlexResize(long_block, (new_capacity*entry_size_in_bytes));
    rtrue;
];
[ BlkValueRead from pos do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((from == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = from);
    } else {
        (long_block = BlkValueGetLongBlock(from));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    return (long_block->(0));
                    ;
                2:
                    return (((long_block->(0))*256) + (long_block->(1)));
                    ;
                4:
                    return (long_block-->(0));
                    ;
            }
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueRead: reading from index out of range: ";
    print pos;
    print " in ";
    print from;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueWrite to pos val do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((to == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = to);
    } else {
        BlkMakeMutable(to);
        (long_block = BlkValueGetLongBlock(to));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    ((long_block->(0)) = val);
                    ;
                2:
                    ((long_block->(0)) = ((val/256)%256));
                    ((long_block->(1)) = (val%256));
                    ;
                4:
                    ((long_block-->(0)) = val);
                    ;
            }
            rtrue;
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueWrite: writing to index out of range: ";
    print pos;
    print " in ";
    print to;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueSeekZeroEntry from long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes byte_position addr from_addr to_addr;
    if ((from == 0)) {
        return (-(1));
    }
    (long_block = BlkValueGetLongBlock(from));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (byte_position = 0);
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        (from_addr = (long_block + header_size_in_bytes));
        (to_addr = (from_addr + chunk_size_in_bytes));
        switch (entry_size_in_bytes) {
            1:
                for ((addr = from_addr):(addr < to_addr):(addr)++) {
                    if (((addr->(0)) == 0)) {
                        return ((byte_position + addr) - from_addr);
                    }
                }
                ;
            2:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 2))) {
                    if (((((addr->(0)) == 0)) && (((addr->(1)) == 0)))) {
                        return (((byte_position + addr) - from_addr)/2);
                    }
                }
                ;
            4:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 4))) {
                    if (((addr-->(0)) == 0)) {
                        return (((byte_position + addr) - from_addr)/4);
                    }
                }
                ;
        }
        (byte_position = (byte_position + chunk_size_in_bytes));
    }
    return (-(1));
];
[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy from_long_block from_addr from_bytes_left from_header_size_in_bytes to_long_block to_addr to_bytes_left to_header_size_in_bytes bytes_to_copy flags entry_size_in_bytes min;
    BlkMakeMutable(to_bv);
    (from_long_block = BlkValueGetLongBlock(from_bv));
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (from_long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (from_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (from_addr = (from_long_block + from_header_size_in_bytes));
    (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
    (to_addr = (to_long_block + to_header_size_in_bytes));
    (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
    (bytes_to_copy = (entry_size_in_bytes*no_entries_to_copy));
    while (1) {
        if ((from_bytes_left == 0)) {
            (from_long_block = (from_long_block-->(BLK_NEXT)));
            if ((from_long_block == 0)) {
                BlkValueError("copy destination exhausted");
            }
            (from_addr = (from_long_block + from_header_size_in_bytes));
            (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
        } else {
            if ((to_bytes_left == 0)) {
                (to_long_block = (to_long_block-->(BLK_NEXT)));
                if ((to_long_block == 0)) {
                    BlkValueError("copy source exhausted");
                }
                (to_addr = (to_long_block + to_header_size_in_bytes));
                (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
            } else {
                (min = from_bytes_left);
                if ((to_bytes_left < min)) {
                    (min = to_bytes_left);
                }
                if ((bytes_to_copy <= min)) {
                    Memcpy(to_addr, from_addr, bytes_to_copy);
                    rtrue;
                }
                Memcpy(to_addr, from_addr, min);
                (bytes_to_copy = (bytes_to_copy - min));
                (from_addr = (from_addr + min));
                (from_bytes_left = (from_bytes_left - min));
                (to_addr = (to_addr + min));
                (to_bytes_left = (to_bytes_left - min));
            }
        }
    }
];
[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy to_long_block to_addr to_entries_left to_header_size to_entry_size flags;
    BlkMakeMutable(to_bv);
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    (to_entry_size = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (to_entry_size = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (to_entry_size = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size = BLK_DATA_OFFSET);
    }
    (to_addr = (to_long_block + to_header_size));
    (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    while ((no_entries_to_copy > to_entries_left)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
        (no_entries_to_copy = (no_entries_to_copy - to_entries_left));
        (from_array = (from_array + (to_entries_left*from_entry_size)));
        (to_long_block = (to_long_block-->(BLK_NEXT)));
        if ((to_long_block == 0)) {
            BlkValueError("copy source exhausted");
        }
        (to_addr = (to_long_block + to_header_size));
        (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    }
    if ((no_entries_to_copy > 0)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
    }
];
[ BlkValueCreate strong_kind short_block kovs;
    (kovs = KOVSupportFunction(strong_kind, "impossible allocation"));
    (short_block = (kovs)(CREATE_KOVS,strong_kind,short_block));
    return short_block;
];
[ BlkValueError reason;
    print "*** Value handling failed: ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ BlkValueCreateSB1 short_block val;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val);
    return short_block;
];
[ BlkValueCreateSB2 short_block val1 val2;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate((2*WORDSIZE), 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val1);
    ((short_block-->(1)) = val2);
    return short_block;
];
[ StackFramingInitialise;
    (I7SFRAME = (blockv_stack + (WORDSIZE*BLOCKV_STACK_SIZE)));
];
[ StackFrameCreate size new;
    (new = (I7SFRAME - (WORDSIZE*size)));
    if ((new < blockv_stack)) {
        RunTimeProblem(RTP_HEAPERROR);
        @quit;
    }
    (I7SFRAME = new);
];
[ BlkValueCreateOnStack offset strong_kind;
    BlkValueCreate(strong_kind, (I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFreeOnStack offset;
    BlkValueFree((I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFree bv kovs d;
    if ((bv == 0)) {
        rtrue;
    }
    (kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation"));
    BlkValueDestroyPrimitive(bv, kovs);
    (d = (bv - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        FlexFree((bv - BLK_DATA_OFFSET));
    }
];
[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
    BlkValueDestroyPrimitive(to_bv, kovs);
    (kovs)(COPYSB_KOVS,to_bv,from_bv);
    BlkValueIncRefCountPrimitive(from_bv);
];
[ BlkValueCopySB1 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    if (((to_bv-->(0)) == 0)) {
        ((to_bv-->(0)) = (from_bv + WORDSIZE));
    }
];
[ BlkValueCopySB2 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    ((to_bv-->(1)) = (from_bv-->(1)));
    if (((to_bv-->(1)) == 0)) {
        ((to_bv-->(1)) = (from_bv + (2*WORDSIZE)));
    }
];
[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling k from_long_block no_entries_to_copy;
    (k = (kovs)(KINDDATA_KOVS,to_bv,from_bv));
    (from_long_block = BlkValueGetLongBlock(from_bv));
    if (from_long_block) {
        if (recycling) {
            BlkValueRecyclePrimitive(to_bv, kovs);
        }
        (no_entries_to_copy = (kovs)(EXTENT_KOVS,from_bv));
        if ((no_entries_to_copy == -1)) {
            (no_entries_to_copy = BlkValueLBCapacity(from_bv));
        }
        BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
    }
    (kovs)(COPY_KOVS,to_bv,from_bv,k);
];
[ BlkValueCopy to_bv from_bv to_kind from_kind kovs;
    if ((to_bv == 0)) {
        BlkValueError("copy to null value");
    }
    if ((from_bv == 0)) {
        BlkValueError("copy from null value");
    }
    if ((to_bv == from_bv)) {
        rtrue;
    }
    (to_kind = BlkValueWeakKind(to_bv));
    (from_kind = BlkValueWeakKind(from_bv));
    if ((to_kind ~= from_kind)) {
        BlkValueError("copy incompatible kinds");
    }
    (kovs = KOVSupportFunction(to_kind, "impossible copy"));
    if ((kovs)(COPYQUICK_KOVS,to_bv,from_bv)) {
        BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
    } else {
        BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, 1);
    }
    return to_bv;
];
[ BlkValueCopyAZ to_bv from_bv;
    if (from_bv) {
        return BlkValueCopy(to_bv, from_bv);
    }
    return to_bv;
];
[ BlkValueDestroyPrimitive bv kovs long_block;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            FlexFree(long_block);
        }
    }
];
[ BlkValueRecyclePrimitive bv kovs;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        BlkValueIncRefCountPrimitive(bv);
    } else {
        BlkValueCreate(BlkValueWeakKind(bv), bv);
    }
];
[ BlkMakeMutable bv block bv_kind kovs sb_size;
    if ((bv == 0)) {
        BlkValueError("tried to make null block mutable");
    }
    if ((BlkValueGetRefCountPrimitive(bv) > 1)) {
        BlkValueDecRefCountPrimitive(bv);
        (bv_kind = BlkValueWeakKind(bv));
        (kovs = KOVSupportFunction(bv_kind, "impossible mutability"));
        (sb_size = (kovs)(MAKEMUTABLE_KOVS,bv));
        if ((sb_size > 0)) {
            @push I7SFRAME;
            StackFrameCreate(sb_size);
            BlkValueCreateOnStack(0, bv_kind);
            (kovs)(COPYKIND_KOVS,I7SFRAME,bv);
            BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, 0);
            (kovs)(COPYSB_KOVS,bv,I7SFRAME);
            @pull I7SFRAME;
        }
    }
];
[ BlkValueCast to_bv original_kind original_value kovs;
    (kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast"));
    (kovs)(CAST_KOVS,to_bv,original_kind,original_value);
    return to_bv;
];
[ BlkValueCompare bv_left bv_right kind_left kind_right kovs;
    if ((((bv_left == 0)) && ((bv_right == 0)))) {
        rfalse;
    }
    if ((bv_left == 0)) {
        rtrue;
    }
    if ((bv_right == 0)) {
        return (-(1));
    }
    (kind_left = BlkValueWeakKind(bv_left));
    (kind_right = BlkValueWeakKind(bv_right));
    if ((kind_left ~= kind_right)) {
        return (kind_left - kind_right);
    }
    (kovs = KOVSupportFunction(kind_left, "impossible comparison"));
    return (kovs)(COMPARE_KOVS,bv_left,bv_right);
];
[ GetHashValue kind value;
    if (KOVIsBlockValue(kind)) {
        return BlkValueHash(value);
    }
    return value;
];
[ BlkValueHash bv bv_kind kovs;
    if ((bv == 0)) {
        rfalse;
    }
    (bv_kind = BlkValueWeakKind(bv));
    (kovs = KOVSupportFunction(bv_kind, "impossible hashing"));
    return (kovs)(HASH_KOVS,bv);
];
[ BlkValueReadFromFile bv auxf ch bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(READ_FILE_KOVS,bv,auxf,ch);
    }
    rfalse;
];
[ BlkValueWriteToFile bv bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(WRITE_FILE_KOVS,bv);
    }
    rfalse;
];
[ BlkValueDebug bv flag refc long_block kovs;
    print "(BV";
    if (bv) {
        BlkDebugAddress(bv, flag);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            if (((bv-->(0)) == 0)) {
                print "...";
            } else {
                print "-->";
            }
            print "L";
            BlkDebugAddress(long_block, flag);
            print " 2**";
            print (long_block->(BLK_HEADER_N));
            (refc = BlkValueGetRefCountPrimitive(bv));
            if ((refc == RC_INFINITY)) {
                print " resident";
            } else {
                print " ";
                print refc;
                print " ref";
                if ((refc ~= 1)) {
                    print "s";
                }
            }
        }
        (kovs = KOVSupportFunction(BlkValueWeakKind(bv)));
        if (kovs) {
            (kovs)(DEBUG_KOVS,bv);
        }
    }
    print ")";
];
[ BlkDebugAddress addr flag d;
    if (flag) {
        print "###";
        rtrue;
    }
    (d = (addr - blockv_stack));
    if ((((d >= 0)) && ((d <= (WORDSIZE*BLOCKV_STACK_SIZE))))) {
        print "s+";
        BlkPrintHexadecimal(d);
        (d = (addr - I7SFRAME));
        print "=f";
        if ((d >= 0)) {
            print "+";
        }
        print d;
        rtrue;
    }
    (d = (addr - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        print "h+";
        BlkPrintHexadecimal(d);
        rtrue;
    }
    BlkPrintHexadecimal(addr);
];
[ BlkPrintHexadecimal v;
    if (((v)&(-65536))) {
        if (((v)&(-16777216))) {
            BlkPrintHexDigit((v/268435456));
            BlkPrintHexDigit((v/16777216));
        }
        BlkPrintHexDigit((v/1048576));
        BlkPrintHexDigit((v/65536));
    }
    BlkPrintHexDigit((v/4096));
    BlkPrintHexDigit((v/256));
    BlkPrintHexDigit((v/16));
    BlkPrintHexDigit(v);
];
[ BlkPrintHexDigit v;
    (v = ((v)&(15)));
    if ((v < 10)) {
        print v;
    } else {
        print (char) ((65 + v) - 10);
    }
];
[ TEXT_TY_Extent arg1 x;
    (x = BlkValueSeekZeroEntry(arg1));
    if ((x < 0)) {
        return (-(1));
    }
    return (x + 1);
];
[ TEXT_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return TEXT_TY_Create(arg2);
            ;
        CAST_KOVS:
            TEXT_TY_Cast(arg1, arg2, arg3);
            ;
        MAKEMUTABLE_KOVS:
            return TEXT_TY_Mutable(arg1);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            TEXT_TY_CopySB(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return TEXT_TY_Extent(arg1);
            ;
        COMPARE_KOVS:
            return TEXT_TY_Compare(arg1, arg2);
            ;
        READ_FILE_KOVS:
            if ((arg3 == -1)) {
                rtrue;
            }
            return TEXT_TY_ReadFile(arg1, arg2, arg3);
            ;
        WRITE_FILE_KOVS:
            return TEXT_TY_WriteFile(arg1);
            ;
        HASH_KOVS:
            return TEXT_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            TEXT_TY_Debug(arg1);
            ;
    }
    rfalse;
];
[ TEXT_TY_Debug txt;
    switch ((txt-->(0))) {
        CONSTANT_PACKED_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        CONSTANT_PERISHABLE_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        PACKED_TEXT_STORAGE:
            print " = p~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        UNPACKED_TEXT_STORAGE:
            print " = ~";
            TEXT_TY_Say(txt);
            print "~";
            ;
        default:
            print " broken?";
            ;
    }
];
[ TEXT_TY_Create short_block x;
    return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];
[ TEXT_TY_CopySB to_bv from_bv;
    BlkValueCopySB2(to_bv, from_bv);
    if ((((to_bv-->(0)))&(BLK_BVBITMAP_CONSTANTMASK))) {
        ((to_bv-->(0)) = PACKED_TEXT_STORAGE);
    }
];
[ TEXT_TY_Transmute txt;
    TEXT_TY_Temporarily_Transmute(txt);
];
[ TEXT_TY_Temporarily_Transmute txt x;
    if (((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) {
        (x = (txt-->(1)));
        ((txt-->(0)) = UNPACKED_TEXT_STORAGE);
        ((txt-->(1)) = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags));
        if ((x ~= EMPTY_TEXT_PACKED)) {
            TEXT_TY_CastPrimitive(txt, 0, x);
        }
        return x;
    }
    rfalse;
];
[ TEXT_TY_Untransmute txt pk cp x;
    if (((pk) && (((txt-->(0)) == UNPACKED_TEXT_STORAGE)))) {
        (x = (txt-->(1)));
        FlexFree(x);
        ((txt-->(0)) = cp);
        ((txt-->(1)) = pk);
    }
    return txt;
];
[ TEXT_TY_Mutable txt;
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        TEXT_TY_Transmute(txt);
        rfalse;
    }
    return 2;
];
[ TEXT_TY_Cast to_txt from_kind from_value;
    if ((from_kind == TEXT_TY)) {
        BlkValueCopy(to_txt, from_value);
    } else {
        if ((from_kind == SNIPPET_TY)) {
            TEXT_TY_Transmute(to_txt);
            TEXT_TY_CastPrimitive(to_txt, 1, from_value);
        } else {
            BlkValueError("impossible cast to text");
        }
    }
];
[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
    return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value len i stream saved_stream news buffer buffer_size memory_to_free results;
    if ((to_txt == 0)) {
        BlkValueError("no destination for cast");
    }
    (buffer_size = ((TEXT_TY_BufferSize + 2)*WORDSIZE));
    (RawBufferSize = TEXT_TY_BufferSize);
    (buffer = (RawBufferAddress + (TEXT_TY_CastPrimitiveNesting*buffer_size)));
    (TEXT_TY_CastPrimitiveNesting)++;
    if ((TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)) {
        (buffer = VM_AllocateMemory(buffer_size));
        (memory_to_free = buffer);
        if ((buffer == 0)) {
            FlexError("ran out with too many simultaneous text conversions");
        }
    }
    if (unicode_gestalt_ok) {
        SuspendRTP();
        .RetryWithLargerBuffer;
        (saved_stream = glk_stream_get_current());
        (stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0));
        glk_stream_set_current(stream);
        @push say__p;
        @push say__pc;
        ClearParagraphing(7);
        if (from_snippet) {
            PrintSnippet(from_value);
        } else {
            PrintI6Text(from_value);
        }
        @pull say__pc;
        @pull say__p;
        (results = ((buffer + buffer_size) - (2*WORDSIZE)));
        glk_stream_close(stream, results);
        if (saved_stream) {
            glk_stream_set_current(saved_stream);
        }
        ResumeRTP();
        (len = (results-->(1)));
        if ((len > (RawBufferSize - 1))) {
            (news = RawBufferSize);
            while ((news < len)) {
                (news = (news*2));
            }
            (i = VM_AllocateMemory((news*WORDSIZE)));
            if ((i ~= 0)) {
                if (memory_to_free) {
                    VM_FreeMemory(memory_to_free);
                }
                (memory_to_free = i);
                (buffer = i);
                (RawBufferSize = news);
                (buffer_size = ((RawBufferSize + 2)*WORDSIZE));
                jump RetryWithLargerBuffer;
            }
            (len = (RawBufferSize - 1));
        }
        ((buffer-->(len)) = 0);
        (TEXT_TY_CastPrimitiveNesting)--;
        BlkValueMassCopyFromArray(to_txt, buffer, 4, (len + 1));
    } else {
        RunTimeProblem(RTP_NOGLULXUNICODE);
    }
    if (memory_to_free) {
        VM_FreeMemory(memory_to_free);
    }
];
[ TEXT_TY_Compare left_txt right_txt rv;
    @push say__comp;
    (say__comp = 1);
    (rv = TEXT_TY_Compare_Inner(left_txt, right_txt));
    @pull say__comp;
    return rv;
];
[ TEXT_TY_Compare_Inner left_txt right_txt pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
    if (((((left_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fl = 1);
    }
    if (((((right_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fr = 1);
    }
    if (((fl) && (fr))) {
        if (((((left_txt-->(1)) ofclass String)) && (((right_txt-->(1)) ofclass String)))) {
            return ((left_txt-->(1)) - (right_txt-->(1)));
        }
        if (((((left_txt-->(1)) ofclass Routine)) && (((right_txt-->(1)) ofclass Routine)))) {
            if (((left_txt-->(1)) == (right_txt-->(1)))) {
                rfalse;
            }
        }
        (cpl = (left_txt-->(0)));
        (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        (cpr = (right_txt-->(0)));
        (cr = TEXT_TY_Temporarily_Transmute(right_txt));
    } else {
        if (fl) {
            (cpl = (left_txt-->(0)));
            (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        } else {
            if (fr) {
                (cpr = (right_txt-->(0)));
                (cr = TEXT_TY_Temporarily_Transmute(right_txt));
            }
        }
    }
    if (((cl) || (cr))) {
        (pos = TEXT_TY_Compare(left_txt, right_txt));
        TEXT_TY_Untransmute(left_txt, cl, cpl);
        TEXT_TY_Untransmute(right_txt, cr, cpr);
        return pos;
    }
    (capacity_left = BlkValueLBCapacity(left_txt));
    (capacity_right = BlkValueLBCapacity(right_txt));
    for ((pos = 0):(((pos < capacity_left)) && ((pos < capacity_right))):(pos)++) {
        (ch1 = BlkValueRead(left_txt, pos));
        (ch2 = BlkValueRead(right_txt, pos));
        if ((ch1 ~= ch2)) {
            return (ch1 - ch2);
        }
        if ((ch1 == 0)) {
            rfalse;
        }
    }
    if ((pos == capacity_left)) {
        return (-(1));
    }
    rtrue;
];
[ TEXT_TY_Distinguish left_txt right_txt;
    if ((TEXT_TY_Compare(left_txt, right_txt) == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Hash txt rv len i p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (rv = 0);
    (len = BlkValueLBCapacity(txt));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + BlkValueRead(txt, i)));
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return rv;
];
[ TEXT_TY_Say txt ch i dsize;
    if ((txt == 0)) {
        rfalse;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        return PrintI6Text((txt-->(1)));
    }
    (dsize = BlkValueLBCapacity(txt));
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        @streamunichar ch;
    }
    if ((i == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Say_Capitalised txt mod rc;
    (mod = BlkValueCreate(TEXT_TY));
    TEXT_TY_SubstitutedForm(mod, txt);
    if ((TEXT_TY_CharacterLength(mod) > 0)) {
        BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
        TEXT_TY_Say(mod);
        (rc = 1);
        (say__p = 1);
    }
    BlkValueFree(mod);
    return rc;
];
[ TEXT_TY_WriteFile txt len pos ch p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = BlkValueLBCapacity(txt));
    print "S";
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 0)) {
            print "0;";
            break;
        } else {
            print ch;
            print ",";
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
];
[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
    TEXT_TY_Transmute(txt);
    (tsize = BlkValueLBCapacity(txt));
    while ((ch ~= 32 or 9 or 10 or 13 or 0 or -1)) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 44 or 59)) {
            if (((pos + 1) >= tsize)) {
                if ((BlkValueSetLBCapacity(txt, (2*pos)) == 0)) {
                    break;
                }
                (tsize = BlkValueLBCapacity(txt));
            }
            BlkValueWrite(txt, (pos)++, v);
            (v = 0);
            if ((ch == 59)) {
                break;
            }
        } else {
            (dg = (ch - 48));
            (v = ((v*10) + dg));
        }
    }
    BlkValueWrite(txt, pos, 0);
    return txt;
];
[ TEXT_TY_SubstitutedForm to txt;
    if (txt) {
        BlkValueCopy(to, txt);
        TEXT_TY_Transmute(to);
    }
    return to;
];
[ TEXT_TY_IsSubstituted txt;
    if (((((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) && (((txt-->(1)) ofclass Routine)))) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_ExpandIfPerishable to from;
    if (((from) && (((from-->(0)) == CONSTANT_PERISHABLE_TEXT_STORAGE)))) {
        return TEXT_TY_SubstitutedForm(to, from);
    }
    return from;
];
[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt p1 p2 cp1 cp2 r;
    if ((txt == 0)) {
        rfalse;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_CharacterLength(txt);
    }
    (cp1 = (txt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(txt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    TEXT_TY_Transmute(ctxt);
    if (ctxt) {
        BlkMakeMutable(ctxt);
    }
    (r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt));
    TEXT_TY_Untransmute(txt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt brm oldbrm ch i dsize blobcount gp cl j;
    (dsize = BlkValueLBCapacity(txt));
    if (((rtxt) && ((ctxt == 0)))) {
        print "*** rtxt without ctxt ***";
        new_line;
        rtrue;
    }
    (brm = WS_BRM);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        (oldbrm = brm);
        if ((ch == 10 or 13 or 32 or 9)) {
            if ((oldbrm ~= WS_BRM)) {
                (gp = 0);
                for ((j = i):(j < dsize):(j)++) {
                    (ch = BlkValueRead(txt, j));
                    if ((ch == 0)) {
                        (brm = WS_BRM);
                        break;
                    }
                    if ((ch == 10 or 13)) {
                        (gp)++;
                        continue;
                    }
                    if ((ch ~= 32 or 9)) {
                        break;
                    }
                }
                (ch = BlkValueRead(txt, i));
                if ((j == dsize)) {
                    (brm = WS_BRM);
                }
                switch (blobtype) {
                    PARA_BLOB:
                        if ((gp >= 2)) {
                            (brm = WS_BRM);
                        }
                        ;
                    LINE_BLOB:
                        if ((gp >= 1)) {
                            (brm = WS_BRM);
                        }
                        ;
                    default:
                        (brm = WS_BRM);
                        ;
                }
            }
        } else {
            (gp = 0);
            if ((((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB)) && ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                (gp = 1);
            }
            switch (oldbrm) {
                WS_BRM:
                    (brm = ACCEPTED_BRM);
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                SKIPPED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        }
                    }
                    ;
                ACCEPTED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDP_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
                ACCEPTEDN_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDPN_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
            }
        }
        if ((brm == ACCEPTED_BRM or ACCEPTEDP_BRM)) {
            if ((oldbrm ~= brm)) {
                (blobcount)++;
            }
            if (((ctxt) && ((blobcount == wanted)))) {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    if ((brm == ACCEPTED_BRM)) {
                        (brm = ACCEPTEDN_BRM);
                    }
                    if ((brm == ACCEPTEDP_BRM)) {
                        (brm = ACCEPTEDPN_BRM);
                    }
                } else {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            } else {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            }
        } else {
            if (((rtxt) && ((brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)))) {
                if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
    }
    if (ctxt) {
        if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
            BlkValueSetLBCapacity(ctxt, (2*cl));
        }
        BlkValueWrite(ctxt, (cl)++, 0);
    }
    return blobcount;
];
[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
    if ((txt == 0)) {
        rtrue;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_GetCharacter(ctxt, txt, wanted);
    }
    TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
    return ctxt;
];
[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
    TEXT_TY_Transmute(txt);
    (cp = (rtxt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(rtxt));
    if ((blobtype == CHR_BLOB)) {
        (ilen = TEXT_TY_CharacterLength(txt));
        (rlen = TEXT_TY_CharacterLength(rtxt));
        (wanted)--;
        if ((((wanted >= 0)) && ((wanted < ilen)))) {
            if ((rlen == 1)) {
                BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
            } else {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                if (BlkValueSetLBCapacity(ctxt, ((ilen + rlen) + 1))) {
                    for ((i = 0):(i < wanted):(i)++) {
                        BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
                    }
                    for ((i = 0):(i < rlen):(i)++) {
                        BlkValueWrite(ctxt, (wanted + i), BlkValueRead(rtxt, i));
                    }
                    for ((i = (wanted + 1)):(i < ilen):(i)++) {
                        BlkValueWrite(ctxt, ((rlen + i) - 1), BlkValueRead(txt, i));
                    }
                    BlkValueWrite(ctxt, (rlen + ilen), 0);
                    BlkValueCopy(txt, ctxt);
                }
                BlkValueFree(ctxt);
            }
        }
    } else {
        (ctxt = BlkValueCreate(TEXT_TY));
        TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
        BlkValueCopy(txt, ctxt);
        BlkValueFree(ctxt);
    }
    TEXT_TY_Untransmute(rtxt, p, cp);
];
[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt r p1 p2 cp1 cp2;
    TEXT_TY_Transmute(txt);
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
    if ((blobtype == REGEXP_BLOB or CHR_BLOB)) {
        return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
    }
    (ilen = TEXT_TY_CharacterLength(txt));
    (flen = TEXT_TY_CharacterLength(ftxt));
    (ctxt = BlkValueCreate(TEXT_TY));
    TEXT_TY_Transmute(ctxt);
    (csize = BlkValueLBCapacity(ctxt));
    (mpos = 0);
    (whitespace = 1);
    (punctuation = 0);
    for ((i = 0):(i <= ilen):(i)++) {
        (ch = BlkValueRead(txt, i));
        (chm = BlkValueRead(ftxt, (mpos)++));
        if ((mpos == 1)) {
            switch (blobtype) {
                WORD_BLOB:
                    if ((((whitespace == 0)) && ((punctuation == 0)))) {
                        (chm = -1);
                    }
                    ;
            }
        }
        (whitespace = 0);
        if ((ch == 10 or 13 or 32 or 9)) {
            (whitespace = 1);
        }
        (punctuation = 0);
        if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
            if ((blobtype == WORD_BLOB)) {
                (chm = -1);
            }
            (punctuation = 1);
        }
        if ((ch == chm)) {
            if ((mpos == flen)) {
                if ((i == ilen)) {
                    (chm = 0);
                } else {
                    (chm = BlkValueRead(txt, (i + 1)));
                }
                if ((((((blobtype == CHR_BLOB)) || ((chm == 0 or 10 or 13 or 32 or 9)))) || ((chm == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (mpos = 0);
                    (cl = (cl - (flen - 1)));
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (csize = BlkValueLBCapacity(ctxt));
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    continue;
                }
            }
        } else {
            (mpos = 0);
        }
        if (((cl + 1) >= csize)) {
            if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                break;
            }
            (csize = BlkValueLBCapacity(ctxt));
        }
        BlkValueWrite(ctxt, (cl)++, ch);
    }
    BlkValueCopy(txt, ctxt);
    BlkValueFree(ctxt);
];
[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (dsize = BlkValueLBCapacity(txt));
    (r = dsize);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            (r = i);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_Empty txt;
    if ((txt == 0)) {
        rtrue;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        if (((txt-->(1)) == EMPTY_TEXT_PACKED)) {
            rtrue;
        }
        rfalse;
    }
    if ((TEXT_TY_CharacterLength(txt) == 0)) {
        rtrue;
    }
    rfalse;
];
[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    if ((((i <= 0)) || ((i > TEXT_TY_CharacterLength(txt))))) {
        (ch = 0);
    } else {
        (ch = BlkValueRead(txt, (i - 1)));
    }
    BlkValueWrite(ctxt, 0, ch);
    BlkValueWrite(ctxt, 1, 0);
    TEXT_TY_Untransmute(txt, p, cp);
    return ctxt;
];
[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = TEXT_TY_CharacterLength(txt));
    (r = 1);
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt, i));
        if (((ch) && ((CharIsOfCase(ch, case) == 0)))) {
            (r = 0);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (pk = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    (len = TEXT_TY_CharacterLength(txt));
    if (BlkValueSetLBCapacity(ctxt, (len + 1))) {
        (bnd = 1);
        for ((i = 0):(i < len):(i)++) {
            (ch = BlkValueRead(txt, i));
            if ((case < 2)) {
                BlkValueWrite(ctxt, i, CharToCase(ch, case));
            } else {
                BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
                if ((case == 2)) {
                    (bnd = 0);
                    if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        (bnd = 1);
                    }
                }
                if ((case == 3)) {
                    if ((ch ~= 0 or 10 or 13 or 32 or 9)) {
                        if ((bnd == 1)) {
                            (bnd = 0);
                        } else {
                            if ((ch == 46 or 33 or 63)) {
                                (bnd = 1);
                            }
                        }
                    }
                }
            }
        }
        BlkValueWrite(ctxt, len, 0);
    }
    TEXT_TY_Untransmute(txt, pk, cp);
    return ctxt;
];
[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt p cp r;
    if ((to_txt == 0)) {
        rfalse;
    }
    if ((from_txt == 0)) {
        return to_txt;
    }
    TEXT_TY_Transmute(to_txt);
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt));
    TEXT_TY_Untransmute(from_txt, p, cp);
    return r;
];
[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt pos len ch i tosize x y case;
    switch (blobtype) {
        CHR_BLOB, 0:
            (pos = TEXT_TY_CharacterLength(to_txt));
            (len = TEXT_TY_CharacterLength(from_txt));
            if ((BlkValueSetLBCapacity(to_txt, ((pos + len) + 1)) == 0)) {
                return to_txt;
            }
            for ((i = 0):(i < len):(i)++) {
                (ch = BlkValueRead(from_txt, i));
                BlkValueWrite(to_txt, (i + pos), ch);
            }
            BlkValueWrite(to_txt, (len + pos), 0);
            return to_txt;
            ;
        REGEXP_BLOB:
            return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
            ;
    }
    print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
    rfalse;
];
[ CharIsOfCase c case i tab min max len par;
    if ((c < 65)) {
        rfalse;
    }
    if ((case == 0)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            rtrue;
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            rtrue;
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        rfalse;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            rfalse;
        }
        if ((c < (min + len))) {
            if (par) {
                if ((((c - min)%2) == 0)) {
                    rtrue;
                }
            } else {
                rtrue;
            }
        }
    }
    rfalse;
];
[ CharToCase c case i tab min max len par del f;
    if ((c < 65)) {
        return c;
    }
    if ((case == 1)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            return (c - 32);
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            return (c + 32);
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        return c;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (del = (tab-->(i)));
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            return c;
        }
        if ((c < (min + len))) {
            (f = 0);
            if (par) {
                if ((((c - min)%2) == 0)) {
                    (f = 1);
                }
            } else {
                (f = 1);
            }
            if (f) {
                if ((del == UNIC_NCT)) {
                    return c;
                }
                return (c + del);
            }
        }
    }
    return c;
];
[ TEXT_TY_RevCase ch;
    if ((ch < 65)) {
        return ch;
    }
    if ((((ch >= 97)) && ((ch <= 122)))) {
        return ((ch - 97) + 65);
    }
    if ((((ch >= 65)) && ((ch <= 90)))) {
        return ((ch - 65) + 97);
    }
    if ((ch < 128)) {
        return ch;
    }
    if (CharIsOfCase(ch, 0)) {
        return CharToCase(ch, 1);
    }
    if (CharIsOfCase(ch, 1)) {
        return CharToCase(ch, 0);
    }
    return ch;
];
[ DigitToValue c n;
    (n = (c - 48));
    if ((((n < 0)) || ((n > 9)))) {
        return (-(1));
    }
    return n;
];
[ CharTestCases case i j;
    for ((i = 32):(i < 224):(i)++) {
        if ((((i >= 127)) && ((i < 155)))) {
            continue;
        }
        print i;
        print " - ";
        print (char) i;
        print " -";
        if (CharIsOfCase(i, 0)) {
            print "  lower";
        }
        if (CharIsOfCase(i, 1)) {
            print "  upper";
        }
        (j = CharToCase(i, 0));
        if ((j ~= i)) {
            print "  tolower: ";
            print (char) j;
        }
        (j = CharToCase(i, 1));
        if ((j ~= i)) {
            print "  toupper: ";
            print (char) j;
        }
        print "^";
    }
];
[ TEXT_TY_RE_SetTrace F;
    (TEXT_TY_RE_Trace = F);
];
[ TEXT_TY_RE_Node n cc par1 par2 par3 offset;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        rfalse;
    }
    (offset = (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES)));
    ((offset-->(RE_CCLASS)) = cc);
    ((offset-->(RE_PAR1)) = par1);
    ((offset-->(RE_PAR2)) = par2);
    ((offset-->(RE_PAR3)) = par3);
    ((offset-->(RE_NEXT)) = NULL);
    ((offset-->(RE_PREVIOUS)) = NULL);
    ((offset-->(RE_DOWN)) = NULL);
    ((offset-->(RE_UP)) = NULL);
    ((offset-->(RE_DATA1)) = -1);
    ((offset-->(RE_DATA2)) = -1);
    ((offset-->(RE_CONSTRAINT)) = -1);
    return offset;
];
[ TEXT_TY_RE_NodeAddress n;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        return (-(1));
    }
    return (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES));
];
[ TEXT_TY_RE_DebugMatchVars txt offset n i;
    print (RE_Subexpressions-->(10));
    print " collecting subexps^";
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        print "Subexp ";
        print (offset-->(RE_PAR1));
        print " = [";
        print (offset-->(RE_DATA1));
        print ",";
        print (offset-->(RE_DATA2));
        print "] = ";
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            print (char) BlkValueRead(txt, i);
        }
        print "^";
    }
];
[ TEXT_TY_RE_CreateMatchVars txt offset n i ch ctxt cl csize;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        if ((Allocated_Match_Vars-->(n))) {
            BlkValueFree((Allocated_Match_Vars-->(n)));
        }
        ((Allocated_Match_Vars-->(n)) = BlkValueCreate(TEXT_TY));
        TEXT_TY_Transmute((Allocated_Match_Vars-->(n)));
        (ctxt = (Allocated_Match_Vars-->(n)));
        (csize = BlkValueLBCapacity(ctxt));
        (cl = 0);
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            (ch = BlkValueRead(txt, i));
            if (((cl + 1) >= csize)) {
                if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                    break;
                }
                (csize = BlkValueLBCapacity(ctxt));
            }
            BlkValueWrite(ctxt, (cl)++, ch);
        }
        BlkValueWrite(ctxt, cl, 0);
    }
];
[ TEXT_TY_RE_EmptyMatchVars txt n;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        if (((Allocated_Match_Vars-->(n)) ~= 0)) {
            BlkValueWrite((Allocated_Match_Vars-->(n)), 0, 0);
        }
    }
];
[ TEXT_TY_RE_GetMatchVar vn offset;
    if ((((((vn < 0)) || ((vn >= 10)))) || ((vn >= (RE_Subexpressions-->(10)))))) {
        return EMPTY_TEXT_VALUE;
    }
    (offset = (RE_Subexpressions-->(vn)));
    if ((offset == 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((offset-->(RE_DATA1)) < 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((Allocated_Match_Vars-->(vn)) == 0)) {
        print "*** ";
        print vn;
        print " unallocated! ***^";
        return EMPTY_TEXT_VALUE;
    }
    return (Allocated_Match_Vars-->(vn));
];
[ TEXT_TY_MV_End n end offset;
    (offset = (RE_Subexpressions-->(n)));
    if ((end == 0)) {
        return (offset-->(RE_DATA1));
    }
    return (offset-->(RE_DATA2));
];
[ TEXT_TY_RE_Clear_Markers token;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_Clear_Markers((token-->(RE_DOWN)));
        }
        ((token-->(RE_DATA1)) = -1);
        ((token-->(RE_DATA2)) = -1);
        ((token-->(RE_CONSTRAINT)) = -1);
    }
];
[ TEXT_TY_RE_DebugTree ftxt detail;
    print "Pattern: ";
    TEXT_TY_Say(ftxt);
    print "^";
    TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];
[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail cup;
    if ((offset ~= NULL)) {
        (cup = (offset-->(RE_UP)));
        if (((offset-->(RE_PREVIOUS)) ~= NULL)) {
            print "*** broken initial previous ***^";
        }
    }
    while ((offset ~= NULL)) {
        if (((offset-->(RE_UP)) ~= cup)) {
            print "*** broken up matching ***^";
        }
        spaces (depth*2);
        TEXT_TY_RE_DebugNode(offset, ftxt, detail);
        if (((offset-->(RE_DOWN)) ~= NULL)) {
            if ((((offset-->(RE_DOWN))-->(RE_UP)) ~= offset)) {
                print "*** broken down/up ***^";
            }
            TEXT_TY_RE_DebugSubtree(ftxt, (depth + 1), (offset-->(RE_DOWN)), detail);
        }
        if (((offset-->(RE_NEXT)) ~= NULL)) {
            if ((((offset-->(RE_NEXT))-->(RE_PREVIOUS)) ~= offset)) {
                print "*** broken next/previous ***^";
            }
        }
        (offset = (offset-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_DebugNode offset ftxt detail i par1 par2 par3;
    if ((offset == NULL)) {
        print "[NULL]";
        new_line;
        rtrue;
    }
    print "[";
    print ((offset - RE_PACKET_space)/RE_PACKET_SIZE_IN_BYTES);
    print "] ";
    (par1 = (offset-->(RE_PAR1)));
    (par2 = (offset-->(RE_PAR2)));
    (par3 = (offset-->(RE_PAR3)));
    switch ((offset-->(RE_CCLASS))) {
        DIGIT_RE_CC:
            print "DIGIT";
            ;
        NONDIGIT_RE_CC:
            print "NONDIGIT";
            ;
        UCASE_RE_CC:
            print "UCASE";
            ;
        NONUCASE_RE_CC:
            print "NONUCASE";
            ;
        LCASE_RE_CC:
            print "LCASE";
            ;
        NONLCASE_RE_CC:
            print "NONLCASE";
            ;
        WHITESPACE_RE_CC:
            print "WHITESPACE";
            ;
        NONWHITESPACE_RE_CC:
            print "NONWHITESPACE";
            ;
        PUNCTUATION_RE_CC:
            print "PUNCTUATION";
            ;
        NONPUNCTUATION_RE_CC:
            print "NONPUNCTUATION";
            ;
        WORD_RE_CC:
            print "WORD";
            ;
        NONWORD_RE_CC:
            print "NONWORD";
            ;
        ALWAYS_RE_CC:
            print "ALWAYS";
            ;
        NEVER_RE_CC:
            print "NEVER";
            ;
        START_RE_CC:
            print "START";
            ;
        END_RE_CC:
            print "END";
            ;
        BOUNDARY_RE_CC:
            print "BOUNDARY";
            ;
        NONBOUNDARY_RE_CC:
            print "NONBOUNDARY";
            ;
        ANYTHING_RE_CC:
            print "ANYTHING";
            ;
        NOTHING_RE_CC:
            print "NOTHING";
            ;
        RANGE_RE_CC:
            print "RANGE";
            if ((par3 == 1)) {
                print " (negated)";
            }
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        VARIABLE_RE_CC:
            print "VARIABLE ";
            print par1;
            ;
        SUBEXP_RE_CC:
            if ((par1 == 0)) {
                print "EXP";
            } else {
                print "SUBEXP ";
            }
            if ((par1 >= 0)) {
                print "= V";
                print par1;
            }
            if ((par2 == 1)) {
                if ((par3 == 0)) {
                    print " (?=...) lookahead";
                } else {
                    print " (?<=...) lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 2)) {
                if ((par3 == 0)) {
                    print " (?!...) negated lookahead";
                } else {
                    print " (?<!...) negated lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 3)) {
                print " uncollecting";
            }
            if ((par2 == 0 or 3)) {
                if ((par3 == 1)) {
                    print " forcing case sensitivity";
                }
                if ((par3 == 2)) {
                    print " forcing case insensitivity";
                }
            }
            if ((par2 == 4)) {
                print " (?>...) possessive";
            }
            ;
        NEWLINE_RE_CC:
            print "NEWLINE";
            ;
        TAB_RE_CC:
            print "TAB";
            ;
        QUANTIFIER_RE_CC:
            print "QUANTIFIER min=";
            print par1;
            print " max=";
            print par2;
            if (par3) {
                print " (lazy)";
            } else {
                print " (greedy)";
            }
            ;
        LITERAL_RE_CC:
            print "LITERAL";
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        DISJUNCTION_RE_CC:
            print "DISJUNCTION of ";
            print par1;
            print " choices";
            ;
        CHOICE_RE_CC:
            print "CHOICE no ";
            print par1;
            ;
        SENSITIVITY_RE_CC:
            print "SENSITIVITY";
            if (par1) {
                print " off";
            } else {
                print " on";
            }
            ;
        IF_RE_CC:
            print "IF";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        CONDITION_RE_CC:
            print "CONDITION";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        THEN_RE_CC:
            print "THEN";
            ;
        ELSE_RE_CC:
            print "ELSE";
            ;
    }
    if (detail) {
        print ": ";
        print (offset-->(RE_DATA1));
        print ", ";
        print (offset-->(RE_DATA2));
        print ", ";
        print (offset-->(RE_CONSTRAINT));
    }
    print "^";
];
[ TEXT_TY_CHR_CompileTree ftxt exactly root literal fto no_packets token attach_to;
    (fto = TEXT_TY_CharacterLength(ftxt));
    (root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0));
    (literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0));
    ((root-->(RE_DOWN)) = literal);
    ((literal-->(RE_UP)) = root);
    if (exactly) {
        (no_packets = 2);
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
];
[ TEXT_TY_RE_CompileTree ftxt exactly no_packets ffrom fto cc par1 par2 par3 quantifiable token attach_to no_subs blevel bits;
    (fto = TEXT_TY_CharacterLength(ftxt));
    if ((fto == 0)) {
        TEXT_TY_RE_Node((no_packets)++, NEVER_RE_CC, 0, 0, 0);
        rtrue;
    }
    (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, 0, 0, 0));
    ((RE_Subexpressions-->(0)) = attach_to);
    ((RE_Subexpressions-->(10)) = 1);
    (no_subs = 1);
    (quantifiable = 0);
    (blevel = 0);
    for ((ffrom = 0):(ffrom < fto):) {
        (cc = BlkValueRead(ftxt, (ffrom)++));
        (par1 = 0);
        (par2 = 0);
        (par3 = 0);
        if ((cc == 92)) {
            if ((ffrom == fto)) {
                return "Search pattern not terminated";
            }
            (cc = BlkValueRead(ftxt, (ffrom)++));
            switch (cc) {
                98:
                    (cc = BOUNDARY_RE_CC);
                    ;
                66:
                    (cc = NONBOUNDARY_RE_CC);
                    ;
                100:
                    (cc = DIGIT_RE_CC);
                    ;
                68:
                    (cc = NONDIGIT_RE_CC);
                    ;
                108:
                    (cc = LCASE_RE_CC);
                    ;
                76:
                    (cc = NONLCASE_RE_CC);
                    ;
                110:
                    (cc = NEWLINE_RE_CC);
                    ;
                112:
                    (cc = PUNCTUATION_RE_CC);
                    ;
                80:
                    (cc = NONPUNCTUATION_RE_CC);
                    ;
                115:
                    (cc = WHITESPACE_RE_CC);
                    ;
                83:
                    (cc = NONWHITESPACE_RE_CC);
                    ;
                116:
                    (cc = TAB_RE_CC);
                    ;
                117:
                    (cc = UCASE_RE_CC);
                    ;
                85:
                    (cc = NONUCASE_RE_CC);
                    ;
                119:
                    (cc = WORD_RE_CC);
                    ;
                87:
                    (cc = NONWORD_RE_CC);
                    ;
                default:
                    if ((((cc >= 49)) && ((cc <= 57)))) {
                        (par1 = (cc - 48));
                        (cc = VARIABLE_RE_CC);
                    } else {
                        if ((((((cc >= 97)) && ((cc <= 122)))) || ((((cc >= 65)) && ((cc <= 90)))))) {
                            return "unknown escape";
                        }
                        (cc = LITERAL_RE_CC);
                        (par1 = (ffrom - 1));
                        (par2 = ffrom);
                    }
                    ;
            }
            (quantifiable = 1);
        } else {
            switch (cc) {
                40:
                    (par2 = 0);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (bits = 1);
                        if ((BlkValueRead(ftxt, ffrom) == 45)) {
                            (ffrom)++;
                            (bits = 0);
                        } else {
                            if ((BlkValueRead(ftxt, ffrom) == 60)) {
                                (ffrom)++;
                                (bits = 0);
                            }
                        }
                        switch ((cc = BlkValueRead(ftxt, (ffrom)++))) {
                            35:
                                while ((BlkValueRead(ftxt, (ffrom)++) ~= 0 or 41)) {
                                }
                                if ((BlkValueRead(ftxt, (ffrom - 1)) == 0)) {
                                    return "comment never ends";
                                }
                                continue;
                                ;
                            40:
                                (cc = BlkValueRead(ftxt, ffrom));
                                if ((((cc == 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) && ((BlkValueRead(ftxt, (ffrom + 1)) == 41)))) {
                                    (ffrom = (ffrom + 2));
                                    (par1 = (cc - 48));
                                } else {
                                    (ffrom)--;
                                }
                                (cc = IF_RE_CC);
                                (quantifiable = 0);
                                if ((blevel == 20)) {
                                    return "subexpressions too deep";
                                }
                                ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                                jump CClassKnown;
                                ;
                            61:
                                (par2 = 1);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            33:
                                (par2 = 2);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            58:
                                (par2 = 3);
                                ;
                            62:
                                (par2 = 4);
                                ;
                            default:
                                if ((BlkValueRead(ftxt, ffrom) == 41)) {
                                    if ((cc == 105)) {
                                        (cc = SENSITIVITY_RE_CC);
                                        (par1 = bits);
                                        (ffrom)++;
                                        jump CClassKnown;
                                    }
                                }
                                if ((BlkValueRead(ftxt, ffrom) == 58)) {
                                    if ((cc == 105)) {
                                        (par1 = bits);
                                        (par2 = 3);
                                        (par3 = (bits + 1));
                                        (ffrom)++;
                                        jump AllowForm;
                                    }
                                }
                                return "unknown (?...) form";
                                ;
                        }
                    }
                    .AllowForm;
                    if ((par2 == 0)) {
                        (par1 = (no_subs)++);
                    } else {
                        (par1 = -1);
                    }
                    (cc = SUBEXP_RE_CC);
                    (quantifiable = 0);
                    if ((blevel == 20)) {
                        return "subexpressions too deep";
                    }
                    ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                    ;
                41:
                    if ((blevel == 0)) {
                        return "subexpression bracket mismatch";
                    }
                    (blevel)--;
                    (attach_to = (Subexp_Posns-->(blevel)));
                    if (((attach_to-->(RE_DOWN)) == NULL)) {
                        if ((no_packets >= RE_MAX_PACKETS)) {
                            return "regexp too complex";
                        }
                        ((attach_to-->(RE_DOWN)) = TEXT_TY_RE_Node((no_packets)++, ALWAYS_RE_CC, 0, 0, 0));
                        (((attach_to-->(RE_DOWN))-->(RE_UP)) = attach_to);
                    }
                    (quantifiable = 1);
                    continue;
                    ;
                46:
                    (cc = ANYTHING_RE_CC);
                    (quantifiable = 1);
                    ;
                124:
                    (cc = CHOICE_RE_CC);
                    (quantifiable = 0);
                    ;
                94:
                    (cc = START_RE_CC);
                    (quantifiable = 0);
                    ;
                36:
                    (cc = END_RE_CC);
                    (quantifiable = 0);
                    ;
                123:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (par1 = 0);
                    (par2 = -1);
                    (bits = 1);
                    while (((cc = BlkValueRead(ftxt, (ffrom)++)) ~= 0 or 125)) {
                        if ((cc == 44)) {
                            (bits)++;
                            if ((bits >= 3)) {
                                return "too many colons in ?{...}";
                            }
                            continue;
                        }
                        if ((((cc >= 48)) || ((cc <= 57)))) {
                            if ((bits == 1)) {
                                if ((par1 < 0)) {
                                    (par1 = 0);
                                }
                                (par1 = ((par1*10) + (cc - 48)));
                            } else {
                                if ((par2 < 0)) {
                                    (par2 = 0);
                                }
                                (par2 = ((par2*10) + (cc - 48)));
                            }
                        } else {
                            return "non-digit in ?{...}";
                        }
                    }
                    if ((cc ~= 125)) {
                        return "{x,y} quantifier never ends";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    if ((par2 == -1)) {
                        if ((bits == 2)) {
                            (par2 = 30000);
                        } else {
                            (par2 = par1);
                        }
                    }
                    if ((par1 > par2)) {
                        return "{x,y} with x greater than y";
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                60, 91:
                    (par3 = 0);
                    if ((cc == 60)) {
                        (bits = 62);
                    } else {
                        (bits = 93);
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 94)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (par1 = ffrom);
                    if ((BlkValueRead(ftxt, ffrom) == bits)) {
                        (ffrom)++;
                    }
                    while ((cc ~= bits or 0)) {
                        (cc = BlkValueRead(ftxt, (ffrom)++));
                        if ((cc == 92)) {
                            (cc = BlkValueRead(ftxt, (ffrom)++));
                            if ((cc ~= 0)) {
                                (cc = BlkValueRead(ftxt, (ffrom)++));
                            }
                        }
                    }
                    if ((cc == 0)) {
                        return "Character range never ends";
                    }
                    (par2 = (ffrom - 1));
                    if ((((((((par2 > (par1 + 1))) && ((BlkValueRead(ftxt, par1) == 58)))) && ((BlkValueRead(ftxt, (par2 - 1)) == 58)))) && ((BlkValueRead(ftxt, (par2 - 2)) ~= 92)))) {
                        return "POSIX named character classes unsupported";
                    }
                    (bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2));
                    if (bits) {
                        return bits;
                    }
                    if ((par1 < par2)) {
                        (cc = RANGE_RE_CC);
                    } else {
                        (cc = NOTHING_RE_CC);
                    }
                    (quantifiable = 1);
                    ;
                42:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                43:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 1);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                63:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 1);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
            }
        }
        .CClassKnown;
        if ((cc >= 0)) {
            (quantifiable = 1);
            if (((((attach_to-->(RE_CCLASS)) == LITERAL_RE_CC)) && ((BlkValueRead(ftxt, ffrom) ~= 42 or 43 or 63 or 123)))) {
                ((attach_to-->(RE_PAR2)))++;
                if ((TEXT_TY_RE_Trace == 2)) {
                    print "Extending literal by ";
                    print cc;
                    print "=";
                    print (char) cc;
                    print "^";
                }
                continue;
            }
            (cc = LITERAL_RE_CC);
            (par1 = (ffrom - 1));
            (par2 = ffrom);
        }
        if ((no_packets >= RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Attaching packet ";
            print (no_packets + 1);
            print " to ";
            TEXT_TY_RE_DebugNode(attach_to, ftxt);
            TEXT_TY_RE_DebugTree(ftxt);
        }
        (token = TEXT_TY_RE_Node((no_packets)++, cc, par1, par2, par3));
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 0)))) {
            ((RE_Subexpressions-->((token-->(RE_PAR1)))) = token);
            ((RE_Subexpressions-->(10)))++;
        }
        if (((((attach_to-->(RE_CCLASS)) == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC)) && (((attach_to-->(RE_DOWN)) == NULL)))) {
            ((attach_to-->(RE_DOWN)) = token);
            ((token-->(RE_UP)) = attach_to);
        } else {
            if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && ((((attach_to-->(RE_UP))-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (no_packets)--;
                (token = (attach_to-->(RE_UP)));
            } else {
                if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                    while (((attach_to-->(RE_PREVIOUS)) ~= NULL)) {
                        (attach_to = (attach_to-->(RE_PREVIOUS)));
                    }
                }
                if (((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC or CHOICE_RE_CC)) {
                    ((token-->(RE_PREVIOUS)) = (attach_to-->(RE_PREVIOUS)));
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                    if (((((attach_to-->(RE_UP)) ~= NULL)) && (((attach_to-->(RE_PREVIOUS)) == NULL)))) {
                        (((attach_to-->(RE_UP))-->(RE_DOWN)) = token);
                    }
                    ((token-->(RE_DOWN)) = attach_to);
                    (bits = attach_to);
                    while ((bits ~= NULL)) {
                        ((bits-->(RE_UP)) = token);
                        (bits = (bits-->(RE_NEXT)));
                    }
                    ((attach_to-->(RE_PREVIOUS)) = NULL);
                    if (((token-->(RE_PREVIOUS)) ~= NULL)) {
                        (((token-->(RE_PREVIOUS))-->(RE_NEXT)) = token);
                    }
                } else {
                    ((attach_to-->(RE_NEXT)) = token);
                    ((token-->(RE_PREVIOUS)) = attach_to);
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                }
            }
        }
        if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            ((token-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, CHOICE_RE_CC, 0, 0, 0));
            (((token-->(RE_NEXT))-->(RE_PREVIOUS)) = token);
            (((token-->(RE_NEXT))-->(RE_UP)) = (token-->(RE_UP)));
            (token = (token-->(RE_NEXT)));
        }
        (attach_to = token);
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Result:^";
            TEXT_TY_RE_DebugTree(ftxt);
        }
    }
    if ((blevel ~= 0)) {
        return "subexpression bracket mismatch";
    }
    if (exactly) {
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
    if (TEXT_TY_RE_Trace) {
        print "Compiled pattern:^";
        TEXT_TY_RE_DebugTree(ftxt);
    }
    (bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs));
    if (bits) {
        return bits;
    }
    return no_packets;
];
[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt i chm;
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            if ((((((chm >= 97)) && ((chm <= 122)))) || ((((chm >= 65)) && ((chm <= 90)))))) {
                if ((chm ~= 115 or 83 or 112 or 80 or 119 or 87 or 100 or 68 or 110 or 116 or 108 or 76 or 117 or 85)) {
                    return "Invalid escape in {} range";
                }
            }
        }
        if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
            if ((chm > BlkValueRead(ftxt, (i + 2)))) {
                return "Invalid {} range";
            }
            (i = (i + 2));
        }
    }
    rfalse;
];
[ TEXT_TY_RE_ExpandChoices token no_packets rv prev nex holder new ct n cond_node then_node else_node;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == IF_RE_CC)) {
            if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                for (((nex = (token-->(RE_DOWN))),(n = 0)):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    (n)++;
                }
                if ((n ~= 2)) {
                    return "conditional has too many clauses";
                }
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                }
                (then_node = (token-->(RE_DOWN)));
                ((then_node-->(RE_CCLASS)) = THEN_RE_CC);
                (else_node = (then_node-->(RE_NEXT)));
                ((else_node-->(RE_CCLASS)) = ELSE_RE_CC);
                if (((cond_node-->(RE_PAR1)) < 1)) {
                    ((cond_node-->(RE_DOWN)) = (then_node-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((then_node-->(RE_DOWN))-->(RE_NEXT)));
                    if (((then_node-->(RE_DOWN)) ~= NULL)) {
                        (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                    }
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
            } else {
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (then_node = TEXT_TY_RE_Node((no_packets)++, THEN_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                    ((then_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                } else {
                    ((cond_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((token-->(RE_DOWN))-->(RE_NEXT)));
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
                ((then_node-->(RE_UP)) = token);
                ((then_node-->(RE_NEXT)) = NULL);
                if (((then_node-->(RE_DOWN)) ~= NULL)) {
                    (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                }
                for ((nex = (then_node-->(RE_DOWN))):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    ((nex-->(RE_UP)) = then_node);
                }
            }
            if (((cond_node-->(RE_DOWN)) ~= NULL)) {
                (nex = (cond_node-->(RE_DOWN)));
                if (((((((nex-->(RE_CCLASS)) ~= SUBEXP_RE_CC)) || (((nex-->(RE_NEXT)) ~= NULL)))) || (((nex-->(RE_PAR2)) ~= 1 or 2)))) {
                    return "condition not lookahead/behind";
                }
            }
        }
        if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && (((token-->(RE_PAR1)) < 1)))) {
            (prev = (token-->(RE_PREVIOUS)));
            (nex = (token-->(RE_NEXT)));
            while ((((nex ~= NULL)) && (((nex-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (nex = (nex-->(RE_NEXT)));
            }
            (holder = (token-->(RE_UP)));
            if ((holder == NULL)) {
                return "bang";
            }
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            (new = TEXT_TY_RE_Node((no_packets)++, DISJUNCTION_RE_CC, 0, 0, 0));
            ((holder-->(RE_DOWN)) = new);
            ((new-->(RE_UP)) = holder);
            if ((prev ~= NULL)) {
                ((prev-->(RE_NEXT)) = new);
                ((new-->(RE_PREVIOUS)) = prev);
            }
            if ((nex ~= NULL)) {
                ((nex-->(RE_PREVIOUS)) = new);
                ((new-->(RE_NEXT)) = nex);
            }
            ((new-->(RE_DOWN)) = token);
            ((token-->(RE_PREVIOUS)) = NULL);
            (ct = 1);
            while ((token ~= NULL)) {
                ((token-->(RE_PAR1)) = (ct)++);
                ((token-->(RE_UP)) = new);
                if (((((token-->(RE_NEXT)) ~= NULL)) && ((((token-->(RE_NEXT))-->(RE_CCLASS)) ~= CHOICE_RE_CC)))) {
                    ((token-->(RE_NEXT)) = NULL);
                }
                (token = (token-->(RE_NEXT)));
            }
            ((new-->(RE_PAR1)) = (ct - 1));
            if ((token ~= NULL)) {
                ((token-->(RE_NEXT)) = NULL);
            }
            (token = new);
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (no_packets = TEXT_TY_RE_ExpandChoices((token-->(RE_DOWN)), no_packets));
            if ((((no_packets < 0)) || ((no_packets >= RE_MAX_PACKETS)))) {
                break;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    return no_packets;
];
[ TEXT_TY_RE_CheckTree token no_subs rv;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == VARIABLE_RE_CC)) {
            if (((token-->(RE_PAR1)) >= no_subs)) {
                return "reference to nonexistent group";
            }
        }
        if (((((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2)))) && (((token-->(RE_PAR3)) == -1)))) {
            ((token-->(RE_PAR3)) = TEXT_TY_RE_Width((token-->(RE_DOWN))));
            if (((token-->(RE_PAR3)) == -1)) {
                return "variable length lookbehind not implemented";
            }
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (rv = TEXT_TY_RE_CheckTree((token-->(RE_DOWN)), no_subs));
            if (rv) {
                return rv;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    rfalse;
];
[ TEXT_TY_RE_Width token downwards w rv aw choice;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC, PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC, ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC, UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
                (w)++;
                ;
            START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
                ;
            LITERAL_RE_CC:
                (w = ((w + (token-->(RE_PAR2))) - (token-->(RE_PAR1))));
                ;
            VARIABLE_RE_CC:
                return (-(1));
                ;
            IF_RE_CC:
                (rv = TEXT_TY_RE_Width(((token-->(RE_DOWN))-->(RE_NEXT))));
                if ((rv == -1)) {
                    return (-(1));
                }
                if ((rv ~= TEXT_TY_RE_Width((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))))) {
                    return (-(1));
                }
                (w = (w + rv));
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (rv = 0);
                } else {
                    (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                }
                (w = (w + rv));
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_PAR1)) ~= (token-->(RE_PAR2)))) {
                    return (-(1));
                }
                (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                if ((rv == -1)) {
                    return (-(1));
                }
                (w = (w + (rv*(token-->(RE_PAR1)))));
                ;
            DISJUNCTION_RE_CC:
                (aw = -1);
                for ((choice = (token-->(RE_DOWN))):(choice ~= NULL):(choice = (choice-->(RE_NEXT)))) {
                    (rv = TEXT_TY_RE_Width((choice-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                    if ((((aw >= 0)) && ((aw ~= rv)))) {
                        return (-(1));
                    }
                    (aw = rv);
                }
                (w = (w + aw));
                ;
            SENSITIVITY_RE_CC:
                ;
        }
        if (downwards) {
            return w;
        }
        if ((token ~= NULL)) {
            (token = (token-->(RE_NEXT)));
        }
    }
    return w;
];
[ TEXT_TY_RE_PrintNoRewinds;
    print TEXT_TY_RE_RewindCount;
];
[ TEXT_TY_RE_Parse ftxt txt ipos insens ilen rv root i initial_mode;
    (ilen = TEXT_TY_CharacterLength(txt));
    if ((((ipos < 0)) || ((ipos > ilen)))) {
        return (-(1));
    }
    (root = RE_PACKET_space);
    (initial_mode = 0);
    if (insens) {
        (initial_mode = CIS_MFLAG);
    }
    TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
    for (:(ipos <= ilen):(ipos)++) {
        if (((((((RE_PACKET_space-->(RE_DOWN)) ~= NULL)) && ((((RE_PACKET_space-->(RE_DOWN))-->(RE_CCLASS)) == START_RE_CC)))) && ((ipos > 0)))) {
            (rv = -1);
            break;
        }
        if ((ipos > 0)) {
            TEXT_TY_RE_EraseConstraints(RE_PACKET_space);
        }
        (TEXT_TY_RE_RewindCount = 0);
        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode));
        if ((rv >= 0)) {
            break;
        }
    }
    if ((rv == -1)) {
        ((root-->(RE_DATA1)) = -1);
        ((root-->(RE_DATA2)) = -1);
    } else {
        ((root-->(RE_DATA1)) = ipos);
        ((root-->(RE_DATA2)) = (ipos + rv));
    }
    return rv;
];
[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags outcome ipos npos rv i ch edge rewind_this;
    if ((ifrom > ito)) {
        return (-(1));
    }
    (ipos = ifrom);
    .Rewind;
    while ((token ~= NULL)) {
        (outcome = 0);
        if (TEXT_TY_RE_Trace) {
            print "Matching at ";
            print ipos;
            print ": ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if ((ipos < ito)) {
            (ch = BlkValueRead(txt, ipos));
        } else {
            (ch = 0);
        }
        ((token-->(RE_MODES)) = mode_flags);
        switch ((token-->(RE_CCLASS))) {
            CHOICE_RE_CC:
                return "internal error";
                ;
            SENSITIVITY_RE_CC:
                if ((token-->(RE_PAR1))) {
                    (mode_flags = ((mode_flags)|(CIS_MFLAG)));
                } else {
                    (mode_flags = ((mode_flags)&((~(CIS_MFLAG)))));
                }
                (outcome = 1);
                ;
            ALWAYS_RE_CC:
                (outcome = 1);
                ;
            NEVER_RE_CC:
                ;
            START_RE_CC:
                if ((ipos == 0)) {
                    (outcome = 1);
                }
                ;
            END_RE_CC:
                if ((BlkValueRead(txt, ipos) == 0)) {
                    (outcome = 1);
                }
                ;
            BOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv == 1)) {
                    (outcome = 1);
                }
                ;
            NONBOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv ~= 1)) {
                    (outcome = 1);
                }
                ;
            IF_RE_CC:
                (i = (token-->(RE_PAR1)));
                (ch = 0);
                if (TEXT_TY_RE_Trace) {
                    print "Trying conditional from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if ((i >= 1)) {
                    if ((((i < (RE_Subexpressions-->(10)))) && ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)))) {
                        (ch = 1);
                    }
                } else {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((token-->(RE_DOWN))-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        (ch = 1);
                    }
                }
                if (TEXT_TY_RE_Trace) {
                    print "Condition found to be ";
                    print ch;
                    print "^";
                }
                if (ch) {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                } else {
                    if (((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT)) == NULL)) {
                        (rv = 0);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                    }
                }
                if ((rv >= 0)) {
                    (outcome = 1);
                    (ipos = (ipos + rv));
                }
                ;
            DISJUNCTION_RE_CC:
                if (TEXT_TY_RE_Trace) {
                    print "Trying disjunction from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                for ((ch = (token-->(RE_DOWN))):(ch ~= NULL):(ch = (ch-->(RE_NEXT)))) {
                    if (((ch-->(RE_PAR1)) <= (token-->(RE_CONSTRAINT)))) {
                        continue;
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Trying choice at ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                    }
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (ch-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        ((token-->(RE_DATA1)) = ipos);
                        ((token-->(RE_DATA2)) = (ch-->(RE_PAR1)));
                        (ipos = (ipos + rv));
                        (outcome = 1);
                        if (TEXT_TY_RE_Trace) {
                            print "Choice worked with width ";
                            print rv;
                            print ": ";
                            TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                        }
                        break;
                    } else {
                        if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                            TEXT_TY_RE_FailSubexpressions((ch-->(RE_DOWN)));
                        }
                    }
                }
                if ((outcome == 0)) {
                    if (TEXT_TY_RE_Trace) {
                        print "Failed disjunction from ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    ((token-->(RE_DATA1)) = ipos);
                    ((token-->(RE_DATA2)) = -1);
                }
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (npos = (ipos - (token-->(RE_PAR3))));
                    if ((npos < 0)) {
                        (rv = -1);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), mode_flags));
                    }
                } else {
                    switch ((token-->(RE_PAR3))) {
                        0:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), mode_flags));
                            ;
                        1:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)&((~(CIS_MFLAG))))));
                            ;
                        2:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)|(CIS_MFLAG))));
                            ;
                    }
                }
                (npos = ipos);
                if ((rv >= 0)) {
                    (npos = (ipos + rv));
                }
                switch ((token-->(RE_PAR2))) {
                    1:
                        if ((rv >= 0)) {
                            (rv = 0);
                        }
                        ;
                    2:
                        if ((rv >= 0)) {
                            (rv = -1);
                        } else {
                            (rv = 0);
                        }
                        ;
                }
                if ((rv >= 0)) {
                    ((token-->(RE_DATA1)) = ipos);
                    (ipos = (ipos + rv));
                    ((token-->(RE_DATA2)) = npos);
                    (outcome = 1);
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        ((token-->(RE_DATA1)) = -1);
                        ((token-->(RE_DATA2)) = -1);
                    }
                }
                if (((token-->(RE_PAR2)) == 2)) {
                    TEXT_TY_RE_FailSubexpressions(token, 1);
                }
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_DATA1)) = ipos);
                if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                    (((token-->(RE_DOWN))-->(RE_CACHE1)) = -1);
                    (((token-->(RE_DOWN))-->(RE_CACHE2)) = -1);
                }
                if (TEXT_TY_RE_Trace) {
                    print "Trying quantifier from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if (((token-->(RE_PAR3)) == 0)) {
                    (edge = (token-->(RE_PAR2)));
                    if (((token-->(RE_CONSTRAINT)) >= 0)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    (rv = -1);
                    for (((i = 0),(npos = ipos)):(i < edge):(i)++) {
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= (token-->(RE_PAR1)))) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                } else {
                    (edge = (token-->(RE_PAR1)));
                    if (((token-->(RE_CONSTRAINT)) > edge)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    for (((i = 0),(npos = ipos)):(((npos < ito)) && ((i < (token-->(RE_PAR2))))):(i)++) {
                        if ((i >= edge)) {
                            break;
                        }
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= edge)) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                }
                if (outcome) {
                    if (((token-->(RE_PAR3)) == 0)) {
                        if ((i > (token-->(RE_PAR1)))) {
                            ((token-->(RE_DATA2)) = (i - 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    } else {
                        if ((i < (token-->(RE_PAR2)))) {
                            ((token-->(RE_DATA2)) = (i + 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    }
                    (ipos = npos);
                    if ((((i == 0)) && ((((mode_flags)&(ACCUM_MFLAG)) == 0)))) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                        (((token-->(RE_DOWN))-->(RE_DATA1)) = ((token-->(RE_DOWN))-->(RE_CACHE1)));
                        (((token-->(RE_DOWN))-->(RE_DATA2)) = ((token-->(RE_DOWN))-->(RE_CACHE2)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Successful quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Failed quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                }
                ;
            NOTHING_RE_CC:
                ;
            ANYTHING_RE_CC:
                if (ch) {
                    (outcome = 1);
                }
                (ipos)++;
                ;
            WHITESPACE_RE_CC:
                if ((ch == 10 or 13 or 32 or 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWHITESPACE_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            PUNCTUATION_RE_CC:
                if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONPUNCTUATION_RE_CC:
                if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            WORD_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWORD_RE_CC:
                if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            DIGIT_RE_CC:
                if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONDIGIT_RE_CC:
                if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LCASE_RE_CC:
                if (CharIsOfCase(ch, 0)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONLCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 0) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            UCASE_RE_CC:
                if (CharIsOfCase(ch, 1)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONUCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 1) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NEWLINE_RE_CC:
                if ((ch == 10)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            TAB_RE_CC:
                if ((ch == 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            RANGE_RE_CC:
                if (TEXT_TY_RE_Range(ch, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), (token-->(RE_PAR3)), ((mode_flags)&(CIS_MFLAG)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LITERAL_RE_CC:
                (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), ((mode_flags)&(CIS_MFLAG))));
                if ((rv >= 0)) {
                    (ipos = (ipos + rv));
                    (outcome = 1);
                }
                ;
            VARIABLE_RE_CC:
                (i = (token-->(RE_PAR1)));
                if ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)) {
                    (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, txt, ((RE_Subexpressions-->(i))-->(RE_DATA1)), ((RE_Subexpressions-->(i))-->(RE_DATA2)), ((mode_flags)&(CIS_MFLAG))));
                    if ((rv >= 0)) {
                        (ipos = (ipos + rv));
                        (outcome = 1);
                    }
                }
                ;
        }
        if ((outcome == 0)) {
            if (((TEXT_TY_RE_RewindCount)++ >= 10000)) {
                if ((TEXT_TY_RE_RewindCount == 10001)) {
                    style bold;
                    print "OVERFLOW^";
                    style roman;
                }
                return (-(1));
            }
            if (TEXT_TY_RE_Trace) {
                print "Rewind sought from failure at pos ";
                print ipos;
                print " with: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            if (((((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC)) && (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, 0)))) {
                jump RewindFound;
            }
            if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                TEXT_TY_RE_FailSubexpressions(token);
            }
            (token = (token-->(RE_PREVIOUS)));
            while ((token ~= NULL)) {
                if (TEXT_TY_RE_SeekBacktrack(token, ftxt, 1, ito, 0)) {
                    .RewindFound;
                    (ipos = (token-->(RE_DATA1)));
                    (mode_flags = (token-->(RE_MODES)));
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions(token, 1);
                    }
                    if ((ipos == -1)) {
                        TEXT_TY_RE_DebugTree(ftxt, 1);
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "^[";
                        print ifrom;
                        print ",";
                        print ito;
                        print "] rewinding to ";
                        print ipos;
                        print " at ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    jump Rewind;
                }
                (token = (token-->(RE_PREVIOUS)));
            }
            if (TEXT_TY_RE_Trace) {
                print "^Rewind impossible^";
            }
            return (-(1));
        }
        (token = (token-->(RE_NEXT)));
    }
    return (ipos - ifrom);
];
[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only untried;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
            print "Scan for rewind: ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2 or 4)))) {
            if (downwards) {
                rfalse;
            }
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                print "Descend^";
            }
            if (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, report_only)) {
                rtrue;
            }
        }
        (untried = 0);
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                if (((((((token-->(RE_DATA2)) >= 1)) && (((token-->(RE_DATA2)) < (token-->(RE_PAR1)))))) && (((token-->(RE_CONSTRAINT)) < (token-->(RE_PAR1)))))) {
                    if (report_only) {
                        rtrue;
                    }
                    if (((token-->(RE_CONSTRAINT)) == -1)) {
                        ((token-->(RE_CONSTRAINT)) = 1);
                    } else {
                        ((token-->(RE_CONSTRAINT)))++;
                    }
                    (untried = 1);
                }
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_CONSTRAINT)) ~= -2)) {
                    if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                        print "Quant with cons not -2: ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    if (((token-->(RE_DATA2)) >= 0)) {
                        if (report_only) {
                            rtrue;
                        }
                        ((token-->(RE_CONSTRAINT)) = (token-->(RE_DATA2)));
                        (untried = 1);
                    }
                }
                ;
        }
        if (untried) {
            if (TEXT_TY_RE_Trace) {
                print "Grounds for rewind at: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            TEXT_TY_RE_EraseConstraints((token-->(RE_NEXT)));
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
            rtrue;
        }
        if (downwards) {
            rfalse;
        }
    }
    rfalse;
];
[ TEXT_TY_RE_FailSubexpressions token downwards;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
        }
        if (((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
            ((token-->(RE_DATA1)) = -1);
            ((token-->(RE_DATA2)) = -1);
        }
        if (downwards) {
            break;
        }
    }
];
[ TEXT_TY_RE_EraseConstraints token;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
        }
        if ((token-->(RE_DOWN))) {
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
        }
        (token = (token-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens i ch;
    if ((mfrom < 0)) {
        rfalse;
    }
    if (insens) {
        for ((i = mfrom):(i < mto):(i)++) {
            (ch = BlkValueRead(mtxt, i));
            if ((BlkValueRead(txt, (ipos)++) ~= ch or TEXT_TY_RevCase(ch))) {
                return (-(1));
            }
        }
    } else {
        for ((i = mfrom):(i < mto):(i)++) {
            if ((BlkValueRead(txt, (ipos)++) ~= BlkValueRead(mtxt, i))) {
                return (-(1));
            }
        }
    }
    return (mto - mfrom);
];
[ TEXT_TY_RE_Range ch ftxt rf rt negate insens i chm upper crev;
    if ((ch == 0)) {
        rfalse;
    }
    if ((negate == 1)) {
        if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, 0, insens)) {
            rfalse;
        }
        rtrue;
    }
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            switch (chm) {
                115:
                    if ((ch == 10 or 13 or 32 or 9)) {
                        rtrue;
                    }
                    ;
                83:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                        rtrue;
                    }
                    ;
                112:
                    if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                80:
                    if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                119:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                87:
                    if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                100:
                    if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                        rtrue;
                    }
                    ;
                68:
                    if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                        rtrue;
                    }
                    ;
                108:
                    if (CharIsOfCase(ch, 0)) {
                        rtrue;
                    }
                    ;
                76:
                    if ((CharIsOfCase(ch, 0) == 0)) {
                        rtrue;
                    }
                    ;
                117:
                    if (CharIsOfCase(ch, 1)) {
                        rtrue;
                    }
                    ;
                85:
                    if ((CharIsOfCase(ch, 1) == 0)) {
                        rtrue;
                    }
                    ;
                110:
                    if ((ch == 10)) {
                        rtrue;
                    }
                    ;
                116:
                    if ((ch == 9)) {
                        rtrue;
                    }
                    ;
            }
        } else {
            if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
                (upper = BlkValueRead(ftxt, (i + 2)));
                if ((((ch >= chm)) && ((ch <= upper)))) {
                    rtrue;
                }
                if (insens) {
                    (crev = TEXT_TY_RevCase(ch));
                    if ((((crev >= chm)) && ((crev <= upper)))) {
                        rtrue;
                    }
                }
                (i = (i + 2));
            } else {
                if ((chm == ch)) {
                    rtrue;
                }
                if (((insens) && ((chm == TEXT_TY_RevCase(ch))))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly r p p1 p2 cp cp1 cp2;
    if ((rtxt == 0 or 1)) {
        (cp = (txt-->(0)));
        (p = TEXT_TY_Temporarily_Transmute(txt));
    } else {
        TEXT_TY_Transmute(txt);
    }
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    if ((rtxt == 0 or 1)) {
        TEXT_TY_Untransmute(txt, p, cp);
    }
    return r;
];
[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly ctxt csize ilen i cl mpos cpos ch chm;
    (ilen = TEXT_TY_CharacterLength(txt));
    (TEXT_TY_RE_Err = 0);
    switch (ftxtype) {
        REGEXP_BLOB:
            (i = TEXT_TY_RE_CompileTree(ftxt, exactly));
            ;
        CHR_BLOB:
            (i = TEXT_TY_CHR_CompileTree(ftxt, exactly));
            ;
        default:
            print "*** bad ftxtype ***";
            new_line;
            rtrue;
            ;
    }
    if ((((i < 0)) || ((i > RE_MAX_PACKETS)))) {
        (TEXT_TY_RE_Err = i);
        print "*** Regular expression error: ";
        print (string) TEXT_TY_RE_Err;
        print " ***^";
        RunTimeProblem(RTP_REGEXPSYNTAXERROR);
        rfalse;
    }
    if (TEXT_TY_RE_Trace) {
        TEXT_TY_RE_DebugTree(ftxt);
        print "(compiled to ";
        print i;
        print " packets)^";
    }
    if ((ftxtype == REGEXP_BLOB)) {
        TEXT_TY_RE_EmptyMatchVars();
    }
    (mpos = 0);
    (chm = 0);
    (cpos = 0);
    while ((TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0)) {
        (chm)++;
        if (TEXT_TY_RE_Trace) {
            print "^*** Match ";
            print chm;
            print " found (";
            print (RE_PACKET_space-->(RE_DATA1));
            print ",";
            print (RE_PACKET_space-->(RE_DATA2));
            print "): ";
            if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
                print "<empty>";
            }
            for ((i = (RE_PACKET_space-->(RE_DATA1))):(i < (RE_PACKET_space-->(RE_DATA2))):(i)++) {
                print (char) BlkValueRead(txt, i);
            }
            print " ***^";
        }
        if ((rtxt == 0)) {
            break;
        }
        if ((rtxt ~= 0 or 1)) {
            if ((chm == 1)) {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                (csize = BlkValueLBCapacity(ctxt));
            }
            for ((i = cpos):(i < (RE_PACKET_space-->(RE_DATA1))):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
            BlkValueWrite(ctxt, cl, 0);
            TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
            (csize = BlkValueLBCapacity(ctxt));
            (cl = TEXT_TY_CharacterLength(ctxt));
        }
        (mpos = (RE_PACKET_space-->(RE_DATA2)));
        (cpos = mpos);
        if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
            (mpos)++;
        }
        if (TEXT_TY_RE_Trace) {
            if ((chm == 100)) {
                print "(Stopping after 100 matches.)^";
                break;
            }
        }
    }
    if ((chm > 0)) {
        if ((rtxt ~= 0 or 1)) {
            for ((i = cpos):(i < ilen):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
        if ((ftxtype == REGEXP_BLOB)) {
            TEXT_TY_RE_CreateMatchVars(txt);
            if (TEXT_TY_RE_Trace) {
                TEXT_TY_RE_DebugMatchVars(txt);
            }
        }
        if ((rtxt ~= 0 or 1)) {
            BlkValueWrite(ctxt, cl, 0);
            BlkValueCopy(txt, ctxt);
            BlkValueFree(ctxt);
        }
    }
    return chm;
];
[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref pos len ch i tosize x y case;
    if ((((txt_to == 0)) || ((BlkValueWeakKind(txt_to) ~= TEXT_TY)))) {
        rfalse;
    }
    if ((((txt_from == 0)) || ((BlkValueWeakKind(txt_from) ~= TEXT_TY)))) {
        return txt_to;
    }
    (pos = TEXT_TY_CharacterLength(txt_to));
    (tosize = BlkValueLBCapacity(txt_to));
    (len = TEXT_TY_CharacterLength(txt_from));
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt_from, i));
        if ((((ch == 92)) && ((i < (len - 1))))) {
            (ch = BlkValueRead(txt_from, ++(i)));
            if ((ch == 110)) {
                (ch = 10);
            }
            if ((ch == 116)) {
                (ch = 9);
            }
            (case = -1);
            if ((ch == 108)) {
                (case = 0);
            }
            if ((ch == 117)) {
                (case = 1);
            }
            if ((case >= 0)) {
                (ch = BlkValueRead(txt_from, ++(i)));
            }
            if ((((ch >= 48)) && ((ch <= 57)))) {
                (ch = (ch - 48));
                if ((ch < (RE_Subexpressions-->(10)))) {
                    (x = ((RE_Subexpressions-->(ch))-->(RE_DATA1)));
                    (y = ((RE_Subexpressions-->(ch))-->(RE_DATA2)));
                    if ((x >= 0)) {
                        for (:(x < y):(x)++) {
                            (ch = BlkValueRead(txt_ref, x));
                            if (((pos + 1) >= tosize)) {
                                if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                                    break;
                                }
                                (tosize = BlkValueLBCapacity(txt_to));
                            }
                            if ((case >= 0)) {
                                BlkValueWrite(txt_to, (pos)++, CharToCase(ch, case));
                            } else {
                                BlkValueWrite(txt_to, (pos)++, ch);
                            }
                        }
                    }
                }
                continue;
            }
        }
        if (((pos + 1) >= tosize)) {
            if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                break;
            }
            (tosize = BlkValueLBCapacity(txt_to));
        }
        BlkValueWrite(txt_to, (pos)++, ch);
    }
    BlkValueWrite(txt_to, pos, 0);
    return txt_to;
];
[ LIST_OF_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return LIST_OF_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            LIST_OF_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return LIST_OF_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            return LIST_OF_TY_QuickCopy(arg1, arg2);
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return LIST_OF_TY_KindData(arg1, arg2);
            ;
        EXTENT_KOVS:
            return (BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE);
            ;
        COPY_KOVS:
            LIST_OF_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return LIST_OF_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return LIST_OF_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = {";
            LIST_OF_TY_Say(arg1);
            print "} of kind ";
            print BlkValueRead(arg1, LIST_ITEM_KOV_F);
            ;
    }
    rfalse;
];
[ LIST_OF_TY_Create skov sb list;
    (skov = KindBaseTerm(skov, 0));
    (list = FlexAllocate((27*WORDSIZE), LIST_OF_TY, (BLK_FLAG_MULTIPLE + BLK_FLAG_WORD)));
    BlkValueWrite(list, LIST_ITEM_KOV_F, skov, 1);
    BlkValueWrite(list, LIST_LENGTH_F, 0, 1);
    (sb = BlkValueCreateSB1(sb, list));
    return sb;
];
[ LIST_OF_TY_Destroy list no_items i k;
    (k = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (KOVIsBlockValue(k)) {
        (no_items = BlkValueRead(list, LIST_LENGTH_F));
        for ((i = 0):(i < no_items):(i)++) {
            BlkValueFree(BlkValueRead(list, (i + LIST_ITEM_BASE)));
        }
    }
];
[ LIST_OF_TY_CopyKind to from;
    BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_QuickCopy to from;
    if ((BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_KindData list dummy;
    return BlkValueRead(list, LIST_ITEM_KOV_F);
];
[ LIST_OF_TY_Copy lto lfrom precopied_list_kov no_items i nv bk val splk;
    (no_items = BlkValueRead(lfrom, LIST_LENGTH_F));
    (bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F));
    if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
    } else {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
    }
    if (KOVIsBlockValue(bk)) {
        for ((i = 0):(i < no_items):(i)++) {
            (val = BlkValueRead(lfrom, (i + LIST_ITEM_BASE)));
            if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
                (nv = BlkValueCreate(precopied_list_kov));
            } else {
                (nv = BlkValueCreate(bk));
            }
            BlkValueCopy(nv, val);
            BlkValueWrite(lto, (i + LIST_ITEM_BASE), nv);
        }
    }
];
[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
    (delta = (BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F)));
    if (delta) {
        return delta;
    }
    (no_items = BlkValueRead(listleft, LIST_LENGTH_F));
    if ((no_items == 0)) {
        rfalse;
    }
    (delta = (BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F)));
    if (delta) {
        return delta;
    }
    (cf = LIST_OF_TY_ComparisonFn(listleft));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (BlkValueRead(listleft, (i + LIST_ITEM_BASE)) - BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (cf)(BlkValueRead(listleft, (i + LIST_ITEM_BASE)),BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_ComparisonFn list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_Distinguish txb1 txb2;
    if ((LIST_OF_TY_Compare(txb1, txb2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_Hash list len kov rv i;
    (rv = 0);
    (len = BlkValueRead(list, LIST_LENGTH_F));
    (kov = BlkValueRead(list, LIST_ITEM_KOV_F));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + GetHashValue(kov, BlkValueRead(list, (i + LIST_ITEM_BASE)))));
    }
    return rv;
];
[ LIST_OF_TY_Say list format no_items v i bk;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rtrue;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F)));
    if ((format == 1)) {
        print "{";
    }
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        switch (format) {
            2:
                DefArt(v);
                ;
            3:
                IndefArt(v);
                ;
            default:
                if ((bk == LIST_OF_TY)) {
                    LIST_OF_TY_Say(v, 1);
                } else {
                    if ((((bk == TEXT_TY)) && ((format == 1)))) {
                        print "~";
                        PrintKindValuePair(bk, v);
                        print "~";
                    } else {
                        PrintKindValuePair(bk, v);
                    }
                }
                ;
        }
        if ((i < (no_items - 2))) {
            print ", ";
        }
        if ((i == (no_items - 2))) {
            if ((format == 1)) {
                print ", ";
            } else {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((no_items ~= 2)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
        }
    }
    if ((format == 1)) {
        print "}";
    }
    (prior_named_list = no_items);
    (prior_named_list_gender = -1);
];
[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    (len = (desc)(-3));
    if (((len + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (len + LIST_ITEM_BASE)) == 0)) {
            rfalse;
        }
    }
    if (kov) {
        BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
    } else {
        BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
    }
    BlkValueWrite(list, LIST_LENGTH_F, len);
    (obj = 0);
    for ((i = 0):(i < len):(i)++) {
        (obj = (desc)(-2,obj,i));
        BlkValueWrite(list, (i + LIST_ITEM_BASE), obj);
    }
    return list;
];
[ LIST_OF_TY_FindItem list v i no_items cf;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            if ((v == BlkValueRead(list, (i + LIST_ITEM_BASE)))) {
                rtrue;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            if (((cf)(v,BlkValueRead(list, (i + LIST_ITEM_BASE))) == 0)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if (((nodups) && (LIST_OF_TY_FindItem(list, v)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    (contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + LIST_ITEM_BASE) + 1) > ex)) {
        if ((BlkValueSetLBCapacity(list, (ex + 16)) == 0)) {
            rfalse;
        }
    }
    if (KOVIsBlockValue(contents_kind)) {
        (nv = BlkValueCreate(contents_kind));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if (posnflag) {
        (posn)--;
        for ((i = no_items):(i > posn):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - 1) + LIST_ITEM_BASE)));
        }
        BlkValueWrite(list, (posn + LIST_ITEM_BASE), v);
    } else {
        BlkValueWrite(list, (no_items + LIST_ITEM_BASE), v);
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + 1));
    return list;
];
[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((((more == 0)) || ((BlkValueWeakKind(more) ~= LIST_OF_TY)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (msize = BlkValueRead(more, LIST_LENGTH_F));
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + msize) + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (((no_items + msize) + LIST_ITEM_BASE) + 8)) == 0)) {
            rfalse;
        }
    }
    if (posnflag) {
        (posn)--;
        for ((i = (no_items + msize)):(i >= (posn + msize)):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - msize) + LIST_ITEM_BASE)));
        }
        for ((j = 0):(j < msize):(j)++) {
            (v = BlkValueRead(more, (j + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            BlkValueWrite(list, ((posn + j) + LIST_ITEM_BASE), v);
        }
    } else {
        for (((i = 0),(j = 0)):(i < msize):(i)++) {
            (v = BlkValueRead(more, (i + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            if ((((nodups == 0)) || ((LIST_OF_TY_FindItem(list, v) == 0)))) {
                BlkValueWrite(list, ((no_items + j) + LIST_ITEM_BASE), v);
                (j)++;
            }
        }
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + j));
    return list;
];
[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    for ((i = 0):(i < no_items):(i)++) {
        (delendum = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        if ((cf == 0 or UnsignedCompare)) {
            (f = (v == delendum));
        } else {
            (f = ((cf)(v,delendum) == 0));
        }
        if (f) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                BlkValueFree(delendum);
            }
            for ((j = (i + 1)):(j < no_items):(j)++) {
                BlkValueWrite(list, ((j - 1) + LIST_ITEM_BASE), BlkValueRead(list, (j + LIST_ITEM_BASE)));
            }
            (no_items)--;
            (i)--;
            BlkValueWrite(list, LIST_LENGTH_F, no_items);
        }
    }
    if ((odsize ~= no_items)) {
        rfalse;
    }
    if (forgive) {
        rfalse;
    }
    print "*** Couldn't remove: the value ";
    PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
    print " was not present in the list ";
    LIST_OF_TY_Say(list, 1);
    print " ***^";
    RunTimeProblem(RTP_LISTRANGEERROR);
];
[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((((from > to)) || ((from <= 0)))) || ((to > no_items)))) {
        if (forgive) {
            if ((from <= 0)) {
                (from = 1);
            }
            if ((to >= no_items)) {
                (to = no_items);
            }
            if ((from > to)) {
                return list;
            }
        } else {
            print "*** Couldn't remove entries ";
            print from;
            print " to ";
            print to;
            print " from the list ";
            LIST_OF_TY_Say(list, 1);
            print ", which has entries in the range 1 to ";
            print no_items;
            print " ***^";
            RunTimeProblem(RTP_LISTRANGEERROR);
            rfalse;
        }
    }
    (to)--;
    (from)--;
    (d = ((to - from) + 1));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        for ((i = 0):(i < d):(i)++) {
            BlkValueFree(BlkValueRead(list, ((from + i) + LIST_ITEM_BASE)));
        }
    }
    for ((i = from):(i < (no_items - d)):(i)++) {
        BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i + d) + LIST_ITEM_BASE)));
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items - d));
    return list;
];
[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    (rsize = BlkValueRead(rlist, LIST_LENGTH_F));
    (cf = LIST_OF_TY_ComparisonFn(list));
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        for ((k = 0):(k < rsize):(k)++) {
            (w = BlkValueRead(rlist, (k + LIST_ITEM_BASE)));
            if ((cf == 0 or UnsignedCompare)) {
                (f = (v == w));
            } else {
                (f = ((cf)(v,w) == 0));
            }
            if (f) {
                if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                    BlkValueFree(v);
                }
                for ((j = (i + 1)):(j < no_items):(j)++) {
                    BlkValueWrite(list, ((j + LIST_ITEM_BASE) - 1), BlkValueRead(list, (j + LIST_ITEM_BASE)));
                }
                (no_items)--;
                (i)--;
                BlkValueWrite(list, LIST_LENGTH_F, no_items);
                break;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_GetLength list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return BlkValueRead(list, LIST_LENGTH_F);
];
[ LIST_OF_TY_Empty list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((BlkValueRead(list, LIST_LENGTH_F) == 0)) {
        rtrue;
    }
    rfalse;
];
[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((newsize < 0)) {
        return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
    }
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < newsize)) {
        if ((this_way_only == -1)) {
            return list;
        }
        (ex = BlkValueLBCapacity(list));
        if (((newsize + LIST_ITEM_BASE) > ex)) {
            if ((BlkValueSetLBCapacity(list, (newsize + LIST_ITEM_BASE)) == 0)) {
                rfalse;
            }
        }
        (dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F)));
        for ((i = no_items):(i < newsize):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), dv);
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    if ((no_items > newsize)) {
        if ((this_way_only == 1)) {
            return list;
        }
        if ((truncation_end == -1)) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = 0):(i < (no_items - newsize)):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
            for ((i = 0):(i < newsize):(i)++) {
                BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - newsize) + i)));
            }
        } else {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = newsize):(i < no_items):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    return list;
];
[ LIST_OF_TY_GetItem list i forgive no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        if (forgive) {
            rfalse;
        }
        print "*** Couldn't read from entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        RunTimeProblem(RTP_LISTRANGEERROR);
        if ((no_items >= 1)) {
            (i = 1);
        } else {
            rfalse;
        }
    }
    return BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1));
];
[ WriteLIST_OF_TY_GetItem list i val no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        print "*** Couldn't write to list entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        return RunTimeProblem(RTP_LISTRANGEERROR);
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), val);
];
[ LIST_OF_TY_PutItem list i v no_items nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if ((((i <= 0)) || ((i > no_items)))) {
        rfalse;
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), v);
];
[ LIST_OF_TY_Reverse list no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    for ((i = 0):((i*2) < no_items):(i)++) {
        (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
        BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - 1) - i)));
        BlkValueWrite(list, (((LIST_ITEM_BASE + no_items) - 1) - i), v);
    }
    return list;
];
[ LIST_OF_TY_Rotate list backwards no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    if (backwards) {
        (v = BlkValueRead(list, LIST_ITEM_BASE));
        for ((i = 0):(i < (no_items - 1)):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) + 1)));
        }
        BlkValueWrite(list, ((no_items - 1) + LIST_ITEM_BASE), v);
    } else {
        (v = BlkValueRead(list, ((no_items - 1) + LIST_ITEM_BASE)));
        for ((i = (no_items - 1)):(i > 0):(i)--) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
        }
        BlkValueWrite(list, LIST_ITEM_BASE, v);
    }
    return list;
];
[ LIST_OF_TY_Sort list dir prop cf i j no_items v;
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((dir == 2)) {
        if ((no_items < 2)) {
            rtrue;
        }
        for ((i = 1):(i < no_items):(i)++) {
            (j = (random((i + 1)) - 1));
            (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (LIST_ITEM_BASE + j)));
            BlkValueWrite(list, (LIST_ITEM_BASE + j), v);
        }
        rtrue;
    }
    SetSortDomain(ListSwapEntries, ListCompareEntries);
    if (cf) {
        (LIST_OF_TY_Sort_cf = BlkValueCompare);
    } else {
        (LIST_OF_TY_Sort_cf = 0);
    }
    SortArray(list, prop, dir, no_items, 0);
];
[ ListSwapEntries list i j v;
    if ((i == j)) {
        rtrue;
    }
    (v = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + j) - 1), v);
];
[ ListCompareEntries list col i j d cf;
    if ((i == j)) {
        rfalse;
    }
    (i = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    (j = BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    if (I7S_Col) {
        if ((_final_propertyexists(OBJECT_TY, i, I7S_Col))) {
            (i = _final_propertyvalue(OBJECT_TY, i, I7S_Col));
        } else {
            (i = 0);
        }
        if ((_final_propertyexists(OBJECT_TY, j, I7S_Col))) {
            (j = _final_propertyvalue(OBJECT_TY, j, I7S_Col));
        } else {
            (j = 0);
        }
        (cf = LIST_OF_TY_Sort_cf);
    } else {
        (cf = LIST_OF_TY_ComparisonFn(list));
    }
    if ((cf == 0)) {
        if ((i > j)) {
            rtrue;
        }
        if ((i < j)) {
            return (-(1));
        }
        rfalse;
    } else {
        return (cf)(i,j);
    }
];
[ COMBINATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return COMBINATION_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            COMBINATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return COMBINATION_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return COMBINATION_TY_KindData(arg1);
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            COMBINATION_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return COMBINATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return COMBINATION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            COMBINATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ COMBINATION_TY_Create kind sb long_block N i bk v;
    (N = KindBaseArity(kind));
    (long_block = FlexAllocate(((COMBINATION_ITEM_BASE + N)*WORDSIZE), COMBINATION_TY, BLK_FLAG_WORD));
    BlkValueWrite(long_block, COMBINATION_KIND_F, kind, 1);
    for ((i = 0):(i < N):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (v = BlkValueCreate(bk));
        } else {
            (v = DefaultValueOfKOV(bk));
        }
        BlkValueWrite(long_block, (COMBINATION_ITEM_BASE + i), v, 1);
    }
    return BlkValueCreateSB1(sb, long_block);
];
[ COMBINATION_TY_Destroy comb kind no_items i bk;
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            BlkValueFree(BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        }
    }
];
[ COMBINATION_TY_CopyKind to from;
    BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];
[ COMBINATION_TY_CopySB to from;
    BlkValueCopySB1(to, from);
];
[ COMBINATION_TY_KindData comb;
    return BlkValueRead(comb, COMBINATION_KIND_F);
];
[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov no_items i nv kind bk;
    (no_items = KindBaseArity(precopied_comb_kov));
    BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (nv = BlkValueCreate(bk));
            BlkValueCopy(nv, BlkValueRead(from_comb, (i + COMBINATION_ITEM_BASE)));
            BlkValueWrite(to_comb, (i + COMBINATION_ITEM_BASE), nv);
        }
    }
];
[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
    (kind = BlkValueRead(left_comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (cf = KOVComparisonFunction(bk));
        if ((cf == 0 or UnsignedCompare)) {
            (delta = (BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)) - BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        } else {
            (delta = (cf)(BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)),BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ COMBINATION_TY_Distinguish left_comb right_comb;
    if ((COMBINATION_TY_Compare(left_comb, right_comb) == 0)) {
        rfalse;
    }
    rtrue;
];
[ COMBINATION_TY_Hash comb kind rv no_items i bk;
    (rv = 0);
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (rv = ((rv*33) + GetHashValue(bk, BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)))));
    }
    return rv;
];
[ COMBINATION_TY_Say comb format no_items v i kind bk;
    if ((((comb == 0)) || ((BlkValueWeakKind(comb) ~= COMBINATION_TY)))) {
        rtrue;
    }
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    print "(";
    for ((i = 0):(i < no_items):(i)++) {
        if ((i > 0)) {
            print ", ";
        }
        (bk = KindBaseTerm(kind, i));
        (v = BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        if ((bk == LIST_OF_TY)) {
            LIST_OF_TY_Say(v, 1);
        } else {
            PrintKindValuePair(bk, v);
        }
    }
    print ")";
];
[ RELATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return RELATION_TY_Create(arg1, 0, arg2);
            ;
        DESTROY_KOVS:
            RELATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            RELATION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return RELATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return arg1;
            ;
        DEBUG_KOVS:
            print " = ";
            RELATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ RelationTest relation task X Y handler;
    (handler = RlnGetF(relation, RR_HANDLER));
    return (handler)(relation,task,X,Y);
];
[ RlnGetF rel fld i;
    (rel = BlkValueGetLongBlock(rel));
    return (rel-->(fld));
];
[ RlnSetF rel fld v;
    (rel = BlkValueGetLongBlock(rel));
    ((rel-->(fld)) = v);
];
[ EmptyRelationHandler relation task X Y;
    if ((task == RELS_EMPTY)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_Create kov from sb rel i skov handler;
    (rel = FlexAllocate(((RRV_DATA_BASE + (3*RRP_MIN_SIZE))*WORDSIZE), RELATION_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
    if ((((from == 0)) && ((kov ~= 0)))) {
        (from = DefaultValueFinder(kov));
    }
    if (from) {
        for ((i = 0):(i < RRV_DATA_BASE):(i)++) {
            BlkValueWrite(rel, i, BlkValueRead(from, i), 1);
        }
        if ((BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler)) {
            (handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, 1)));
            BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
            BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
            BlkValueWrite(rel, RRV_HANDLER, handler, 1);
            BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
            BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
            BlkValueWrite(rel, RRV_USED, 0, 1);
            BlkValueWrite(rel, RRV_FILLED, 0, 1);
        }
    } else {
        (handler = ChooseRelationHandler(kov));
        BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
        BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
        BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
        BlkValueWrite(rel, RRV_KIND, kov, 1);
        BlkValueWrite(rel, RRV_HANDLER, handler, 1);
        BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
        BlkValueWrite(rel, RRV_USED, 0, 1);
        BlkValueWrite(rel, RRV_FILLED, 0, 1);
    }
    return BlkValueCreateSB1(sb, rel);
];
[ RELATION_TY_Destroy rel handler;
    (handler = BlkValueRead(rel, RRV_HANDLER));
    (handler)(rel,RELS_DESTROY);
];
[ RELATION_TY_Copy lto lfrom handler;
    (handler = BlkValueRead(lto, RRV_HANDLER));
    (handler)(lto,RELS_COPY);
];
[ RELATION_TY_Compare rleft rright ind1 ind2;
    (ind1 = BlkValueRead(rleft, RRV_HANDLER));
    (ind2 = BlkValueRead(rright, RRV_HANDLER));
    if ((ind1 ~= ind2)) {
        return (ind1 - ind2);
    }
    if ((IsMutableRelationHandler(ind1) == 0)) {
        rfalse;
    }
    return (rleft - rright);
];
[ RELATION_TY_Distinguish rleft rright;
    if ((RELATION_TY_Compare(rleft, rright) == 0)) {
        rfalse;
    }
    rtrue;
];
[ RELATION_TY_Say rel;
    if ((rel == 0)) {
        print "(null relation)";
    } else {
        print (string) RlnGetF(rel, RR_NAME);
    }
];
[ RELATION_TY_Name rel txt;
    if (rel) {
        BlkValueWrite(rel, RRV_NAME, txt);
        BlkValueWrite(rel, RRV_DESCRIPTION, txt);
    }
];
[ ChooseRelationHandler kov sym;
    if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
        if (sym) {
            return SymHashListRelationHandler;
        }
        return HashListRelationHandler;
    }
    if (sym) {
        return SymDoubleHashSetRelationHandler;
    }
    return DoubleHashSetRelationHandler;
];
[ IsMutableRelationHandler h;
    if ((h == SymHashListRelationHandler or HashListRelationHandler or SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_SetValency rel val kov filled cur handler ext;
    (filled = BlkValueRead(rel, RRV_FILLED));
    if (filled) {
        RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
        rfalse;
    }
    (kov = BlkValueRead(rel, RRV_KIND));
    if ((val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O)) {
        if ((KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1))) {
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
        }
    }
    (cur = BlkValueRead(rel, RRV_HANDLER));
    switch (val) {
        RRVAL_V_TO_V:
            (handler = ChooseRelationHandler(kov, 0));
            ;
        RRVAL_V_TO_O:
            (handler = HashTableRelationHandler);
            ;
        RRVAL_O_TO_V:
            (handler = ReversedHashTableRelationHandler);
            ;
        RRVAL_O_TO_O:
            (handler = TwoInOneHashTableRelationHandler);
            ;
        RRVAL_EQUIV:
            (handler = EquivHashTableRelationHandler);
            ;
        RRVAL_SYM_V_TO_V:
            (handler = ChooseRelationHandler(kov, 1));
            ;
        RRVAL_SYM_O_TO_O:
            (handler = Sym2in1HashTableRelationHandler);
            ;
        default:
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
            ;
    }
    if ((cur == handler)) {
        rtrue;
    }
    if ((cur == TwoInOneHashTableRelationHandler)) {
        (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (3*ext)));
    } else {
        if ((handler == TwoInOneHashTableRelationHandler)) {
            (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
            BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (4*ext)));
        }
    }
    BlkValueWrite(rel, RRV_HANDLER, handler);
];
[ RELATION_TY_GetValency rel handler;
    return ((BlkValueRead(rel, RRV_PERMISSIONS))&(VALENCY_MASK));
];
[ DoubleHashSetRelationHandler rel task X Y sym kov kx ky at tmp v;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((tmp)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (ky) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((tmp)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (Y) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((tmp)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            DoubleHashSetRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                    if ((Y == RLANY_GET_X or RLANY_CAN_GET_X)) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    } else {
                                        (v = BlkValueRead(rel, (tmp + 1)));
                                        if (KOVIsBlockValue(kx)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_Y)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 2));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                            (v = BlkValueRead(rel, (tmp + 1)));
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(v, X) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((v ~= X)) {
                                                    continue;
                                                }
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((((X == 0)) || ((BlkValueWeakKind(X) ~= LIST_OF_TY)))) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X, RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (tmp)++;
                                                        if ((Y == RLIST_ALL_Y)) {
                                                            (tmp)++;
                                                        }
                                                        (v = BlkValueRead(rel, tmp));
                                                        LIST_OF_TY_InsertItem(X, v, 0, 0, 1);
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (Y = BlkValueCreate(kov));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (v = BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
                                                        (v = BlkValueRead(rel, (tmp + 2)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), v);
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
    switch (task) {
        RELS_TEST:
            if ((at >= 0)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at >= 0)) {
                rtrue;
            }
            (at = (~(at)));
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
            if (KOVIsBlockValue(kx)) {
                (X = BlkValueCopy(BlkValueCreate(kx), X));
            }
            if (KOVIsBlockValue(ky)) {
                (Y = BlkValueCopy(BlkValueCreate(ky), Y));
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
            DoubleHashSetCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            if (KOVIsBlockValue(ky)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ DoubleHashSetLookUp rel kx ky X Y hashv i free mask perturb flags;
    (hashv = (GetHashValue(kx, X) + GetHashValue(ky, Y)));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ DoubleHashSetCheckResize rel filled ext newext temp i at kov kx ky F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ DoubleHashSetEntryMatches rel at kx ky X Y cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    (cy = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
    if (KOVIsBlockValue(ky)) {
        if ((BlkValueCompare(cy, Y) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cy ~= Y)) {
            rfalse;
        }
    }
    rtrue;
];
[ HashListRelationHandler rel task X Y sym kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];
[ HashTableRelationHandler rel task X Y kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ ReversedHashTableRelationHandler rel task X Y kov kx ky swap;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    switch (task) {
        RELS_SET_VALENCY:
            return RELATION_TY_SetValency(rel, X);
            ;
        RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
            return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
            ;
        RELS_LOOKUP_ANY:
            switch (Y) {
                RLANY_GET_X:
                    (Y = RLANY_GET_Y);
                    ;
                RLANY_GET_Y:
                    (Y = RLANY_GET_X);
                    ;
                RLANY_CAN_GET_X:
                    (Y = RLANY_CAN_GET_Y);
                    ;
                RLANY_CAN_GET_Y:
                    (Y = RLANY_CAN_GET_X);
                    ;
            }
            ;
        RELS_LOOKUP_ALL_X:
            (task = RELS_LOOKUP_ALL_Y);
            ;
        RELS_LOOKUP_ALL_Y:
            (task = RELS_LOOKUP_ALL_X);
            ;
        RELS_SHOW:
            (swap = X);
            (X = Y);
            (Y = swap);
            (swap = kx);
            (kx = ky);
            (ky = swap);
            ;
        RELS_LIST:
            switch (Y) {
                RLIST_ALL_X:
                    (Y = RLIST_ALL_Y);
                    ;
                RLIST_ALL_Y:
                    (Y = RLIST_ALL_X);
                    ;
            }
            ;
    }
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ SymDoubleHashSetRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        DoubleHashSetRelationHandler(rel, task, Y, X);
    }
    return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];
[ SymHashListRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        HashListRelationHandler(rel, task, Y, X);
    }
    return HashListRelationHandler(rel, task, X, Y);
];
[ Sym2in1HashTableRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        TwoInOneHashTableRelationHandler(rel, task, Y, X);
    }
    return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];
[ HashCoreRelationHandler rel task kx ky X Y mult sym rev at tmp fl;
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((fl)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (((ky) || ((~~(((fl)&(RRF_SINGLE))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (((Y) || ((~~(((fl)&(RRF_SINGLE))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    switch (RELATION_TY_GetValency(rel)) {
                        RRVAL_SYM_V_TO_V:
                            (sym = 1);
                            (tmp = KOVComparisonFunction(kx));
                            if ((~~(tmp))) {
                                (tmp = UnsignedCompare);
                            }
                            ;
                        RRVAL_O_TO_V:
                            (rev = 1);
                            ;
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((fl)&(RRF_SINGLE))) {
                                if (((sym) && (((tmp)(X,Y) > 0)))) {
                                    continue;
                                }
                                print "  ";
                                if (rev) {
                                    PrintKindValuePair(ky, Y);
                                } else {
                                    PrintKindValuePair(kx, X);
                                }
                                if (sym) {
                                    print " <=> ";
                                } else {
                                    print " >=> ";
                                }
                                if (rev) {
                                    PrintKindValuePair(kx, X);
                                } else {
                                    PrintKindValuePair(ky, Y);
                                }
                                print "^";
                            } else {
                                for ((mult = 1):(mult <= LIST_OF_TY_GetLength(Y)):(mult)++) {
                                    (fl = LIST_OF_TY_GetItem(Y, mult));
                                    if (((sym) && (((tmp)(X,fl) > 0)))) {
                                        continue;
                                    }
                                    print "  ";
                                    if (rev) {
                                        PrintKindValuePair(ky, fl);
                                    } else {
                                        PrintKindValuePair(kx, X);
                                    }
                                    if (sym) {
                                        print " <=> ";
                                    } else {
                                        print " >=> ";
                                    }
                                    if (rev) {
                                        PrintKindValuePair(kx, X);
                                    } else {
                                        PrintKindValuePair(ky, fl);
                                    }
                                    print "^";
                                }
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            HashCoreRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_GET_Y or RLANY_CAN_GET_Y)) {
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at >= 0)) {
                                    if ((Y == RLANY_CAN_GET_Y)) {
                                        rtrue;
                                    }
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    (tmp = BlkValueRead(rel, (tmp + 2)));
                                    if (((fl)&(RRF_SINGLE))) {
                                        return tmp;
                                    }
                                    return LIST_OF_TY_GetItem(tmp, 1);
                                }
                            } else {
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(ky)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    (at = HashCoreLookUp(rel, kx, X));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            LIST_OF_TY_InsertItem(Y, tmp);
                                        } else {
                                            LIST_OF_TY_AppendList(Y, tmp);
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((BlkValueWeakKind(X) ~= LIST_OF_TY)) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)));
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            LIST_OF_TY_InsertItem(X, tmp, 0, 0, 1);
                                                        } else {
                                                            LIST_OF_TY_AppendList(X, tmp, 0, 0, 1);
                                                        }
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                if ((RELATION_TY_GetValency(rel) == RRVAL_O_TO_V)) {
                                                    (rev = 1);
                                                }
                                                (Y = BlkValueCreate(COMBINATION_TY, tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + rev), BlkValueRead(rel, (tmp + 1)));
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), tmp);
                                                            LIST_OF_TY_InsertItem(X, Y);
                                                        } else {
                                                            for ((mult = LIST_OF_TY_GetLength(tmp)):(mult > 0):(mult)--) {
                                                                BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), LIST_OF_TY_GetItem(tmp, mult));
                                                                LIST_OF_TY_InsertItem(X, Y);
                                                            }
                                                        }
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            } else {
                return LIST_OF_TY_FindItem(tmp, Y);
            }
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                if (KOVIsBlockValue(ky)) {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                HashCoreCheckResize(rel);
                break;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                if (mult) {
                    (fl = BlkValueCreate(LIST_OF_TY));
                    BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
                    LIST_OF_TY_SetLength(fl, 2);
                    BlkValueWrite(fl, LIST_ITEM_BASE, tmp);
                    LIST_OF_TY_PutItem(fl, 2, Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), fl);
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_USED);
                } else {
                    if (KOVIsBlockValue(ky)) {
                        BlkValueFree(tmp);
                        (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                    }
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                }
            } else {
                LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
            }
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) ~= 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp ~= Y)) {
                        rtrue;
                    }
                }
                if (KOVIsBlockValue(ky)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                }
                .DeleteEntryIgnoringY;
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
                if (KOVIsBlockValue(kx)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            } else {
                LIST_OF_TY_RemoveValue(tmp, Y, 1);
                if ((LIST_OF_TY_GetLength(tmp) == 0)) {
                    BlkValueFree(tmp);
                    jump DeleteEntryIgnoringY;
                }
            }
            rtrue;
            ;
    }
    rtrue;
];
[ HashCoreLookUp rel kx X hashv i free mask perturb flags;
    (hashv = GetHashValue(kx, X));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (HashCoreEntryMatches(rel, i, kx, X)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (HashCoreEntryMatches(rel, i, kx, X)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ HashCoreCheckResize rel filled ext newext temp i at kov kx F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = HashCoreLookUp(rel, kx, X));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ HashCoreEntryMatches rel at kx X cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    rtrue;
];
[ EquivHashTableRelationHandler rel task X Y kx at at2 tmp fl i ext;
    (kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            if (KOVIsBlockValue(kx)) {
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    (at)--;
                }
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                if (KOVIsBlockValue(kx)) {
                    (at = BlkValueRead(rel, RRV_STORAGE));
                    while ((at >= 0)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1));
                        }
                        (at)--;
                    }
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for (((at = 0),(X = RRV_DATA_BASE)):(at <= ext):((at)++,(X = (X + 3)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            BlkValueWrite(rel, (X + 2), (-(BlkValueRead(rel, (X + 2)))));
                        }
                    }
                    for (((at = 0),((X = RRV_DATA_BASE),(fl = 0))):(at <= ext):((at)++,((X = (X + 3)),(fl = 0)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            (fl = BlkValueRead(rel, (X + 2)));
                            if ((fl > 0)) {
                                continue;
                            }
                            BlkValueWrite(rel, (X + 2), (-(fl)));
                            (tmp = BlkValueRead(rel, (X + 1)));
                            (i = 0);
                            for (((at2 = (at + 1)),(Y = (RRV_DATA_BASE + (3*at2)))):(at2 <= ext):((at2)++,(Y = (Y + 3)))) {
                                if (((BlkValueRead(rel, Y))&(RRF_USED))) {
                                    if ((BlkValueRead(rel, (Y + 2)) ~= fl)) {
                                        continue;
                                    }
                                    BlkValueWrite(rel, (Y + 2), (-(fl)));
                                    if ((~~(i))) {
                                        print "  { ";
                                        PrintKindValuePair(kx, tmp);
                                        (i = 1);
                                    }
                                    print ", ";
                                    PrintKindValuePair(kx, BlkValueRead(rel, (Y + 1)));
                                }
                            }
                            if (i) {
                                print " }^";
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y)) {
                                rtrue;
                            }
                            return X;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at < 0)) {
                                    LIST_OF_TY_InsertItem(Y, X);
                                } else {
                                    (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        if (((fl)&(RRF_USED))) {
                                            if ((BlkValueRead(rel, (tmp + 2)) ~= X)) {
                                                continue;
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                        }
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LIST)) {
                                    print "*** Domains of equivalence relations cannot be listed ***^";
                                    return X;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    (at2 = HashCoreLookUp(rel, kx, Y));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                if (KOVIsBlockValue(kx)) {
                    if ((BlkValueCompare(X, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((X == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            }
            if ((at2 < 0)) {
                rfalse;
            }
            if ((at == at2)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) == tmp)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if (KOVIsBlockValue(kx)) {
                if ((BlkValueCompare(X, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((X == Y)) {
                    rtrue;
                }
            }
            if ((at < 0)) {
                if ((at2 < 0)) {
                    (tmp = 0);
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for ((i = 0):(i <= ext):(i)++) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
                        if (((fl)&(RRF_USED))) {
                            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*i)) + 2)));
                            if ((fl > tmp)) {
                                (tmp = fl);
                            }
                        }
                    }
                    (tmp)++;
                    BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 2));
                    (at = (~(at)));
                    if (KOVIsBlockValue(kx)) {
                        (X = BlkValueCopy(BlkValueCreate(kx), X));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                    (at2 = (~(HashCoreLookUp(rel, kx, Y))));
                    if (KOVIsBlockValue(kx)) {
                        (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                    jump CheckResize;
                }
                (at = (~(at)));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                jump CheckResize;
            }
            if ((at2 < 0)) {
                (at2 = (~(at2)));
                if (KOVIsBlockValue(kx)) {
                    (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                jump CheckResize;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
            if ((tmp < fl)) {
                (i = tmp);
                (tmp = fl);
                (fl = i);
            }
            (ext = BlkValueRead(rel, RRV_STORAGE));
            for ((at = 0):(at <= ext):(at)++) {
                (i = ((RRV_DATA_BASE + (3*at)) + 2));
                if ((BlkValueRead(rel, i) == tmp)) {
                    BlkValueWrite(rel, i, fl);
                }
            }
            .CheckResize;
            HashCoreCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((((at < 0)) || ((at2 < 0)))) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) ~= tmp)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ TwoInOneHashTableRelationHandler rel task X Y sym kov kx ky at at2 tmp fl;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_USED))) {
                    if (((((kx) && (((fl)&(RRF_ENTKEYX))))) || (((ky) && (((fl)&(RRF_ENTKEYY))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    if (((fl)&(RRF_USED))) {
                        if (((((X) && (((fl)&(RRF_ENTKEYX))))) || (((Y) && (((fl)&(RRF_ENTKEYY))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            if (((fl)&(RRF_ENTKEYX))) {
                                (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            } else {
                                (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            }
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), tmp);
                            if (((fl)&(RRF_HASX))) {
                                (at2 = TwoInOneLookUp(rel, kx, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 2)), RRF_ENTKEYX));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 3), tmp);
                                }
                            }
                            if (((fl)&(RRF_HASY))) {
                                (at2 = TwoInOneLookUp(rel, ky, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)), RRF_ENTKEYY));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), tmp);
                                }
                            }
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                        if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (4*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                                BlkValueWrite(rel, (tmp + 3), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            switch (Y) {
                                RLANY_GET_X, RLANY_CAN_GET_X:
                                    (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                            if ((Y == RLANY_CAN_GET_X)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 2));
                                        }
                                    }
                                    ;
                                RLANY_GET_Y, RLANY_CAN_GET_Y:
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            if ((Y == RLANY_CAN_GET_Y)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 3));
                                        }
                                    }
                                    ;
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                if ((at >= 0)) {
                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 3)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                (fl = ((RRF_USED + RRF_ENTKEYX) + RRF_HASY));
                                                jump ListEntryKeys;
                                                ;
                                            RLIST_ALL_Y:
                                                (fl = ((RRF_USED + RRF_ENTKEYY) + RRF_HASX));
                                                .ListEntryKeys;
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    if ((((BlkValueRead(rel, tmp))&(fl)) == fl)) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)), 0, 0, 1);
                                                    }
                                                }
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (tmp = BlkValueRead(X, LIST_ITEM_KOV_F));
                                                if ((KindAtomic(tmp) ~= COMBINATION_TY)) {
                                                    rfalse;
                                                }
                                                (Y = BlkValueCreate(tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), BlkValueRead(rel, (tmp + 3)));
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        return X;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((~~(((fl)&(RRF_HASY))))) {
                rfalse;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((tmp == Y)) {
                    rtrue;
                }
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                (fl = ((RRF_USED + RRF_HASY) + RRF_ENTKEYX));
                if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                    (fl = (fl + RRF_ENTKEYY));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
            } else {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_HASY))) {
                    (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                    if (KOVIsBlockValue(ky)) {
                        if ((BlkValueCompare(tmp, Y) == 0)) {
                            rtrue;
                        }
                    } else {
                        if ((tmp == Y)) {
                            rtrue;
                        }
                    }
                    (at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY));
                    if ((at2 >= 0)) {
                        TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                    }
                } else {
                    BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), (fl + RRF_HASY));
                }
                (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
            }
            (at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY));
            if (KOVIsBlockValue(ky)) {
                if ((at2 >= 0)) {
                    (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at2)) + 1)));
                } else {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
            if ((at2 >= 0)) {
                TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
            } else {
                (at2 = (~(at2)));
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at2))));
            if ((fl == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            (fl = ((fl)|(((RRF_USED + RRF_HASX) + RRF_ENTKEYY))));
            if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                (fl = ((fl)|(RRF_ENTKEYX)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at2)), fl);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 1), Y);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), X);
            TwoInOneCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((((fl)&(RRF_HASY)) == 0)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) ~= 0)) {
                    rtrue;
                }
            } else {
                if ((tmp ~= Y)) {
                    rtrue;
                }
            }
            TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
            rtrue;
            ;
    }
];
[ TwoInOneDelete rel at kx ky ekflag both fl at2 E i;
    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
    if ((ekflag == RRF_ENTKEYX)) {
        if (((fl)&(RRF_HASY))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 3));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                }
                if ((at2 == at)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                }
            }
            (fl = ((fl)&((~(RRF_HASY)))));
        }
    } else {
        if (((fl)&(RRF_HASX))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 2));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
                    if ((at2 == at)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    }
                }
            }
            (fl = ((fl)&((~(RRF_HASX)))));
        }
    }
    if ((((fl)&((RRF_HASX + RRF_HASY))) == 0)) {
        if (((((((fl)&(RRF_ENTKEYX))) && (KOVIsBlockValue(kx)))) || ((((((ky ~= kx)) && (((fl)&(RRF_ENTKEYY))))) && (KOVIsBlockValue(ky)))))) {
            BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
        }
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), RRF_DELETED);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), 0);
        BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
    } else {
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
    }
];
[ TwoInOneLookUp rel ke E ekflag hashv i free mask perturb flags;
    (hashv = GetHashValue(ke, E));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ TwoInOneCheckResize rel filled ext newext temp i at kov kx ky F E X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(4*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*4)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*4)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*4)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (4*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (E = BlkValueRead(temp, ((4*i) + 1), 1));
            (X = BlkValueRead(temp, ((4*i) + 2), 1));
            (Y = BlkValueRead(temp, ((4*i) + 3), 1));
            if (((F)&(RRF_ENTKEYX))) {
                (at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
            } else {
                (at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
            }
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), E);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
        }
        FlexFree(temp);
    }
];
[ TwoInOneEntryMatches rel at ke E ce;
    (ce = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
    if (KOVIsBlockValue(ke)) {
        if ((BlkValueCompare(ce, E) ~= 0)) {
            rfalse;
        }
    } else {
        if ((ce ~= E)) {
            rfalse;
        }
    }
    rtrue;
];
[ RELATION_TY_Empty rel set handler;
    (handler = RlnGetF(rel, RR_HANDLER));
    return (handler)(rel,RELS_EMPTY,set);
];
[ RELATION_TY_EquivalenceAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_EQUIVALENCE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_EQUIVALENCE));
        if ((((perms)&(RELS_SYMMETRIC)) == 0)) {
            (perms = (perms + RELS_SYMMETRIC));
        }
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_EQUIVALENCE));
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to an equivalence relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_SymmetricAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_SYMMETRIC))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_SYMMETRIC));
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_SYMMETRIC));
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a symmetric relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToOAdjective rel set perms state handler i;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == (RELS_X_UNIQUE + RELS_Y_UNIQUE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_X_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToOAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_Y_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == 0)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    if ((((set == 0)) && (state))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ Relation_Now1to1 obj1 relation_property obj2 ol;
    if (obj2) {
        objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, ol, relation_property) == obj2)) {
                (_final_store_property(OBJECT_TY,ol,relation_property, 0));
            }
        }
    }
    if (obj1) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
    }
];
[ Relation_NowN1toV obj1 relation_property obj2;
    if (((obj1) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
    }
];
[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N;
    if (obj2) {
        (N = KOVDomainSize(KOV));
        for ((ol = 1):(ol <= N):(ol)++) {
            if ((GProperty(KOV, ol, relation_property) == obj2)) {
                WriteGProperty(KOV, ol, relation_property, 0);
            }
        }
    }
    if (obj1) {
        WriteGProperty(KOV, obj1, relation_property, obj2);
    }
];
[ Relation_NowN1toVV obj1 obj2 KOV relation_property;
    if (((obj1) && ((GProperty(KOV, obj1, relation_property) == obj2)))) {
        WriteGProperty(KOV, obj1, relation_property, 0);
    }
];
[ Relation_NowS1to1 obj1 relation_property obj2;
    if ((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) {
        if (_final_propertyvalue(OBJECT_TY, obj1, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj1, relation_property),relation_property, 0));
        }
        if (_final_propertyvalue(OBJECT_TY, obj2, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj2, relation_property),relation_property, 0));
        }
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
        (_final_store_property(OBJECT_TY,obj2,relation_property, obj1));
    }
];
[ Relation_NowSN1to1 obj1 relation_property obj2;
    if ((((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
        (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
    }
];
[ Relation_NowS1to1V obj1 obj2 KOV relation_property;
    if (GProperty(KOV, obj1, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
    }
    if (GProperty(KOV, obj2, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
    }
    WriteGProperty(KOV, obj1, relation_property, obj2);
    WriteGProperty(KOV, obj2, relation_property, obj1);
];
[ Relation_NowSN1to1V obj1 obj2 KOV relation_property;
    if ((GProperty(KOV, obj1, relation_property) == obj2)) {
        WriteGProperty(KOV, obj1, relation_property, 0);
        WriteGProperty(KOV, obj2, relation_property, 0);
    }
];
[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    ((vtov_structure-->(pr)) = (((vtov_structure-->(pr)))|(i1)));
];
[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowNVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        ((vtov_structure-->(pr)) = ((vtov_structure-->(pr)) - i1));
    }
];
[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    if (((sym) && ((obj2 > obj1)))) {
        (sym = obj1);
        (obj1 = obj2);
        (obj2 = sym);
    }
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            RunTimeProblem(RTP_IMPREL, obj1, relation);
            rfalse;
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            RunTimeProblem(RTP_IMPREL, obj2, relation);
            rfalse;
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        rtrue;
    }
    rfalse;
];
[ Relation_NowEquiv obj1 relation_property obj2 big little;
    (big = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (little = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
        (big = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    }
    objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == big)) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, little));
        }
    }
];
[ Relation_NowNEquiv obj1 relation_property obj2 old new;
    (old = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) > new)) {
            (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
        }
    }
    (new)++;
    (_final_store_property(OBJECT_TY,obj1,relation_property, new));
];
[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
    (big = GProperty(KOV, obj1, relation_property));
    (little = GProperty(KOV, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = GProperty(KOV, obj1, relation_property));
        (big = GProperty(KOV, obj2, relation_property));
    }
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) == big)) {
            WriteGProperty(KOV, i, relation_property, little);
        }
    }
];
[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
    (old = GProperty(KOV, obj1, relation_property));
    (new = GProperty(KOV, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) > new)) {
            (new = GProperty(KOV, i, relation_property));
        }
    }
    (new)++;
    WriteGProperty(KOV, obj1, relation_property, new);
];
[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    if (sym) {
                        print "  <=>  ";
                    } else {
                        print "  >=>  ";
                    }
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    (proutine2)(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    (proutine1)(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if ((x == 0)) {
                    print (string) RlnGetF(relation, RR_DESCRIPTION);
                    print ":^";
                    (x = 1);
                }
                print "  ";
                (proutine1)(obj1);
                print "  >=>  ";
                (proutine2)(obj2);
                print "^";
            }
        }
    }
];
[ Relation_ShowOtoO relation sym x relation_property t tr N obj1 obj2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (tr = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            CDefArt(obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    } else {
        (N = KOVDomainSize(t));
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            (obj2 = GProperty(t, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            PrintKindValuePair(t, obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    }
];
[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
    } else {
        (N2 = KOVDomainSize(t2));
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        }
    }
];
[ RSE_Flip KOV v relation_property x;
    (x = GProperty(KOV, v, relation_property));
    (x = (-(x)));
    WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
    if ((GProperty(KOV, v, relation_property) < 0)) {
        rtrue;
    }
    rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
    print (string) RlnGetF(relation, RR_DESCRIPTION);
    print ":^";
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
        }
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (v = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                (c = 0);
                objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
                    give obj2 ~workflag2;
                }
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) == v)) {
                        give obj2 workflag2;
                        (_final_store_property(OBJECT_TY,obj2,relation_property, (-(v))));
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  { ";
                    WriteListOfMarkedObjects(ENGLISH_BIT);
                    print " }^";
                } else {
                    (_final_store_property(OBJECT_TY,obj1,relation_property, v));
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (c)++;
                give obj1 workflag2;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c < 4)) {
            WriteListOfMarkedObjects(ENGLISH_BIT);
            print " in";
        } else {
            print c;
        }
        if ((c == 1)) {
            print " a";
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            RSE_Flip(t, obj1, relation_property);
        }
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (v = GProperty(t, obj1, relation_property));
                (c = 0);
                for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                    if ((GProperty(t, obj2, relation_property) == v)) {
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  {";
                    (d = 0);
                    for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                        if ((GProperty(t, obj2, relation_property) == v)) {
                            print " ";
                            PrintKindValuePair(t, obj2);
                            if ((d < (c - 1))) {
                                print ",";
                            }
                            print " ";
                            RSE_Flip(t, obj2, relation_property);
                            (d)++;
                        }
                    }
                    print "}^";
                } else {
                    WriteGProperty(t, obj1, relation_property, v);
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (c)++;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c == 1)) {
            print "a";
        } else {
            print c;
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                RSE_Flip(t, obj1, relation_property);
            }
        }
    }
];
[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
            (obj1 = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
                } else {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
            (obj1 = GProperty(t2, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    WriteGProperty(t2, obj2, relation_property, 0);
                } else {
                    rfalse;
                }
            }
        }
    }
    if ((t1 ~= t2)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
                    } else {
                        rfalse;
                    }
                }
            }
        } else {
            for ((obj1 = 1):(obj1 <= N2):(obj1)++) {
                (obj2 = GProperty(t1, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        WriteGProperty(t1, obj1, relation_property, 0);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyEquiv relation sym clear relation_property obj1 obj2 t N v;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if (clear) {
        (v = 1);
        if ((t == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (v)++));
            }
        } else {
            for ((obj1 = 1):(obj1 <= N):(obj1)++) {
                WriteGProperty(t, obj1, relation_property, (v)++);
            }
        }
        rtrue;
    }
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                if ((((obj1 < obj2)) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == _final_propertyvalue(OBJECT_TY, obj2, relation_property))))) {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            for ((obj2 = (obj1 + 1)):(obj1 <= N):(obj1)++) {
                if ((GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))) {
                    rfalse;
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ RelationRouteTo relation from to count handler;
    if (count) {
        if ((from == 0)) {
            return (-(1));
        }
        if ((to == 0)) {
            return (-(1));
        }
        if ((relation == 0)) {
            return (-(1));
        }
    } else {
        if ((from == 0)) {
            rfalse;
        }
        if ((to == 0)) {
            rfalse;
        }
        if ((relation == 0)) {
            rfalse;
        }
    }
    if ((from == to)) {
        rfalse;
    }
    if ((((RlnGetF(relation, RR_PERMISSIONS))&(RELS_ROUTE_FIND)) == 0)) {
        RunTimeProblem(RTP_ROUTELESS);
        rfalse;
    }
    if ((RlnGetF(relation, RR_STORAGE) == 0)) {
        rfalse;
    }
    (handler = RlnGetF(relation, RR_HANDLER));
    if (count) {
        return (handler)(relation,RELS_ROUTE_FIND_COUNT,from,to);
    }
    return (handler)(relation,RELS_ROUTE_FIND,from,to);
];
[ RelFollowVector rv from to obj i;
    if ((rv == 0)) {
        return (-(1));
    }
    (i = 0);
    (obj = from);
    while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
        (i)++;
        (obj = (obj.vector));
    }
    return i;
];
[ OtoVRelRouteTo relation_property from to previous;
    while (((((to) && ((_final_propertyexists(OBJECT_TY, to, relation_property))))) && (_final_propertyvalue(OBJECT_TY, to, relation_property)))) {
        (previous = _final_propertyvalue(OBJECT_TY, to, relation_property));
        ((previous.vector) = to);
        if ((previous == from)) {
            return to;
        }
        (to = previous);
    }
    rfalse;
];
[ VtoORelRouteTo relation_property from to next start;
    (start = from);
    while (((((from) && ((_final_propertyexists(OBJECT_TY, from, relation_property))))) && (_final_propertyvalue(OBJECT_TY, from, relation_property)))) {
        (next = _final_propertyvalue(OBJECT_TY, from, relation_property));
        ((from.vector) = next);
        if ((next == to)) {
            return (start.vector);
        }
        (from = next);
    }
    rfalse;
];
[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    if ((vtov_structure-->(VTOVS_CACHE))) {
        return FastVtoVRelRouteTo(relation, from, to, count);
    }
    (left_ix = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_vector))))) {
        ((obj.vector) = 0);
    }
    ((to.vector) = 1);
    while (1) {
        (progressed = 0);
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            if (((obj.vector) == 0)) {
                objectloop (obj2 ofclass Object && (((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) && (((obj2.vector) > 0)))) {
                    if (Relation_TestVtoV(obj, relation, obj2)) {
                        ((obj.vector) = ((obj2)|(WORD_HIGHBIT)));
                        (progressed = 1);
                        continue;
                    }
                }
            }
        }
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            ((obj.vector) = (((obj.vector))&((~(WORD_HIGHBIT)))));
        }
        if ((from.vector)) {
            break;
        }
        if ((progressed == 0)) {
            break;
        }
    }
    if (count) {
        if (((from.vector) == 0)) {
            return (-(1));
        }
        (i = 0);
        (obj = from);
        while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
            (i)++;
            (obj = (obj.vector));
        }
        return i;
    }
    return (from.vector);
];
[ FastVtoVRelRouteTo relation from to count domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
    (domainsize = (RlnGetF(relation, RR_STORAGE)-->(2)));
    (left_ix = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_LEFT_INDEX_PROP)));
    if ((((_final_propertyexists(OBJECT_TY, from, left_ix))) && ((_final_propertyexists(OBJECT_TY, to, left_ix))))) {
        if ((domainsize < 256)) {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + (domainsize*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 1);
                            ((cache2->(offset)) = _final_propertyvalue(OBJECT_TY, ox, left_ix));
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 0);
                            ((cache2->(offset)) = 255);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache->(offset)) = (axy + ayj));
                                        ((cache2->(offset)) = (cache2->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            (oy = (cache2->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
            if ((oy < 255)) {
                objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                    if ((_final_propertyvalue(OBJECT_TY, ox, left_ix) == oy)) {
                        return ox;
                    }
                }
            }
            rfalse;
        } else {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + ((WORDSIZE*domainsize)*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 1);
                            ((cache2-->(offset)) = ox);
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 0);
                            ((cache2-->(offset)) = 0);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache-->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache-->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache-->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache-->(offset)) = (axy + ayj));
                                        ((cache2-->(offset)) = (cache2-->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            return (cache2-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix))));
        }
    }
    if (count) {
        return (-(1));
    }
    rfalse;
];
[ RunTimeProblem n par1 par2 par3 ln file;
    if (((RTP_Buffer-->(0)) == -1)) {
        ((RTP_Buffer-->(0)) = n);
        ((RTP_Buffer-->(1)) = par1);
        ((RTP_Buffer-->(2)) = par2);
        ((RTP_Buffer-->(3)) = par3);
        ((RTP_Buffer-->(4)) = ln);
        ((RTP_Buffer-->(5)) = file);
    }
    RunTimeProblemShow();
];
[ ClearRTP;
    ((RTP_Buffer-->(0)) = -1);
    ((RTP_Buffer-->(6)) = 0);
];
[ SuspendRTP;
    ((RTP_Buffer-->(6)) = 1);
];
[ ResumeRTP;
    ((RTP_Buffer-->(6)) = 0);
];
[ RunTimeProblemShow n par1 par2 par3 ln file i c;
    if (((RTP_Buffer-->(0)) == -1 or -2)) {
        rtrue;
    }
    if ((RTP_Buffer-->(6))) {
        rtrue;
    }
    (n = (RTP_Buffer-->(0)));
    (par1 = (RTP_Buffer-->(1)));
    (par2 = (RTP_Buffer-->(2)));
    (par3 = (RTP_Buffer-->(3)));
    (ln = (RTP_Buffer-->(4)));
    (file = (RTP_Buffer-->(5)));
    ((RTP_Buffer-->(0)) = -2);
    print "^";
    print "*** Run-time problem P";
    print n;
    if (ln) {
        print " (at paragraph ";
        print ln;
        print " in ";
        if ((file == 0)) {
            print "the source text";
        } else {
            ShowOneExtension(file);
        }
        print ")";
    }
    print ": ";
    switch (n) {
        RTP_IMPREL:
            print "Tried to access an inappropriate relation for ";
            DefArt(par1);
            print ", violating '";
            print (string) RlnGetF(par2, RR_DESCRIPTION);
            print "'.^";
            ;
        RTP_TOOMANYRULEBOOKS:
            print "Too many rulebooks in simultaneous use.^";
            ;
        RTP_BADPROPERTY:
            print "Tried to access non-existent property for ";
            DefArt(par1);
            print ".^";
            ;
        RTP_UNPROVIDED:
            print "Since ";
            DefArt(par1);
            print " is not allowed the property ~";
            PrintPropertyName(par2);
            print "~, it is against the rules to try to use it.^";
            ;
        RTP_UNSET:
            print "Although ";
            DefArt(par1);
            print " is allowed to have the property ~";
            PrintPropertyName(par2);
            print "~, no value was ever given, so it can't now be used.^";
            ;
        RTP_TOOMANYACTS:
            print "Too many activities are going on at once.^";
            ;
        RTP_CANTABANDON:
            print "Tried to abandon an activity which wasn't going on.^";
            ;
        RTP_CANTEND:
            print "Tried to end an activity which wasn't going on.^";
            ;
        RTP_DIVZERO:
            print "You can't divide by zero.^";
            ;
        RTP_BADVALUEPROPERTY:
            print "Tried to access property for a value which didn't fit: ";
            print "if this were a number it would be ";
            print par1;
            print ".^";
            ;
        RTP_TABLE_NOCOL:
            print "Attempt to look up a non-existent column in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOCORR:
            print "Attempt to look up a non-existent correspondence in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROW:
            print "Attempt to look up a non-existent row in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOENTRY:
            print "Attempt to look up a non-existent entry at column ";
            print par2;
            print ", row ";
            print par3;
            print " of the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOTABLE:
            print "Attempt to blank out a row from a non-existent table (value ";
            print par1;
            print ").^";
            ;
        RTP_TABLE_NOTABLE2:
            print "Attempt to access an entry from a non-existent table.^";
            ;
        RTP_TABLE_NOMOREBLANKS:
            print "Attempt to choose a blank row in a table with none left: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROWS:
            print "Attempt to choose a random row in an entirely blank table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTRUNTHROUGH:
            print "Attempt to repeat through a table in a tricky column order: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSORT:
            print "Attempt to sort a table whose ordering must remain fixed: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSAVE:
            print "Attempt to save a table to a file whose data is unstable: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_WONTFIT:
            print "File being read has too many rows or columns to fit into table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_BADFILE:
            print "File being read is not a previously saved table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_ROUTELESS:
            print "Attempt to find route or count steps through an implicit relation.^";
            ;
        RTP_PROPOFNOTHING:
            print "Attempt to use a property of the 'nothing' non-object: property ";
            PrintPropertyName(par2);
            print "^";
            ;
        RTP_DECIDEONWRONGKIND:
            print "Attempt to 'decide on V' where V is the wrong kind of object.^";
            ;
        RTP_DECIDEONNOTHING:
            print "Attempt to 'decide on nothing'.^";
            ;
        RTP_LOWLEVELERROR:
            print "Low level error.^";
            ;
        RTP_LISTWRITERMEMORY:
            print "The list-writer has run out of memory.^";
            ;
        RTP_MSTACKMEMORY:
            print "The memory stack is exhausted.^";
            ;
        RTP_TYPECHECK:
            print "Phrase applied to an incompatible kind of value.^";
            ;
        RTP_FILEIOERROR:
            print "Error handling external file.^";
            ;
        RTP_HEAPERROR:
            print "Memory allocation proved impossible.^";
            ;
        RTP_LISTRANGEERROR:
            print "Attempt to use list item which does not exist.^";
            ;
        RTP_LISTSIZENEGATIVE:
            print "Attempt to resize list to ";
            print par1;
            print " entries - there must ";
            print "always be 0 or more.^";
            ;
        RTP_REGEXPSYNTAXERROR:
            print "Syntax error in regular expression.^";
            ;
        RTP_NOGLULXUNICODE:
            print "This interpreter does not support Unicode.^";
            ;
        RTP_NEGATIVEROOT:
            print "You can't take the square root of a negative number.^";
            ;
        RTP_CANTITERATE:
            print "You can't implicitly repeat through the values of this kind: ";
            print "a problem arising from a description which started out here - ~";
            print (string) par1;
            print "~.^";
            ;
        RTP_WRONGASSIGNEDKIND:
            print "Attempt to set a variable to the wrong kind of object: ";
            print "you wrote '";
            print (string) par2;
            print "', which sets the value to ";
            DefArt(par1);
            print " - but that doesn't have the kind '";
            print (string) par3;
            print "'.^";
            ;
        RTP_RELKINDVIOLATION:
            print "Tried to change a relation for objects with the wrong kinds: ";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print ", but you tried to ";
            print "relate (or unrelate) ";
            DefArt(par1);
            print " to ";
            DefArt(par2);
            print ".^";
            ;
        RTP_TEXTTOKENTOOHARD:
            print "This use of '[text]' is too complicated.^";
            ;
        RTP_RELATIONCHANGEIMPOSSIBLE:
            print "This change of the relation's nature is impossible in play.^";
            ;
        RTP_RELMINIMAL:
            print "This operation can't be done with the relation '";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print "'.^";
            ;
    }
    RunTimeProblemShowWM(n, par1, par2, par3);
    print "^";
];
[ RunTimeError n p1 p2;
    print "** Library error ";
    print n;
    print " (";
    print p1;
    print ",";
    print p2;
    print ") **^** ";
    switch (n) {
        1:
            print "preposition not found (this should not occur)";
            ;
        2:
            print "Property value not routine or string: ~";
            DebugProperty(p2);
            print "~ of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        3:
            print "Entry in property list not routine or string: ~";
            DebugProperty(p2);
            print "~ list of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        4:
            print "Too many timers/daemons are active simultaneously. The limit is the library constant MAX_TIMERS (currently ";
            print MAX_TIMERS;
            print ") and should be increased";
            ;
        5:
            print "Object ~";
            PrintShortName(p1);
            print "~ has no ~time_left~ property";
            ;
        7:
            print "The object ~";
            PrintShortName(p1);
            print "~ can only be used as a player object if it has the ~number~ property";
            ;
        8:
            print "Attempt to take random entry from an empty table array";
            ;
        9:
            print p1;
            print " is not a valid direction property number";
            ;
        10:
            print "The player-object is outside the object tree";
            ;
        11:
            print "The room ~";
            PrintShortName(p1);
            print "~ has no ~description~ property";
            ;
        12:
            print "Tried to set a non-existent pronoun using SetPronoun";
            ;
        13:
            print "A 'topic' token can only be followed by a preposition";
            ;
        default:
            print "(unexplained)";
            ;
    }
    print " **^";
    RunTimeProblem(RTP_LOWLEVELERROR);
];
[ ArgumentTypeFailed line file;
    RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];
[ CheckKindReturned V K;
    if ((V ofclass K)) {
        return V;
    }
    if ((V == 0)) {
        RunTimeProblem(RTP_DECIDEONNOTHING);
    } else {
        RunTimeProblem(RTP_DECIDEONWRONGKIND);
    }
    return V;
];
[ ProvidesProperty K obj q issue_rtp a l holder;
    if ((K == OBJECT_TY)) {
        if (ScanPropertyMetadata(obj, q, 4)) {
            jump PermissionFound;
        }
        if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
            (l = (obj.KD_Count));
            while ((l > 0)) {
                (a = (l*2));
                if (ScanPropertyMetadata((KindHierarchy-->(a)), q, 4)) {
                    jump PermissionFound;
                }
                (l = (KindHierarchy-->((a + 1))));
            }
        }
        if (ScanPropertyMetadata(K0_kind, q, 4)) {
            jump PermissionFound;
        }
        if (issue_rtp) {
            RunTimeProblem(RTP_UNPROVIDED, obj, q);
        }
        rfalse;
    }
    .PermissionFound;
    if ((_final_propertyexists(K, obj, q))) {
        rtrue;
    }
    if (issue_rtp) {
        RunTimeProblem(RTP_UNSET, obj, q);
    }
    rfalse;
];
[ PrintPropertyName p textual;
    if ((p < 0)) {
        (p = (~(p)));
    }
    (textual = (p-->(3)));
    print (string) textual;
];
[ ScanPropertyMetadata obj property_metadata off i;
    for ((i = off):((property_metadata-->(i)) >= 0):(i)++) {
        if ((obj == (property_metadata-->(i)))) {
            rtrue;
        }
    }
    rfalse;
];
[ GProperty K V pr err holder val;
    if (ProvidesProperty(K, V, pr, (1 - err))) {
        return _final_propertyvalue(K, V, pr);
    }
    rfalse;
];
[ WriteGProperty K V pr val holder;
    if (ProvidesProperty(K, V, pr, 1)) {
        (_final_store_property(K,V,pr, val));
    }
];
[ PROPERTY_TY_Say v;
    print "property ";
    print v;
];
[ LanguageTimeOfDay hours mins i;
    (i = (hours%12));
    if ((i == 0)) {
        (i = 12);
    }
    if ((i < 10)) {
        print " ";
    }
    print i;
    print ":";
    print (mins/10);
    print (mins%10);
    if (((hours/12) > 0)) {
        print " pm";
    } else {
        print " am";
    }
];
[ LanguageDirection d;
    PrintShortName(d);
];
[ LanguageToInformese;
];
[ LanguageContraction text;
    if (((text->(0)) == 97 or 101 or 105 or 111 or 117 or 65 or 69 or 73 or 79 or 85)) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerb i;
    switch (i) {
        'i//', 'inv', 'inventory':
            print "take inventory";
            ;
        'l//':
            print "look";
            ;
        'x//':
            print "examine";
            ;
        'z//':
            print "wait";
            ;
        default:
            rfalse;
            ;
    }
    rtrue;
];
[ LanguageVerbLikesAdverb w;
    if ((w == 'look' or 'go' or 'push' or 'walk')) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerbMayBeName w;
    if ((w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')) {
        rtrue;
    }
    rfalse;
];
[ LanguageIsVerb buffer parse verb_wordnum;
    rfalse;
];
[ ParserError error_type;
    if (error_type) {
        PrintSingleParagraph(error_type);
    }
    rfalse;
];
[ UnknownVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        (verb_wordnum = 0);
        return 'no.verb';
    }
    rfalse;
];
[ PrintVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        if ((v == 'no.verb')) {
            print "do something to";
            rtrue;
        }
    }
    rfalse;
];
[ GlkListSub id val;
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        print "Window ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print "): ";
        (val = glk_window_get_type(id));
        switch (val) {
            1:
                print "pair";
                ;
            2:
                print "blank";
                ;
            3:
                print "textbuffer";
                ;
            4:
                print "textgrid";
                ;
            5:
                print "graphics";
                ;
            default:
                print "unknown";
                ;
        }
        (val = glk_window_get_parent(id));
        if (val) {
            print ", parent is window ";
            print val;
        } else {
            print ", no parent (root)";
        }
        (val = glk_window_get_stream(id));
        print ", stream ";
        print val;
        (val = glk_window_get_echo_stream(id));
        if (val) {
            print ", echo stream ";
            print val;
        }
        print "^";
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        print "Stream ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print ")^";
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        print "Fileref ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print ")^";
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            print "Soundchannel ";
            print id;
            print " (";
            print (gg_arguments-->(0));
            print ")^";
            (id = glk_schannel_iterate(id, gg_arguments));
        }
    }
];
[ VM_Undo result_code;
    @restoreundo result_code;
    return (~~(result_code));
];
[ VM_Save_Undo result_code;
    @saveundo result_code;
    if ((result_code == -1)) {
        GGRecoverObjects();
        return 2;
    }
    return (~~(result_code));
];
[ QUIT_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    QUIT_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        quit;
    }
];
[ RESTART_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    RESTART_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        @restart;
        RESTART_THE_GAME_RM(66);
        print "^";
    }
];
[ RESTORE_THE_GAME_R res fref;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(1, 2, 0));
    if ((fref == 0)) {
        jump RFailed;
    }
    (gg_savestr = glk_stream_open_file(fref, 2, GG_SAVESTR_ROCK));
    glk_fileref_destroy(fref);
    if ((gg_savestr == 0)) {
        jump RFailed;
    }
    @restore gg_savestr res;
    glk_stream_close(gg_savestr, 0);
    (gg_savestr = 0);
    .RFailed;
    RESTORE_THE_GAME_RM(65);
    print "^";
];
[ SAVE_THE_GAME_R fref len res;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(fileusage_SavedGame, filemode_Write, 0));
    if (fref) {
        (gg_savestr = glk_stream_open_file(fref, filemode_Write, GG_SAVESTR_ROCK));
        if (gg_savestr) {
            @save gg_savestr res;
            if ((res == -1)) {
                GGRecoverObjects();
                glk_stream_close(gg_savestr, GLK_NULL);
                (gg_savestr = 0);
                RESTORE_THE_GAME_RM(66);
                print "^";
                rtrue;
            }
            glk_stream_close(gg_savestr, GLK_NULL);
            (gg_savestr = 0);
            if ((res == 0)) {
                if (glk_fileref_does_file_exist(fref)) {
                    (gg_savestr = glk_stream_open_file(fref, filemode_Read, GG_SAVESTR_ROCK));
                    if (gg_savestr) {
                        glk_stream_set_position(gg_savestr, 0, seekmode_End);
                        (len = glk_stream_get_position(gg_savestr));
                        glk_stream_close(gg_savestr, GLK_NULL);
                        (gg_savestr = 0);
                        if (len) {
                            SAVE_THE_GAME_RM(66);
                            print "^";
                            glk_fileref_destroy(fref);
                            rtrue;
                        }
                        glk_fileref_delete_file(fref);
                    }
                }
            }
        }
        glk_fileref_destroy(fref);
    }
    SAVE_THE_GAME_RM(65);
    print "^";
];
[ VERIFY_THE_STORY_FILE_R res;
    if ((actor ~= player)) {
        rfalse;
    }
    @verify res;
    if ((res == 0)) {
        VERIFY_THE_STORY_FILE_RM(65);
        print "^";
        rtrue;
    }
    VERIFY_THE_STORY_FILE_RM(66);
    print "^";
];
[ SWITCH_TRANSCRIPT_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr ~= 0)) {
        SWITCH_TRANSCRIPT_ON_RM(65);
        print "^";
        rtrue;
    }
    .S2Failed;
    if ((gg_scriptfref == 0)) {
        (gg_scriptfref = glk_fileref_create_by_prompt(258, 5, GG_SCRIPTFREF_ROCK));
        if ((gg_scriptfref == 0)) {
            jump S1Failed;
        }
    }
    (gg_scriptstr = glk_stream_open_file(gg_scriptfref, 5, GG_SCRIPTSTR_ROCK));
    if ((gg_scriptstr == 0)) {
        glk_fileref_destroy(gg_scriptfref);
        (gg_scriptfref = 0);
        jump S2Failed;
    }
    glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
    SWITCH_TRANSCRIPT_ON_RM(66);
    print "^";
    VersionSub();
    rtrue;
    .S1Failed;
    SWITCH_TRANSCRIPT_ON_RM(67);
    print "^";
];
[ SWITCH_TRANSCRIPT_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr == 0)) {
        SWITCH_TRANSCRIPT_OFF_RM(65);
        print "^";
        rtrue;
    }
    SWITCH_TRANSCRIPT_OFF_RM(66);
    print "^";
    glk_stream_close(gg_scriptstr, 0);
    (gg_scriptstr = 0);
];
[ ANNOUNCE_STORY_FILE_VERSION_R ix;
    if ((actor ~= player)) {
        rfalse;
    }
    Banner();
    print "Inform 7 v";
    PrintI6Text(I7_FULL_VERSION_NUMBER);
    print "^";
    if (((UUID_ARRAY->(0)) >= 6)) {
        print "Identification number: ";
        for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
            print (char) (UUID_ARRAY->(ix));
        }
        print "^";
    }
    @gestalt 1 0 ix;
    print "Interpreter version ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print " / ";
    @gestalt 0 0 ix;
    print "VM ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print "^";
    ShowExtensionVersions();
    (say__p = 1);
];
[ DESCEND_TO_SPECIFIC_ACTION_R;
    ((#actions_table-->((action + 1))))();
    rtrue;
];
[ OffersLight obj j;
    while (obj) {
        if ((obj has light)) {
            rtrue;
        }
        objectloop (j in obj) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
        if ((((((obj has container)) && ((~~((obj has open)))))) && ((~~((obj has transparent)))))) {
            rfalse;
        }
        if ((((_final_propertyexists(OBJECT_TY, obj, A_component_parent))) && ((obj.component_parent)))) {
            (obj = (obj.component_parent));
        } else {
            (obj = parent(obj));
        }
    }
    rfalse;
];
[ HasLightSource i j ad sr po;
    if ((i == 0)) {
        rfalse;
    }
    if ((i has light)) {
        rtrue;
    }
    if (((IsSeeThrough(i)) && ((~~(HidesLightSource(i)))))) {
        objectloop (j in i) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, i, A_add_to_scope)));
    if ((((parent(i) ~= 0)) && ((ad ~= 0)))) {
        if ((metaclass((ad-->(0))) == Routine)) {
            (ats_hls = 0);
            (ats_flag = 1);
            (sr = scope_reason);
            (po = parser_one);
            (scope_reason = LOOPOVERSCOPE_REASON);
            (parser_one = 0);
            RunRoutines(i, A_add_to_scope);
            (scope_reason = sr);
            (parser_one = po);
            (ats_flag = 0);
            if ((ats_hls == 1)) {
                rtrue;
            }
        } else {
            for ((j = 0):((WORDSIZE*j) < (_final_propertylength(OBJECT_TY, i, A_add_to_scope))):(j)++) {
                if ((((ad-->(j))) && ((HasLightSource((ad-->(j))) == 1)))) {
                    rtrue;
                }
            }
        }
    }
    if (ComponentHasLight(i)) {
        rtrue;
    }
    rfalse;
];
[ ComponentHasLight o obj next_obj;
    if ((_final_propertyexists(OBJECT_TY, o, A_component_child))) {
        (obj = (o.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((obj has light)) {
                rtrue;
            }
            if (HasLightSource(obj)) {
                rtrue;
            }
            if ((((_final_propertyexists(OBJECT_TY, obj, A_component_child))) && (ComponentHasLight(obj)))) {
                rtrue;
            }
            (obj = next_obj);
        }
    }
    rfalse;
];
[ HidesLightSource obj;
    if ((obj == player)) {
        rfalse;
    }
    if (((or_tmp_var = obj) && (((or_tmp_var has transparent)) || ((or_tmp_var has supporter))))) {
        rfalse;
    }
    if ((obj has animate)) {
        rfalse;
    }
    if ((obj has container)) {
        return (~~((obj has open)));
    }
    return (~~((obj has enterable)));
];
[ ADJUST_LIGHT_R previous_light_condition;
    (previous_light_condition = lightflag);
    (lightflag = OffersLight(parent(player)));
    if ((((previous_light_condition == 0)) && ((lightflag == 0)))) {
        (location = thedark);
        rfalse;
    }
    if ((((previous_light_condition == 0)) && ((lightflag == 1)))) {
        (location = real_location);
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 0)))) {
        (location = thedark);
        DivideParagraphPoint();
        BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        if ((ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == 0)) {
            ADJUST_LIGHT_RM(65);
            print "^";
        }
        EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 1)))) {
        (location = real_location);
        rfalse;
    }
    rfalse;
];
[ SilentlyConsiderLight;
    (lightflag = OffersLight(parent(player)));
    if (lightflag) {
        (location = real_location);
    } else {
        (location = thedark);
    }
    rfalse;
];
[ IsSeeThrough obj;
    if ((((((((obj has supporter)) || ((obj has transparent)))) || ((obj has animate)))) || ((((obj has container)) && ((obj has open)))))) {
        rtrue;
    }
    rfalse;
];
[ VisibilityParent o;
    if (((((((o) && ((o has container)))) && ((~~((o has open)))))) && ((~~((o has transparent)))))) {
        rfalse;
    }
    if (o) {
        (o = CoreOfParentOfCoreOf(o));
    }
    return o;
];
[ FindVisibilityLevels lc up;
    if ((location == thedark)) {
        (visibility_ceiling = thedark);
        (visibility_levels = 0);
    } else {
        (visibility_ceiling = player);
        while (1) {
            (up = VisibilityParent(visibility_ceiling));
            if ((up == 0)) {
                break;
            }
            (visibility_ceiling = up);
            (lc)++;
        }
        (visibility_levels = lc);
    }
];
[ TouchabilityCeiling original o p;
    (o = original);
    while (o) {
        (p = CoreOfParentOfCoreOf(o));
        if ((p ofclass K1_room)) {
            return p;
        }
        if ((p == 0)) {
            return o;
        }
        if (((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))) {
            return p;
        }
        (o = p);
    }
    return o;
];
[ ScopeCeiling pos c;
    if ((((pos == player)) && ((location == thedark)))) {
        return thedark;
    }
    (c = parent(pos));
    if ((c == 0)) {
        return pos;
    }
    while (VisibilityParent(c)) {
        (c = VisibilityParent(c));
    }
    return c;
];
[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
    if ((LocationOf(p) ~= real_location)) {
        for ((x = CoreOf(item)):x:(x = CoreOfParentOfCoreOf(x))) {
            if ((x ofclass K4_door or K7_backdrop)) {
                (moving = 1);
                MoveFloatingObjects(LocationOf(p));
                break;
            }
        }
    }
    (untouchable_object = item);
    (untouchable_silence = silent_flag);
    (touch_persona = p);
    if ((p == actor)) {
        (touch_persona = 0);
    }
    (save_sp = say__p);
    (say__p = 0);
    @push actor;
    (actor = p);
    if (FollowRulebook(ACCESSIBILITY_RB, 0, 1)) {
        if (RulebookSucceeded()) {
            (decision = 0);
        } else {
            (decision = 1);
        }
    } else {
        (decision = 0);
    }
    @pull actor;
    if ((say__p == 0)) {
        (say__p = save_sp);
    }
    if (moving) {
        MoveFloatingObjects();
    }
    (untouchable_silence = 0);
    return decision;
];
[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
    (p = touch_persona);
    if ((p == 0)) {
        (p = actor);
    }
    (ancestor = CommonAncestor(p, untouchable_object));
    if ((((((ancestor == 0)) && ((LocationOf(untouchable_object) == 0)))) && (((untouchable_object ofclass K4_door or K7_backdrop) == 0)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                ACCESS_THROUGH_BARRIERS_RM(65, untouchable_object);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    if ((CoreOf(p) ~= ancestor)) {
        (i = parent(CoreOf(p)));
        (j = CoreOf(i));
        (external = 0);
        if ((j ~= i)) {
            (i = j);
            (external = 1);
        }
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_OUTSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = parent(CoreOf(i)));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    if ((CoreOf(untouchable_object) ~= ancestor)) {
        (i = CoreOf(untouchable_object));
        (i = parent(i));
        (external = 0);
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_INSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = CoreOf(i));
            if ((i == ancestor)) {
                break;
            }
            (i = parent(i));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    RulebookSucceeds();
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_OUTSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_OUTSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_INSIDE_ROOMS_R;
    if (((parameter_value) && ((parameter_value ofclass K1_room)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_ROOMS_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ RequisitionStack len top addr;
    (top = (requisition_stack_pointer + len));
    if ((top > REQUISITION_STACK_SIZE)) {
        rfalse;
    }
    (addr = (requisition_stack + (requisition_stack_pointer*WORDSIZE)));
    (requisition_stack_pointer = top);
    return addr;
];
[ FreeStack addr;
    if ((addr == 0)) {
        rtrue;
    }
    (requisition_stack_pointer = ((addr - requisition_stack)/WORDSIZE));
];
[ WriteListOfMarkedObjects in_style obj common_parent first mixed_parentage length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        if ((first == 0)) {
            (first = obj);
            (common_parent = parent(obj));
        } else {
            if ((parent(obj) ~= common_parent)) {
                (mixed_parentage = 1);
            }
        }
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    if (mixed_parentage) {
        (common_parent = 0);
    }
    if ((length == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            if ((((in_style)&(CFIRSTART_BIT)) ~= 0)) {
                LIST_WRITER_INTERNAL_RM(88);
            } else {
                LIST_WRITER_INTERNAL_RM(89);
            }
        }
    } else {
        @push MarkedObjectArray;
        @push MarkedObjectLength;
        (MarkedObjectArray = RequisitionStack(length));
        (MarkedObjectLength = length);
        if ((MarkedObjectArray == 0)) {
            return RunTimeProblem(RTP_LISTWRITERMEMORY);
        }
        if (common_parent) {
            ObjectTreeCoalesce(child(common_parent));
            (length = 0);
            objectloop (obj in common_parent) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        } else {
            (length = 0);
            objectloop (obj ofclass Object && (obj ofclass Object)) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        }
        WriteListFrom(first, in_style, 0, 0, MarkedListIterator);
        FreeStack(MarkedObjectArray);
        @pull MarkedObjectLength;
        @pull MarkedObjectArray;
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    rtrue;
];
[ RegardingMarkedObjects obj length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
            (prior_named_noun = obj);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    if ((length == 0)) {
        (prior_named_noun = 0);
        (prior_named_list_gender = -1);
    }
    rtrue;
];
[ PNToVP gna;
    if ((prior_named_noun == player)) {
        return story_viewpoint;
    }
    if (prior_named_noun) {
        (gna = GetGNAOfObject(prior_named_noun));
    }
    if ((((((gna%6)/3) == 1)) || ((prior_named_list >= 2)))) {
        return 6;
    }
    return 3;
];
[ SetLWI a b c;
    ((LWI_Storage-->(0)) = a);
    ((LWI_Storage-->(1)) = b);
    ((LWI_Storage-->(2)) = c);
];
[ RegardingLWI;
    (prior_named_list = (LWI_Storage-->(0)));
    (prior_named_list_gender = (LWI_Storage-->(1)));
    (prior_named_noun = (LWI_Storage-->(2)));
];
[ ResponseViaActivity R;
    @push prior_named_noun;
    @push prior_named_list;
    @push prior_named_list_gender;
    RegardingSingleObject(0);
    CarryOutActivity(PRINTING_RESPONSE_ACT, R);
    @pull prior_named_list_gender;
    @pull prior_named_list;
    @pull prior_named_noun;
];
[ MarkedListIterator obj depth required_lt function i;
    if ((obj == 0)) {
        rfalse;
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    switch (function) {
        START_ITF:
            return (MarkedObjectArray-->(0));
            ;
        COALESCE_ITF:
            return MarkedListCoalesce();
            ;
        SEEK_ITF, ADVANCE_ITF:
            for ((i = 0):(i < MarkedObjectLength):(i)++) {
                if (((MarkedObjectArray-->(i)) == obj)) {
                    if ((function == ADVANCE_ITF)) {
                        (i)++;
                    }
                    for (:(i < MarkedObjectLength):(i)++) {
                        (obj = (MarkedObjectArray-->(i)));
                        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
                            continue;
                        }
                        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
                            continue;
                        }
                        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
                            continue;
                        }
                        return obj;
                    }
                    rfalse;
                }
            }
            ;
    }
    rfalse;
];
[ ConcealedFromLists obj c;
    if ((((obj has concealed)) || ((obj has scenery)))) {
        rtrue;
    }
    (c = parent(obj));
    if (((((c) && ((c ofclass K5_container or K6_supporter)))) && (TestConcealment(c, obj)))) {
        rtrue;
    }
    rfalse;
];
[ MarkedListCoalesce o i lt l swap m;
    for ((i = 0):(i < MarkedObjectLength):(i)++) {
        (lt = ((MarkedObjectArray-->(i)).list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)) {
            for ((i)++:(((i < MarkedObjectLength)) && ((LT_Compare(((MarkedObjectArray-->(i)).list_together), lt) == 0))):(i)++) {
            }
            if ((i == MarkedObjectLength)) {
                return (MarkedObjectArray-->(0));
            }
            for ((l = (i + 1)):(l < MarkedObjectLength):(l)++) {
                if ((LT_Compare(((MarkedObjectArray-->(l)).list_together), lt) == 0)) {
                    (swap = (MarkedObjectArray-->(l)));
                    for ((m = l):(m > i):(m)--) {
                        ((MarkedObjectArray-->(m)) = (MarkedObjectArray-->((m - 1))));
                    }
                    ((MarkedObjectArray-->(i)) = swap);
                    (i)++;
                    if ((i == MarkedObjectLength)) {
                        return (MarkedObjectArray-->(0));
                    }
                }
            }
            (i)--;
        }
    }
    return (MarkedObjectArray-->(0));
];
[ ObjectTreeIterator obj depth required_lt function;
    if ((((obj == 0)) || ((parent(obj) == 0)))) {
        rfalse;
    }
    if ((function == START_ITF)) {
        (obj = child(parent(obj)));
    }
    if ((function == COALESCE_ITF)) {
        return ObjectTreeCoalesce(obj);
    }
    if ((function == ADVANCE_ITF)) {
        (obj = sibling(obj));
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    for (:1:(obj = sibling(obj))) {
        if ((obj == 0)) {
            rfalse;
        }
        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
            continue;
        }
        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
            continue;
        }
        if ((~~(_final_propertyvalue(OBJECT_TY, obj, list_filter_permits)))) {
            continue;
        }
        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
            continue;
        }
        return obj;
    }
];
[ ObjectTreeCoalesce obj memb lt later;
    .StartAgain;
    (memb = obj);
    while ((memb ~= 0)) {
        (lt = (memb.list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) == 0)) {
            (memb = sibling(memb));
            continue;
        }
        for ((memb = sibling(memb)):((memb) && ((LT_Compare((memb.list_together), lt) == 0))):(memb = sibling(memb))) {
        }
        if ((memb == 0)) {
            return obj;
        }
        for ((later = sibling(memb)):later:(later = sibling(later))) {
            if ((LT_Compare((later.list_together), lt) == 0)) {
                (obj = GroupChildren(parent(obj), lt));
                jump StartAgain;
            }
        }
    }
    return obj;
];
[ GroupChildren par value;
    while ((child(par) ~= 0)) {
        if ((LT_Compare((child(par).list_together), value) ~= 0)) {
            move child(par) to out_obj;
        } else {
            move child(par) to in_obj;
        }
    }
    while ((child(in_obj) ~= 0)) {
        move child(in_obj) to par;
    }
    while ((child(out_obj) ~= 0)) {
        move child(out_obj) to par;
    }
    return child(par);
];
[ WriteListFrom first in_style depth noactivity iter a ol;
    @push c_iterator;
    @push c_style;
    @push c_depth;
    @push c_margin;
    if (iter) {
        (c_iterator = iter);
    } else {
        (c_iterator = ObjectTreeIterator);
    }
    (c_style = in_style);
    (c_depth = depth);
    (c_margin = 0);
    if (((in_style)&(EXTRAINDENT_BIT))) {
        (c_margin = 1);
    }
    objectloop (a ofclass Object && (a ofclass Object)) {
        (_final_store_property(OBJECT_TY,a,list_filter_permits, 1));
        if (((list_filter_routine) && (((list_filter_routine)(a) == 0)))) {
            (_final_store_property(OBJECT_TY,a,list_filter_permits, 0));
        }
    }
    (first = (c_iterator)(first,depth,0,START_ITF));
    if ((first == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            LIST_WRITER_INTERNAL_RM(89);
        }
        if ((((in_style)&(NEWLINE_BIT)) ~= 0)) {
            print "^";
        }
    } else {
        if (((noactivity) || (iter))) {
            WriteListR(first, c_depth, 1);
            (say__p = 1);
        } else {
            objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, A_list_together))) {
                BlkValueCopy((ol.list_together), EMPTY_TEXT_VALUE);
            }
            CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
        }
    }
    @pull c_margin;
    @pull c_depth;
    @pull c_style;
    @pull c_iterator;
];
[ STANDARD_CONTENTS_LISTING_R;
    WriteListFrom(child(parameter_value), c_style, c_depth, 1);
];
[ PartitionList first no_objs depth partition_classes partition_class_sizes i k l n m;
    for ((i = 0):(i < no_objs):(i)++) {
        ((partition_classes->(i)) = 0);
    }
    (n = 1);
    for (((i = first),(k = 0)):(k < no_objs):((i = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(k)++)) {
        if (((partition_classes->(k)) == 0)) {
            ((partition_classes->(k)) = n);
            ((partition_class_sizes->(n)) = 1);
            for (((l = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(m = (k + 1))):(((l ~= 0)) && ((m < no_objs))):((l = (c_iterator)(l,depth,lt_value,ADVANCE_ITF)),(m)++)) {
                if (((((partition_classes->(m)) == 0)) && (ListEqual(i, l)))) {
                    if (((partition_class_sizes->(n)) < 255)) {
                        ((partition_class_sizes->(n)))++;
                    }
                    ((partition_classes->(m)) = n);
                }
            }
            if ((n < 255)) {
                (n)++;
            }
        }
    }
    (n)--;
    return n;
];
[ ListEqual o1 o2;
    if (((((o1.plural) == 0)) || (((o2.plural) == 0)))) {
        rfalse;
    }
    if ((((child(o1) ~= 0)) && ((WillRecurs(o1) ~= 0)))) {
        rfalse;
    }
    if ((((child(o2) ~= 0)) && ((WillRecurs(o2) ~= 0)))) {
        rfalse;
    }
    if ((((c_style)&((FULLINV_BIT + PARTINV_BIT))) ~= 0)) {
        if ((((((~~((o1 has worn)))) && ((o2 has worn)))) || ((((~~((o2 has worn)))) && ((o1 has worn)))))) {
            rfalse;
        }
        if ((((((~~((o1 has light)))) && ((o2 has light)))) || ((((~~((o2 has light)))) && ((o1 has light)))))) {
            rfalse;
        }
        if ((o1 has container)) {
            if ((~~((o2 has container)))) {
                rfalse;
            }
            if ((((((o1 has open)) && ((~~((o2 has open)))))) || ((((o2 has open)) && ((~~((o1 has open)))))))) {
                rfalse;
            }
        } else {
            if ((o2 has container)) {
                rfalse;
            }
        }
    }
    return Identical(o1, o2);
];
[ WillRecurs o;
    if ((((c_style)&(ALWAYS_BIT)) ~= 0)) {
        rtrue;
    }
    if ((((c_style)&(RECURSE_BIT)) == 0)) {
        rfalse;
    }
    if ((((o has supporter)) || ((((o has container)) && (((or_tmp_var = o) && (((or_tmp_var has open)) || ((or_tmp_var has transparent))))))))) {
        rtrue;
    }
    rfalse;
];
[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes no_groups cl memb k current_lt lt;
    (current_lt = EMPTY_TEXT_VALUE);
    (lt = EMPTY_TEXT_VALUE);
    (no_groups = no_classes);
    for (((cl = 1),((memb = o),(k = 0))):(cl <= no_classes):(cl)++) {
        while (((partition_classes->(k)) ~= cl)) {
            (k)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
        }
        if (memb) {
            (lt = (memb.list_together));
            if ((((((LT_Compare(lt, lt_value) ~= 0)) && ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)))) && ((LT_Compare(lt, current_lt) == 0)))) {
                (no_groups)--;
            }
            (current_lt = lt);
        }
    }
    return no_groups;
];
[ LT_Compare lt1 lt2;
    if ((lt1 == lt2)) {
        rfalse;
    }
    if ((lt1 == 0)) {
        (lt1 = EMPTY_TEXT_VALUE);
    }
    if ((lt2 == 0)) {
        (lt2 = EMPTY_TEXT_VALUE);
    }
    if ((TEXT_TY_IsSubstituted(lt1) == 0)) {
        if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
            return ((lt1-->(1)) - (lt2-->(1)));
        }
        return (-(1));
    }
    if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
        return (-(1));
    }
    return BlkValueCompare(lt1, lt2);
];
[ WriteListR o depth from_start partition_classes partition_class_sizes cl memb index k2 l m no_classes q groups_to_do current_lt;
    if ((o == 0)) {
        rtrue;
    }
    if (from_start) {
        (o = (c_iterator)(o,depth,0,COALESCE_ITF));
    }
    (o = (c_iterator)(o,depth,0,SEEK_ITF));
    if ((o == 0)) {
        rtrue;
    }
    for (((memb = o),(index = 0)):memb:(memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF))) {
        (index)++;
    }
    if ((((c_style)&(ISARE_BIT)) ~= 0)) {
        SetLWI(index, (-(1)), o);
        LIST_WRITER_INTERNAL_RM(86, o);
        if ((((c_style)&(NEWLINE_BIT)) ~= 0)) {
            print ":^";
        } else {
            print (char) 32;
        }
        (c_style = (c_style - ISARE_BIT));
    }
    (partition_classes = RequisitionStack(((index/WORDSIZE) + 2)));
    (partition_class_sizes = RequisitionStack(((index/WORDSIZE) + 2)));
    if ((((partition_classes == 0)) || ((partition_class_sizes == 0)))) {
        return RunTimeProblem(RTP_LISTWRITERMEMORY);
    }
    (no_classes = PartitionList(o, index, depth, partition_classes, partition_class_sizes));
    (groups_to_do = NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes));
    for (((cl = 1),((memb = o),((index = 0),(current_lt = EMPTY_TEXT_VALUE)))):(groups_to_do > 0):(cl)++) {
        while (((partition_classes->(index)) ~= cl)) {
            (index)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
            if ((memb == 0)) {
                print "*** Error in list-writer ***^";
                rtrue;
            }
        }
        if ((((LT_Compare((memb.list_together), lt_value) == 0)) || ((LT_Compare((memb.list_together), EMPTY_TEXT_VALUE) == 0)))) {
            (current_lt = EMPTY_TEXT_VALUE);
        } else {
            if ((LT_Compare((memb.list_together), current_lt) == 0)) {
                continue;
            }
            @push listing_size;
            (q = memb);
            (listing_size = 1);
            (l = index);
            (m = cl);
            while ((((m < no_classes)) && ((LT_Compare((q.list_together), (memb.list_together)) == 0)))) {
                (m)++;
                while (((partition_classes->(l)) ~= m)) {
                    (l)++;
                    (q = (c_iterator)(q,depth,lt_value,ADVANCE_ITF));
                }
                if ((LT_Compare((q.list_together), (memb.list_together)) == 0)) {
                    (listing_size)++;
                }
            }
            if ((listing_size > 1)) {
                WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
                (current_lt = (memb.list_together));
                jump GroupComplete;
            }
            (current_lt = EMPTY_TEXT_VALUE);
            @pull listing_size;
        }
        WriteSingleClassGroup(cl, memb, depth, (partition_class_sizes->(cl)));
        .GroupComplete;
        (groups_to_do)--;
        if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
            if ((groups_to_do == 1)) {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((cl > 1)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
            if ((groups_to_do > 1)) {
                print ", ";
            }
        }
    }
    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
];
[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
    (q = c_style);
    if ((((c_style)&(INDENT_BIT)) ~= 0)) {
        PrintSpaces((2*(depth + c_margin)));
    }
    BeginActivity(GROUPING_TOGETHER_ACT, memb);
    if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
        (c_style = ((c_style)&((~(NEWLINE_BIT)))));
    } else {
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 1);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            if ((((pv-->(1)))() == 1)) {
                jump Omit__Sublist2;
            }
        } else {
            if (pv) {
                (k2 = 0);
                for ((l = 0):(l < listing_size):(l)++) {
                    (k2 = (k2 + (partition_class_sizes->((l + cl)))));
                }
                EnglishNumber(k2);
                print " ";
                TEXT_TY_Say(pv);
                if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
                    print " (";
                }
                if ((((c_style)&(INDENT_BIT)) ~= 0)) {
                    print ":^";
                }
            }
        }
        (c_margin)++;
        @push lt_value;
        @push listing_together;
        @push listing_size;
        (lt_value = (memb.list_together));
        (listing_together = memb);
        WriteListR(memb, depth, 0);
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        (c_margin)--;
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 2);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            ((pv-->(1)))();
        } else {
            if ((LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0)) {
                if ((((q)&(ENGLISH_BIT)) ~= 0)) {
                    print ")";
                }
            }
        }
        .Omit__Sublist2;
    }
    EndActivity(GROUPING_TOGETHER_ACT, memb);
    if ((((((q)&(NEWLINE_BIT)) ~= 0)) && ((((c_style)&(NEWLINE_BIT)) == 0)))) {
        print "^";
    }
    (c_style = q);
];
[ WriteSingleClassGroup cl memb depth size q;
    (q = c_style);
    if (((c_style)&(INDENT_BIT))) {
        PrintSpaces((2*(depth + c_margin)));
    }
    if ((size == 1)) {
        if ((((c_style)&(NOARTICLE_BIT)) ~= 0)) {
            PrintShortName(memb);
        } else {
            if (((c_style)&(DEFART_BIT))) {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CDefArt(memb);
                } else {
                    DefArt(memb);
                }
            } else {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CIndefArt(memb);
                } else {
                    IndefArt(memb);
                }
            }
        }
    } else {
        if (((c_style)&(DEFART_BIT))) {
            if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                PrefaceByArticle(memb, 0, size);
            } else {
                PrefaceByArticle(memb, 1, size);
            }
        }
        @push listing_size;
        (listing_size = size);
        CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
        @pull listing_size;
    }
    if ((((size > 1)) && ((~~((memb has pluralname)))))) {
        give memb pluralname;
        WriteAfterEntry(memb, depth);
        give memb ~pluralname;
    } else {
        WriteAfterEntry(memb, depth);
    }
    (c_style = q);
];
[ WriteAfterEntry o depth p recurse_flag parenth_flag eldest_child child_count combo;
    (inventory_stage = 2);
    if (((c_style)&(PARTINV_BIT))) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == 0)) {
            (combo = 0);
            if ((((o has light)) && ((~~((location has light)))))) {
                (combo = (combo + 1));
            }
            if ((((o has container)) && ((~~((o has open)))))) {
                (combo = (combo + 2));
            }
            if ((((((o has container)) && ((((o has open)) || ((o has transparent)))))) && ((child(o) == 0)))) {
                (combo = (combo + 4));
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(65);
            }
            switch (combo) {
                1:
                    LIST_WRITER_INTERNAL_RM(68, o);
                    ;
                2:
                    LIST_WRITER_INTERNAL_RM(69, o);
                    ;
                3:
                    LIST_WRITER_INTERNAL_RM(72, o);
                    ;
                4:
                    LIST_WRITER_INTERNAL_RM(70, o);
                    ;
                5:
                    LIST_WRITER_INTERNAL_RM(73, o);
                    ;
                6:
                    LIST_WRITER_INTERNAL_RM(71, o);
                    ;
                7:
                    LIST_WRITER_INTERNAL_RM(74, o);
                    ;
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }
    if (((c_style)&(FULLINV_BIT))) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == 0)) {
            if ((((o has light)) && ((o has worn)))) {
                LIST_WRITER_INTERNAL_RM(65);
                LIST_WRITER_INTERNAL_RM(75, o);
                (parenth_flag = 1);
            } else {
                if ((o has light)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(68, o);
                    (parenth_flag = 1);
                }
                if ((o has worn)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(76, o);
                    (parenth_flag = 1);
                }
            }
            if ((o has container)) {
                if ((o has openable)) {
                    if (parenth_flag) {
                        if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                            print ",";
                        }
                        LIST_WRITER_INTERNAL_RM(67);
                    } else {
                        LIST_WRITER_INTERNAL_RM(65, o);
                    }
                    if ((o has open)) {
                        if (child(o)) {
                            LIST_WRITER_INTERNAL_RM(77, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(78, o);
                        }
                    } else {
                        if ((((o has lockable)) && ((o has locked)))) {
                            LIST_WRITER_INTERNAL_RM(80, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(79, o);
                        }
                    }
                    (parenth_flag = 1);
                } else {
                    if ((((child(o) == 0)) && ((o has transparent)))) {
                        if (parenth_flag) {
                            LIST_WRITER_INTERNAL_RM(67);
                            LIST_WRITER_INTERNAL_RM(70);
                        } else {
                            LIST_WRITER_INTERNAL_RM(65);
                            LIST_WRITER_INTERNAL_RM(70);
                            LIST_WRITER_INTERNAL_RM(66);
                        }
                    }
                }
            }
            if (parenth_flag) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }
    (child_count = 0);
    (eldest_child = 0);
    objectloop (p in o) {
        if ((((((c_style)&(CONCEAL_BIT)) == 0)) || ((ConcealedFromLists(p) == 0)))) {
            if (_final_propertyvalue(OBJECT_TY, p, list_filter_permits)) {
                (child_count)++;
                if ((eldest_child == 0)) {
                    (eldest_child = p);
                }
            }
        }
    }
    if (((child_count) && (((c_style)&(ALWAYS_BIT))))) {
        if (((c_style)&(ENGLISH_BIT))) {
            print " ";
            LIST_WRITER_INTERNAL_RM(81, o);
            print " ";
        }
        (recurse_flag = 1);
    }
    if (((child_count) && (((c_style)&(RECURSE_BIT))))) {
        if ((o has supporter)) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(82, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(83, o);
                }
            }
            (recurse_flag = 1);
        }
        if ((((o has container)) && ((((o has open)) || ((o has transparent)))))) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(84, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(85, o);
                }
            }
            (recurse_flag = 1);
        }
    }
    if (((recurse_flag) && (((c_style)&(ENGLISH_BIT))))) {
        SetLWI(child_count, (-(1)), eldest_child);
        LIST_WRITER_INTERNAL_RM(86, o);
        print " ";
    }
    if (((c_style)&(NEWLINE_BIT))) {
        print "^";
    }
    if (recurse_flag) {
        (o = child(o));
        @push lt_value;
        @push listing_together;
        @push listing_size;
        @push c_iterator;
        (c_iterator = ObjectTreeIterator);
        (lt_value = EMPTY_TEXT_VALUE);
        (listing_together = 0);
        (listing_size = 0);
        WriteListR(o, (depth + 1), 1);
        @pull c_iterator;
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        if (((c_style)&(TERSE_BIT))) {
            LIST_WRITER_INTERNAL_RM(66);
        }
    }
];
[ LIST_WRITER_INTERNAL_R;
];
[ Main;
    #ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    FollowRulebook(STARTUP_RB);
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    while (1) {
        while ((deadflag == 0)) {
            (EarlyInTurnSequence = 1);
            (action = ##Wait);
            (meta = 0);
            (noun = 0);
            (second = 0);
            (actor = player);
            FollowRulebook(TURN_SEQUENCE_RB);
            (IterationsOfTurnSequence)++;
        }
        if ((FollowRulebook(SHUTDOWN_RB) == 0)) {
            rtrue;
        }
    }
];
[ VIRTUAL_MACHINE_STARTUP_R;
    CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
    VM_Initialise();
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    print "^^^";
    rfalse;
];
[ INITIALISE_MEMORY_R;
    VM_PreInitialise();
    (not_yet_in_play = 1);
    (lookmode = KIT_CONFIGURATION_LOOKMODE);
    (player = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (the_time = (InitialSituation-->(START_TIME_INIS)));
    (real_location = 0);
    (location = 0);
    HeapInitialise();
    StackFramingInitialise();
    CreateDynamicRelations();
    rfalse;
];
[ POSITION_PLAYER_IN_MODEL_R player_to_be;
    (player = selfobj);
    (player_to_be = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (location = LocationOf(player_to_be));
    if ((location == 0)) {
        (location = (InitialSituation-->(START_ROOM_INIS)));
        if ((InitialSituation-->(START_OBJECT_INIS))) {
            move player_to_be to (InitialSituation-->(START_OBJECT_INIS));
        } else {
            move player_to_be to location;
        }
    }
    if ((player_to_be ~= player)) {
        remove selfobj;
        ChangePlayer(player_to_be);
    } else {
        (real_location = location);
        SilentlyConsiderLight();
    }
    NOTE_OBJECT_ACQUISITIONS_R();
    MoveFloatingObjects();
    (actor = player);
    (act_requester = 0);
    (actors_location = real_location);
    (action = ##Wait);
    ((InitialSituation-->(DONE_INIS)) = 1);
    rfalse;
];
[ PARSE_COMMAND_R;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (not_yet_in_play = 0);
    Parser__parse();
    TreatParserResults();
    rfalse;
];
[ TreatParserResults;
    if (((parser_results-->(ACTION_PRES)) == ##MistakeAction)) {
        (meta = 1);
    }
    if (((((((parser_results-->(ACTION_PRES)) == ##Tell)) && (((parser_results-->(INP1_PRES)) == player)))) && ((actor ~= player)))) {
        ((parser_results-->(ACTION_PRES)) = ##Ask);
        ((parser_results-->(INP1_PRES)) = actor);
        (actor = player);
    }
];
[ GENERATE_ACTION_R i;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (EarlyInTurnSequence = 0);
    (action = (parser_results-->(ACTION_PRES)));
    (act_requester = 0);
    if ((actor ~= player)) {
        (act_requester = player);
    }
    (inp1 = 0);
    (inp2 = 0);
    (multiflag = 0);
    if (((parser_results-->(NO_INPS_PRES)) >= 1)) {
        (inp1 = (parser_results-->(INP1_PRES)));
        if ((inp1 == 0)) {
            (multiflag = 1);
        }
    }
    if (((parser_results-->(NO_INPS_PRES)) >= 2)) {
        (inp2 = (parser_results-->(INP2_PRES)));
        if ((inp2 == 0)) {
            (multiflag = 1);
        }
    }
    if ((inp1 == 1)) {
        (noun = 0);
    } else {
        (noun = inp1);
    }
    if ((inp2 == 1)) {
        (second = 0);
    } else {
        (second = inp2);
    }
    if (multiflag) {
        if (((multiple_object-->(0)) == 0)) {
            if ((actor == player)) {
                GENERATE_ACTION_RM(66);
                print "^";
            }
            rtrue;
        }
        if (toomany_flag) {
            (toomany_flag = 0);
            if ((actor == player)) {
                GENERATE_ACTION_RM(65);
            }
        }
        (i = (multiple_object-->(0)));
        FollowRulebook(MULTIPLE_ACTION_PROCESSING_RB);
        if (((((multiple_object-->(0)) == 1)) && ((i > 1)))) {
            (multiflag = 0);
            if ((inp1 == 0)) {
                (noun = (multiple_object-->(1)));
            }
            if ((((inp2 == 0)) && (((parser_results-->(NO_INPS_PRES)) >= 2)))) {
                (second = (multiple_object-->(1)));
            }
        }
        if (((multiple_object-->(0)) == 0)) {
            rfalse;
        }
    }
    if (multiflag) {
        GenerateMultipleActions();
        (multiflag = 0);
    } else {
        BeginAction(action, noun, second);
    }
    if ((((actor ~= player)) || (act_requester))) {
        (action = ##Wait);
    }
    (actor = player);
    (act_requester = 0);
    if (meta) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenerateMultipleActions initial_location k item;
    (initial_location = location);
    for ((k = 1):(k <= (multiple_object-->(0))):(k)++) {
        (item = (multiple_object-->(k)));
        RunParagraphOn();
        if ((inp1 == 0)) {
            (inp1 = item);
            BeginAction(action, item, second, item);
            (inp1 = 0);
        } else {
            (inp2 = item);
            BeginAction(action, noun, item, item);
            (inp2 = 0);
        }
        if (deadflag) {
            rtrue;
        }
        if ((location ~= initial_location)) {
            if ((player == actor)) {
                ACTION_PROCESSING_INTERNAL_RM(74);
                print "^";
            }
            rtrue;
        }
    }
];
[ TIMED_EVENTS_R i d event_timer fire rule;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if (((rule = (TimedEventsTable-->(i))) ~= 0)) {
            (event_timer = (TimedEventTimesTable-->(i)));
            (fire = 0);
            if ((event_timer < 0)) {
                ((TimedEventTimesTable-->(i)))++;
                if (((TimedEventTimesTable-->(i)) == 0)) {
                    (fire = 1);
                }
            } else {
                (d = (((the_time - event_timer) + TWENTY_FOUR_HOURS)%TWENTY_FOUR_HOURS));
                if ((((d >= 0)) && ((d < 30)))) {
                    (fire = 1);
                }
            }
            if (fire) {
                ((TimedEventsTable-->(i)) = 0);
                FollowRulebook(rule);
            }
        }
    }
    rfalse;
];
[ SetTimedEvent rule event_time absolute_time i b;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if ((rule == (TimedEventsTable-->(i)))) {
            (b = i);
            break;
        }
        if ((((b == 0)) && (((TimedEventsTable-->(i)) == 0)))) {
            (b = i);
        }
    }
    if ((b == 0)) {
        return RunTimeProblem(RTP_TOOMANYEVENTS);
    }
    ((TimedEventsTable-->(b)) = rule);
    if (absolute_time) {
        ((TimedEventTimesTable-->(b)) = event_time);
    } else {
        ((TimedEventTimesTable-->(b)) = (-(event_time)));
    }
];
[ SetTime t s;
    (the_time = t);
    (time_rate = s);
    (time_step = 0);
    if ((s < 0)) {
        (time_step = (0 - s));
    }
];
[ ADVANCE_TIME_R;
    (turns)++;
    if ((the_time ~= NULL)) {
        if ((time_rate >= 0)) {
            (the_time = (the_time + time_rate));
        } else {
            (time_step)--;
            if ((time_step == 0)) {
                (the_time)++;
                (time_step = (-(time_rate)));
            }
        }
        (the_time = (the_time%TWENTY_FOUR_HOURS));
    }
    rfalse;
];
[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) {
        give obj moved;
    }
    objectloop (obj ofclass Object && (obj has concealed)) {
        if (IndirectlyContains(player, obj)) {
            give obj ~concealed;
        }
    }
    rfalse;
];
[ RESURRECT_PLAYER_IF_ASKED_R;
    if (resurrect_please) {
        RulebookSucceeds();
        (resurrect_please = 0);
        (deadflag = 0);
        (story_complete = 0);
        rtrue;
    }
    rfalse;
];
[ ASK_FINAL_QUESTION_R;
    print "^";
    while (1) {
        CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
        DivideParagraphPoint();
        if (resurrect_please) {
            rtrue;
        }
    }
];
[ READ_FINAL_ANSWER_R;
    DrawStatusLine();
    KeyboardPrimitive(buffer, parse);
    (players_command = (100 + WordCount()));
    (num_words = WordCount());
    (wn = 1);
    rfalse;
];
[ IMMEDIATELY_RESTART_VM_R;
    @restart;
];
[ IMMEDIATELY_RESTORE_SAVED_R;
    (actor = player);
    RESTORE_THE_GAME_R();
];
[ IMMEDIATELY_QUIT_R;
    @quit;
];
[ IMMEDIATELY_UNDO_R;
    Perform_Undo();
];
[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if ((deadflag == 1)) {
        PRINT_OBITUARY_HEADLINE_RM(65);
    }
    if ((deadflag == 2)) {
        PRINT_OBITUARY_HEADLINE_RM(66);
    }
    if ((deadflag == 3)) {
        PRINT_OBITUARY_HEADLINE_RM(67);
    }
    if ((deadflag ~= 0 or 1 or 2 or 3)) {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^^";
    rfalse;
];
[ PRINT_FINAL_SCORE_R;
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        ANNOUNCE_SCORE_R();
    }
    rfalse;
];
[ DISPLAY_FINAL_STATUS_LINE_R;
    (sline1 = score);
    (sline2 = turns);
    rfalse;
];
[ FindAction fa t;
    if ((fa == -1)) {
        (fa = action);
    }
    (t = 1);
    while ((t <= (ActionData-->(0)))) {
        if ((fa == (ActionData-->(t)))) {
            return t;
        }
        (t = (t + AD_RECORD_SIZE));
    }
    rfalse;
];
[ ActionNumberIndexed i;
    if ((((i >= 0)) && ((i < AD_RECORDS)))) {
        return (ActionData-->((((i*AD_RECORD_SIZE) + AD_ACTION) + 1)));
    }
    rfalse;
];
[ NeedToCarryNoun;
    return TestActionMask(CARRY_NOUN_ABIT);
];
[ NeedToCarrySecondNoun;
    return TestActionMask(CARRY_SECOND_ABIT);
];
[ NeedToTouchNoun;
    return TestActionMask(TOUCH_NOUN_ABIT);
];
[ NeedToTouchSecondNoun;
    return TestActionMask(TOUCH_SECOND_ABIT);
];
[ NeedLightForAction;
    return TestActionMask(LIGHT_ABIT);
];
[ TestActionMask match mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(match))) {
        rtrue;
    }
    rfalse;
];
[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
    if (stora) {
        return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
    }
    (tbits = ((req)&((16 + 32))));
    (req = ((req)&(1)));
    @push actor;
    @push act_requester;
    @push inp1;
    @push inp2;
    @push parsed_number;
    (smeta = meta);
    if ((by == 0)) {
        (by = player);
    }
    (actor = by);
    if (req) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
    (by = FindAction(ac));
    if (by) {
        if (((ActionData-->((by + AD_NOUN_KOV))) == OBJECT_TY)) {
            (inp1 = n);
        } else {
            (inp1 = 1);
            (parsed_number = n);
        }
        if (((ActionData-->((by + AD_SECOND_KOV))) == OBJECT_TY)) {
            (inp2 = s);
        } else {
            (inp2 = 1);
            (parsed_number = s);
        }
        if (((((((ActionData-->((by + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((by + AD_SECOND_KOV))) == UNDERSTANDING_TY)))) && (tbits))) {
            (saved_command = BlkValueCreate(TEXT_TY));
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            if ((tbits == 16)) {
                (n = players_command);
                (inp1 = 1);
                (parsed_number = players_command);
            } else {
                (s = players_command);
                (inp2 = 1);
                (parsed_number = players_command);
            }
            BlkValueFree(text_of_command);
            @push consult_from;
            @push consult_words;
            (consult_from = 1);
            (consult_words = (parsed_number - 100));
        }
    }
    BeginAction(ac, n, s, 0, 1);
    if (saved_command) {
        @pull consult_words;
        @pull consult_from;
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    (meta = smeta);
    @pull parsed_number;
    @pull inp2;
    @pull inp1;
    @pull act_requester;
    @pull actor;
    TrackActions(1, smeta);
];
[ R_Process a i j;
    @push inp1;
    @push inp2;
    (inp1 = i);
    (inp2 = j);
    BeginAction(a, i, j);
    @pull inp2;
    @pull inp1;
];
[ GVS_Convert ac n s;
    (converted_action_outcome = BeginAction(ac, n, s));
    if ((converted_action_outcome == 1)) {
        FollowRulebook(AFTER_RB, 0, 1);
    }
    rtrue;
];
[ ConvertToRequest X AN Y Z;
    WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if ((X == player)) {
        TryAction(0, X, AN, Y, Z);
    } else {
        TryAction(1, X, AN, Y, Z);
    }
    rtrue;
];
[ ConvertToGoingWithPush i oldrm newrm infl;
    (i = noun);
    if ((IndirectlyContains(noun, actor) == 0)) {
        move i to actor;
        (infl = 1);
    }
    (move_pushing = i);
    (oldrm = LocationOf(noun));
    BeginAction(##Go, second);
    (newrm = LocationOf(actor));
    (move_pushing = 0);
    move i to newrm;
    if ((newrm ~= oldrm)) {
        if (IndirectlyContains(i, player)) {
            TryAction(0, player, ##Look, 0, 0);
        }
        RulebookSucceeds();
    } else {
        RulebookFails();
    }
    rtrue;
];
[ ImplicitTake obj ks;
    if ((actor == player)) {
        STANDARD_IMPLICIT_TAKING_RM(65, obj);
    } else {
        if (TestVisibility(player, actor)) {
            STANDARD_IMPLICIT_TAKING_RM(66, obj, actor);
        }
    }
    ClearParagraphing(3);
    @push keep_silent;
    (keep_silent = 1);
    @push say__p;
    @push say__pc;
    ClearParagraphing(4);
    if (act_requester) {
        TryAction(1, actor, ##Take, obj, 0);
    } else {
        TryAction(0, actor, ##Take, obj, 0);
    }
    DivideParagraphPoint();
    @pull say__pc;
    @pull say__p;
    AdjustParagraphPoint();
    @pull keep_silent;
    if ((obj in actor)) {
        rtrue;
    }
    rfalse;
];
[ LookAfterGoing;
    GoingLookBreak();
    AbbreviatedRoomDescription();
];
[ AbbreviatedRoomDescription prior_action pos frame_id;
    (prior_action = action);
    (action = ##Look);
    (pos = FindAction(##Look));
    if (((pos) && ((ActionData-->((pos + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((pos + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
        FollowRulebook(SETTING_ACTION_VARIABLES_RB);
        ((MStack-->(MstVO(frame_id, 0))) = prior_action);
        ((MStack-->(MstVO(frame_id, 1))) = 1);
    }
    LookSub();
    if (frame_id) {
        Mstack_Destroy_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
    }
    (action = prior_action);
];
[ BeginAction a n s moi notrack rv;
    ChronologyPoint();
    @push action;
    @push noun;
    @push second;
    @push self;
    @push multiple_object_item;
    (action = a);
    (noun = n);
    (second = s);
    (self = noun);
    (multiple_object_item = moi);
    if ((action < 4096)) {
        (rv = ActionPrimitive());
    }
    @pull multiple_object_item;
    @pull self;
    @pull second;
    @pull noun;
    @pull action;
    if ((notrack == 0)) {
        TrackActions(1, meta);
    }
    return rv;
];
[ ActionPrimitive rv p1 p2 p3 p4 p5 frame_id;
    MStack_CreateRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    (reason_the_action_failed = 0);
    (frame_id = -1);
    (p1 = FindAction(action));
    if (((p1) && ((ActionData-->((p1 + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((p1 + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    if (ActionVariablesNotTypeSafe()) {
        if ((actor ~= player)) {
            ACTION_PROCESSING_INTERNAL_RM(75);
            print "^";
        }
        if ((frame_id ~= -1)) {
            Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
        }
        MStack_DestroyRBVars(ACTION_PROCESSING_RB);
        rtrue;
    }
    FollowRulebook(SETTING_ACTION_VARIABLES_RB);
    if (((trace_actions) && (FindAction(-1)))) {
        print "[";
        (p1 = actor);
        (p2 = act_requester);
        (p3 = action);
        (p4 = noun);
        (p5 = second);
        DB_Action(p1, p2, p3, p4, p5);
        print "]^";
        ClearParagraphing(5);
    }
    ++(debug_rule_nesting);
    TrackActions(0, meta);
    if (((meta) && ((actor ~= player)))) {
        ACTION_PROCESSING_INTERNAL_RM(65, actor);
        print "^";
        (rv = RS_FAILS);
    } else {
        if (meta) {
            DESCEND_TO_SPECIFIC_ACTION_R();
            (rv = RulebookOutcome());
        } else {
            FollowRulebook(ACTION_PROCESSING_RB);
            (rv = RulebookOutcome());
        }
    }
    --(debug_rule_nesting);
    if (((trace_actions) && (FindAction(-1)))) {
        print "[";
        DB_Action(p1, p2, p3, p4, p5);
        print " - ";
        switch (rv) {
            RS_SUCCEEDS:
                print "succeeded";
                ;
            RS_FAILS:
                print "failed";
                if (reason_the_action_failed) {
                    print " the ";
                    RulePrintingRule(reason_the_action_failed);
                }
                ;
            default:
                print "ended without result";
                ;
        }
        print "]^";
        (say__p = 1);
        SetRulebookOutcome(rv);
    }
    if ((rv == RS_SUCCEEDS)) {
        UpdateActionBitmap();
    }
    if ((frame_id ~= -1)) {
        (p1 = FindAction(action));
        Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    MStack_DestroyRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    if ((rv == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ACTION_PROCESSING_INTERNAL_R;
];
[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (noun_kova = (ActionData-->((at + AD_NOUN_KOV))));
    (second_kova = (ActionData-->((at + AD_SECOND_KOV))));
    if ((noun_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        if ((inp1 ~= 1)) {
            (inp2 = inp1);
            (second = noun);
        }
        (parsed_number = ((100*consult_from) + consult_words));
        (inp1 = 1);
        (noun = 0);
    }
    if ((second_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        (parsed_number = ((100*consult_from) + consult_words));
        (inp2 = 1);
        (second = 0);
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(OUT_OF_WORLD_ABIT))) {
        (meta = 1);
        rfalse;
    }
    (meta = 0);
    if ((inp1 == 1)) {
        if ((noun_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(66);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((noun_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(67);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_NOUN_ABIT))) && ((noun == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
            @pull act_requester;
            if ((noun == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(68);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_NOUN_ABIT)) == 0)) && ((noun ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(69);
                print "^";
            }
            rtrue;
        }
    }
    if ((inp2 == 1)) {
        if ((second_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(70);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((second_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(71);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_SECOND_ABIT))) && ((second == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
            @pull act_requester;
            if ((second == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(72);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_SECOND_ABIT)) == 0)) && ((second ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(73);
                print "^";
            }
            rtrue;
        }
    }
    rfalse;
];
[ BASIC_VISIBILITY_R;
    if (act_requester) {
        rfalse;
    }
    if (((((((NeedLightForAction()) && ((actor == player)))) && (FollowRulebook(VISIBLE_RB)))) && (RulebookSucceeded()))) {
        BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        if ((ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT) == 0)) {
            BASIC_VISIBILITY_RM(65);
            print "^";
        }
        EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        (reason_the_action_failed = BASIC_VISIBILITY_R);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ BASIC_ACCESSIBILITY_R mask at;
    if (act_requester) {
        rfalse;
    }
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if ((noun ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(noun, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if ((second ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(second, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    rfalse;
];
[ CARRYING_REQUIREMENTS_R mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if (((((mask)&(CARRY_NOUN_ABIT))) && ((noun notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
            if ((noun notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if (((((mask)&(CARRY_SECOND_ABIT))) && ((second notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
            if ((second notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    rfalse;
];
[ STANDARD_IMPLICIT_TAKING_R;
    ImplicitTake(parameter_value);
    rfalse;
];
[ REQUESTED_ACTIONS_REQUIRE_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push say__p;
        (say__p = 0);
        (rv = FollowRulebook(PERSUADE_RB));
        if ((RulebookSucceeded() == 0)) {
            if ((((deadflag == 0)) && ((say__p == 0)))) {
                REQUESTED_ACTIONS_REQUIRE_RM(65, actor);
                print "^";
            }
            ActRulebookFails(rv);
            rtrue;
        }
        @pull say__p;
    }
    rfalse;
];
[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push act_requester;
        (act_requester = 0);
        (rv = BeginAction(action, noun, second));
        if (((((meta) || ((rv == 0)))) && ((deadflag == 0)))) {
            if ((FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == 0)) {
                CARRY_OUT_REQUESTED_ACTIONS_RM(65, actor);
                print "^";
            }
        }
        @pull act_requester;
        FollowRulebook(AFTER_RB);
        ActRulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenericVerbSub ch co re vis rv;
    @push converted_action_outcome;
    (converted_action_outcome = -1);
    ((Details_of_Specific_Action-->(0)) = 1);
    if (meta) {
        ((Details_of_Specific_Action-->(0)) = 0);
    }
    ((Details_of_Specific_Action-->(1)) = keep_silent);
    ((Details_of_Specific_Action-->(2)) = ch);
    ((Details_of_Specific_Action-->(3)) = co);
    ((Details_of_Specific_Action-->(4)) = re);
    FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, 1);
    if (((RulebookFailed()) && ((converted_action_outcome == 1)))) {
        ActRulebookSucceeds();
    }
    @pull converted_action_outcome;
    rtrue;
];
[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0))) = (Details_of_Specific_Action-->(0)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1))) = (Details_of_Specific_Action-->(1)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2))) = (Details_of_Specific_Action-->(2)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3))) = (Details_of_Specific_Action-->(3)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4))) = (Details_of_Specific_Action-->(4)));
    rfalse;
];
[ TestActionBitmap obj act i j k bitmap;
    if ((obj == 0)) {
        (bitmap = ActionHappened);
    } else {
        if ((~~((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))))) {
            rfalse;
        }
        (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
    }
    if ((act == -1)) {
        return ((((bitmap->(0)))&(1)) ~= 0);
    }
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            return ((((bitmap->(j)))&(k)) ~= 0);
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
    rfalse;
];
[ UpdateActionBitmap;
    SetActionBitmap(noun, action);
    if ((action == ##Go)) {
        SetActionBitmap(location, ##Enter);
    }
];
[ SetActionBitmap obj act i j k bitmap;
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            if ((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))) {
                (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
                ((bitmap->(0)) = (((bitmap->(0)))|(1)));
                ((bitmap->(j)) = (((bitmap->(j)))|(k)));
            }
            ((ActionHappened->(0)) = (((ActionHappened->(0)))|(1)));
            ((ActionHappened->(j)) = (((ActionHappened->(j)))|(k)));
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
];
[ SayActionName act;
    DB_Action(0, 0, act, 0, 0, 2);
];
[ DA_Name n;
    if ((n ofclass K3_direction)) {
        PrintShortName(n);
    } else {
        DefArt(n);
    }
];
[ DA_Topic x a b c d i cf cw;
    (cw = (x%100));
    (cf = (x/100));
    print "~";
    for ((a = cf):(d < cw):((d)++,(a)++)) {
        (wn = a);
        (b = WordAddress(a));
        (c = WordLength(a));
        for ((i = b):(i < (b + c)):(i)++) {
            print (char) (0->(i));
        }
        if ((d < (cw - 1))) {
            print " ";
        }
    }
    print "~";
];
[ DB_Action ac acr act n s for_say t at l j v c clc;
    if ((((for_say == 0)) && ((debug_rule_nesting > 0)))) {
        print "(";
        print debug_rule_nesting;
        print ") ";
    }
    if ((((ac ~= player)) && ((for_say ~= 2)))) {
        if (acr) {
            print "asking ";
            DefArt(ac);
            print " to try ";
        } else {
            DefArt(ac);
            print " ";
        }
    }
    DB_Action_Details(act, n, s, for_say);
    if (((keep_silent) && ((for_say == 0)))) {
        print " - silently";
    }
];
[ FixInhibitFlag n act inhibit_rule_debugging;
    for ((n = 0):(n < activities_sp):(n)++) {
        (act = (activities_stack-->(n)));
        if ((act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)) {
            (inhibit_rule_debugging = 1);
        }
    }
    if ((((inhibit_flag == 0)) && (inhibit_rule_debugging))) {
        (saved_debug_rules = debug_rules);
        (debug_rules = 0);
    }
    if (((inhibit_flag) && ((inhibit_rule_debugging == 0)))) {
        (debug_rules = saved_debug_rules);
    }
    (inhibit_flag = inhibit_rule_debugging);
];
[ TestActivity A desc val i;
    for ((i = 0):(i < activities_sp):(i)++) {
        if (((activities_stack-->(i)) == A)) {
            if (desc) {
                if ((desc)((activity_parameters_stack-->(i)))) {
                    rtrue;
                }
            } else {
                if (val) {
                    if ((val == (activity_parameters_stack-->(i)))) {
                        rtrue;
                    }
                } else {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ ActivityEmpty A x;
    (x = (Activity_before_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_for_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_after_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ RulebookEmpty rb;
    if (((rulebooks_array-->(rb)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ ProcessActivityRulebook rulebook parameter rv;
    @push self;
    if (parameter) {
        (self = parameter);
    }
    (rv = FollowRulebook(rulebook, parameter, 1));
    @pull self;
    if (rv) {
        rtrue;
    }
    rfalse;
];
[ CarryOutActivity A o rv;
    BeginActivity(A, o);
    (rv = ForActivity(A, o));
    EndActivity(A, o);
    return rv;
];
[ BeginActivity A o x;
    if ((activities_sp == MAX_NESTED_ACTIVITIES)) {
        return RunTimeProblem(RTP_TOOMANYACTS);
    }
    ((activity_parameters_stack-->(activities_sp)) = o);
    ((activities_stack-->((activities_sp)++)) = A);
    FixInhibitFlag();
    MStack_CreateAVVars(A);
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_before_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ ForActivity A o x;
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_for_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ EndActivity A o rv x;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        if ((Activity_atb_rulebooks->(A))) {
            (x = action);
            (action = action_to_be);
        }
        (rv = ProcessActivityRulebook((Activity_after_rulebooks-->(A)), o));
        if ((Activity_atb_rulebooks->(A))) {
            (action = x);
        }
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        return rv;
    }
    return RunTimeProblem(RTP_CANTEND);
];
[ AbandonActivity A o;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        rtrue;
    }
    return RunTimeProblem(RTP_CANTABANDON);
];
[ DisplayFigure resource_ID one_time;
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    print "^";
    VM_Picture(resource_ID);
    print "^";
];
[ PlaySound resource_ID one_time;
    if ((resource_ID == 0)) {
        rtrue;
    }
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    VM_SoundEffect(resource_ID);
];
[ Perform_Undo;
    if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
        IMMEDIATELY_UNDO_RM(65);
        print "^";
        rtrue;
    }
    if ((IterationsOfTurnSequence == 0)) {
        IMMEDIATELY_UNDO_RM(66);
        print "^";
        rtrue;
    }
    if ((undo_flag == 0)) {
        IMMEDIATELY_UNDO_RM(67);
        print "^";
        rtrue;
    }
    if ((undo_flag == 1)) {
        IMMEDIATELY_UNDO_RM(68);
        print "^";
        rtrue;
    }
    if ((VM_Undo() == 0)) {
        IMMEDIATELY_UNDO_RM(70);
        print "^";
    }
];
[ ANNOUNCE_SCORE_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_RM(67);
        print "^";
    } else {
        ANNOUNCE_SCORE_RM(65);
        PrintRank();
    }
];
[ SWITCH_SCORE_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 1);
    }
];
[ REP_SWITCH_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_ON_RM(65);
        print "^";
    }
];
[ SWITCH_SCORE_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 0);
    }
];
[ REP_SWITCH_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_OFF_RM(65);
        print "^";
    }
];
[ PREFER_SOMETIMES_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 1);
];
[ REP_PREFER_SOMETIMES_ABBR_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_SOMETIMES_ABBR_RM(65);
    print "^";
];
[ PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 2);
];
[ REP_PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_UNABBREVIATED_RM(65);
    print "^";
];
[ PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 3);
];
[ REP_PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_ABBREVIATED_RM(65);
    print "^";
];
[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
    if ((actor ~= player)) {
        rfalse;
    }
    ANNOUNCE_PRONOUN_MEANINGS_RM(65);
    (c = ((LanguagePronouns-->(0))/3));
    if ((player ~= selfobj)) {
        (c)++;
    }
    if ((c == 0)) {
        ANNOUNCE_PRONOUN_MEANINGS_RM(68);
        rtrue;
    }
    for (((x = 1),(d = 0)):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        print "~";
        print (address) (LanguagePronouns-->(x));
        print "~ ";
        (y = (LanguagePronouns-->((x + 2))));
        if ((y == NULL)) {
            ANNOUNCE_PRONOUN_MEANINGS_RM(67);
        } else {
            ANNOUNCE_PRONOUN_MEANINGS_RM(66);
            DefArt(y);
        }
        (d)++;
        if ((d < (c - 1))) {
            print ", ";
        }
        if ((d == (c - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                print ",";
            }
            LIST_WRITER_INTERNAL_RM(67);
        }
    }
    if ((player ~= selfobj)) {
        print "~";
        print (address) ME1__WD;
        print "~ ";
        ANNOUNCE_PRONOUN_MEANINGS_RM(66);
        (c = player);
        (player = selfobj);
        DefArt(c);
        (player = c);
    }
    print ".";
    new_line;
    rtrue;
];
[ PrintPrompt i;
    RunTimeProblemShow();
    ClearRTP();
    style roman;
    EnsureBreakBeforePrompt();
    TEXT_TY_Say(CommandPromptText());
    ClearBoxedText();
    ClearParagraphing(14);
];
[ DisplayBoxedQuotation Q;
    (pending_boxed_quotation = Q);
];
[ ClearBoxedText i;
    if (pending_boxed_quotation) {
        ClearParagraphing(15);
        (pending_boxed_quotation)();
        ClearParagraphing(16);
        (pending_boxed_quotation = 0);
    }
];
[ NotifyTheScore d;
    if (((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) && ((notify_mode == 1)))) {
        DivideParagraphPoint();
        VM_Style(NOTE_VMSTY);
        (d = (score - last_score));
        if ((d > 0)) {
            ANNOUNCE_SCORE_RM(68, d);
        } else {
            if ((d < 0)) {
                ANNOUNCE_SCORE_RM(69, (-(d)));
            }
        }
        print "^";
        VM_Style(NORMAL_VMSTY);
    }
];
[ PrintRank i j v;
    if (((KIT_CONFIGURATION_BITMAP)&(RANKING_TABLE_TCBIT))) {
        ANNOUNCE_SCORE_RM(66);
        (j = TableRows(RANKING_TABLE));
        for ((i = j):(i >= 1):(i)--) {
            if ((score >= TableLookUpEntry(RANKING_TABLE, 1, i))) {
                (v = TableLookUpEntry(RANKING_TABLE, 2, i));
                TEXT_TY_Say(v);
                print ".";
                new_line;
                rtrue;
            }
        }
    }
    print ".";
    new_line;
    rtrue;
];
[ DrawStatusLine width posb;
    @push say__p;
    @push say__pc;
    BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
    VM_StatusLineHeight(1);
    VM_MoveCursorInStatusLine(1, 1);
    if (statuswin_current) {
        (width = VM_ScreenWidth());
        (posb = (width - 15));
        spaces width;
        ClearParagraphing(17);
        if ((ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == 0)) {
            VM_MoveCursorInStatusLine(1, 2);
            TEXT_TY_Say(left_hand_status_line);
            VM_MoveCursorInStatusLine(1, posb);
            TEXT_TY_Say(right_hand_status_line);
        }
        VM_MoveCursorInStatusLine(1, 1);
        VM_MainWindow();
    }
    ClearParagraphing(18);
    EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
    @pull say__pc;
    @pull say__p;
];
[ SL_Score_Moves;
    if (not_yet_in_play) {
        rtrue;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        print sline1;
        print "/";
        print sline2;
    }
];
[ SL_Location even_before;
    if (((not_yet_in_play) && ((even_before == 0)))) {
        rtrue;
    }
    if ((location == thedark)) {
        BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
        if ((ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == 0)) {
            DARKNESS_NAME_INTERNAL_RM(65);
        }
        EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
    } else {
        FindVisibilityLevels();
        if ((visibility_ceiling == location)) {
            PrintShortName(location);
        } else {
            CDefArt(visibility_ceiling);
        }
    }
];
[ DARKNESS_NAME_INTERNAL_R;
];
[ Banner;
    BeginActivity(PRINTING_BANNER_TEXT_ACT);
    if ((ForActivity(PRINTING_BANNER_TEXT_ACT) == 0)) {
        VM_Style(HEADER_VMSTY);
        TEXT_TY_Say(Story);
        VM_Style(NORMAL_VMSTY);
        print "^";
        TEXT_TY_Say(Headline);
        if (((KIT_CONFIGURATION_BITMAP)&(STORY_AUTHOR_TCBIT))) {
            print " by ";
            TEXT_TY_Say(Story_Author);
        }
        print "^";
        VM_Describe_Release();
        print " / Inform 7 v";
        PrintI6Text(I7_VERSION_NUMBER);
        print " / D";
        print "^";
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];
[ CPrintOrRun obj prop v length i;
    if ((((obj ofclass String or Routine)) || ((prop == 0)))) {
        VM_PrintToBuffer(StorageForShortName, 160, obj);
    } else {
        if ((_final_propertyvalue(OBJECT_TY, obj, prop) == NULL)) {
            rfalse;
        }
        if ((metaclass(_final_propertyvalue(OBJECT_TY, obj, prop)) == Routine or String)) {
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        } else {
            return RunTimeError(2, obj, prop);
        }
    }
    (length = (StorageForShortName-->(0)));
    ((StorageForShortName->(WORDSIZE)) = VM_LowerToUpperCase((StorageForShortName->(WORDSIZE))));
    for ((i = WORDSIZE):(i < (length + WORDSIZE)):(i)++) {
        print (char) (StorageForShortName->(i));
    }
    if ((i > WORDSIZE)) {
        (say__p = 1);
    }
    rtrue;
];
[ Cap str nocaps;
    if (nocaps) {
        print (string) str;
    } else {
        CPrintOrRun(str, 0);
    }
];
[ PSN__ o;
    if ((o == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(o)) {
        Routine:
            print "<routine ";
            print o;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) o;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print o;
            print ">";
            rtrue;
            ;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];
[ PrintShortName obj i;
    (i = indef_mode);
    (indef_mode = NULL);
    PSN__(obj);
    (indef_mode = i);
];
[ STANDARD_NAME_PRINTING_R obj;
    (obj = parameter_value);
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(obj)) {
        Routine:
            print "<routine ";
            print obj;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) obj;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print obj;
            print ">";
            rtrue;
            ;
    }
    if ((obj == player)) {
        if ((((indef_mode == NULL)) && (caps_mode))) {
            PRINT_PROTAGONIST_INTERNAL_RM(65);
        } else {
            PRINT_PROTAGONIST_INTERNAL_RM(66);
        }
        rtrue;
    }
    if (((((indef_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_short_name_indef))))) && ((PrintOrRun(obj, A_short_name_indef, 1) ~= 0)))) {
        rtrue;
    }
    if (((((caps_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_cap_short_name))))) && ((PrintOrRun(obj, A_cap_short_name, 1) ~= 0)))) {
        (caps_mode = 0);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_short_name))) && ((PrintOrRun(obj, A_short_name, 1) ~= 0)))) {
        rtrue;
    }
    print (object) obj;
];
[ STANDARD_PLURAL_NAME_PRINTING_R obj;
    (obj = parameter_value);
    PrintOrRun(obj, A_plural, 1);
];
[ PRINT_PROTAGONIST_INTERNAL_R;
];
[ PrefaceByArticle obj acode pluralise capitalise i artform findout artval;
    if ((_final_propertyexists(OBJECT_TY, obj, A_articles))) {
        (artval = ((_final_propertyarray(OBJECT_TY, obj, A_articles))-->((acode + (short_name_case*LanguageCases)))));
        if (capitalise) {
            Cap(artval);
        } else {
            print (string) artval;
        }
        if (pluralise) {
            rtrue;
        }
        PSN__(obj);
        rtrue;
    }
    (i = GetGNAOfObject(obj));
    if (pluralise) {
        if ((((i < 3)) || ((((i >= 6)) && ((i < 9)))))) {
            (i = (i + 3));
        }
    }
    (i = (LanguageGNAsToArticles-->(i)));
    (artform = (LanguageArticles + (((3*WORDSIZE)*LanguageContractionForms)*(short_name_case + (i*LanguageCases)))));
    switch (LanguageContractionForms) {
        2:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            ;
        3:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            ;
        4:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 6))) ~= (artform-->((acode + 9))))) {
                (findout = 1);
            }
            ;
        default:
            (findout = 1);
            ;
    }
    if (findout) {
        if (pluralise) {
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        } else {
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        }
        (acode = (acode + (3*LanguageContraction(StorageForShortName))));
    }
    Cap((artform-->(acode)), (~~(capitalise)));
    if (pluralise) {
        rtrue;
    }
    PSN__(obj);
];
[ IndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        PrintOrRun(obj, A_article, 1);
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2);
    (indef_mode = i);
    (self = s);
];
[ CIndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(88);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        TEXT_TY_Say_Capitalised((obj.article));
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2, 0, 1);
    (indef_mode = i);
    (self = s);
];
[ DefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 1);
    (indef_mode = i);
    (self = s);
];
[ CDefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((obj ofclass Object)) && ((((obj has proper)) || ((obj == player)))))) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 0);
    (indef_mode = i);
    (self = s);
];
[ STANDARD_RESPONSE_ISSUING_R;
    RegardingSingleObject();
    TEXT_TY_Say((ResponseTexts-->((parameter_value - 1))));
];
[ HolderOf o;
    if (((InitialSituation-->(DONE_INIS)) == 0)) {
        return thedark;
    }
    if (((o) && ((o.component_parent)))) {
        return (o.component_parent);
    }
    if (((o) && (parent(o)))) {
        return parent(o);
    }
    rfalse;
];
[ ParentOf o;
    if (o) {
        (o = parent(o));
    }
    return o;
];
[ CoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ CoreOfParentOfCoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    if (o) {
        (o = parent(o));
    }
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ LocationOf o;
    if ((~~((o ofclass K1_room or K2_thing)))) {
        rfalse;
    }
    if ((o ofclass K4_door)) {
        if ((parent(o) == real_location)) {
            return real_location;
        }
        return FrontSideOfDoor(o);
    }
    if ((o ofclass K7_backdrop)) {
        return BackdropLocation(o);
    }
    while (o) {
        if ((o ofclass K1_room)) {
            return o;
        }
        (o = CoreOfParentOfCoreOf(o));
    }
    rfalse;
];
[ CommonAncestor o1 o2 i j;
    (o1 = CoreOf(o1));
    (o2 = CoreOf(o2));
    for ((i = o1):i:(i = CoreOfParentOfCoreOf(i))) {
        for ((j = o2):j:(j = CoreOfParentOfCoreOf(j))) {
            if ((j == i)) {
                return j;
            }
        }
    }
    rfalse;
];
[ IndirectlyContains o1 o2;
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K1_room)) && ((o2 ofclass K4_door)))) {
        if ((o1 == FrontSideOfDoor(o2))) {
            rtrue;
        }
        if ((o1 == BackSideOfDoor(o2))) {
            rtrue;
        }
        rfalse;
    }
    if ((o2 ofclass K7_backdrop)) {
        rfalse;
    }
    for ((o2 = HolderOf(o2)):((o2) && ((o2 ~= thedark))):(o2 = HolderOf(o2))) {
        if ((o2 == o1)) {
            rtrue;
        }
    }
    rfalse;
];
[ WhetherIn obj;
    if ((obj has enterable)) {
        if (IndirectlyContains(obj, player)) {
            rtrue;
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        return TestRegionalContainment(real_location, obj);
    }
    if ((obj ofclass K1_room)) {
        if ((obj == real_location)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_NOTINAROOM, obj);
    rfalse;
];
[ ContainerOf A p;
    if ((A ofclass K1_room)) {
        return (A.map_region);
    }
    (p = parent(A));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K5_container)) {
        return p;
    }
    if ((p ofclass K1_room)) {
        return p;
    }
    if ((p ofclass K9_region)) {
        return p;
    }
    rfalse;
];
[ TestContainmentRange obj e f;
    if ((obj ofclass K9_region)) {
        objectloop (f ofclass K1_room && (((f ofclass K1_room)) && (((f.map_region) == obj)))) {
            if ((f > e)) {
                return f;
            }
        }
        rfalse;
    }
    if ((obj ofclass K5_container or K1_room)) {
        if ((e == 0)) {
            return child(obj);
        }
        return sibling(e);
    }
    rfalse;
];
[ SupporterOf obj p;
    (p = parent(obj));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K6_supporter)) {
        return p;
    }
    rfalse;
];
[ CarrierOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((~~((obj has worn)))))) {
        return p;
    }
    rfalse;
];
[ WearerOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((obj has worn)))) {
        return p;
    }
    rfalse;
];
[ OwnerOf obj p;
    (p = parent(obj));
    if (((p) && ((p ofclass K8_person)))) {
        return p;
    }
    rfalse;
];
[ PartOf P;
    if ((P ofclass K2_thing)) {
        return (P.component_parent);
    }
    rfalse;
];
[ MakePart P Of First;
    if ((P == player)) {
        return RunTimeProblem(RTP_CANTMAKEPART, Of);
    }
    if (parent(P)) {
        remove P;
    }
    give P ~worn;
    if ((Of == 0)) {
        DetachPart(P);
        rtrue;
    }
    if ((P.component_parent)) {
        DetachPart(P);
    }
    ((P.component_parent) = Of);
    (First = (Of.component_child));
    ((Of.component_child) = P);
    ((P.component_sibling) = First);
];
[ DetachPart P From Daddy O;
    (Daddy = (P.component_parent));
    ((P.component_parent) = 0);
    if ((Daddy == 0)) {
        ((P.component_sibling) = 0);
        rtrue;
    }
    if (((Daddy.component_child) == P)) {
        ((Daddy.component_child) = (P.component_sibling));
        ((P.component_sibling) = 0);
        rtrue;
    }
    for ((O = (Daddy.component_child)):O:(O = (O.component_sibling))) {
        if (((O.component_sibling) == P)) {
            ((O.component_sibling) = (P.component_sibling));
            ((P.component_sibling) = 0);
            rtrue;
        }
    }
];
[ MoveObject F T opt going_mode was L;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTMOVENOTHING);
    }
    if ((F ofclass K7_backdrop)) {
        if ((T ofclass K9_region)) {
            give F ~absent;
            ((F.found_in) = (T.regional_found_in));
            if (TestRegionalContainment(LocationOf(player), T)) {
                move F to LocationOf(player);
            } else {
                remove F;
            }
            rtrue;
        }
        if ((T == FoundEverywhere)) {
            give F ~absent;
            ((F.found_in) = FoundEverywhere);
            rtrue;
        }
        return RunTimeProblem(RTP_BACKDROP, F, T);
    }
    if ((T ofclass K9_region)) {
        return RunTimeProblem(RTP_NOTBACKDROP, F, T);
    }
    if ((T == FoundEverywhere)) {
        return RunTimeProblem(RTP_BACKDROPONLY, F);
    }
    if ((~~((F ofclass K2_thing)))) {
        return RunTimeProblem(RTP_NOTTHING, F, T);
    }
    if ((F has worn)) {
        give F ~worn;
        if ((F in T)) {
            rtrue;
        }
    }
    DetachPart(F);
    if ((going_mode == 0)) {
        if ((F == player)) {
            PlayerTo(T, opt);
            rtrue;
        }
        if (IndirectlyContains(F, player)) {
            (L = LocationOf(T));
            if ((L == 0)) {
                return RunTimeProblem(RTP_CANTBEOFFSTAGE);
            }
            if ((LocationOf(player) ~= L)) {
                (was = parent(player));
                move player to real_location;
                move F to T;
                PlayerTo(was, 1);
                rtrue;
            }
        }
    }
    move F to T;
];
[ RemoveFromPlay F;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTREMOVENOTHING);
    }
    if ((F == player)) {
        return RunTimeProblem(RTP_CANTREMOVEPLAYER);
    }
    if ((F ofclass K4_door)) {
        return RunTimeProblem(RTP_CANTREMOVEDOORS);
    }
    if (IndirectlyContains(F, player)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    give F ~worn;
    DetachPart(F);
    if ((F ofclass K7_backdrop)) {
        give F absent;
    }
    remove F;
];
[ OnStage O set x;
    if ((O ofclass K1_room)) {
        rfalse;
    }
    if ((set < 0)) {
        while ((metaclass(O) == Object)) {
            if ((O ofclass K1_room)) {
                rtrue;
            }
            if ((O ofclass K9_region)) {
                rfalse;
            }
            if ((O ofclass K4_door)) {
                rtrue;
            }
            if ((O ofclass K7_backdrop)) {
                if ((O has absent)) {
                    rfalse;
                }
                rtrue;
            }
            (x = (O.component_parent));
            if (x) {
                (O = x);
                continue;
            }
            (x = parent(O));
            if (x) {
                (O = x);
                continue;
            }
            rfalse;
        }
    }
    (x = OnStage(O, (-(1))));
    if (((x) && ((set == 0)))) {
        RemoveFromPlay(O);
    }
    if ((((x == 0)) && (set))) {
        MoveObject(O, real_location);
    }
    rfalse;
];
[ PlayerTo newplace flag L;
    (L = LocationOf(newplace));
    if ((L == 0)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    @push actor;
    (actor = player);
    move player to newplace;
    (location = L);
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if ((flag == 0)) {
        R_Process(##Look);
    }
    if ((flag == 1)) {
        give location visited;
    }
    if ((flag == 2)) {
        AbbreviatedRoomDescription();
    }
    @pull actor;
];
[ MoveDuringGoing F T;
    MoveObject(F, T, 0, 1);
    if ((actor == player)) {
        (location = LocationOf(player));
        (real_location = location);
    }
];
[ FoundEverywhere;
    rtrue;
];
[ BackdropEverywhere O;
    if ((O ofclass K7_backdrop)) {
        if ((O has absent)) {
            rfalse;
        }
        if (((O.found_in) == FoundEverywhere)) {
            rtrue;
        }
    }
    rfalse;
];
[ ChangePlayer obj flag;
    if ((~~((obj ofclass K8_person)))) {
        return RunTimeProblem(RTP_CANTCHANGE, obj);
    }
    if ((~~(OnStage(obj, (-(1)))))) {
        return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
    }
    if ((obj.component_parent)) {
        return RunTimeProblem(RTP_CANTMAKEPART, obj);
    }
    if ((obj == player)) {
        rtrue;
    }
    give player ~concealed;
    if ((player has remove_proper)) {
        give player ~proper;
    }
    if ((player == selfobj)) {
        ((player.saved_short_name) = (player.short_name));
        ((player.short_name) = PRINT_PROTAGONIST_INTERNAL_RM(99));
    }
    (player = obj);
    if ((player == selfobj)) {
        ((player.short_name) = (player.saved_short_name));
    }
    if ((~~((player has proper)))) {
        give player remove_proper;
    }
    give player concealed;
    give player proper;
    (location = LocationOf(player));
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
];
[ MoveFloatingObjects toroom i k l m address flag;
    if ((toroom == 0)) {
        (toroom = real_location);
    }
    if ((toroom == 0)) {
        rtrue;
    }
    objectloop (i ofclass Object && i) {
        (address = (_final_propertyarray(OBJECT_TY, i, A_found_in)));
        if ((((address ~= 0)) && ((~~((i has absent)))))) {
            if ((ZRegion((address-->(0))) == 2)) {
                (m = (address-->(0)));
                .TestPropositionally;
                if (((m)(toroom) ~= 0)) {
                    move i to toroom;
                } else {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            } else {
                (k = (_final_propertylength(OBJECT_TY, i, A_found_in)));
                for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
                    (m = (address-->(l)));
                    if ((ZRegion(m) == 2)) {
                        jump TestPropositionally;
                    }
                    if ((((m == toroom)) || ((m in toroom)))) {
                        if ((i notin toroom)) {
                            move i to toroom;
                        }
                        (flag = 1);
                    }
                }
                if ((flag == 0)) {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            }
            if ((((i ofclass K4_door)) && ((parent(i) == 0)))) {
                move i to _final_message0(i, A_door_to);
            }
        }
    }
];
[ MoveBackdrop bd D x address;
    if ((~~((bd ofclass K7_backdrop)))) {
        return RunTimeProblem(RTP_BACKDROPONLY, bd);
    }
    if (((_final_propertylength(OBJECT_TY, bd, A_found_in)) > WORDSIZE)) {
        (address = (_final_propertyarray(OBJECT_TY, bd, A_found_in)));
        ((address-->(0)) = D);
    } else {
        ((bd.found_in) = D);
    }
    give bd ~absent;
    MoveFloatingObjects();
];
[ BackdropLocation O target address m x i k l r sl;
    if ((O has absent)) {
        rfalse;
    }
    if ((((target == 0 or real_location)) && ((parent(O) == real_location)))) {
        return real_location;
    }
    (address = (_final_propertyarray(OBJECT_TY, O, A_found_in)));
    if ((address ~= 0)) {
        (k = (_final_propertylength(OBJECT_TY, O, A_found_in)));
        for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
            (m = (address-->(l)));
            if ((ZRegion(m) == 2)) {
                (sl = location);
                if (target) {
                    (location = target);
                    (r = (m)());
                    if ((r ~= 0)) {
                        (location = sl);
                        return target;
                    }
                } else {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        (location = x);
                        (r = (m)());
                        if ((r ~= 0)) {
                            (location = sl);
                            return x;
                        }
                    }
                }
                (location = sl);
            } else {
                if ((m ofclass K9_region)) {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        if (TestRegionalContainment(x, m)) {
                            if ((target == 0 or x)) {
                                return x;
                            }
                        }
                    }
                } else {
                    if ((target == 0 or m)) {
                        return m;
                    }
                }
            }
        }
    }
    rfalse;
];
[ WearObject X P opt;
    if ((X == 0)) {
        rfalse;
    }
    if ((X notin P)) {
        MoveObject(X, P, opt);
    }
    give X worn;
];
[ MapConnection from_room dir in_direction through_door;
    if ((((from_room ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((from_room.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room)) {
            return in_direction;
        }
        if ((in_direction ofclass K4_door)) {
            @push location;
            (location = from_room);
            (through_door = _final_message0(in_direction, A_door_to));
            @pull location;
            if ((through_door ofclass K1_room)) {
                return through_door;
            }
        }
    }
    rfalse;
];
[ DoorFrom obj dir rv;
    (rv = RoomOrDoorFrom(obj, dir));
    if ((rv ofclass K4_door)) {
        return rv;
    }
    rfalse;
];
[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
    if ((((obj ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((obj.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room or K4_door)) {
            return in_direction;
        }
    }
    rfalse;
];
[ AssertMapConnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((((in_direction == 0)) || ((in_direction ofclass K1_room)))) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = r2);
        rtrue;
    }
    if ((in_direction ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    RunTimeProblem(RTP_NOEXIT, r1, dir);
];
[ AssertMapUnconnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((r1 ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    if ((in_direction == r2)) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = 0);
    }
    rtrue;
];
[ TestAdjacency R1 R2 i row;
    if ((((R1 == 0)) || ((R2 == 0)))) {
        rfalse;
    }
    if ((R1 ofclass K9_region)) {
        RunTimeProblem(RTP_REGIONSNOTADJACENT, R1);
    } else {
        if ((R2 ofclass K9_region)) {
            RunTimeProblem(RTP_REGIONSNOTADJACENT, R2);
        }
    }
    (row = ((R1.IK1_Count)*No_Directions));
    for ((i = 0):(i < No_Directions):((i)++,(row)++)) {
        if (((Map_Storage-->(row)) == R2)) {
            rtrue;
        }
    }
    rfalse;
];
[ TestRegionalContainment obj region o;
    if ((((obj == 0)) || ((region == 0)))) {
        rfalse;
    }
    if ((obj ofclass K7_backdrop or K4_door)) {
        if ((obj has absent)) {
            rfalse;
        }
        objectloop (o ofclass K1_room && (o ofclass K1_room)) {
            if (TestRegionalContainment(o, region)) {
                if (BackdropLocation(obj, o)) {
                    rtrue;
                }
            }
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        (o = obj);
    } else {
        if ((~~((obj ofclass K1_room)))) {
            (obj = LocationOf(obj));
        }
        if ((obj == 0)) {
            rfalse;
        }
        (o = (obj.map_region));
    }
    while (o) {
        if ((o == region)) {
            rtrue;
        }
        (o = parent(o));
    }
    rfalse;
];
[ FrontSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(0));
    }
    return parent(D);
];
[ BackSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(1));
    }
    rfalse;
];
[ OtherSideOfDoor D from_room rv;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_to));
        @pull location;
    }
    return rv;
];
[ DirectionDoorLeadsIn D from_room rv dir;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_dir));
        @pull location;
    }
    return rv;
];
[ TestVisibility A B;
    if ((~~(OffersLight(parent(CoreOf(A)))))) {
        rfalse;
    }
    if (suppress_scope_loops) {
        rtrue;
    }
    return TestScope(B, A);
];
[ TestTouchability A B rv;
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(B));
    }
    if ((B ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(A));
    }
    if ((TestScope(B, A) == 0)) {
        (rv = 1);
    } else {
        (rv = ObjectIsUntouchable(B, 1, A));
    }
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects();
    }
    if (rv) {
        rfalse;
    }
    rtrue;
];
[ TestConcealment A B;
    if ((((A ofclass K2_thing)) && ((B ofclass K2_thing)))) {
        if (IndirectlyContains(A, B)) {
            (particular_possession = B);
            if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ SignalMapChange;
    (map_has_changed = 1);
];
[ MapRouteTo from to filter use_doors count oy oyi ds;
    if ((from == 0)) {
        rfalse;
    }
    if ((to == 0)) {
        rfalse;
    }
    if ((from == to)) {
        rfalse;
    }
    if (((filter) && (((filter)(from) == 0)))) {
        rfalse;
    }
    if (((filter) && (((filter)(to) == 0)))) {
        rfalse;
    }
    if ((((last_filter ~= filter)) || ((last_use_doors ~= use_doors)))) {
        (map_has_changed = 1);
    }
    (oyi = 0);
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if ((((filter == 0)) || ((filter)(oy)))) {
            if (((oy.room_index) == -1)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = (oyi)++);
        } else {
            if (((oy.room_index) >= 0)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = -1);
        }
    }
    (oyi = 0);
    objectloop (oy ofclass K4_door && (oy ofclass K4_door)) {
        (ds = 0);
        if (((((((use_doors)&(2))) || ((oy has open)))) || ((((oy has openable)) && ((~~((oy has locked)))))))) {
            (ds = 1);
        }
        if (((DoorRoutingViable->(oyi)) ~= ds)) {
            (map_has_changed = 1);
        }
        ((DoorRoutingViable->(oyi)) = ds);
        (oyi)++;
    }
    if (map_has_changed) {
        ComputeFWMatrix(filter, use_doors);
        (map_has_changed = 0);
        (last_filter = filter);
        (last_use_doors = use_doors);
    }
    if (count) {
        return FastCountRouteTo(from, to, filter, use_doors);
    }
    return FastRouteTo(from, to, filter, use_doors);
];
[ FastRouteTo from to filter use_doors diri i dir oy;
    if ((from == to)) {
        rfalse;
    }
    (i = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((i == 0)) {
        rfalse;
    }
    (diri = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))%No_Directions));
    (i = 0);
    objectloop (dir ofclass K3_direction && (dir ofclass K3_direction)) {
        if ((i == diri)) {
            return dir;
        }
        (i)++;
    }
    rfalse;
];
[ FastCountRouteTo from to filter use_doors k;
    if ((from == to)) {
        rfalse;
    }
    (k = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((k == 0)) {
        return (-(1));
    }
    return k;
];
[ ComputeFWMatrix filter use_doors oy ox oj axy ayj axj dir diri nd row;
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = 0);
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            (row = ((oy.IK1_Count)*No_Directions));
            for ((diri = 0):(diri < No_Directions):(diri)++) {
                (ox = (Map_Storage-->((row + diri))));
                if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                    continue;
                }
                if (((((use_doors) && ((ox ofclass K4_door)))) && (((((use_doors)&(2))) || ((DoorRoutingViable->((ox.IK4_Count)))))))) {
                    @push location;
                    (location = oy);
                    (ox = _final_message0(ox, A_door_to));
                    @pull location;
                    if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                        ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                        continue;
                    }
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    (axy = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))/No_Directions));
                    if ((axy > 0)) {
                        objectloop (oj ofclass Object && (oj has mark_as_room)) {
                            if (((oj.room_index) >= 0)) {
                                (ayj = ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                if ((ayj > 0)) {
                                    (axj = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index)))) = (((axy + ayj)*No_Directions) + ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))%No_Directions)));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
];
[ RunTimeProblemShowWM n par1 par2 par3;
    switch (n) {
        RTP_BACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (a backdrop) to ";
            DefArt(par2);
            print ", which is not a region.^";
            ;
        RTP_CANTCHANGE:
            print "Tried to change player to ";
            DefArt(par1);
            print ", which is not a person.^";
            ;
        RTP_NOEXIT:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it didn't seem to have such an exit to change.^";
            ;
        RTP_EXITDOOR:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it led to a door, not a room.^";
            ;
        RTP_TOOMANYEVENTS:
            print "Too many timed events are going on at once.^";
            ;
        RTP_CANTMOVENOTHING:
            print "You can't move nothing.^";
            ;
        RTP_CANTREMOVENOTHING:
            print "You can't remove nothing from play.^";
            ;
        RTP_NOTBACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (not a backdrop) to ";
            DefArt(par2);
            print ", which is a region.^";
            ;
        RTP_NOTINAROOM:
            print "Attempt to test if the current location is '";
            DefArt(par1);
            print "', which is not a room or region.^";
            ;
        RTP_BADTOPIC:
            print "Attempt to see if a snippet of text matches something which is not a topic.^";
            ;
        RTP_DONTIGNORETURNSEQUENCE:
            print "Attempt to ignore the turn sequence rules.^";
            ;
        RTP_SAYINVALIDSNIPPET:
            print "Attempt to say a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_SPLICEINVALIDSNIPPET:
            print "Attempt to splice a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_INCLUDEINVALIDSNIPPET:
            print "Attempt to match a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_CANTREMOVEPLAYER:
            print "Attempt to remove the player from play.^";
            ;
        RTP_CANTBEOFFSTAGE:
            print "Attempt to move the player off-stage.^";
            ;
        RTP_CANTREMOVEDOORS:
            print "Attempt to remove a door from play.^";
            ;
        RTP_CANTCHANGEOFFSTAGE:
            print "Attempt to change the player to a person off-stage.^";
            ;
        RTP_BACKDROPONLY:
            print "Only backdrops can be moved to multiple places.^";
            ;
        RTP_NOTTHING:
            print "Tried to move ";
            DefArt(par1);
            print " (not a thing) to ";
            DefArt(par2);
            print ", but only things can move around.^";
            ;
        RTP_CANTMAKEPART:
            print "Tried to make the player part of something: ";
            DefArt(par1);
            print ".^";
            ;
        RTP_REGIONSNOTADJACENT:
            print "You can't test whether something is adjacent to a region: ";
            print "such as, in this case, ";
            DefArt(par1);
            print ".^";
            ;
        RTP_SCENEHASNTSTARTED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't started, so you can't ask when it did.^";
            ;
        RTP_SCENEHASNTENDED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't ended, so you can't ask when it did.^";
            ;
    }
];
[ NUMBER_TY_to_TIME_TY n;
    (n = (n%1440));
    if ((n < 0)) {
        return (n + 1440);
    }
    return n;
];
[ PrintTimeOfDay t h aop;
    if ((t < 0)) {
        print "<no time>";
        rtrue;
    }
    if ((t >= TWELVE_HOURS)) {
        (aop = "pm");
        (t = (t - TWELVE_HOURS));
    } else {
        (aop = "am");
    }
    (h = (t/ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    print h;
    print ":";
    if (((t%ONE_HOUR) < 10)) {
        print "0";
    }
    print (t%ONE_HOUR);
    print " ";
    print (string) aop;
];
[ PrintTimeOfDayEnglish t h m dir aop;
    (h = ((t/ONE_HOUR)%12));
    (m = (t%ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    if ((m == 0)) {
        LanguageNumber(h);
        print " o'clock";
        rtrue;
    }
    (dir = "past");
    if ((m > HALF_HOUR)) {
        (m = (ONE_HOUR - m));
        (h = ((h + 1)%12));
        if ((h == 0)) {
            (h = 12);
        }
        (dir = "to");
    }
    switch (m) {
        QUARTER_HOUR:
            print "quarter";
            ;
        HALF_HOUR:
            print "half";
            ;
        default:
            LanguageNumber(m);
            if (((m%5) ~= 0)) {
                if ((m == 1)) {
                    print " minute";
                } else {
                    print " minutes";
                }
            }
            ;
    }
    print " ";
    print (string) dir;
    print " ";
    LanguageNumber(h);
];
[ TIME_TOKEN first_word second_word at length flag illegal_char offhour hr mn i original_wn;
    (original_wn = wn);
    (i = TIME_TOKEN_INNER());
    if ((i ~= GPR_FAIL)) {
        return i;
    }
    (wn = original_wn);
    (first_word = NextWordStopped());
    switch (first_word) {
        'midnight':
            (parsed_number = 0);
            return GPR_NUMBER;
            ;
        'midday', 'noon':
            (parsed_number = TWELVE_HOURS);
            return GPR_NUMBER;
            ;
    }
    (at = WordAddress((wn - 1)));
    (length = WordLength((wn - 1)));
    for ((i = 0):(i < length):(i)++) {
        switch ((at->(i))) {
            58:
                if ((((((flag == 0)) && ((i > 0)))) && ((i < (length - 1))))) {
                    (flag = 1);
                } else {
                    (illegal_char = 1);
                }
                ;
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
                ;
            default:
                (illegal_char = 1);
                ;
        }
    }
    if ((((((length < 3)) || ((length > 5)))) || (illegal_char))) {
        (flag = 0);
    }
    if (flag) {
        for ((i = 0):((at->(i)) ~= 58):((i)++,(hr = (hr*10)))) {
            (hr = ((hr + (at->(i))) - 48));
        }
        (hr = (hr/10));
        for ((i)++:(i < length):((i)++,(mn = (mn*10)))) {
            (mn = ((mn + (at->(i))) - 48));
        }
        (mn = (mn/10));
        (second_word = NextWordStopped());
        (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
        if ((parsed_number == -1)) {
            return GPR_FAIL;
        }
        if ((second_word ~= 'pm' or 'am')) {
            (wn)--;
        }
        return GPR_NUMBER;
    }
    (offhour = -1);
    if ((first_word == 'half')) {
        (offhour = HALF_HOUR);
    }
    if ((first_word == 'quarter')) {
        (offhour = QUARTER_HOUR);
    }
    if ((offhour < 0)) {
        (offhour = TryNumber((wn - 1)));
    }
    if ((((offhour < 0)) || ((offhour >= ONE_HOUR)))) {
        return GPR_FAIL;
    }
    (second_word = NextWordStopped());
    switch (second_word) {
        'o^clock', 'am', 'pm', (-(1)):
            (hr = offhour);
            if ((hr > 12)) {
                return GPR_FAIL;
            }
            ;
        'to', 'past':
            (mn = offhour);
            (hr = TryNumber(wn));
            if ((hr <= 0)) {
                switch (NextWordStopped()) {
                    'noon', 'midday':
                        (hr = 12);
                        ;
                    'midnight':
                        (hr = 0);
                        ;
                    default:
                        return GPR_FAIL;
                        ;
                }
            }
            if ((hr >= 13)) {
                return GPR_FAIL;
            }
            if ((second_word == 'to')) {
                (mn = (ONE_HOUR - mn));
                (hr)--;
                if ((hr < 0)) {
                    (hr = 23);
                }
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
        default:
            (hr = offhour);
            (mn = TryNumber(--(wn)));
            if ((((mn < 0)) || ((mn >= ONE_HOUR)))) {
                return GPR_FAIL;
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
    }
    (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
    if ((parsed_number < 0)) {
        return GPR_FAIL;
    }
    if ((second_word ~= 'pm' or 'am' or 'o^clock')) {
        (wn)--;
    }
    return GPR_NUMBER;
];
[ HoursMinsWordToTime hour minute word x;
    if ((hour >= 24)) {
        return (-(1));
    }
    if ((minute >= ONE_HOUR)) {
        return (-(1));
    }
    (x = ((hour*ONE_HOUR) + minute));
    if ((hour >= 13)) {
        return x;
    }
    (x = (x%TWELVE_HOURS));
    if ((word == 'pm')) {
        (x = (x + TWELVE_HOURS));
    }
    if ((((word ~= 'am' or 'pm')) && ((hour == 12)))) {
        (x = (x + TWELVE_HOURS));
    }
    return x;
];
[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
    (original_wn = wn);
    (wn = original_wn);
    (first_word = NextWordStopped());
    (wn)--;
    if ((first_word == 'an' or 'a//')) {
        (mn = 1);
    } else {
        (mn = TryNumber(wn));
    }
    if ((mn == -1000)) {
        (first_word = NextWordStopped());
        if ((first_word == 'half')) {
            (offhour = HALF_HOUR);
        }
        if ((first_word == 'quarter')) {
            (offhour = QUARTER_HOUR);
        }
        if ((offhour > 0)) {
            (second_word = NextWordStopped());
            if ((second_word == 'of')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'an')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'hour')) {
                (parsed_number = offhour);
                return GPR_NUMBER;
            }
        }
        return GPR_FAIL;
    }
    (wn)++;
    (first_word = NextWordStopped());
    switch (first_word) {
        'minutes', 'minute':
            (mult = 1);
            ;
        'hours', 'hour':
            (mult = 60);
            ;
        default:
            return GPR_FAIL;
            ;
    }
    (parsed_number = (mn*mult));
    if ((mult == 60)) {
        (mn = TryNumber(wn));
        if ((mn ~= -1000)) {
            (wn)++;
            (first_word = NextWordStopped());
            if ((first_word == 'minutes' or 'minute')) {
                (parsed_number = (parsed_number + mn));
            } else {
                (wn = (wn - 2));
            }
        }
    }
    return GPR_NUMBER;
];
[ SCENE_CHANGE_MACHINERY_R;
    DetectSceneChange();
];
[ DuringSceneMatching prop sc;
    for ((sc = 0):(sc < NUMBER_SCENES_CREATED):(sc)++) {
        if (((((scene_status-->(sc)) == 1)) && ((prop)((sc + 1))))) {
            rtrue;
        }
    }
    rfalse;
];
[ SceneUtility sc task;
    if ((sc <= 0)) {
        rfalse;
    }
    if ((task == 1 or 2)) {
        if (((scene_endings-->((sc - 1))) == 0)) {
            return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
        }
    } else {
        if (((scene_endings-->((sc - 1))) <= 1)) {
            return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
        }
    }
    switch (task) {
        1:
            return ((the_time - (scene_started-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        2:
            return (scene_started-->((sc - 1)));
            ;
        3:
            return ((the_time - (scene_ended-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        4:
            return (scene_ended-->((sc - 1)));
            ;
    }
];
[ XAbstractSub;
    if (XTestMove(noun, second)) {
        rtrue;
    }
    move noun to second;
    (say__p = 1);
    print "[Abstracted.]";
    new_line;
    rtrue;
];
[ XTestMove obj dest;
    if ((obj.component_parent)) {
        print "[Can't move ";
        PrintShortName(obj);
        print ": it's part of ";
        DefArt((obj.component_parent));
        print ".]";
        print "^";
        rtrue;
    }
    while (dest) {
        if ((dest == obj)) {
            print "[Can't move ";
            PrintShortName(obj);
            print ": it would contain itself.]";
            print "^";
            rtrue;
        }
        (dest = CoreOfParentOfCoreOf(dest));
    }
    rfalse;
];
[ ActionsOnSub;
    (trace_actions = 1);
    (say__p = 1);
    print "Actions listing on.";
    new_line;
    rtrue;
];
[ ActionsOffSub;
    (trace_actions = 0);
    (say__p = 1);
    print "Actions listing off.";
    new_line;
    rtrue;
];
[ GonearSub;
    PlayerTo(LocationOf(noun));
];
[ XPurloinSub;
    if (XTestMove(noun, player)) {
        rtrue;
    }
    move noun to player;
    give noun moved;
    give noun ~concealed;
    (say__p = 1);
    print "[Purloined.]";
    new_line;
    rtrue;
];
[ PredictableSub;
    VM_Seed_RNG(-100);
    (say__p = 1);
    print "[Random number generator now predictable.]";
    new_line;
    rtrue;
];
[ ShowRelationsSub;
    IterateRelations(ShowOneRelation);
];
[ ShowOneRelation rel;
    if (((RlnGetF(rel, RR_PERMISSIONS))&(RELS_SHOW))) {
        (RlnGetF(rel, RR_HANDLER))(rel,RELS_SHOW);
    }
];
[ ShowResponsesSub a i j reg wd set_mode;
    if ((NO_RESPONSES == 0)) {
        print "There are no lettered responses.";
        new_line;
        rtrue;
    }
    (wn = 2);
    if ((NextWordStopped() == 'now')) {
        (set_mode = 1);
    } else {
        (wn)--;
    }
    if ((NextWordStopped() == 'set')) {
        (set_mode = 2);
    } else {
        (wn)--;
    }
    (wd = NextWordStopped());
    (wn)--;
    if ((wd == 'all')) {
        (reg = 0);
    } else {
        (reg = -1);
        if ((wd ~= -1)) {
            (reg = TryNumber(wn));
        }
        if ((reg < 0)) {
            (say__p = 1);
            print ">--> The following sets of responses are available:^";
            print "    RESPONSES ALL^";
        }
    }
    for (((a = 0),((i = 1),(j = 0))):(ResponseDivisions-->(a)):((a = (a + 3)),(i)++)) {
        if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
            (j)++;
        }
        if ((((reg == 0)) || ((reg == j)))) {
            if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
                if (set_mode) {
                    print "[";
                    print (string) (ResponseDivisions-->(a));
                    print "]^";
                } else {
                    print (string) (ResponseDivisions-->(a));
                    print ":^";
                }
            }
            ShowResponsesRange((ResponseDivisions-->((a + 1))), (ResponseDivisions-->((a + 2))), set_mode);
        }
        if ((reg < 0)) {
            if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
                print "    RESPONSES ";
                print j;
                print ": ";
                print (string) (ResponseDivisions-->(a));
                print "^";
            }
        }
    }
];
[ ShowResponsesRange from to set_mode i;
    (say__p = 1);
    for ((i = from):(i <= to):(i)++) {
        switch (set_mode) {
            1:
                print "now ";
                ;
            2:
                ;
            0:
                print "    ";
                ;
        }
        PrintResponse(i);
        switch (set_mode) {
            1:
                print " is ";
                ;
            2:
                print " is ";
                ;
            0:
                print ": ";
                ;
        }
        (suppress_text_substitution = 1);
        CarryOutActivity(PRINTING_RESPONSE_ACT, i);
        (suppress_text_substitution = 0);
        switch (set_mode) {
            1:
                print ";";
                ;
            2:
                print ".";
                ;
        }
        print "^";
    }
];
[ RulesOnSub;
    (debug_rules = 1);
    (say__p = 1);
    print "Rules tracing now switched on. Type ~rules off~ to switch it off again, or ~rules all~ to include even rules which do not apply.";
    new_line;
    rtrue;
];
[ RulesAllSub;
    (debug_rules = 2);
    (say__p = 1);
    print "Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
    new_line;
    rtrue;
];
[ RulesOffSub;
    (debug_rules = 0);
    (say__p = 1);
    print "Rules tracing now switched off. Type ~rules~ to switch it on again.";
    new_line;
    rtrue;
];
[ ScenesOnSub;
    (debug_scenes = 1);
    ShowSceneStatus();
    (say__p = 1);
    print "(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
    new_line;
    rtrue;
];
[ ScenesOffSub;
    (debug_scenes = 0);
    (say__p = 1);
    print "(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
    new_line;
    rtrue;
];
[ ScopeSub;
    (x_scope_count = 0);
    LoopOverScope(Print_ScL, noun);
    if ((x_scope_count == 0)) {
        print "Nothing is in scope.";
        new_line;
        rtrue;
    }
];
[ Print_ScL obj;
    print ++(x_scope_count);
    print ": ";
    IndefArt(obj);
    print " (";
    print obj;
    print ")";
    print "^";
    rtrue;
];
[ ShowHeapSub;
    HeapDebug();
];
[ ShowMeSub t_0 na;
    (t_0 = noun);
    if ((noun == 0)) {
        (noun = real_location);
    }
    if (ShowMeRecursively(noun, 0, (noun == real_location))) {
        if ((noun == real_location)) {
            print "* denotes things which are not in scope^";
        }
    }
    if ((t_0 ofclass K2_thing)) {
        print "location:";
        ShowRLocation(noun, 1);
        print "^";
    }
    (na = ShowMeKindDetails(0, na, t_0));
    (na = ShowMeInstanceDetails(0, na, t_0));
    (na = ShowMeKindDetails(1, na, t_0));
    (na = ShowMeInstanceDetails(1, na, t_0));
];
[ ShowRLocation obj top;
    if ((obj ofclass K1_room)) {
        rtrue;
    }
    print " ";
    if (parent(obj)) {
        if ((obj has worn)) {
            print "worn by ";
        } else {
            if ((parent(obj) has animate)) {
                print "carried by ";
            }
            if ((parent(obj) has container)) {
                print "in ";
            }
            if ((parent(obj) ofclass K1_room)) {
                print "in ";
            }
            if ((parent(obj) has supporter)) {
                print "on ";
            }
        }
        DefArt(parent(obj));
        ShowRLocation(parent(obj));
    } else {
        if ((obj.component_parent)) {
            if ((top == 0)) {
                print ", which is ";
            }
            print "part of ";
            DefArt((obj.component_parent));
            ShowRLocation((obj.component_parent));
        } else {
            print "out of play";
        }
    }
];
[ ShowMeRecursively obj depth f c i k;
    spaces (2*depth);
    if (((((f) && ((depth > 0)))) && ((TestScope(obj, player) == 0)))) {
        print "*";
        (c = 1);
    }
    PrintShortName(obj);
    if ((depth > 0)) {
        if ((obj.component_parent)) {
            print " (part of ";
            PrintShortName((obj.component_parent));
            print ")";
        }
        if ((obj has worn)) {
            print " (worn)";
        }
    }
    if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
        (k = (KindHierarchy-->(((obj.KD_Count)*2))));
        if ((((k ~= K2_thing)) || ((depth == 0)))) {
            print " - ";
            if ((k == K4_door or K5_container)) {
                if ((obj has transparent)) {
                    print "transparent ";
                }
                if ((obj has locked)) {
                    print "locked ";
                } else {
                    if ((obj has open)) {
                        print "open ";
                    } else {
                        print "closed ";
                    }
                }
            }
            I7_Kind_Name(k);
        }
    }
    print "^";
    if ((obj.component_child)) {
        (c = ((c)|(ShowMeRecursively((obj.component_child), (depth + 2), f))));
    }
    if (child(obj)) {
        (c = ((c)|(ShowMeRecursively(child(obj), (depth + 2), f))));
    }
    if ((((depth > 0)) && ((obj.component_sibling)))) {
        (c = ((c)|(ShowMeRecursively((obj.component_sibling), depth, f))));
    }
    if ((((depth > 0)) && (sibling(obj)))) {
        (c = ((c)|(ShowMeRecursively(sibling(obj), depth, f))));
    }
    return c;
];
[ AllowInShowme pr;
    if ((pr == A_workflag or A_concealed or A_mentioned)) {
        rfalse;
    }
    rtrue;
];
[ ShowVerbSub address lines meta i x;
    (wn = 2);
    (x = NextWordStopped());
    if ((((x == 0)) || (((((x->(#dict_par1)))&(1)) == 0)))) {
        print "Try typing ~showverb~ and then the name of a verb.";
        new_line;
        rtrue;
    }
    (meta = ((((x->(#dict_par1)))&(2))/2));
    (i = DictionaryWordToVerbNum(x));
    (address = VM_CommandTableAddress(i));
    (lines = (address->(0)));
    (address)++;
    print "Verb ";
    if (meta) {
        print "meta ";
    }
    VM_PrintCommandWords(i);
    print "^";
    if ((lines == 0)) {
        print "has no grammar lines.^";
    }
    for (:(lines > 0):(lines)--) {
        (address = UnpackGrammarLine(address));
        print "    ";
        DebugGrammarLine();
        print "^";
    }
    ParaContent();
];
[ DebugGrammarLine pcount;
    print " * ";
    for (:((line_token-->(pcount)) ~= ENDIT_TOKEN):(pcount)++) {
        if (((((line_token-->(pcount))->(0)))&(16))) {
            print "/ ";
        }
        DebugToken((line_token-->(pcount)));
        print " ";
    }
    print "-> ";
    DebugAction(action_to_be);
    if (action_reversed) {
        print " reverse";
    }
];
[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
        ILLEGAL_TT:
            print "<illegal token number ";
            print token;
            print ">";
            ;
        ELEMENTARY_TT:
            switch (found_tdata) {
                NOUN_TOKEN:
                    print "noun";
                    ;
                HELD_TOKEN:
                    print "held";
                    ;
                MULTI_TOKEN:
                    print "multi";
                    ;
                MULTIHELD_TOKEN:
                    print "multiheld";
                    ;
                MULTIEXCEPT_TOKEN:
                    print "multiexcept";
                    ;
                MULTIINSIDE_TOKEN:
                    print "multiinside";
                    ;
                CREATURE_TOKEN:
                    print "creature";
                    ;
                SPECIAL_TOKEN:
                    print "special";
                    ;
                NUMBER_TOKEN:
                    print "number";
                    ;
                TOPIC_TOKEN:
                    print "topic";
                    ;
                ENDIT_TOKEN:
                    print "END";
                    ;
            }
            ;
        PREPOSITION_TT:
            print "'";
            print (address) found_tdata;
            print "'";
            ;
        ROUTINE_FILTER_TT:
            print "noun=Routine(";
            print found_tdata;
            print ")";
            ;
        ATTR_FILTER_TT:
            DebugAttribute(found_tdata);
            ;
        SCOPE_TT:
            print "scope=Routine(";
            print found_tdata;
            print ")";
            ;
        GPR_TT:
            print "Routine(";
            print found_tdata;
            print ")";
            ;
    }
];
[ TestStart T R l k;
    if ((test_sp >= TEST_STACK_SIZE)) {
        print ">--> Testing too many levels deep";
        new_line;
        rtrue;
    }
    ((test_stack-->(test_sp)) = T);
    ((test_stack-->((test_sp + 1))) = 0);
    ((test_stack-->((test_sp + 3))) = l);
    (test_sp = (test_sp + 4));
    if ((((R-->(0))) && (((R-->(0)) ~= real_location)))) {
        print "(first moving to ";
        PrintShortName((R-->(0)));
        print ")^";
        PlayerTo((R-->(0)), 1);
    }
    (k = 1);
    while ((R-->(k))) {
        if (((R-->(k)) notin player)) {
            print "(first acquiring ";
            DefArt((R-->(k)));
            print ")^";
            move (R-->(k)) to player;
        }
        (k)++;
    }
    print "(Testing.)^";
    (say__p = 1);
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
    if ((test_sp == 0)) {
        ((test_stack-->(2)) = 1);
        return VM_ReadKeyboard(a_buffer, a_table);
    } else {
        (p = (test_stack-->((test_sp - 4))));
        (i = (test_stack-->((test_sp - 3))));
        (l = (test_stack-->((test_sp - 1))));
        print "[";
        print (test_stack-->(2));
        print "] ";
        ((test_stack-->(2)) = ((test_stack-->(2)) + 1));
        style bold;
        while ((((i < l)) && (((p->(i)) ~= 47)))) {
            (ch = (p->(i)));
            if (((spaced) || ((ch ~= 32)))) {
                if (((((((p->(i)) == 91)) && (((p->((i + 1))) == 47)))) && (((p->((i + 2))) == 93)))) {
                    (ch = 47);
                    (i = (i + 2));
                }
                ((a_buffer->((j + WORDSIZE))) = ch);
                print (char) ch;
                (i)++;
                (j)++;
                (spaced = 1);
            } else {
                (i)++;
            }
        }
        style roman;
        print "^";
        ((a_buffer-->(0)) = j);
        VM_Tokenise(a_buffer, a_table);
        if (((p->(i)) == 47)) {
            (i)++;
        }
        if ((i >= l)) {
            (test_sp = (test_sp - 4));
        } else {
            ((test_stack-->((test_sp - 3))) = i);
        }
    }
];
[ TraceOnSub;
    (parser_trace = 1);
    (say__p = 1);
    print "[Trace on.]";
    new_line;
    rtrue;
];
[ TraceLevelSub;
    (parser_trace = parsed_number);
    (say__p = 1);
    print "[Parser tracing set to level ";
    print parser_trace;
    print ".]^";
];
[ TraceOffSub;
    (parser_trace = 0);
    (say__p = 1);
    print "Trace off.";
    new_line;
    rtrue;
];
[ XTreeSub i;
    if ((noun == 0)) {
        objectloop (i ofclass Object && i) {
            if ((((i ofclass Object)) && ((parent(i) == 0)))) {
                XObj(i);
            }
        }
    } else {
        XObj(noun, 1);
    }
];
[ XObj obj f;
    if ((parent(obj) == 0)) {
        PrintShortName(obj);
    } else {
        IndefArt(obj);
    }
    print " (";
    print obj;
    print ") ";
    if ((((f == 1)) && ((parent(obj) ~= 0)))) {
        print "(in ";
        PrintShortName(parent(obj));
        print " ";
        print parent(obj);
        print ")";
    }
    print "^";
    if ((child(obj) == 0)) {
        rtrue;
    }
    if ((obj == Class)) {
        WriteListFrom(child(obj), (((NEWLINE_BIT + INDENT_BIT) + ALWAYS_BIT) + NOARTICLE_BIT), 1);
    } else {
        WriteListFrom(child(obj), (((NEWLINE_BIT + INDENT_BIT) + ALWAYS_BIT) + FULLINV_BIT), 1);
    }
];
[ testcommandnoun obj o2;
    switch (scope_stage) {
        1:
            rtrue;
            ;
        2:
            objectloop (obj ofclass Object && obj) {
                if ((((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))))) {
                    PlaceInScope(obj, 1);
                }
            }
            ;
        3:
            print "There seems to be no such object anywhere in the model world.^";
            ;
    }
];
[ ChronologyPoint pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        ((past_chronological_record-->(pt)) = (present_chronological_record-->(pt)));
    }
];
[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        TestSinglePastState(0, pt, 1, (-(1)));
    }
    ChronologyPoint();
    rfalse;
];
[ TrackActions readjust oow i;
    for ((i = 0):(PastActionsI6Routines-->(i)):(i)++) {
        if (((PastActionsI6Routines-->(i)))()) {
            if (readjust) {
                continue;
            }
            ((TimesActionHasHappened-->(i)))++;
            if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                ((LastTurnActionHappenedOn-->(i)) = (turns + 5));
                ((ActionCurrentlyHappeningFlag->(i)) = 1);
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)))++;
                }
            }
        } else {
            if ((oow == 0)) {
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)) = 0);
                }
                if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                    ((ActionCurrentlyHappeningFlag->(i)) = 0);
                }
            }
        }
    }
];
[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return STORED_ACTION_TY_Create(arg2);
            ;
        DESTROY_KOVS:
            STORED_ACTION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return 6;
            ;
        COPY_KOVS:
            STORED_ACTION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return STORED_ACTION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return STORED_ACTION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            STORED_ACTION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ STORED_ACTION_TY_Create sb stora;
    (stora = FlexAllocate((6*WORDSIZE), STORED_ACTION_TY, BLK_FLAG_WORD));
    BlkValueWrite(stora, STORA_ACTION_F, ##Wait, 1);
    BlkValueWrite(stora, STORA_NOUN_F, 0, 1);
    BlkValueWrite(stora, STORA_SECOND_F, 0, 1);
    BlkValueWrite(stora, STORA_ACTOR_F, player, 1);
    BlkValueWrite(stora, STORA_REQUEST_F, 0, 1);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, 1);
    return BlkValueCreateSB1(sb, stora);
];
[ STORED_ACTION_TY_New a n s ac req stora;
    if ((stora == 0)) {
        (stora = BlkValueCreate(STORED_ACTION_TY));
    }
    BlkValueWrite(stora, STORA_ACTION_F, a);
    BlkValueWrite(stora, STORA_NOUN_F, n);
    BlkValueWrite(stora, STORA_SECOND_F, s);
    BlkValueWrite(stora, STORA_ACTOR_F, ac);
    BlkValueWrite(stora, STORA_REQUEST_F, req);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    return stora;
];
[ STORED_ACTION_TY_Destroy stora toc;
    (toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (toc) {
        BlkValueFree(toc);
    }
];
[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
    (tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F));
    if ((tocfrom == 0)) {
        rtrue;
    }
    (tocto = BlkValueCreate(TEXT_TY));
    BlkValueCopy(tocto, tocfrom);
    BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];
[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
    (delta = (BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F)));
    if (delta) {
        return delta;
    }
    (itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F));
    (itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F));
    if ((((itleft ~= 0)) && ((itright ~= 0)))) {
        return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
    }
    return (itleft - itright);
];
[ STORED_ACTION_TY_Distinguish stora1 stora2;
    if ((STORED_ACTION_TY_Compare(stora1, stora2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ STORED_ACTION_TY_Hash stora rv it;
    (rv = BlkValueRead(stora, STORA_ACTION_F));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_NOUN_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_SECOND_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_ACTOR_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_REQUEST_F)));
    (it = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if ((it ~= 0)) {
        (rv = ((rv*33) + TEXT_TY_Support(HASH_KOVS, it)));
    }
    return rv;
];
[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    (saved_pn = parsed_number);
    (saved_action = action);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (cf = consult_from);
    (cw = consult_words);
    (at = FindAction(-1));
    (K1 = (ActionData-->((at + AD_NOUN_KOV))));
    (K2 = (ActionData-->((at + AD_SECOND_KOV))));
    if ((K1 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        if ((((K1 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    if ((K2 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        if ((((K2 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    DB_Action(BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F), 1);
    (parsed_number = saved_pn);
    (action = saved_action);
    (consult_from = cf);
    (consult_words = cw);
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
];
[ STORED_ACTION_TY_Involves stora item at;
    (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
    if (at) {
        if (((((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_NOUN_F) == item)))) {
            rtrue;
        }
        if (((((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_SECOND_F) == item)))) {
            rtrue;
        }
    }
    if ((BlkValueRead(stora, STORA_ACTOR_F) == item)) {
        rtrue;
    }
    rfalse;
];
[ STORED_ACTION_TY_Part stora ind at ado;
    if ((ind == STORA_NOUN_F or STORA_SECOND_F)) {
        if ((ind == STORA_NOUN_F)) {
            (ado = AD_NOUN_KOV);
        } else {
            (ado = AD_SECOND_KOV);
        }
        (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
        if (((at) && (((ActionData-->((at + ado))) == OBJECT_TY)))) {
            return BlkValueRead(stora, ind);
        }
        rfalse;
    }
    return BlkValueRead(stora, ind);
];
[ STORED_ACTION_TY_Adopt stora at;
    ((SAT_Tmp-->(1)) = action);
    ((SAT_Tmp-->(2)) = noun);
    ((SAT_Tmp-->(3)) = second);
    ((SAT_Tmp-->(4)) = actor);
    ((SAT_Tmp-->(5)) = act_requester);
    ((SAT_Tmp-->(6)) = parsed_number);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        (noun = BlkValueRead(stora, STORA_NOUN_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        (noun = 0);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        (second = BlkValueRead(stora, STORA_SECOND_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        (second = 0);
    }
    (actor = BlkValueRead(stora, STORA_ACTOR_F));
    if (BlkValueRead(stora, STORA_REQUEST_F)) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
];
[ STORED_ACTION_TY_Unadopt;
    (action = (SAT_Tmp-->(1)));
    (noun = (SAT_Tmp-->(2)));
    (second = (SAT_Tmp-->(3)));
    (actor = (SAT_Tmp-->(4)));
    (act_requester = (SAT_Tmp-->(5)));
    (parsed_number = (SAT_Tmp-->(6)));
    return (SAT_Tmp-->(0));
];
[ STORED_ACTION_TY_Current stora at text_of_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rfalse;
    }
    BlkValueWrite(stora, STORA_ACTION_F, action);
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_NOUN_F, noun);
    } else {
        BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_SECOND_F, second);
    } else {
        BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
    }
    BlkValueWrite(stora, STORA_ACTOR_F, actor);
    if (act_requester) {
        BlkValueWrite(stora, STORA_REQUEST_F, 1);
    } else {
        BlkValueWrite(stora, STORA_REQUEST_F, 0);
    }
    if (((at) && (((((ActionData-->((at + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((at + AD_SECOND_KOV))) == UNDERSTANDING_TY)))))) {
        (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
        if ((text_of_command == 0)) {
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
        }
        BlkValueCast(text_of_command, SNIPPET_TY, players_command);
    } else {
        BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    }
    return stora;
];
[ STORED_ACTION_TY_Try stora ks text_of_command saved_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    if (ks) {
        @push keep_silent;
        (keep_silent = 1);
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    TryAction(BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F));
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    if (ks) {
        @pull keep_silent;
    }
];
[ WordCount;
    return (parse-->(0));
];
[ WordAddress wordnum;
    return (buffer + (parse-->((wordnum*3))));
];
[ WordLength wordnum;
    return (parse-->(((wordnum*3) - 1)));
];
[ WordFrom w p i j wc;
    (wc = (p-->(0)));
    (i = ((w*3) - 2));
    if ((((w < 1)) || ((w > wc)))) {
        rfalse;
    }
    (j = (p-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWord i j wc;
    (wc = (parse-->(0)));
    (i = ((wn*3) - 2));
    (wn)++;
    if ((((wn < 2)) || ((wn > (wc + 1))))) {
        rfalse;
    }
    (j = (parse-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWordStopped wc;
    (wc = (parse-->(0)));
    if ((((wn < 1)) || ((wn > wc)))) {
        (wn)++;
        return (-(1));
    }
    return NextWord();
];
[ PrintSnippet snip from to i w1 w2;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((((w2 < w1)) || ((w1 < 1)))) || ((w2 > WordCount())))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
    }
    (from = WordAddress(w1));
    (to = ((WordAddress(w2) + WordLength(w2)) - 1));
    for ((i = from):(i <= to):(i)++) {
        print (char) (i->(0));
    }
];
[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen saved;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rtrue;
        }
        return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
    }
    @push say__p;
    @push say__pc;
    (nextw = (w2 + 1));
    (at = (WordAddress(w1) - buffer));
    if ((nextw <= WordCount())) {
        (endsnippet = ((100*nextw) + ((WordCount() - nextw) + 1)));
    }
    (saved = (buffer2-->(0)));
    ((buffer2-->(0)) = 120);
    (newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet));
    for ((i = 0):(((i < newlen)) && (((at + i) < 120))):(i)++) {
        ((buffer->((at + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer-->(0)) = (at + i));
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    ((buffer2-->(0)) = saved);
    @pull say__pc;
    @pull say__p;
];
[ SpliceSnippet__TextPrinter t endsnippet;
    TEXT_TY_Say(t);
    if (endsnippet) {
        print " ";
        PrintSnippet(endsnippet);
    }
];
[ SnippetIncludes test snippet w1 w2 wlen i j;
    (w1 = (snippet/100));
    (w2 = ((w1 + (snippet%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
    }
    if ((metaclass(test) == Routine)) {
        (wlen = (snippet%100));
        for (((i = w1),(j = wlen)):(j > 0):((i)++,(j)--)) {
            if (((test)(i,0) ~= GPR_FAIL)) {
                return (((i*100) + wn) - i);
            }
        }
    }
    rfalse;
];
[ SnippetMatches snippet topic_gpr rv;
    (wn = 1);
    if ((topic_gpr == 0)) {
        rfalse;
    }
    if ((metaclass(topic_gpr) == Routine)) {
        (rv = (topic_gpr)((snippet/100),(snippet%100)));
        if ((rv ~= GPR_FAIL)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_BADTOPIC);
    rfalse;
];
[ UnpackGrammarLine line_address i size;
    for ((i = 0):(i < 32):(i)++) {
        ((line_token-->(i)) = ENDIT_TOKEN);
        ((line_ttype-->(i)) = ELEMENTARY_TT);
        ((line_tdata-->(i)) = ENDIT_TOKEN);
    }
    @aloads line_address 0 action_to_be;
    (action_reversed = ((((line_address->(2)))&(1)) ~= 0));
    (line_address = (line_address - 2));
    (size = 5);
    (params_wanted = 0);
    for ((i = 0):1:(i)++) {
        (line_address = (line_address + size));
        if (((line_address->(0)) == ENDIT_TOKEN)) {
            break;
        }
        ((line_token-->(i)) = line_address);
        AnalyseToken(line_address);
        if ((found_ttype ~= PREPOSITION_TT)) {
            (params_wanted)++;
        }
        ((line_ttype-->(i)) = found_ttype);
        ((line_tdata-->(i)) = found_tdata);
    }
    return (line_address + 1);
];
[ AnalyseToken token;
    if ((token == ENDIT_TOKEN)) {
        (found_ttype = ELEMENTARY_TT);
        (found_tdata = ENDIT_TOKEN);
        rtrue;
    }
    (found_ttype = (((token->(0)))&(15)));
    (found_tdata = ((token + 1)-->(0)));
];
[ KeyboardPrimitive a_buffer a_table;
    return TestKeyboardPrimitive(a_buffer, a_table);
    return VM_ReadKeyboard(a_buffer, a_table);
];
[ Keyboard a_buffer a_table nw i w w2 x1 x2;
    (sline1 = score);
    (sline2 = turns);
    while (1) {
        for ((i = 0):(i < 64):(i)++) {
            ((oops_workspace->(i)) = (a_buffer->(i)));
        }
        PrintPrompt();
        DrawStatusLine();
        KeyboardPrimitive(a_buffer, a_table);
        (nw = (a_table-->(0)));
        if ((nw == 0)) {
            @push etype;
            (etype = BLANKLINE_PE);
            (players_command = 100);
            BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
            if ((ForActivity(PRINTING_A_PARSER_ERROR_ACT) == 0)) {
                PARSER_ERROR_INTERNAL_RM(88, noun);
                print "^";
            }
            EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            @pull etype;
            continue;
        }
        (w = (a_table-->(1)));
        if ((w == OOPS1__WD or OOPS2__WD or OOPS3__WD)) {
            if ((oops_from == 0)) {
                PARSER_COMMAND_INTERNAL_RM(65);
                print "^";
                continue;
            }
            if ((nw == 1)) {
                PARSER_COMMAND_INTERNAL_RM(66);
                print "^";
                continue;
            }
            if ((nw > 2)) {
                PARSER_COMMAND_INTERNAL_RM(67);
                print "^";
                continue;
            }
            for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
                ((buffer2->(i)) = (a_buffer->(i)));
            }
            (x1 = (a_table-->(6)));
            (x2 = (a_table-->(5)));
            for ((i = 0):(i < 64):(i)++) {
                ((a_buffer->(i)) = (oops_workspace->(i)));
            }
            VM_Tokenise(a_buffer, a_table);
            (w = (a_table-->((3*oops_from))));
            (w2 = (a_table-->(((3*oops_from) - 1))));
            for ((i = 0):(i < w2):(i)++) {
                ((a_buffer->((i + w))) = 32);
            }
            if ((w2 < x2)) {
                for ((i = (INPUT_BUFFER_LEN - 1)):(i >= (w + x2)):(i)--) {
                    ((a_buffer->(i)) = (a_buffer->(((i - x2) + w2))));
                }
                ((a_buffer-->(0)) = ((a_buffer-->(0)) + (x2 - w2)));
            }
            for ((i = 0):(i < x2):(i)++) {
                ((a_buffer->((i + w))) = (buffer2->((i + x1))));
            }
            VM_Tokenise(a_buffer, a_table);
            (nw = (a_table-->(0)));
            return nw;
        }
        if ((((w == UNDO1__WD or UNDO2__WD or UNDO3__WD)) && ((nw == 1)))) {
            Perform_Undo();
            continue;
        }
        (i = VM_Save_Undo());
        if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
            (undo_flag = 0);
        } else {
            (undo_flag = 2);
        }
        if ((i == -1)) {
            (undo_flag = 0);
        }
        if ((i == 0)) {
            (undo_flag = 1);
        }
        if ((i == 2)) {
            DealWithUndo();
            continue;
        }
        return nw;
    }
];
[ DealWithUndo;
    VM_RestoreWindowColours();
    VM_Style(SUBHEADER_VMSTY);
    SL_Location();
    print "^";
    VM_Style(NORMAL_VMSTY);
    IMMEDIATELY_UNDO_RM(69);
    print "^";
];
[ Parser__parse syntax line num_lines line_address i j k token l m inferred_go;
    (cobj_flag = 0);
    ((parser_results-->(ACTION_PRES)) = 0);
    ((parser_results-->(NO_INPS_PRES)) = 0);
    ((parser_results-->(INP1_PRES)) = 0);
    ((parser_results-->(INP2_PRES)) = 0);
    (meta = 0);
    if (held_back_mode) {
        (held_back_mode = 0);
        (wn = hb_wn);
        if ((verb_wordnum > 0)) {
            (i = WordAddress(verb_wordnum));
        } else {
            (i = WordAddress(1));
        }
        (j = WordAddress(wn));
        if ((i <= j)) {
            for (:(i < j):(i)++) {
                ((i->(0)) = 32);
            }
        }
        (i = NextWord());
        if ((i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (i = (WordAddress((wn - 2)) - buffer));
            if ((wn > num_words)) {
                (j = (INPUT_BUFFER_LEN - 1));
            } else {
                (j = (WordAddress(wn) - buffer));
            }
            for (:(i < j):(i)++) {
                ((buffer3->(i)) = 32);
            }
        }
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }
    .ReType;
    (cobj_flag = 0);
    (actors_location = ScopeCeiling(player));
    BeginActivity(READING_A_COMMAND_ACT);
    if ((ForActivity(READING_A_COMMAND_ACT) == 0)) {
        Keyboard(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
    }
    if (EndActivity(READING_A_COMMAND_ACT)) {
        jump ReType;
    }
    .ReParse;
    (parser_inflection = A_name);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (inferred_go = 0);
    LanguageToInformese();
    VM_Tokenise(buffer, parse);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (token_filter = 0);
    (allow_plurals = 1);
    ResetDescriptors();
    (k = 0);
    if ((parser_trace >= 2)) {
        print "[ ";
        for ((i = 0):(i < num_words):(i)++) {
            (j = (parse-->(((i*3) + 1))));
            (k = WordAddress((i + 1)));
            (l = WordLength((i + 1)));
            print "~";
            for ((m = 0):(m < l):(m)++) {
                print (char) (k->(m));
            }
            print "~ ";
            if ((j == 0)) {
                print "?";
            } else {
                if (((j->(0)) == 96)) {
                    print (address) j;
                } else {
                    print j;
                }
            }
            if ((i ~= (num_words - 1))) {
                print " / ";
            }
        }
        print " ]^";
    }
    (verb_wordnum = 1);
    (actor = player);
    (actors_location = ScopeCeiling(player));
    (usual_grammar_after = 0);
    .AlmostReParse;
    (scope_token = 0);
    (action_to_be = NULL);
    .BeginCommand;
    (wn = verb_wordnum);
    (verb_word = NextWordStopped());
    if ((verb_word == -1)) {
        (best_etype = STUCK_PE);
        jump GiveError;
    }
    if ((verb_word == comma_word)) {
        (best_etype = COMMABEGIN_PE);
        jump GiveError;
    }
    if ((verb_word == AGAIN2__WD or AGAIN3__WD)) {
        (verb_word = AGAIN1__WD);
    }
    if ((verb_word == AGAIN1__WD)) {
        if ((actor ~= player)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
        if (((buffer3-->(0)) == 0)) {
            PARSER_COMMAND_INTERNAL_RM(68);
            print "^";
            jump ReType;
        }
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer->(i)) = (buffer3->(i)));
        }
        VM_Tokenise(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
        jump ReParse;
    }
    if ((verb_word ~= AGAIN1__WD)) {
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer3->(i)) = (buffer->(i)));
        }
    }
    if ((usual_grammar_after == 0)) {
        (j = verb_wordnum);
        (i = RunRoutines(actor, A_grammar));
        if ((((parser_trace >= 2)) && (((actor.grammar) ~= 0 or NULL)))) {
            print " [Grammar property returned ";
            print i;
            print "]^";
        }
        if ((((i ~= 0 or 1)) && (VM_InvalidDictionaryAddress(i)))) {
            (usual_grammar_after = verb_wordnum);
            (i = (-(i)));
        }
        if ((i == 1)) {
            ((parser_results-->(ACTION_PRES)) = action);
            ((parser_results-->(NO_INPS_PRES)) = 0);
            ((parser_results-->(INP1_PRES)) = noun);
            ((parser_results-->(INP2_PRES)) = second);
            if (noun) {
                ((parser_results-->(NO_INPS_PRES)) = 1);
            }
            if (second) {
                ((parser_results-->(NO_INPS_PRES)) = 2);
            }
            rtrue;
        }
        if ((i ~= 0)) {
            (verb_word = i);
            (wn)--;
            (verb_wordnum)--;
        } else {
            (wn = verb_wordnum);
            (verb_word = NextWord());
        }
    } else {
        (usual_grammar_after = 0);
    }
    if ((verb_word == 0)) {
        (i = wn);
        (verb_word = LanguageIsVerb(buffer, parse, verb_wordnum));
        (wn = i);
    }
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (wn = verb_wordnum);
        (indef_mode = 0);
        (token_filter = 0);
        (parameters = 0);
        @push actor;
        @push action;
        @push action_to_be;
        (actor = player);
        (meta = 0);
        (action = ##Go);
        (action_to_be = ##Go);
        (l = NounDomain(Compass, 0, 0));
        @pull action_to_be;
        @pull action;
        @pull actor;
        if ((l == REPARSE_CODE)) {
            jump ReParse;
        }
        if ((((l ~= 0)) && ((l ofclass K3_direction)))) {
            ((parser_results-->(ACTION_PRES)) = ##Go);
            ((parser_results-->(NO_INPS_PRES)) = 1);
            ((parser_results-->(INP1_PRES)) = l);
            (inferred_go = 1);
            jump LookForMore;
        }
    }
    if ((actor == player)) {
        for ((j = 2):(j <= num_words):(j)++) {
            (i = NextWord());
            if ((i == comma_word)) {
                jump Conversation;
            }
        }
    }
    jump NotConversation;
    .Conversation;
    (j = (wn - 1));
    (wn = 1);
    (lookahead = HELD_TOKEN);
    (scope_reason = TALKING_REASON);
    (l = NounDomain(player, actors_location, CREATURE_TOKEN));
    (scope_reason = PARSING_REASON);
    if ((l == REPARSE_CODE)) {
        jump ReParse;
    }
    if ((l == 0)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = MISSINGPERSON_PE);
        jump GiveError;
    }
    if ((((~~((l has animate)))) && ((~~((l has talkable)))))) {
        (best_etype = ANIMALISTEN_PE);
        (noun = l);
        jump GiveError;
    }
    if ((wn ~= j)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = TOTALK_PE);
        jump GiveError;
    }
    PronounNotice(l);
    (verb_wordnum = (j + 1));
    if ((l == player)) {
        (wn = verb_wordnum);
        if ((NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
    }
    (actor = l);
    (actors_location = ScopeCeiling(l));
    if ((parser_trace >= 1)) {
        print "[Actor is ";
        DefArt(actor);
        print " in ";
        PrintShortName(actors_location);
        print "]^";
    }
    jump BeginCommand;
    .NotConversation;
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (verb_word = UnknownVerb(verb_word));
        if ((verb_word ~= 0)) {
            jump VerbAccepted;
        }
        (best_etype = VERB_PE);
        jump GiveError;
    }
    .VerbAccepted;
    (meta = ((((verb_word->(#dict_par1)))&(2))/2));
    if ((((meta == 1)) && ((actor ~= player)))) {
        (best_etype = VERB_PE);
        (meta = 0);
        jump GiveError;
    }
    (i = DictionaryWordToVerbNum(verb_word));
    (syntax = (#grammar_table-->((i + 1))));
    (num_lines = ((syntax->(0)) - 1));
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    if ((parser_trace >= 1)) {
        print "[Parsing for the verb '";
        print (address) verb_word;
        print "' (";
        print (num_lines + 1);
        print " lines)]^";
    }
    (best_etype = STUCK_PE);
    (nextbest_etype = STUCK_PE);
    (multiflag = 0);
    (line_address = (syntax + 1));
    for ((line = 0):(line <= num_lines):(line)++) {
        (line_address = UnpackGrammarLine(line_address));
        if ((parser_trace >= 1)) {
            if ((parser_trace >= 2)) {
                print "^";
            }
            print "[line ";
            print line;
            DebugGrammarLine();
            print "]^";
        }
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (multi_context = 0);
        (etype = STUCK_PE);
        (multi_had = 0);
        (wn = (verb_wordnum + 1));
        (advance_warning = -1);
        (indef_mode = 0);
        for (((i = 0),((m = 0),(pcount = 0))):((line_token-->(pcount)) ~= ENDIT_TOKEN):(pcount)++) {
            (scope_token = 0);
            if (((line_ttype-->(pcount)) ~= PREPOSITION_TT)) {
                (i)++;
            }
            if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
                if (((line_tdata-->(pcount)) == MULTI_TOKEN)) {
                    (m = 1);
                }
                if (((((line_tdata-->(pcount)) == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) && ((i == 1)))) {
                    if ((parser_trace >= 2)) {
                        print " [Trying look-ahead]^";
                    }
                    (pcount)++;
                    if (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
                        do {(l = NextWord());
                        } until (
                            (((wn > num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                        ;
                        if ((wn > num_words)) {
                            if ((parser_trace >= 2)) {
                                print " [Look-ahead aborted: prepositions missing]^";
                            }
                            jump EmptyLine;
                        }
                        do {if ((PrepositionChain(l, pcount) ~= -1)) {
                            if ((((((line_token-->(pcount))->(0)))&(32)) ~= 0)) {
                                (pcount)++;
                                while (((((line_token-->(pcount)) ~= ENDIT_TOKEN)) && ((((((line_token-->(pcount))->(0)))&(16)) ~= 0)))) {
                                    (pcount)++;
                                }
                            } else {
                                (pcount)++;
                            }
                        } else {
                            do {(l = NextWord());
                            } until (
                                (((wn >= num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                            ;
                            if (((l) && ((((l->(#dict_par1)))&(8))))) {
                                continue;
                            }
                            if ((parser_trace >= 2)) {
                                print " [Look-ahead aborted: prepositions don't match]^";
                            }
                            jump LineFailed;
                        }
                        if ((wn <= num_words)) {
                            (l = NextWord());
                        }
                        } until (
                            ((line_ttype-->(pcount)) ~= PREPOSITION_TT))
                        ;
                        .EmptyLine;
                        (wn)--;
                        if (((((line_ttype-->(pcount)) == ELEMENTARY_TT)) && (((line_tdata-->(pcount)) == NOUN_TOKEN)))) {
                            (l = Descriptors());
                            if ((l ~= 0)) {
                                (etype = l);
                            }
                            (k = (parser_results-->(INP1_PRES)));
                            @push k;
                            @push parameters;
                            (parameters = 1);
                            ((parser_results-->(INP1_PRES)) = 0);
                            (l = NounDomain(actors_location, actor, NOUN_TOKEN, 1));
                            @pull parameters;
                            @pull k;
                            ((parser_results-->(INP1_PRES)) = k);
                            if ((parser_trace >= 2)) {
                                print " [Advanced to ~noun~ token: ";
                                if ((l == REPARSE_CODE)) {
                                    print "re-parse request]^";
                                } else {
                                    if ((l == 1)) {
                                        print "but multiple found]^";
                                    }
                                    if ((l == 0)) {
                                        print "error ";
                                        print etype;
                                        print "]^";
                                    }
                                    if ((l >= 2)) {
                                        DefArt(l);
                                        print "]^";
                                    }
                                }
                            }
                            if ((l == REPARSE_CODE)) {
                                jump ReParse;
                            }
                            if ((l >= 2)) {
                                (advance_warning = l);
                            }
                        }
                    }
                    break;
                }
            }
        }
        (take_all_rule = 0);
        if (((((m) && ((params_wanted == 1)))) && ((action_to_be == ##Take)))) {
            (take_all_rule = 1);
        }
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (etype = STUCK_PE);
        (multi_had = 1);
        (wn = (verb_wordnum + 1));
        (m = 1);
        for ((pcount = 1):1:(pcount)++) {
            if (((line_token-->((pcount - 1))) == ENDIT_TOKEN)) {
                if ((pcount >= 2)) {
                    while ((((((line_token-->((pcount - 2)))->(0)))&(16)) ~= 0)) {
                        (pcount)--;
                    }
                    AnalyseToken((line_token-->((pcount - 2))));
                    if ((found_ttype == PREPOSITION_TT)) {
                        (l = -1);
                        while (1) {
                            (m = NextWordStopped());
                            if ((m == -1)) {
                                break;
                            }
                            (l = m);
                        }
                        if ((PrepositionChain(l, (pcount - 2)) == -1)) {
                            (m = 0);
                            if ((parser_trace >= 2)) {
                                print "[line rejected for not ending with correct preposition]^";
                            }
                        } else {
                            (m = 1);
                        }
                    }
                }
                break;
            }
        }
        (wn = (verb_wordnum + 1));
        if (m) {
            for ((pcount = 1):1:(pcount)++) {
                ((pattern-->(pcount)) = PATTERN_NULL);
                (scope_token = 0);
                (token = (line_token-->((pcount - 1))));
                (lookahead = (line_token-->(pcount)));
                if ((parser_trace >= 2)) {
                    print " [line ";
                    print line;
                    print " token ";
                    print pcount;
                    print " word ";
                    print wn;
                    print " : ";
                    DebugToken(token);
                    print "]^";
                }
                if ((token ~= ENDIT_TOKEN)) {
                    (scope_reason = PARSING_REASON);
                    AnalyseToken(token);
                    (l = ParseToken(found_ttype, found_tdata, (pcount - 1), token));
                    while ((((l >= GPR_NOUN)) && ((l < -1)))) {
                        (l = ParseToken(ELEMENTARY_TT, (l + 256)));
                    }
                    (scope_reason = PARSING_REASON);
                    if ((l == GPR_PREPOSITION)) {
                        if ((((found_ttype ~= PREPOSITION_TT)) && ((((found_ttype ~= ELEMENTARY_TT)) || ((found_tdata ~= TOPIC_TOKEN)))))) {
                            (params_wanted)--;
                        }
                        (l = 1);
                    } else {
                        if ((l < 0)) {
                            (l = 0);
                        } else {
                            if ((l ~= GPR_REPARSE)) {
                                if ((l == GPR_NUMBER)) {
                                    if ((nsns == 0)) {
                                        (special_number1 = parsed_number);
                                    } else {
                                        (special_number2 = parsed_number);
                                    }
                                    (nsns)++;
                                    (l = 1);
                                }
                                if ((l == GPR_MULTIPLE)) {
                                    (l = 0);
                                }
                                ((parser_results-->((parameters + INP1_PRES))) = l);
                                (parameters)++;
                                ((pattern-->(pcount)) = l);
                                (l = 1);
                            }
                        }
                    }
                    if ((parser_trace >= 3)) {
                        print "  [token resulted in ";
                        if ((l == REPARSE_CODE)) {
                            print "re-parse request]^";
                        }
                        if ((l == 0)) {
                            print "failure with error type ";
                            print etype;
                            print "]^";
                        }
                        if ((l == 1)) {
                            print "success]^";
                        }
                    }
                    if ((l == REPARSE_CODE)) {
                        jump ReParse;
                    }
                    if ((l == 0)) {
                        break;
                    }
                } else {
                    if ((wn <= num_words)) {
                        (l = NextWord());
                        if ((l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
                            (held_back_mode = 1);
                            (hb_wn = (wn - 1));
                        } else {
                            for ((m = 0):(m < 32):(m)++) {
                                ((pattern2-->(m)) = (pattern-->(m)));
                            }
                            (pcount2 = pcount);
                            (etype = UPTO_PE);
                            break;
                        }
                    }
                    if ((parameters >= 1)) {
                        if (((parser_results-->(INP1_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP2_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                ((parser_results-->(ACTION_PRES)) = action_to_be);
                                break;
                            }
                        }
                    }
                    if ((parameters >= 2)) {
                        if (((parser_results-->(INP2_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP1_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                break;
                            }
                        } else {
                            (k = (parser_results-->(INP1_PRES)));
                            (l = (parser_results-->(INP2_PRES)));
                            if (((k) && (l))) {
                                if ((((((multi_context == MULTIEXCEPT_TOKEN)) && ((k == l)))) || ((((((multi_context == MULTIINSIDE_TOKEN)) && ((k notin l)))) && ((l notin k)))))) {
                                    (best_etype = NOTHING_PE);
                                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                                    jump GiveError;
                                }
                            }
                        }
                    }
                    if ((((take_all_rule == 2)) && (((parser_results-->(INP1_PRES)) == actor)))) {
                        (best_etype = NOTHING_PE);
                        jump GiveError;
                    }
                    if ((multi_had > 1)) {
                        (best_etype = TOOFEW_PE);
                        jump GiveError;
                    }
                    if ((parser_trace >= 1)) {
                        print "[Line successfully parsed]^";
                    }
                    (oops_from = 0);
                    if ((inferfrom ~= 0)) {
                        PrintInferredCommand(inferfrom);
                        ClearParagraphing(20);
                    }
                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                    ((parser_results-->(NO_INPS_PRES)) = parameters);
                    if (((action_reversed) && ((parameters == 2)))) {
                        (i = (parser_results-->(INP1_PRES)));
                        ((parser_results-->(INP1_PRES)) = (parser_results-->(INP2_PRES)));
                        ((parser_results-->(INP2_PRES)) = i);
                        if ((nsns == 2)) {
                            (i = special_number1);
                            (special_number1 = special_number2);
                            (special_number2 = i);
                        }
                    }
                    if ((((parameters > 0)) && (((parser_results-->(INP1_PRES)) >= 2)))) {
                        PronounNotice((parser_results-->(INP1_PRES)));
                    }
                    if (held_back_mode) {
                        (wn = hb_wn);
                        jump LookForMore;
                    }
                    rtrue;
                }
            }
        }
        .LineFailed;
        if ((etype > best_etype)) {
            (best_etype = etype);
        }
        if ((((etype ~= ASKSCOPE_PE)) && ((etype > nextbest_etype)))) {
            (nextbest_etype = etype);
        }
        if ((((take_all_rule == 2)) && ((etype == NOTHING_PE)))) {
            break;
        }
    }
    .GiveError;
    (etype = best_etype);
    if ((actor ~= player)) {
        if ((usual_grammar_after ~= 0)) {
            (verb_wordnum = usual_grammar_after);
            jump AlmostReParse;
        }
        (m = wn);
        (wn = 1);
        while ((((wn <= num_words)) && ((NextWord() ~= comma_word)))) {
        }
        ((parser_results-->(ACTION_PRES)) = ##Answer);
        ((parser_results-->(NO_INPS_PRES)) = 2);
        ((parser_results-->(INP1_PRES)) = actor);
        ((parser_results-->(INP2_PRES)) = 1);
        (special_number1 = special_word);
        (actor = player);
        (consult_from = wn);
        (consult_words = ((num_words - consult_from) + 1));
        (wn = m);
        rtrue;
    }
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        if ((ParserError(etype) ~= 0)) {
            jump ReType;
        }
    } else {
        if ((((verb_wordnum == 0)) && ((etype == CANTSEE_PE)))) {
            (etype = VERB_PE);
        }
        (players_command = (100 + WordCount()));
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) {
            jump SkipParserError;
        }
    }
    (pronoun_word = pronoun__word);
    (pronoun_obj = pronoun__obj);
    if ((etype == STUCK_PE)) {
        PARSER_ERROR_INTERNAL_RM(65);
        print "^";
        (oops_from = 1);
    }
    if ((etype == UPTO_PE)) {
        for ((m = 0):(m < 32):(m)++) {
            ((pattern-->(m)) = (pattern2-->(m)));
        }
        (pcount = pcount2);
        if (inferred_go) {
            PARSER_ERROR_INTERNAL_RM(67);
            PrintShortName((parser_results-->(INP1_PRES)));
        } else {
            PARSER_ERROR_INTERNAL_RM(66);
            PrintCommand(0);
        }
        print ".^";
    }
    if ((etype == NUMBER_PE)) {
        PARSER_ERROR_INTERNAL_RM(68);
        print "^";
    }
    if ((etype == CANTSEE_PE)) {
        PARSER_ERROR_INTERNAL_RM(69);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == TOOLIT_PE)) {
        PARSER_ERROR_INTERNAL_RM(70);
        print "^";
    }
    if ((etype == NOTHELD_PE)) {
        PARSER_ERROR_INTERNAL_RM(71);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == MULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(72);
        print "^";
    }
    if ((etype == MMULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(73);
        print "^";
    }
    if ((etype == VAGUE_PE)) {
        PARSER_ERROR_INTERNAL_RM(74);
        print "^";
    }
    if ((etype == ITGONE_PE)) {
        if ((pronoun_obj == NULL)) {
            PARSER_ERROR_INTERNAL_RM(74);
            print "^";
        } else {
            PARSER_ERROR_INTERNAL_RM(75, noun);
            print "^";
        }
    }
    if ((etype == EXCEPT_PE)) {
        PARSER_ERROR_INTERNAL_RM(76);
        print "^";
    }
    if ((etype == ANIMA_PE)) {
        PARSER_ERROR_INTERNAL_RM(77);
        print "^";
    }
    if ((etype == VERB_PE)) {
        PARSER_ERROR_INTERNAL_RM(78);
        print "^";
    }
    if ((etype == SCENERY_PE)) {
        PARSER_ERROR_INTERNAL_RM(79);
        print "^";
    }
    if ((etype == JUNKAFTER_PE)) {
        PARSER_ERROR_INTERNAL_RM(80);
        print "^";
    }
    if ((etype == TOOFEW_PE)) {
        PARSER_ERROR_INTERNAL_RM(81, multi_had);
        print "^";
    }
    if ((etype == NOTHING_PE)) {
        if (((((parser_results-->(ACTION_PRES)) == ##Remove)) && (((parser_results-->(INP2_PRES)) ofclass Object)))) {
            (noun = (parser_results-->(INP2_PRES)));
            if ((noun has animate)) {
                PARSER_N_ERROR_INTERNAL_RM(67, noun);
                print "^";
            } else {
                if ((~~(((or_tmp_var = noun) && (((or_tmp_var has container)) || ((or_tmp_var has supporter))))))) {
                    PARSER_N_ERROR_INTERNAL_RM(68, noun);
                    print "^";
                } else {
                    if ((((noun has container)) && ((~~((noun has open)))))) {
                        PARSER_N_ERROR_INTERNAL_RM(69, noun);
                        print "^";
                    } else {
                        if ((children(noun) == 0)) {
                            PARSER_N_ERROR_INTERNAL_RM(70, noun);
                            print "^";
                        } else {
                            ((parser_results-->(ACTION_PRES)) = 0);
                        }
                    }
                }
            }
        }
        if (((parser_results-->(ACTION_PRES)) ~= ##Remove)) {
            if ((multi_wanted == 100)) {
                PARSER_N_ERROR_INTERNAL_RM(65);
                print "^";
            } else {
                PARSER_N_ERROR_INTERNAL_RM(66);
                print "^";
            }
        }
    }
    if ((etype == NOTINCONTEXT_PE)) {
        PARSER_ERROR_INTERNAL_RM(82);
        print "^";
    }
    if ((etype == ANIMAAGAIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(83);
        print "^";
    }
    if ((etype == COMMABEGIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(84);
        print "^";
    }
    if ((etype == MISSINGPERSON_PE)) {
        PARSER_ERROR_INTERNAL_RM(85);
        print "^";
    }
    if ((etype == ANIMALISTEN_PE)) {
        PARSER_ERROR_INTERNAL_RM(86, noun);
        print "^";
    }
    if ((etype == TOTALK_PE)) {
        PARSER_ERROR_INTERNAL_RM(87);
        print "^";
    }
    if ((etype == ASKSCOPE_PE)) {
        (scope_stage = 3);
        if (((scope_error)() == -1)) {
            (best_etype = nextbest_etype);
            if ((~~((((etype ofclass Routine)) || ((etype ofclass String)))))) {
                EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            }
            jump GiveError;
        }
    }
    .SkipParserError;
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        jump ReType;
    }
    (say__p = 1);
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);
    jump ReType;
    .LookForMore;
    if ((wn > num_words)) {
        rtrue;
    }
    (i = NextWord());
    if ((i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
        if ((wn > num_words)) {
            (held_back_mode = 0);
            rtrue;
        }
        (hb_wn = wn);
        (held_back_mode = 1);
        rtrue;
    }
    (best_etype = UPTO_PE);
    jump GiveError;
];
[ PARSER_ERROR_INTERNAL_R;
];
[ PARSER_N_ERROR_INTERNAL_R;
];
[ PARSER_COMMAND_INTERNAL_R;
];
[ ParseTokenStopped x y;
    if ((wn > WordCount())) {
        return GPR_FAIL;
    }
    return ParseToken(x, y);
];
[ ParseToken given_ttype given_tdata token_n token i t rv;
    if ((parsetoken_nesting > 0)) {
        @push match_from;
        @push token_filter;
        @push match_length;
        @push number_of_classes;
        @push oops_from;
        for ((i = 0):(i < number_matched):(i)++) {
            (t = (match_list-->(i)));
            @push t;
            (t = (match_classes-->(i)));
            @push t;
            (t = (match_scores-->(i)));
            @push t;
        }
        @push number_matched;
    }
    (parsetoken_nesting)++;
    (rv = ParseToken__(given_ttype, given_tdata, token_n, token));
    (parsetoken_nesting)--;
    if ((parsetoken_nesting > 0)) {
        @pull number_matched;
        for ((i = (number_matched - 1)):(i >= 0):(i)--) {
            @pull t;
            ((match_scores-->(i)) = t);
            @pull t;
            ((match_classes-->(i)) = t);
            @pull t;
            ((match_list-->(i)) = t);
        }
        @pull oops_from;
        @pull number_of_classes;
        @pull match_length;
        @pull token_filter;
        @pull match_from;
    }
    return rv;
];
[ ParseToken__ given_ttype given_tdata token_n token l o i j k and_parity single_object desc_wn many_flag token_allows_multiple prev_indef_wanted;
    (token_filter = 0);
    (parser_inflection = A_name);
    switch (given_ttype) {
        ELEMENTARY_TT:
            switch (given_tdata) {
                SPECIAL_TOKEN:
                    (l = TryNumber(wn));
                    (special_word = NextWord());
                    if ((l ~= -1000)) {
                        if ((parser_trace >= 3)) {
                            print "  [Read special as the number ";
                            print l;
                            print "]^";
                        }
                    }
                    if ((l == -1000)) {
                        if ((parser_trace >= 3)) {
                            print "  [Read special word at word number ";
                            print wn;
                            print "]^";
                        }
                        (l = special_word);
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                NUMBER_TOKEN:
                    (l = TryNumber((wn)++));
                    if ((l == -1000)) {
                        (etype = NUMBER_PE);
                        return GPR_FAIL;
                    }
                    if ((parser_trace >= 3)) {
                        print "  [Read number as ";
                        print l;
                        print "]^";
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                CREATURE_TOKEN:
                    if ((action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)) {
                        (scope_reason = TALKING_REASON);
                    }
                    ;
                TOPIC_TOKEN:
                    (consult_from = wn);
                    if (((((line_ttype-->((token_n + 1))) ~= PREPOSITION_TT)) && (((line_token-->((token_n + 1))) ~= ENDIT_TOKEN)))) {
                        RunTimeProblem(RTP_TEXTTOKENTOOHARD);
                        return GPR_PREPOSITION;
                    }
                    do {(o = NextWordStopped());
                    } until (
                        (((o == -1)) || ((PrepositionChain(o, (token_n + 1)) ~= -1))))
                    ;
                    (wn)--;
                    (consult_words = (wn - consult_from));
                    if ((consult_words == 0)) {
                        return GPR_FAIL;
                    }
                    if ((action_to_be == ##Ask or ##Answer or ##Tell)) {
                        (o = wn);
                        (wn = consult_from);
                        (parsed_number = NextWord());
                        (wn = o);
                        rtrue;
                    }
                    if ((((o == -1)) && (((line_ttype-->((token_n + 1))) == PREPOSITION_TT)))) {
                        return GPR_FAIL;
                    }
                    return GPR_PREPOSITION;
                    ;
            }
            ;
        PREPOSITION_TT:
            if ((parser_trace >= 5)) {
                print "  [Preposition token]^";
            }
            if ((((token->(0)))&(16))) {
                return GPR_PREPOSITION;
            }
            if ((wn > num_words)) {
                if ((((inferfrom == 0)) && ((parameters < params_wanted)))) {
                    (inferfrom = pcount);
                    (inferword = token);
                    ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                }
                if ((inferfrom == 0)) {
                    return (-(1));
                }
                ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                return GPR_PREPOSITION;
            }
            (o = NextWord());
            ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(o)));
            if ((o == given_tdata)) {
                return GPR_PREPOSITION;
            }
            if ((PrepositionChain(o, token_n) ~= -1)) {
                return GPR_PREPOSITION;
            }
            return (-(1));
            ;
        GPR_TT:
            (l = (given_tdata)());
            if ((parser_trace >= 3)) {
                print "  [Outside parsing routine returned ";
                print l;
                print "]^";
            }
            return l;
            ;
        SCOPE_TT:
            (scope_token = given_tdata);
            (scope_stage = 1);
            if ((parser_trace >= 3)) {
                print "  [Scope routine called at stage 1]^";
            }
            (l = (scope_token)());
            if ((parser_trace >= 3)) {
                print "  [Scope routine returned multiple-flag of ";
                print l;
                print "]^";
            }
            if ((l == 1)) {
                (given_tdata = MULTI_TOKEN);
            } else {
                (given_tdata = NOUN_TOKEN);
            }
            ;
        ATTR_FILTER_TT:
            (token_filter = (1 + given_tdata));
            (given_tdata = NOUN_TOKEN);
            ;
        ROUTINE_FILTER_TT:
            (token_filter = given_tdata);
            (given_tdata = NOUN_TOKEN);
            ;
    }
    (token = given_tdata);
    (token_allows_multiple = 0);
    if ((token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        (token_allows_multiple = 1);
    }
    (many_flag = 0);
    (and_parity = 1);
    (dont_infer = 0);
    (dont_infer_pronoun = 0);
    .ObjectList;
    if ((parser_trace >= 3)) {
        print "  [Object list from word ";
        print wn;
        print "]^";
    }
    (o = NextWord());
    (wn)--;
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    (l = PronounValue(o));
    if ((l ~= 0)) {
        (pronoun_word = o);
        (pronoun_obj = l);
        if ((l == NULL)) {
            for ((l = 1):(l <= (LanguageDescriptors-->(0))):(l = (l + 4))) {
                if ((o == (LanguageDescriptors-->(l)))) {
                    jump AssumeDescriptor;
                }
            }
            (pronoun__word = pronoun_word);
            (pronoun__obj = pronoun_obj);
            (etype = VAGUE_PE);
            if ((parser_trace >= 3)) {
                print "  [Stop: unset pronoun]^";
            }
            return GPR_FAIL;
        }
    }
    .AssumeDescriptor;
    if ((o == ME1__WD or ME2__WD or ME3__WD)) {
        (pronoun_word = o);
        (pronoun_obj = player);
    }
    (allow_plurals = 1);
    (desc_wn = wn);
    .TryAgain;
    (l = Descriptors(token_allows_multiple));
    if ((l ~= 0)) {
        (etype = l);
        rfalse;
    }
    .TryAgain2;
    (oops_from = wn);
    if ((token ~= HELD_TOKEN)) {
        (i = (multiple_object-->(0)));
        if ((parser_trace >= 3)) {
            print "  [Calling NounDomain on location and actor]^";
        }
        (l = NounDomain(actors_location, actor, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((((((indef_wanted == INDEF_ALL_WANTED)) && ((l == 0)))) && ((number_matched == 0)))) {
            (l = 1);
        }
        if (((token_allows_multiple) && ((~~(multiflag))))) {
            if ((best_etype == MULTI_PE)) {
                (best_etype = STUCK_PE);
            }
            (multiflag = 1);
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((etype == MULTI_PE)) && (multiflag))) {
                (etype = STUCK_PE);
            }
            (etype = CantSee());
            jump FailToken;
        }
        if ((parser_trace >= 3)) {
            if ((l > 1)) {
                print "  [ND returned ";
                DefArt(l);
                print "]^";
            } else {
                print "  [ND appended to the multiple object list:^";
                (k = (multiple_object-->(0)));
                for ((j = (i + 1)):(j <= k):(j)++) {
                    print "  Entry ";
                    print j;
                    print ": ";
                    CDefArt((multiple_object-->(j)));
                    print " (";
                    print (multiple_object-->(j));
                    print ")^";
                }
                print "  List now has size ";
                print k;
                print "]^";
            }
        }
        if ((l == 1)) {
            if ((~~(many_flag))) {
                (many_flag = 1);
            } else {
                (k = (multiple_object-->(0)));
                ((multiple_object-->(0)) = i);
                for ((j = (i + 1)):(j <= k):(j)++) {
                    if (and_parity) {
                        MultiAdd((multiple_object-->(j)));
                    } else {
                        MultiSub((multiple_object-->(j)));
                    }
                }
                if ((parser_trace >= 3)) {
                    print "  [Merging ";
                    print (k - i);
                    print " new objects to the ";
                    print i;
                    print " old ones]^";
                }
            }
        } else {
            if ((((match_length == 0)) && (indef_possambig))) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((token == CREATURE_TOKEN)) && ((CreatureTest(l) == 0)))) {
                (etype = ANIMA_PE);
                jump FailToken;
            }
            if ((~~(many_flag))) {
                (single_object = l);
            } else {
                if (and_parity) {
                    MultiAdd(l);
                } else {
                    MultiSub(l);
                }
                if ((parser_trace >= 3)) {
                    print "  [Combining ";
                    DefArt(l);
                    print " with list]^";
                }
            }
        }
    } else {
        (l = NounDomain(actor, actors_location, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            (etype = CantSee());
            jump FailToken;
        }
        (o = parent(l));
        if ((o ~= actor)) {
            if ((parser_trace >= 3)) {
                print "  [Allowing object ";
                DefArt(l);
                print " for now]^";
            }
        }
        (single_object = l);
    }
    (wn = (match_from + match_length));
    (o = NextWord());
    if ((o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word)) {
        if ((parser_trace >= 3)) {
            print "  [Read connective '";
            print (address) o;
            print "']^";
        }
        if ((~~(token_allows_multiple))) {
            if (multiflag) {
                jump PassToken;
            }
            (etype = MULTI_PE);
            jump FailToken;
        }
        if ((o == BUT1__WD or BUT2__WD or BUT3__WD)) {
            (and_parity = (1 - and_parity));
        }
        if ((~~(many_flag))) {
            ((multiple_object-->(0)) = 1);
            ((multiple_object-->(1)) = single_object);
            (many_flag = 1);
            if ((parser_trace >= 3)) {
                print "  [Making new list from ";
                DefArt(single_object);
                print "]^";
            }
        }
        (dont_infer = 1);
        (dont_infer_pronoun = 0);
        (inferfrom = 0);
        jump ObjectList;
    }
    (wn)--;
    .PassToken;
    if (many_flag) {
        (single_object = GPR_MULTIPLE);
        (multi_context = token);
    } else {
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
                (multi_context = token);
            }
            if ((((indef_wanted < INDEF_ALL_WANTED)) && ((indef_wanted > 1)))) {
                (multi_had = 1);
                (multi_wanted = indef_wanted);
                if ((parser_trace >= 4)) {
                    print "Too few found at letter F^";
                }
                jump FailToken;
            }
        }
    }
    return single_object;
    .FailToken;
    if (((allow_plurals) && ((indef_guess_p == 1)))) {
        if ((parser_trace >= 4)) {
            print "   [Retrying singulars after failure ";
            print etype;
            print "]^";
        }
        (prev_indef_wanted = indef_wanted);
        (allow_plurals = 0);
        (wn = desc_wn);
        jump TryAgain;
    }
    if ((((((indef_wanted > 0)) || ((prev_indef_wanted > 0)))) && ((~~(multiflag))))) {
        (etype = MULTI_PE);
    }
    return GPR_FAIL;
];
[ ResetDescriptors;
    (indef_mode = 0);
    (indef_type = 0);
    (indef_wanted = 0);
    (indef_guess_p = 0);
    (indef_possambig = 0);
    (indef_owner = 0);
    (indef_cases = 4095);
    (indef_nspec_at = 0);
];
[ ArticleDescriptors o x flag cto type n;
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type == DEFART_PK or INDEFART_PK)) {
                    (flag = 1);
                }
            }
        }
    }
    (wn)--;
    rfalse;
];
[ Descriptors o x flag cto type n;
    ResetDescriptors();
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (flag = 1);
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type ~= DEFART_PK)) {
                    (indef_mode = 1);
                }
                (indef_possambig = 1);
                (indef_cases = ((indef_cases)&((LanguageDescriptors-->((x + 1))))));
                if ((type == POSSESS_PK)) {
                    (cto = (LanguageDescriptors-->((x + 3))));
                    switch (cto) {
                        0:
                            (indef_type = ((indef_type)|(MY_BIT)));
                            ;
                        1:
                            (indef_type = ((indef_type)|(THAT_BIT)));
                            ;
                        default:
                            (indef_owner = PronounValue(cto));
                            if ((indef_owner == NULL)) {
                                (indef_owner = 0);
                            }
                            ;
                    }
                }
                if ((type == LIGHTED_PK)) {
                    (indef_type = ((indef_type)|(LIT_BIT)));
                }
                if ((type == UNLIGHTED_PK)) {
                    (indef_type = ((indef_type)|(UNLIT_BIT)));
                }
            }
        }
        if ((o == OTHER1__WD or OTHER2__WD or OTHER3__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_type = ((indef_type)|(OTHER_BIT)));
        }
        if ((o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_wanted = INDEF_ALL_WANTED);
            if ((take_all_rule == 1)) {
                (take_all_rule = 2);
            }
            (indef_type = ((indef_type)|(PLURAL_BIT)));
        }
        if (allow_plurals) {
            if ((NextWordStopped() ~= -1 or THEN1__WD)) {
                (wn)--;
                (n = TryNumber((wn - 1)));
            } else {
                (n = 0);
                (wn)--;
            }
            if ((n == 1)) {
                (indef_mode = 1);
                (flag = 1);
            }
            if ((n > 1)) {
                (indef_guess_p = 1);
                (indef_mode = 1);
                (flag = 1);
                (indef_wanted = n);
                (indef_nspec_at = (wn - 1));
                (indef_type = ((indef_type)|(PLURAL_BIT)));
            }
        }
        if ((((flag == 1)) && ((NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)))) {
            (wn)--;
        }
    }
    (wn)--;
    rfalse;
];
[ SafeSkipDescriptors;
    @push indef_mode;
    @push indef_type;
    @push indef_wanted;
    @push indef_guess_p;
    @push indef_possambig;
    @push indef_owner;
    @push indef_cases;
    @push indef_nspec_at;
    Descriptors();
    @pull indef_nspec_at;
    @pull indef_cases;
    @pull indef_owner;
    @pull indef_possambig;
    @pull indef_guess_p;
    @pull indef_wanted;
    @pull indef_type;
    @pull indef_mode;
];
[ PrepositionChain wd index;
    if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    if ((((((line_token-->(index))->(0)))&(32)) == 0)) {
        return (-(1));
    }
    do {if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    (index)++;
    } until (
        ((((line_token-->(index)) == ENDIT_TOKEN)) || ((((((line_token-->(index))->(0)))&(16)) == 0))))
    ;
    return (-(1));
];
[ CreatureTest obj;
    if ((obj has animate)) {
        rtrue;
    }
    if ((~~((obj has talkable)))) {
        rfalse;
    }
    if ((action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor)) {
        rtrue;
    }
    rfalse;
];
[ NounDomain domain1 domain2 context dont_ask first_word i j k l answer_words marker;
    if ((parser_trace >= 4)) {
        print "   [NounDomain called at word ";
        print wn;
        print " (domain1 ";
        PrintShortName(domain1);
        print ", domain2 ";
        PrintShortName(domain2);
        print ")^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (((indef_type)&(OTHER_BIT))) {
                print "other ";
            }
            if (((indef_type)&(MY_BIT))) {
                print "my ";
            }
            if (((indef_type)&(THAT_BIT))) {
                print "that ";
            }
            if (((indef_type)&(PLURAL_BIT))) {
                print "plural ";
            }
            if (((indef_type)&(LIT_BIT))) {
                print "lit ";
            }
            if (((indef_type)&(UNLIT_BIT))) {
                print "unlit ";
            }
            if ((indef_owner ~= 0)) {
                print "owner:";
                PrintShortName(indef_owner);
            }
            print "^";
            print "   number wanted: ";
            if ((indef_wanted == INDEF_ALL_WANTED)) {
                print "all";
            } else {
                print indef_wanted;
            }
            print "^";
            print "   most likely GNAs of names: ";
            print indef_cases;
            print "^";
        } else {
            print "seeking definite object^";
        }
    }
    (match_length = 0);
    (number_matched = 0);
    (match_from = wn);
    SearchScope(domain1, domain2, context);
    if ((parser_trace >= 4)) {
        print "   [ND made ";
        print number_matched;
        print " matches]^";
    }
    (wn = (match_from + match_length));
    if ((number_matched == 0)) {
        (wn)++;
        rfalse;
    }
    if ((match_from <= num_words)) {
        if ((number_matched == 1)) {
            (i = (match_list-->(0)));
            return i;
        }
        if ((wn <= num_words)) {
            (i = NextWord());
            (wn)--;
            if ((i ~= AND1__WD or AND2__WD or AND3__WD or comma_word or THEN1__WD or THEN2__WD or THEN3__WD or BUT1__WD or BUT2__WD or BUT3__WD)) {
                if ((lookahead == ENDIT_TOKEN)) {
                    rfalse;
                }
            }
        }
    }
    (number_of_classes = 0);
    if ((number_matched == 1)) {
        (i = (match_list-->(0)));
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN)) {
                BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
                if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) && (RulebookFailed()))) {
                    rfalse;
                }
                EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
            }
        }
    }
    if ((number_matched > 1)) {
        (i = 1);
        if ((number_matched > 1)) {
            for ((j = 0):(j < (number_matched - 1)):(j)++) {
                if ((Identical((match_list-->(j)), (match_list-->((j + 1)))) == 0)) {
                    (i = 0);
                }
            }
        }
        if (i) {
            (dont_infer = 1);
        }
        (i = Adjudicate(context));
        if ((i == -1)) {
            rfalse;
        }
        if ((i == 1)) {
            rtrue;
        }
        (dont_infer_pronoun = 1);
    }
    if ((i ~= 0)) {
        if (dont_infer) {
            return i;
        }
        if ((inferfrom == 0)) {
            (inferfrom = pcount);
        }
        ((pattern-->(pcount)) = i);
        return i;
    }
    if (dont_ask) {
        return (match_list-->(0));
    }
    if ((match_from > num_words)) {
        jump Incomplete;
    }
    BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) {
        jump SkipWhichQuestion;
    }
    (j = 1);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        if ((~~(((match_list-->(marker)) has animate)))) {
            (j = 0);
        }
    }
    if (j) {
        PARSER_CLARIF_INTERNAL_RM(65);
    } else {
        PARSER_CLARIF_INTERNAL_RM(66);
    }
    (j = number_of_classes);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        (k = (match_list-->(marker)));
        if (((match_classes-->(marker)) > 0)) {
            DefArt(k);
        } else {
            IndefArt(k);
        }
        if ((i < (j - 1))) {
            print ", ";
        }
        if ((i == (j - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                if ((j ~= 2)) {
                    print ",";
                }
            }
            PARSER_CLARIF_INTERNAL_RM(72);
        }
    }
    print "?^";
    .SkipWhichQuestion;
    EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    .WhichOne;
    (answer_words = Keyboard(buffer2, parse2));
    (first_word = (parse2-->(1)));
    if ((first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
        if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (l = (multiple_object-->(0)));
            for ((i = 0):(((i < number_matched)) && (((l + i) < MATCH_LIST_WORDS))):(i)++) {
                (k = (match_list-->(i)));
                ((multiple_object-->(((i + 1) + l))) = k);
            }
            ((multiple_object-->(0)) = (i + l));
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM(67);
        jump WhichOne;
    }
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (k = (WordAddress(match_from) - buffer));
    (l = ((buffer2-->(0)) + 1));
    for ((j = ((buffer + INPUT_BUFFER_LEN) - 1)):(j >= ((buffer + k) + l)):(j)--) {
        ((j->(0)) = (j->((-(l)))));
    }
    for ((i = 0):(i < l):(i)++) {
        ((buffer->((k + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer->(((k + l) - 1))) = 32);
    ((buffer-->(0)) = ((buffer-->(0)) + l));
    if (((buffer-->(0)) > (INPUT_BUFFER_LEN - WORDSIZE))) {
        ((buffer-->(0)) = (INPUT_BUFFER_LEN - WORDSIZE));
    }
    .RECONSTRUCT_INPUT;
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (actors_location = ScopeCeiling(player));
    FollowRulebook((Activity_after_rulebooks-->(READING_A_COMMAND_ACT)));
    return REPARSE_CODE;
    .Incomplete;
    if ((context == CREATURE_TOKEN)) {
        PARSER_CLARIF_INTERNAL_RM(68, actor);
    } else {
        PARSER_CLARIF_INTERNAL_RM(69, actor);
    }
    print "^";
    (answer_words = Keyboard(buffer2, parse2));
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (first_word = (parse2-->(1)));
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((inferfrom ~= 0)) {
        for ((j = inferfrom):(j < pcount):(j)++) {
            if (((pattern-->(j)) == PATTERN_NULL)) {
                continue;
            }
            (i = (WORDSIZE + (buffer-->(0))));
            ((buffer-->(0)))++;
            ((buffer->((i)++)) = 32);
            if ((parser_trace >= 5)) {
                print "[Gluing in inference at ";
                print j;
                print " with pattern code ";
                print (pattern-->(j));
                print "]^";
            }
            ((parse2-->(1)) = 0);
            if (((((pattern-->(j)) >= 2)) && (((pattern-->(j)) < REPARSE_CODE)))) {
                if ((dont_infer_pronoun == 0)) {
                    PronounNotice((pattern-->(j)));
                    for ((k = 1):(k <= (LanguagePronouns-->(0))):(k = (k + 3))) {
                        if (((pattern-->(j)) == (LanguagePronouns-->((k + 2))))) {
                            ((parse2-->(1)) = (LanguagePronouns-->(k)));
                            if ((parser_trace >= 5)) {
                                print "[Using pronoun '";
                                print (address) (parse2-->(1));
                                print "']^";
                            }
                            break;
                        }
                    }
                }
            } else {
                ((parse2-->(1)) = VM_NumberToDictionaryAddress(((pattern-->(j)) - REPARSE_CODE)));
                if ((parser_trace >= 5)) {
                    print "[Using preposition '";
                    print (address) (parse2-->(1));
                    print "']^";
                }
            }
            if (((parse2-->(1)) ~= 0)) {
                (k = (buffer + i));
                (k = Glulx_PrintAnyToArray((buffer + i), (INPUT_BUFFER_LEN - i), (parse2-->(1))));
                (i = (i + k));
                ((buffer-->(0)) = (i - WORDSIZE));
            }
        }
    }
    (i = (WORDSIZE + (buffer-->(0))));
    ((buffer-->(0)))++;
    ((buffer->((i)++)) = 32);
    for ((j = 0):(j < (buffer2-->(0))):((i)++,(j)++)) {
        ((buffer->(i)) = (buffer2->((j + WORDSIZE))));
        ((buffer-->(0)))++;
        if (((buffer-->(0)) == INPUT_BUFFER_LEN)) {
            break;
        }
    }
    jump RECONSTRUCT_INPUT;
];
[ PARSER_CLARIF_INTERNAL_R;
];
[ Adjudicate context i j k good_ones last n ultimate flag offset;
    if ((parser_trace >= 4)) {
        print "   [Adjudicating match list of size ";
        print number_matched;
        print " in context ";
        print context;
        print "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (((indef_type)&(OTHER_BIT))) {
                print "other ";
            }
            if (((indef_type)&(MY_BIT))) {
                print "my ";
            }
            if (((indef_type)&(THAT_BIT))) {
                print "that ";
            }
            if (((indef_type)&(PLURAL_BIT))) {
                print "plural ";
            }
            if (((indef_type)&(LIT_BIT))) {
                print "lit ";
            }
            if (((indef_type)&(UNLIT_BIT))) {
                print "unlit ";
            }
            if ((indef_owner ~= 0)) {
                print "owner:";
                PrintShortName(indef_owner);
            }
            print "^";
            print "   number wanted: ";
            if ((indef_wanted == INDEF_ALL_WANTED)) {
                print "all";
            } else {
                print indef_wanted;
            }
            print "^";
            print "   most likely GNAs of names: ";
            print indef_cases;
            print "^";
        } else {
            print "definite object^";
        }
    }
    (j = (number_matched - 1));
    (good_ones = 0);
    (last = (match_list-->(0)));
    for ((i = 0):(i <= j):(i)++) {
        (n = (match_list-->(i)));
        ((match_scores-->(i)) = good_ones);
        (ultimate = ScopeCeiling(n));
        if ((((context == HELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((((((((((context == MULTI_TOKEN)) && ((ultimate == ScopeCeiling(actor))))) && ((n ~= actor)))) && ((~~((n has concealed)))))) && ((~~((n has scenery)))))) {
            (good_ones)++;
            (last = n);
        }
        if ((((context == MULTIHELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            if ((advance_warning == -1)) {
                if ((context == MULTIEXCEPT_TOKEN)) {
                    (good_ones)++;
                    (last = n);
                }
                if ((context == MULTIINSIDE_TOKEN)) {
                    if ((parent(n) ~= actor)) {
                        (good_ones)++;
                        (last = n);
                    }
                }
            } else {
                if ((((context == MULTIEXCEPT_TOKEN)) && ((n ~= advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
                if ((((context == MULTIINSIDE_TOKEN)) && ((n in advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
            }
        }
        if ((((context == CREATURE_TOKEN)) && ((CreatureTest(n) == 1)))) {
            (good_ones)++;
            (last = n);
        }
        ((match_scores-->(i)) = (1000*(good_ones - (match_scores-->(i)))));
    }
    if ((good_ones == 1)) {
        if ((((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) && ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)))) {
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) && (RulebookFailed()))) {
                (good_ones = 0);
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((good_ones == 1)) {
                return last;
            }
        } else {
            return last;
        }
    }
    if ((((context == CREATURE_TOKEN)) && ((good_ones == 0)))) {
        return (match_list-->(0));
    }
    if ((indef_mode == 0)) {
        (indef_type = 0);
    }
    ScoreMatchL(context);
    if ((number_matched == 0)) {
        return (-(1));
    }
    if ((indef_mode == 0)) {
        (i = SingleBestGuess());
        if ((i >= 0)) {
            if ((parser_trace >= 4)) {
                print "   Single best-scoring object returned.]^";
            }
            return i;
        }
    }
    if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
        if ((context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (etype = MULTI_PE);
            return (-(1));
        }
        (i = 0);
        (offset = (multiple_object-->(0)));
        for ((j = BestGuess()):(((((j ~= -1)) && ((i < indef_wanted)))) && (((i + offset) < (MATCH_LIST_WORDS - 1)))):(j = BestGuess())) {
            (flag = 0);
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j) == 0)) {
                if ((((~~((j has concealed)))) && ((~~((j has worn)))))) {
                    (flag = 1);
                }
                if ((((context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN)) && ((parent(j) ~= actor)))) {
                    (flag = 0);
                }
                if ((((action_to_be == ##Take or ##Remove)) && ((parent(j) == actor)))) {
                    (flag = 0);
                }
                (k = ChooseObjects(j, flag));
                if ((k == 1)) {
                    (flag = 1);
                } else {
                    if ((k == 2)) {
                        (flag = 0);
                    }
                }
            } else {
                (flag = 0);
                if (RulebookSucceeded()) {
                    (flag = 1);
                }
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((flag == 1)) {
                (i)++;
                ((multiple_object-->((i + offset))) = j);
                if ((parser_trace >= 4)) {
                    print "   Accepting it^";
                }
            } else {
                (i = i);
                if ((parser_trace >= 4)) {
                    print "   Rejecting it^";
                }
            }
        }
        if ((((i < indef_wanted)) && ((indef_wanted < INDEF_ALL_WANTED)))) {
            (multi_wanted = indef_wanted);
            if ((parser_trace >= 4)) {
                print "Too few found in Adjudicate^";
            }
            (multi_had = i);
        }
        ((multiple_object-->(0)) = (i + offset));
        (multi_context = context);
        if ((parser_trace >= 4)) {
            print "   Made multiple object of size ";
            print i;
            print "]^";
        }
        rtrue;
    }
    for ((i = 0):(i < number_matched):(i)++) {
        ((match_classes-->(i)) = 0);
    }
    (n = 1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_classes-->(i)) == 0)) {
            ((match_classes-->(i)) = (n)++);
            (flag = 0);
            for ((j = (i + 1)):(j < number_matched):(j)++) {
                if (((((match_classes-->(j)) == 0)) && ((Identical((match_list-->(i)), (match_list-->(j))) == 1)))) {
                    (flag = 1);
                    ((match_classes-->(j)) = (match_classes-->(i)));
                }
            }
            if ((flag == 1)) {
                ((match_classes-->(i)) = (1 - n));
            }
        }
    }
    (n)--;
    (number_of_classes = n);
    if ((parser_trace >= 4)) {
        print "   Grouped into ";
        print n;
        print " possibilities by name:^";
        for ((i = 0):(i < number_matched):(i)++) {
            if (((match_classes-->(i)) > 0)) {
                print "   ";
                CDefArt((match_list-->(i)));
                print " (";
                print (match_list-->(i));
                print ")  ---  group ";
                print (match_classes-->(i));
                print "^";
            }
        }
    }
    if ((indef_mode == 0)) {
        if ((n > 1)) {
            (k = -1);
            for ((i = 0):(i < number_matched):(i)++) {
                if (((match_scores-->(i)) > k)) {
                    (k = (match_scores-->(i)));
                    (j = (match_classes-->(i)));
                    (j = (j*j));
                    (flag = 0);
                } else {
                    if (((match_scores-->(i)) == k)) {
                        if ((((match_classes-->(i))*(match_classes-->(i))) ~= j)) {
                            (flag = 1);
                        }
                    }
                }
            }
            if (flag) {
                if ((parser_trace >= 4)) {
                    print "   Unable to choose best group, so ask player.]^";
                }
                rfalse;
            }
            if ((parser_trace >= 4)) {
                print "   Best choices are all from the same group.^";
            }
        }
    }
    if ((n == 1)) {
        (dont_infer = 1);
    }
    return BestGuess();
];
[ ReviseMulti second_p i low;
    if ((parser_trace >= 4)) {
        print "   Revising multiple object list of size ";
        print (multiple_object-->(0));
        print " with 2nd ";
        PrintShortName(second_p);
        print "^";
    }
    if ((multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
            if ((((((multi_context == MULTIEXCEPT_TOKEN)) && (((multiple_object-->(i)) ~= second_p)))) || ((((multi_context == MULTIINSIDE_TOKEN)) && (((multiple_object-->(i)) in second_p)))))) {
                (low)++;
                ((multiple_object-->(low)) = (multiple_object-->(i)));
            }
        }
        ((multiple_object-->(0)) = low);
    }
    if ((((multi_context == MULTI_TOKEN)) && ((action_to_be == ##Take)))) {
        if ((parser_trace >= 4)) {
            print "   Token 2 plural case: number with actor ";
            print low;
            print "^";
        }
        if ((take_all_rule == 2)) {
            for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
                if ((ScopeCeiling((multiple_object-->(i))) == ScopeCeiling(actor))) {
                    (low)++;
                    ((multiple_object-->(low)) = (multiple_object-->(i)));
                }
            }
            ((multiple_object-->(0)) = low);
        }
    }
    (i = (multiple_object-->(0)));
    if ((parser_trace >= 4)) {
        print "   Done: new size ";
        print i;
        print "^";
    }
    if ((i == 0)) {
        return NOTHING_PE;
    }
    rfalse;
];
[ MakeMatch obj quality i;
    if ((parser_trace >= 6)) {
        print "    Match with quality ";
        print quality;
        print "^";
    }
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(obj) == 0)))) {
        if ((parser_trace >= 6)) {
            print "    Match filtered out: token filter ";
            print token_filter;
            print "^";
        }
        rtrue;
    }
    if ((quality < match_length)) {
        rtrue;
    }
    if ((quality > match_length)) {
        (match_length = quality);
        (number_matched = 0);
    } else {
        if ((number_matched >= MATCH_LIST_WORDS)) {
            rtrue;
        }
        for ((i = 0):(i < number_matched):(i)++) {
            if (((match_list-->(i)) == obj)) {
                rtrue;
            }
        }
    }
    ((match_list-->((number_matched)++)) = obj);
    if ((parser_trace >= 6)) {
        print "    Match added to list^";
    }
];
[ ConsultNounFilterToken obj sn rv;
    if ((token_filter ofclass Routine)) {
        (sn = noun);
        (noun = obj);
        (rv = (token_filter)());
        (noun = sn);
        return rv;
    }
    if (_final_propertyvalue(OBJECT_TY, obj, (token_filter - 1))) {
        rtrue;
    }
    rfalse;
];
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
    if ((((indef_type)&(MY_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(THAT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(LIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(UNLIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((indef_owner ~= 0)) {
        (threshold)++;
    }
    if ((parser_trace >= 4)) {
        print "   Scoring match list: indef mode ";
        print indef_mode;
        print " type ";
        print indef_type;
        print ", satisfying ";
        print threshold;
        print " requirements:^";
    }
    (a_s = SCORE__BESTLOC);
    (l_s = SCORE__NEXTBESTLOC);
    if ((action_to_be == ##Take or ##Remove)) {
        (a_s = SCORE__NEXTBESTLOC);
        (l_s = SCORE__BESTLOC);
    }
    (context = context);
    for ((i = 0):(i < number_matched):(i)++) {
        (obj = (match_list-->(i)));
        (its_owner = parent(obj));
        (its_score = 0);
        (met = 0);
        if ((((((indef_type)&(MY_BIT)) ~= 0)) && ((its_owner == actor)))) {
            (met)++;
        }
        if ((((((indef_type)&(THAT_BIT)) ~= 0)) && ((its_owner == actors_location)))) {
            (met)++;
        }
        if ((((((indef_type)&(LIT_BIT)) ~= 0)) && ((obj has light)))) {
            (met)++;
        }
        if ((((((indef_type)&(UNLIT_BIT)) ~= 0)) && ((~~((obj has light)))))) {
            (met)++;
        }
        if ((((indef_owner ~= 0)) && ((((its_owner == indef_owner)) || ((CoreOf(obj) == indef_owner)))))) {
            (met)++;
        }
        if ((met < threshold)) {
            if ((parser_trace >= 4)) {
                print "   ";
                CDefArt((match_list-->(i)));
                print " (";
                print (match_list-->(i));
                print ") in ";
                DefArt(its_owner);
                print " is rejected (doesn't match descriptors)^";
            }
            ((match_list-->(i)) = -1);
        } else {
            (its_score = 0);
            if ((~~((obj has concealed)))) {
                (its_score = SCORE__UNCONCEALED);
            }
            if ((its_owner == actor)) {
                (its_score = (its_score + a_s));
            } else {
                if ((its_owner == actors_location)) {
                    (its_score = (its_score + l_s));
                } else {
                    if ((its_owner ~= Compass)) {
                        (its_score = (its_score + SCORE__NOTCOMPASS));
                    }
                }
            }
            (its_score = (its_score + (SCORE__CHOOSEOBJ*ChooseObjects(obj, 2))));
            if ((~~((obj has scenery)))) {
                (its_score = (its_score + SCORE__NOTSCENERY));
            }
            if ((obj ~= actor)) {
                (its_score = (its_score + SCORE__NOTACTOR));
            }
            if (((indef_cases)&((PowersOfTwo_TB-->(GetGNAOfObject(obj)))))) {
                (its_score = (its_score + SCORE__GNA));
            }
            ((match_scores-->(i)) = ((match_scores-->(i)) + its_score));
            if ((parser_trace >= 4)) {
                print "     ";
                CDefArt((match_list-->(i)));
                print " in ";
                DefArt(its_owner);
                print " : ";
                print (match_scores-->(i));
                print " points^";
            }
        }
    }
    for ((i = 0):(i < number_matched):(i)++) {
        while (((match_list-->(i)) == -1)) {
            if ((i == (number_matched - 1))) {
                (number_matched)--;
                break;
            }
            for ((j = i):(j < (number_matched - 1)):(j)++) {
                ((match_list-->(j)) = (match_list-->((j + 1))));
                ((match_scores-->(j)) = (match_scores-->((j + 1))));
            }
            (number_matched)--;
        }
    }
];
[ BestGuess earliest its_score best i;
    (earliest = 0);
    (best = -1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_list-->(i)) >= 0)) {
            (its_score = (match_scores-->(i)));
            if ((its_score > best)) {
                (best = its_score);
                (earliest = i);
            }
        }
    }
    if ((parser_trace >= 4)) {
        if ((best < 0)) {
            print "   Best guess ran out of choices^";
        } else {
            print "   Best guess ";
            DefArt((match_list-->(earliest)));
            print "^";
        }
    }
    if ((best < 0)) {
        return (-(1));
    }
    (i = (match_list-->(earliest)));
    ((match_list-->(earliest)) = -1);
    return i;
];
[ SingleBestGuess earliest its_score best i;
    (earliest = -1);
    (best = -1000);
    for ((i = 0):(i < number_matched):(i)++) {
        (its_score = (match_scores-->(i)));
        if ((its_score == best)) {
            (earliest = -1);
        }
        if ((its_score > best)) {
            (best = its_score);
            (earliest = (match_list-->(i)));
        }
    }
    return earliest;
];
[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if ((o1 == o2)) {
        rtrue;
    }
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K3_direction)) || ((o2 ofclass K3_direction)))) {
        rfalse;
    }
    if (((((o1.parse_name) ~= 0)) || (((o2.parse_name) ~= 0)))) {
        if (((o1.parse_name) ~= (o2.parse_name))) {
            rfalse;
        }
        (parser_action = ##TheSame);
        (parser_one = o1);
        (parser_two = o2);
        (j = wn);
        (i = RunRoutines(o1, A_parse_name));
        (wn = j);
        if ((i == -1)) {
            rtrue;
        }
        if ((i == -2)) {
            rfalse;
        }
    }
    (p1 = (_final_propertyarray(OBJECT_TY, o1, A_name)));
    (n1 = ((_final_propertylength(OBJECT_TY, o1, A_name))/WORDSIZE));
    (p2 = (_final_propertyarray(OBJECT_TY, o2, A_name)));
    (n2 = ((_final_propertylength(OBJECT_TY, o2, A_name))/WORDSIZE));
    for ((i = 0):(i < n1):(i)++) {
        (flag = 0);
        for ((j = 0):(j < n2):(j)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    for ((j = 0):(j < n2):(j)++) {
        (flag = 0);
        for ((i = 0):(i < n1):(i)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ PrintInferredCommand from singleton_noun;
    (singleton_noun = 0);
    if ((((((((from ~= 0)) && ((from == (pcount - 1))))) && (((pattern-->(from)) > 1)))) && (((pattern-->(from)) < REPARSE_CODE)))) {
        (singleton_noun = 1);
    }
    if (singleton_noun) {
        BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
        if ((ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from))) == 0)) {
            print "(";
            PrintCommand(from);
            print ")^";
        }
        EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
    } else {
        print "(";
        PrintCommand(from);
        print ")^";
    }
];
[ PrintCommand from i k spacing_flag;
    if ((from == 0)) {
        (i = verb_word);
        if ((LanguageVerb(i) == 0)) {
            if ((PrintVerb(i) == 0)) {
                print (address) i;
            }
        }
        (from)++;
        (spacing_flag = 1);
    }
    for ((k = from):(k < pcount):(k)++) {
        (i = (pattern-->(k)));
        if ((i == PATTERN_NULL)) {
            continue;
        }
        if (spacing_flag) {
            print (char) 32;
        }
        if ((i == 0)) {
            PARSER_CLARIF_INTERNAL_RM(70);
            jump TokenPrinted;
        }
        if ((i == 1)) {
            PARSER_CLARIF_INTERNAL_RM(71);
            jump TokenPrinted;
        }
        if ((i >= REPARSE_CODE)) {
            print (address) VM_NumberToDictionaryAddress((i - REPARSE_CODE));
        } else {
            if ((i ofclass K3_direction)) {
                LanguageDirection(i);
            } else {
                DefArt(i);
            }
        }
        .TokenPrinted;
        (spacing_flag = 1);
    }
];
[ CantSee i w e;
    (saved_oops = oops_from);
    if ((scope_token ~= 0)) {
        (scope_error = scope_token);
        return ASKSCOPE_PE;
    }
    (wn)--;
    (w = NextWord());
    (e = CANTSEE_PE);
    if ((w == pronoun_word)) {
        (w = NextWordStopped());
        (wn)--;
        if ((((w == -1)) || (((line_token-->(pcount)) ~= ENDIT_TOKEN)))) {
            if ((pcount > 0)) {
                AnalyseToken((line_token-->((pcount - 1))));
            }
            if ((((pcount > 0)) && ((found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT)))) {
                (e = NOTINCONTEXT_PE);
            } else {
                (pronoun__word = pronoun_word);
                (pronoun__obj = pronoun_obj);
                (e = ITGONE_PE);
            }
        }
    }
    if ((etype > e)) {
        return etype;
    }
    return e;
];
[ MultiAdd o i j;
    (i = (multiple_object-->(0)));
    if ((i == (MATCH_LIST_WORDS - 1))) {
        (toomany_flag = 1);
        rtrue;
    }
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            rtrue;
        }
    }
    (i)++;
    ((multiple_object-->(i)) = o);
    ((multiple_object-->(0)) = i);
];
[ MultiSub o i j k;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            for ((k = j):(k <= i):(k)++) {
                ((multiple_object-->(k)) = (multiple_object-->((k + 1))));
            }
            ((multiple_object-->(0)) = --(i));
            rfalse;
        }
    }
    return VAGUE_PE;
];
[ MultiFilter attr i j o;
    .MFiltl;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        (o = (multiple_object-->(j)));
        if ((~~(_final_propertyvalue(OBJECT_TY, o, attr)))) {
            MultiSub(o);
            jump MFiltl;
        }
    }
];
[ PlaceInScope O opts ws;
    (ws = wn);
    (wn = match_from);
    if ((opts == 0)) {
        DoScopeActionAndRecurse(O);
    } else {
        DoScopeAction(O);
    }
    (wn = ws);
    rtrue;
];
[ AddToScope obj;
    if ((ats_flag >= 2)) {
        DoScopeActionAndRecurse(obj, 0, (ats_flag - 2));
    }
    if ((ats_flag == 1)) {
        if ((HasLightSource(obj) == 1)) {
            (ats_hls = 1);
        }
    }
];
[ TestScope obj act a al sr ss st x y;
    (x = parser_one);
    (y = parser_two);
    (parser_one = obj);
    (parser_two = 0);
    (a = actor);
    (al = actors_location);
    (ss = scope_stage);
    (st = scope_token);
    (scope_stage = 0);
    (scope_token = 0);
    (sr = scope_reason);
    (scope_reason = TESTSCOPE_REASON);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    SearchScope(actors_location, actor, 0);
    (scope_reason = sr);
    (actor = a);
    (scope_stage = ss);
    (scope_token = st);
    (actors_location = al);
    (parser_one = x);
    (x = parser_two);
    (parser_two = y);
    return x;
];
[ LoopOverScope routine act x y a al;
    (x = parser_one);
    (y = scope_reason);
    (a = actor);
    (al = actors_location);
    (parser_one = routine);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    (scope_reason = LOOPOVERSCOPE_REASON);
    SearchScope(actors_location, actor, 0);
    (parser_one = x);
    (scope_reason = y);
    (actor = a);
    (actors_location = al);
];
[ SearchScope domain1 domain2 context i;
    if ((domain1 == 0)) {
        rtrue;
    }
    if (scope_token) {
        (scope_stage = 2);
        if ((parser_trace >= 3)) {
            print "  [Scope routine called at stage 2]^";
        }
        if (((scope_token)() ~= 0)) {
            rtrue;
        }
    }
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if ((ForActivity(DECIDING_SCOPE_ACT, actor) == 0)) {
        if ((((((scope_reason == PARSING_REASON)) && ((context == MULTIINSIDE_TOKEN)))) && ((advance_warning ~= -1)))) {
            if ((IsSeeThrough(advance_warning) == 1)) {
                ScopeWithin(advance_warning, 0, context);
            }
        } else {
            if ((((((((scope_reason == PARSING_REASON)) && ((context ~= CREATURE_TOKEN)))) && ((indef_mode == 0)))) && ((domain1 == actors_location)))) {
                ScopeWithin(Compass);
            }
            if (((or_tmp_var = domain1) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeAction(domain1);
            }
            ScopeWithin(domain1, domain2, context);
            if (domain2) {
                if (((or_tmp_var = domain2) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                    DoScopeAction(domain2);
                }
                ScopeWithin(domain2, 0, context);
            }
        }
        if ((thedark == domain1 or domain2)) {
            DoScopeActionAndRecurse(actor, actor, context);
            if (((or_tmp_var = parent(actor)) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeActionAndRecurse(parent(actor), parent(actor), context);
            }
        }
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];
[ ScopeWithin domain nosearch context obj next_obj;
    if ((domain == 0)) {
        rtrue;
    }
    (obj = child(domain));
    while (obj) {
        (next_obj = sibling(obj));
        if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
            DoScopeActionAndRecurse(obj, nosearch, context);
        }
        (obj = next_obj);
    }
];
[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
    DoScopeAction(domain);
    if ((((domain ~= nosearch)) && ((((domain ofclass K1_room or K8_person)) || ((IsSeeThrough(domain) == 1)))))) {
        (obj = child(domain));
        while (obj) {
            (next_obj = sibling(obj));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, nosearch, context);
            }
            (obj = next_obj);
        }
    }
    if ((_final_propertyexists(OBJECT_TY, domain, A_component_child))) {
        (obj = (domain.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, 0, context);
            }
            (obj = next_obj);
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, domain, A_add_to_scope)));
    if ((ad ~= 0)) {
        (i = (metaclass((ad-->(0))) == Object));
        if (i) {
            (ats_flag = (2 + context));
            RunRoutines(domain, A_add_to_scope);
            (ats_flag = 0);
        } else {
            (n = (_final_propertylength(OBJECT_TY, domain, A_add_to_scope)));
            for ((i = 0):((WORDSIZE*i) < n):(i)++) {
                if ((ad-->(i))) {
                    DoScopeActionAndRecurse((ad-->(i)), 0, context);
                }
            }
        }
    }
];
[ DoScopeAction item;
    if ((parser_trace >= 6)) {
        print "[DSA on ";
        DefArt(item);
        print " with reason = ";
        print scope_reason;
        print " p1 = ";
        print parser_one;
        print " p2 = ";
        print parser_two;
        print "]^";
    }
    @push parser_one;
    @push scope_reason;
    switch (scope_reason) {
        TESTSCOPE_REASON:
            if ((item == parser_one)) {
                (parser_two = 1);
            }
            ;
        LOOPOVERSCOPE_REASON:
            if ((parser_one ofclass Routine)) {
                (parser_one)(item);
            }
            ;
        PARSING_REASON, TALKING_REASON:
            MatchTextAgainstObject(item);
            ;
    }
    @pull scope_reason;
    @pull parser_one;
];
[ MatchTextAgainstObject item i;
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(item) == 0)))) {
        rtrue;
    }
    if ((match_from <= num_words)) {
        (wn = match_from);
        (i = NounWord());
        if ((((i == 1)) && ((player == item)))) {
            MakeMatch(item, 1);
        }
        if ((((((i >= 2)) && ((i < 128)))) && (((LanguagePronouns-->(i)) == item)))) {
            MakeMatch(item, 1);
        }
    }
    (wn = match_from);
    if ((TryGivenObject(item) > 0)) {
        if ((((indef_nspec_at > 0)) && ((match_from ~= indef_nspec_at)))) {
            (wn = indef_nspec_at);
            if ((TryGivenObject(item) > 0)) {
                (match_from = indef_nspec_at);
                ResetDescriptors();
            }
            (wn = match_from);
        }
    }
];
[ TryGivenObject obj nomatch threshold k w j;
    if ((parser_trace >= 5)) {
        print "    Trying ";
        DefArt(obj);
        print " at word ";
        print wn;
        print "^";
    }
    if (((nomatch) && ((obj == 0)))) {
        rfalse;
    }
    (dict_flags_of_noun = 0);
    if ((wn > num_words)) {
        if (nomatch) {
            rfalse;
        }
        if ((indef_mode ~= 0)) {
            (dict_flags_of_noun = 112);
        }
        MakeMatch(obj, 0);
        if ((parser_trace >= 5)) {
            print "    Matched (0)^";
        }
        rtrue;
    }
    if (((obj.parse_name) ~= 0)) {
        (parser_action = NULL);
        (j = wn);
        (k = RunRoutines(obj, A_parse_name));
        if ((k > 0)) {
            (wn = (j + k));
            .MMbyPN;
            if ((parser_action == ##PluralFound)) {
                (dict_flags_of_noun = ((dict_flags_of_noun)|(4)));
            }
            if (((dict_flags_of_noun)&(4))) {
                if ((~~(allow_plurals))) {
                    (k = 0);
                } else {
                    if ((indef_mode == 0)) {
                        (indef_mode = 1);
                        (indef_type = 0);
                        (indef_wanted = 0);
                    }
                    (indef_type = ((indef_type)|(PLURAL_BIT)));
                    if ((indef_wanted == 0)) {
                        (indef_wanted = INDEF_ALL_WANTED);
                    }
                }
            }
            if ((parser_trace >= 5)) {
                print "    Matched (";
                print k;
                print ")^";
            }
            if ((nomatch == 0)) {
                MakeMatch(obj, k);
            }
            return k;
        }
        if ((k == 0)) {
            jump NoWordsMatch;
        }
    }
    (parser_action = NULL);
    (w = NounWord());
    if ((((w == 1)) && ((player == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((((((w >= 2)) && ((w < 128)))) && (((LanguagePronouns-->(w)) == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((Refers(obj, (wn - 1)) == 0)) {
        .NoWordsMatch;
        if ((indef_mode ~= 0)) {
            (k = 0);
            (parser_action = NULL);
            jump MMbyPN;
        }
        rfalse;
    }
    (threshold = 1);
    (dict_flags_of_noun = (((w->(#dict_par1)))&(116)));
    (w = NextWord());
    while (Refers(obj, (wn - 1))) {
        (threshold)++;
        if (w) {
            (dict_flags_of_noun = ((dict_flags_of_noun)|((((w->(#dict_par1)))&(116)))));
        }
        (w = NextWord());
    }
    (k = threshold);
    jump MMbyPN;
];
[ Refers obj wnum wd k l m;
    if ((obj == 0)) {
        rfalse;
    }
    (k = wn);
    (wn = wnum);
    (wd = NextWordStopped());
    (wn = k);
    if (indirect_parser_inflection) {
        (k = (parser_inflection)(obj,wd));
        if ((k >= 0)) {
            return k;
        }
        (m = (-(k)));
    } else {
        (m = parser_inflection);
    }
    (k = (_final_propertyarray(OBJECT_TY, obj, m)));
    (l = (((_final_propertylength(OBJECT_TY, obj, m))/WORDSIZE) - 1));
    for ((m = 0):(m <= l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ WordInProperty wd obj prop k l m;
    (k = (_final_propertyarray(OBJECT_TY, obj, prop)));
    (l = ((_final_propertylength(OBJECT_TY, obj, prop))/WORDSIZE));
    for ((m = 0):(m < l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ NounWord i j s;
    (i = NextWord());
    if ((i == 0)) {
        rfalse;
    }
    if ((i == ME1__WD or ME2__WD or ME3__WD)) {
        rtrue;
    }
    (s = (LanguagePronouns-->(0)));
    for ((j = 1):(j <= s):(j = (j + 3))) {
        if ((i == (LanguagePronouns-->(j)))) {
            return (j + 2);
        }
    }
    if (((((i->(#dict_par1)))&(128)) == 0)) {
        rfalse;
    }
    return i;
];
[ TryNumber wordnum i j c num len mul tot d digit;
    (i = wn);
    (wn = wordnum);
    (j = NextWord());
    (wn = i);
    (j = NumberWord(j));
    if ((j >= 1)) {
        return j;
    }
    (i = (wordnum*3));
    (j = (parse-->(i)));
    (num = (j + buffer));
    (len = (parse-->((i - 1))));
    if ((len >= 4)) {
        (mul = 1000);
    }
    if ((len == 3)) {
        (mul = 100);
    }
    if ((len == 2)) {
        (mul = 10);
    }
    if ((len == 1)) {
        (mul = 1);
    }
    (tot = 0);
    (c = 0);
    (len = (len - 1));
    for ((c = 0):(c <= len):(c)++) {
        (digit = (num->(c)));
        if ((digit == 48)) {
            (d = 0);
            jump digok;
        }
        if ((digit == 49)) {
            (d = 1);
            jump digok;
        }
        if ((digit == 50)) {
            (d = 2);
            jump digok;
        }
        if ((digit == 51)) {
            (d = 3);
            jump digok;
        }
        if ((digit == 52)) {
            (d = 4);
            jump digok;
        }
        if ((digit == 53)) {
            (d = 5);
            jump digok;
        }
        if ((digit == 54)) {
            (d = 6);
            jump digok;
        }
        if ((digit == 55)) {
            (d = 7);
            jump digok;
        }
        if ((digit == 56)) {
            (d = 8);
            jump digok;
        }
        if ((digit == 57)) {
            (d = 9);
            jump digok;
        }
        return (-(1000));
        .digok;
        (tot = (tot + (mul*d)));
        (mul = (mul/10));
    }
    if ((len > 3)) {
        (tot = 10000);
    }
    return tot;
];
[ GetGender person;
    if ((~~((person has female)))) {
        rtrue;
    }
    rfalse;
];
[ GetGNAOfObject obj case gender;
    if ((~~((obj has animate)))) {
        (case = 6);
    }
    if ((obj has male)) {
        (gender = A_male);
    }
    if ((obj has female)) {
        (gender = A_female);
    }
    if ((obj has neuter)) {
        (gender = A_neuter);
    }
    if ((gender == 0)) {
        if ((case == 0)) {
            (gender = LanguageAnimateGender);
        } else {
            (gender = LanguageInanimateGender);
        }
    }
    if ((gender == A_female)) {
        (case = (case + 1));
    }
    if ((gender == A_neuter)) {
        (case = (case + 2));
    }
    if ((obj has pluralname)) {
        (case = (case + 3));
    }
    return case;
];
[ DetectPluralWord at n i w swn outcome;
    (swn = wn);
    (wn = at);
    for ((i = 0):(i < n):(i)++) {
        (w = NextWordStopped());
        if ((w == 0 or THEN1__WD or comma_word or -1)) {
            break;
        }
        if ((((w->(#dict_par1)))&(4))) {
            (parser_action = ##PluralFound);
            (outcome = 1);
        }
    }
    (wn = swn);
    return outcome;
];
[ SetPronoun dword value x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            ((LanguagePronouns-->((x + 2))) = value);
            rtrue;
        }
    }
    RunTimeError(14);
];
[ PronounValue dword x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            return (LanguagePronouns-->((x + 2)));
        }
    }
    rfalse;
];
[ ResetVagueWords obj;
    PronounNotice(obj);
];
[ PronounNotice obj x bm g;
    if ((obj == player)) {
        rtrue;
    }
    (g = GetGNAOfObject(obj));
    (bm = (PowersOfTwo_TB-->(g)));
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
            ((LanguagePronouns-->((x + 2))) = obj);
        }
    }
    if (((((g%6) < 3)) && ((obj has ambigpluralname)))) {
        (g = (g + 3));
        (bm = (PowersOfTwo_TB-->(g)));
        for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
            if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
                ((LanguagePronouns-->((x + 2))) = obj);
            }
        }
    }
];
[ PronounNoticeHeldObjects x;
    objectloop (x in player) {
        PronounNotice(x);
    }
    (x = 0);
    rfalse;
];
[ YesOrNo i j;
    for (:1:) {
        if ((((location ~= 0)) && ((parent(player) ~= 0)))) {
            DrawStatusLine();
        }
        KeyboardPrimitive(buffer2, parse2);
        (j = (parse2-->(0)));
        if (j) {
            (i = (parse2-->(1)));
            if ((i == YES1__WD or YES2__WD or YES3__WD)) {
                rtrue;
            }
            if ((i == NO1__WD or NO2__WD or NO3__WD)) {
                rfalse;
            }
        }
        YES_OR_NO_QUESTION_INTERNAL_RM(65);
        print "> ";
    }
];
[ YES_OR_NO_QUESTION_INTERNAL_R;
];
[ NumberWord o i n;
    (n = (LanguageNumbers-->(0)));
    for ((i = 1):(i <= n):(i = (i + 2))) {
        if ((o == (LanguageNumbers-->(i)))) {
            return (LanguageNumbers-->((i + 1)));
        }
    }
    rfalse;
];
[ COBJ__Copy words from to i;
    for ((i = 0):(i < words):(i)++) {
        ((to-->(i)) = (from-->(i)));
    }
];
[ COBJ__SwapMatches i x;
    (x = number_matched);
    (number_matched = (alt_match_list-->(0)));
    ((alt_match_list-->(0)) = x);
    if ((x < number_matched)) {
        (x = number_matched);
    }
    for ((i = x):(i > 0):(i)--) {
        (x = (match_list-->((i - 1))));
        ((match_list-->((i - 1))) = (alt_match_list-->(i)));
        ((alt_match_list-->(i)) = x);
    }
];
[ ChooseObjects obj code l i swn spcount;
    if ((code < 2)) {
        rfalse;
    }
    if ((cobj_flag == 1)) {
        .CodeOne;
        if ((parameters > 0)) {
            return ScoreDabCombo((parser_results-->(INP1_PRES)), obj);
        } else {
            (l = 0);
            for ((i = 1):(i <= (alt_match_list-->(0))):(i)++) {
                (spcount = ScoreDabCombo(obj, (alt_match_list-->(i))));
                if ((spcount == HIGHEST_DPMR_SCORE)) {
                    return spcount;
                }
                if ((spcount > l)) {
                    (l = spcount);
                }
            }
            return l;
        }
    }
    if ((cobj_flag == 2)) {
        .CodeTwo;
        @push action_to_be;
        if ((parameters == 0)) {
            if ((advance_warning > 0)) {
                (l = ScoreDabCombo(obj, advance_warning));
            } else {
                (l = ScoreDabCombo(obj, 0));
            }
        } else {
            (l = ScoreDabCombo((parser_results-->(INP1_PRES)), obj));
        }
        @pull action_to_be;
        return l;
    }
    (swn = wn);
    (spcount = pcount);
    while (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
        (pcount)++;
    }
    if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
        if (((line_tdata-->(pcount)) == TOPIC_TOKEN)) {
            (pcount = spcount);
            jump CodeTwo;
        }
        while ((wn <= num_words)) {
            (l = NextWordStopped());
            (wn)--;
            if ((l == THEN1__WD)) {
                break;
            }
            if ((((l ~= -1 or 0)) && ((((l->(#dict_par1)))&(8))))) {
                (wn)++;
                continue;
            }
            if ((l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
                (wn)++;
                continue;
            }
            SafeSkipDescriptors();
            @push match_length;
            @push token_filter;
            @push match_from;
            ((alt_match_list-->(0)) = number_matched);
            COBJ__Copy(number_matched, match_list, (alt_match_list + WORDSIZE));
            (match_length = 0);
            (number_matched = 0);
            (match_from = wn);
            (token_filter = 0);
            SearchScope(actor, actors_location, (line_tdata-->(pcount)));
            (wn = swn);
            (cobj_flag = 1);
            COBJ__SwapMatches();
            @pull match_from;
            @pull token_filter;
            @pull match_length;
            (pcount = spcount);
            jump CodeOne;
        }
    }
    (pcount = spcount);
    (wn = swn);
    (cobj_flag = 2);
    jump CodeTwo;
];
[ ScoreDabCombo a b result;
    @push action;
    @push act_requester;
    @push noun;
    @push second;
    (action = action_to_be);
    (act_requester = player);
    if (action_reversed) {
        (noun = b);
        (second = a);
    } else {
        (noun = a);
        (second = b);
    }
    (result = CheckDPMR());
    @pull second;
    @pull noun;
    @pull act_requester;
    @pull action;
    return result;
];
[ CheckDPMR result sinp1 sinp2 rv;
    (sinp1 = inp1);
    (sinp2 = inp2);
    (inp1 = noun);
    (inp2 = second);
    (rv = FollowRulebook(DOES_THE_PLAYER_MEAN_RB));
    (inp1 = sinp1);
    (inp2 = sinp2);
    if (((rv) && (RulebookSucceeded()))) {
        (result = ResultOfRule());
        if ((result == RBNO4_OUTCOME_U1)) {
            return 4;
        }
        if ((result == RBNO3_OUTCOME_U1)) {
            return 3;
        }
        if ((result == RBNO2_OUTCOME_U1)) {
            return 2;
        }
        if ((result == RBNO1_OUTCOME_U1)) {
            rtrue;
        }
        if ((result == RBNO0_OUTCOME_U1)) {
            rfalse;
        }
    }
    return 2;
];
[ DefaultTopic;
    return GPR_FAIL;
];
[ TEXT_TY_ROGPR txt p cp r;
    if ((txt == 0)) {
        return GPR_FAIL;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (r = TEXT_TY_ROGPRI(txt));
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_ROGPRI txt pos len wa wl wpos bdm ch own;
    (bdm = 1);
    (own = wn);
    (len = BlkValueLBCapacity(txt));
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 32 or 9 or 10 or 0)) {
            if (bdm) {
                continue;
            }
            (bdm = 1);
            if ((wpos ~= wl)) {
                return GPR_FAIL;
            }
            if ((ch == 0)) {
                break;
            }
        } else {
            if (bdm) {
                (bdm = 0);
                if ((NextWordStopped() == -1)) {
                    return GPR_FAIL;
                }
                (wa = WordAddress((wn - 1)));
                (wl = WordLength((wn - 1)));
                (wpos = 0);
            }
            if (((wa->(wpos)) ~= ch or TEXT_TY_RevCase(ch))) {
                return GPR_FAIL;
            }
            (wpos)++;
        }
    }
    if ((wn == own)) {
        return GPR_FAIL;
    }
    return GPR_PREPOSITION;
];
[ RunRoutines obj prop;
    if ((obj == thedark)) {
        (obj = real_location);
    }
    if (((_final_propertyarray(OBJECT_TY, obj, prop)) == 0)) {
        rfalse;
    }
    return _final_message0(obj, prop);
];
[ SetPlayersCommand from_txt i len at p cp;
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (len = TEXT_TY_CharacterLength(from_txt));
    if ((len > 118)) {
        (len = 118);
    }
    ((buffer-->(0)) = len);
    (at = 4);
    for ((i = 0):(i < len):(i)++) {
        ((buffer->((i + at))) = CharToCase(BlkValueRead(from_txt, i), 0));
    }
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    TEXT_TY_Untransmute(from_txt, p, cp);
];
[ LIST_OF_TY_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = (multiple_object-->(0)));
    LIST_OF_TY_SetLength(list, len);
    for ((i = 1):(i <= len):(i)++) {
        LIST_OF_TY_PutItem(list, i, (multiple_object-->(i)));
    }
    return list;
];
[ LIST_OF_TY_Set_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = BlkValueRead(list, LIST_LENGTH_F));
    if ((len > 63)) {
        (len = 63);
    }
    ((multiple_object-->(0)) = len);
    for ((i = 1):(i <= len):(i)++) {
        ((multiple_object-->(i)) = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    }
];
[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
    (wnc = wn);
    (original_wn = wn);
    (group_wn = wn);
    (r = DECIMAL_TOKEN_INNER());
    if ((r ~= GPR_FAIL)) {
        return r;
    }
    (wn = wnc);
    (r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN));
    if ((((r == GPR_NUMBER)) && ((parsed_number ~= 10000)))) {
        return r;
    }
    (wn = wnc);
    (wa = WordAddress(wn));
    (wl = WordLength(wn));
    (sign = 1);
    (base = 10);
    (digit_count = 0);
    if (((wa->(0)) ~= 45 or 36 or 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
        return GPR_FAIL;
    }
    if (((wa->(0)) == 45)) {
        (sign = -1);
        (wl)--;
        (wa)++;
    }
    if ((wl == 0)) {
        return GPR_FAIL;
    }
    (n = 0);
    while ((wl > 0)) {
        if (((wa->(0)) >= 97)) {
            (digit = (((wa->(0)) - 97) + 10));
        } else {
            (digit = ((wa->(0)) - 48));
        }
        (digit_count)++;
        switch (base) {
            2:
                if ((digit_count == 17)) {
                    return GPR_FAIL;
                }
                ;
            10:
                if ((digit_count == 11)) {
                    return GPR_FAIL;
                }
                if ((digit_count == 10)) {
                    if ((n > 214748364)) {
                        return GPR_FAIL;
                    }
                    if ((n == 214748364)) {
                        if ((((sign == 1)) && ((digit > 7)))) {
                            return GPR_FAIL;
                        }
                        if ((((sign == -1)) && ((digit > 8)))) {
                            return GPR_FAIL;
                        }
                    }
                }
                ;
            16:
                if ((digit_count == 5)) {
                    return GPR_FAIL;
                }
                ;
        }
        if ((((digit >= 0)) && ((digit < base)))) {
            (n = ((base*n) + digit));
        } else {
            return GPR_FAIL;
        }
        (wl)--;
        (wa)++;
    }
    (parsed_number = (n*sign));
    (wn)++;
    return GPR_NUMBER;
];
[ TRUTH_STATE_TOKEN original_wn wd;
    (original_wn = wn);
    (wd = TRUTH_STATE_TOKEN_INNER());
    if ((wd ~= GPR_FAIL)) {
        return wd;
    }
    (wn = original_wn);
    (wd = NextWordStopped());
    if ((wd == 'true')) {
        (parsed_number = 1);
        return GPR_NUMBER;
    }
    if ((wd == 'false')) {
        (parsed_number = 0);
        return GPR_NUMBER;
    }
    (wn = original_wn);
    return GPR_FAIL;
];
[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
    if ((wn > num_words)) {
        return GPR_FAIL;
    }
    (firstwd = wn);
    (buf = WordAddress(wn));
    (bufend = buf);
    (lastchar = 0);
    while ((wn <= num_words)) {
        (newstart = WordAddress(wn));
        if ((newstart ~= bufend)) {
            if ((((lastchar ~= 42 or 120 or 88 or 215)) && (((newstart->(0)) ~= 42 or 120 or 88 or 215)))) {
                break;
            }
        }
        (newlen = WordLength(wn));
        for ((ix = 0):(ix < newlen):(ix)++) {
            (ch = (newstart->(ix)));
            if ((~~((((((ch >= 48)) && ((ch <= 57)))) || ((ch == 45 or 43 or 69 or 101 or 46 or 120 or 88 or 42 or 215 or 94)))))) {
                break;
            }
        }
        if ((ix < newlen)) {
            break;
        }
        (bufend = (newstart + newlen));
        (wn)++;
        (lastchar = ((bufend - 1)->(0)));
        (lastwasdot = (((newlen == 1)) && ((lastchar == 46))));
    }
    if ((((wn > firstwd)) && (lastwasdot))) {
        (wn)--;
        (bufend)--;
    }
    if ((wn == firstwd)) {
        return GPR_FAIL;
    }
    (parsed_number = FloatParse(buf, (bufend - buf), 1));
    if ((parsed_number == FLOAT_NAN)) {
        return GPR_FAIL;
    }
    return GPR_NUMBER;
];
#ifdef BASICINFORMKIT;
[ _final_propertyvalue K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) { if (o has p) rtrue; rfalse; }
            if (o provides p) return o.p;
        }
        rfalse;
    } else {
        t = value_property_holders-->K;
        return (t.(p-->1))-->(o+COL_HSIZE);
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyexists K o p holder;
if (K == OBJECT_TY) {
    if ((o) && (metaclass(o) == Object)) {
        if ((p-->0 == 2) || (o provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
} else {
    if ((o >= 1) && (o <= value_ranges-->K)) {
        holder = value_property_holders-->K;
        if ((holder) && (holder provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
}
rfalse; ];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyarray K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.&p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertylength K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.#p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_store_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v) give o p; else give o ~p;
            } else if (o provides p) {
                o.p = v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) = v;
    }
];
[ _final_preinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return ++(o.p);
            }
        }
    } else {
       return ++(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_predec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return --(o.p);
            }
        }
    } else {
       return --(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_postinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)++;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))++;
    }
    return 0;
];
[ _final_postdec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)--;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))--;
    }
    return 0;
];
[ _final_setbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o p;
            } else if (o provides p) {
                o.p = o.p | v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) | v;
    }
];
[ _final_clearbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o ~p;
            } else if (o provides p) {
                o.p = o.p & ~v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) & ~v;
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_message0 o p q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q();
];
[ _final_message1 o p v1 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1);
];
[ _final_message2 o p v1 v2 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2);
];
[ _final_message3 o p v1 v2 v3 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2, v3);
];
#endif;
Verb 'take' 'carry' 'hold' 
	* 'inventory' -> Inv 
	* multi -> Take 
	* 'off' noun -> Disrobe 
	* noun 'off' -> Disrobe 
	* multiinside 'from' noun -> Remove 
	* multiinside 'off' noun -> Remove;
Verb 'get' 
	* 'out' / 'off' / 'down' / 'up' -> Exit 
	* 'in' / 'on' -> Enter 
	* multi -> Take 
	* 'in' / 'into' / 'on' / 'onto' noun -> Enter 
	* 'off' / 'down' noun -> GetOff 
	* 'out' 'of'  noun=Noun_Filter1 -> GetOff 
	* multiinside 'from' noun -> Remove;
Verb 'pick' 
	*  noun=Noun_Filter2 -> Take 
	* 'up' multi -> Take 
	* multi 'up' -> Take;
Verb 'stand' 
	* -> A_standing 
	* 'up' -> A_standing 
	* 'on' noun -> Enter;
Verb 'remove' 
	* held -> Disrobe 
	* multiinside 'from' noun -> Remove;
Verb 'shed' 'doff' 'disrobe' 
	* held -> Disrobe;
Verb 'wear' 'don' 
	* held -> Wear;
Verb 'put' 
	* 'on' held -> Wear 
	* held 'on' -> Wear 
	* 'down' multiheld -> Drop 
	* multiheld 'down' -> Drop 
	*  noun=Noun_Filter3 'on'  noun=Noun_Filter4 -> PutOn 
	* held 'under' noun -> A_hiding_it_under 
	* multiexcept 'in' / 'inside' / 'into' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'insert' 
	* multiexcept 'in' / 'into' noun -> Insert;
Verb 'drop' 'throw' 'discard' 
	* multiheld -> Drop 
	* held 'at' / 'against' noun -> ThrowAt 
	* held 'at' / 'on' noun -> A_throwing 
	* multiexcept 'in' / 'into' / 'down' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'give' 'pay' 'offer' 'feed' 
	* creature held -> Give reverse 
	* held 'to' creature -> Give;
Verb 'show' 'present' 'display' 
	* creature held -> Show reverse 
	* held 'to' creature -> Show;
Verb 'go' 'walk' 'run' 
	* -> Go 
	*  noun=Noun_Filter5 -> Go 
	* noun -> Enter 
	* 'into' / 'in' / 'inside' / 'through' noun -> Enter;
Verb 'inventory' 'i//' 'inv' 
	* -> Inv;
Verb 'look' 'l//' 
	* -> Look 
	* noun -> Examine 
	* 'at' noun -> Examine 
	* 'inside' / 'in' / 'into' / 'through' noun -> Search 
	* 'under' noun -> LookUnder 
	* 'under' / 'underneath' / 'beneath' noun -> LookUnder 
	* 'up' topic 'in' noun -> Consult reverse;
Verb 'consult' 
	* noun 'on' / 'about' topic -> Consult;
Verb 'unwrap' 
	* noun -> Open;
Verb 'close' 'shut' 'cover' 
	* noun -> Close 
	* 'up' noun -> Close 
	* 'off' noun -> SwitchOff;
Verb 'enter' 'cross' 
	* -> Enter 
	* noun -> Enter;
Verb 'sit' 
	* 'on' / 'in' / 'inside' noun -> Enter 
	* 'on' 'top' 'of' noun -> Enter;
Verb 'exit' 'leave' 'out' 
	* -> Exit 
	* Mistake_Token1  noun=Noun_Filter6 -> MistakeAction 
	*  noun=Noun_Filter7 -> GetOff;
Verb 'examine' 'x//' 'watch' 'describe' 'check' 
	* noun -> Examine 
	* 'under' / 'underneath' / 'beneath' noun -> LookUnder;
Verb 'read' 
	* -> A_reading 
	* noun -> Examine 
	* 'about' topic 'in' noun -> Consult reverse 
	* topic 'in' noun -> Consult reverse;
Verb 'yes' 'y//' 
	* -> Yes;
Verb 'no' 
	* -> No;
Verb 'sorry' 
	* -> Sorry;
Verb 'search' 
	* noun -> Search;
Verb 'wave' 
	* -> WaveHands 
	* noun -> Wave;
Verb 'set' 'adjust' 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to 
	* noun 'on' noun -> PutOn 
	* noun 'to' topic -> SetTo;
Verb 'pull' 'drag' 
	* noun -> Pull;
Verb 'push' 'move' 'shift' 'clear' 'press' 
	* noun -> Push 
	* noun  noun=Noun_Filter8 -> PushDir 
	* noun 'to'  noun=Noun_Filter9 -> PushDir;
Verb 'turn' 'rotate' 'twist' 'unscrew' 
	* noun -> Turn 
	* Mistake_Token2 'on'  noun=Noun_Filter10 -> MistakeAction 
	* noun 'on' -> SwitchOn 
	* 'on' noun -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to;
Verb 'switch' 
	*  noun=Noun_Filter11 -> SwitchOff 
	* noun -> SwitchOn 
	* Mistake_Token3 'on'  noun=Noun_Filter12 -> MistakeAction 
	* 'on' noun -> SwitchOn 
	* noun 'on' -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff;
Verb 'lock' 
	*  noun=Noun_Filter13 -> A_locking_keylessly 
	*  noun=Noun_Filter14 -> A_locking_keylessly 
	* noun -> A_locking_keylessly 
	*  noun=Noun_Filter15 'with' noun -> Lock 
	*  noun=Noun_Filter16 'with' noun -> Lock 
	* noun '|__' 'with' noun -> Lock;
Verb 'unlock' 
	*  noun=Noun_Filter17 -> A_unlocking_keylessly 
	*  noun=Noun_Filter18 -> A_unlocking_keylessly 
	* noun -> A_unlocking_keylessly 
	*  noun=Noun_Filter19 'with' noun -> Unlock 
	*  noun=Noun_Filter20 'with' noun -> Unlock 
	* noun 'with' noun -> Unlock;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump' 
	* noun -> Attack 
	* noun -> A_hitting 
	* noun 'with' held -> A_hitting;
Verb 'wait' 'z//' 
	* -> Wait;
Verb 'answer' 'say' 'shout' 'speak' 
	* 'xyzzy' -> A_casting_xyzzy 
	* 'plugh' -> A_casting_plugh 
	* topic 'to' creature -> Answer reverse;
Verb 'tell' 
	* creature 'about' topic -> Tell;
Verb 'ask' 
	* creature 'for' noun -> AskFor 
	* creature 'about' topic -> Ask;
Verb 'eat' 
	* held -> Eat;
Verb 'sleep' 'nap' 
	* -> Sleep;
Verb 'climb' 'scale' 
	* noun -> Climb 
	* 'up' / 'over' noun -> Climb;
Verb 'buy' 'purchase' 
	* noun -> Buy 
	* multi -> Buy;
Verb 'squeeze' 'squash' 
	* noun -> Squeeze;
Verb 'swing' 
	* noun -> Swing 
	* 'on' noun -> Swing 
	* held 'at' noun -> A_hitting reverse;
Verb 'wake' 'awake' 'awaken' 
	* -> Wake 
	* 'up' -> Wake 
	* creature -> WakeOther 
	* creature 'up' -> WakeOther 
	* 'up' creature -> WakeOther;
Verb 'kiss' 'embrace' 'hug' 
	* creature -> Kiss;
Verb 'think' 
	* -> Think;
Verb 'smell' 'sniff' 
	* -> Smell 
	* noun -> Smell;
Verb 'listen' 
	* -> Listen 
	* 'to' noun -> Listen;
Verb 'hear' 
	* noun -> Listen;
Verb 'taste' 
	* noun -> Taste;
Verb 'touch' 'feel' 
	* noun -> Touch;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub' 
	* noun -> Rub;
Verb 'tie' 'attach' 'fasten' 
	* noun 'to' noun -> Tie;
Verb 'burn' 'light' 
	* noun -> Burn;
Verb 'drink' 'swallow' 'sip' 
	* noun -> Drink 
	* 'from'  noun=Noun_Filter21 -> Drink;
Verb 'cut' 'slice' 'prune' 'chop' 
	* noun -> Cut;
Verb 'jump' 'skip' 'hop' 
	* -> Jump;
Verb 'score' 
	* -> Score;
Verb 'quit' 
	* -> Quit;
Verb 'q//' 
	* -> Quit;
Verb 'save' 
	* -> Save;
Verb 'restart' 
	* -> Restart;
Verb 'restore' 
	* -> Restore;
Verb 'verify' 
	* -> Verify;
Verb 'version' 
	* -> Version;
Verb 'script' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'transcript' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'superbrief' 
	* -> LMode3;
Verb 'short' 
	* -> LMode3;
Verb 'verbose' 
	* -> LMode2;
Verb 'long' 
	* -> LMode2;
Verb 'brief' 
	* -> LMode1;
Verb 'normal' 
	* -> LMode1;
Verb 'nouns' 
	* -> Pronouns;
Verb 'pronouns' 
	* -> Pronouns;
Verb 'notify' 
	* -> NotifyOn 
	* 'on' -> NotifyOn 
	* 'off' -> NotifyOff;
Verb 'open' 
	* noun -> Open 
	*  noun=Noun_Filter22 'with' noun -> Unlock 
	*  noun=Noun_Filter23 'with' noun -> Unlock 
	* noun 'with' noun -> Unlock;
Verb 'uncover' 
	* noun -> Open;
Verb 'unlockall' 
	* -> A_universal_unlocking;
Verb 'help' 
	* -> A_asking_for_help;
Verb 'hint' 
	* -> A_asking_for_help;
Verb 'hints' 
	* -> A_asking_for_help;
Verb 'about' 
	* -> A_asking_for_help;
Verb 'info' 
	* -> A_asking_for_help;
Verb 'sing' 
	* -> Sing;
Verb 'pour' 
	*  noun=Noun_Filter24 'in' / 'into' / 'on' / 'onto'  noun=Noun_Filter25 -> A_pouring_it_into 
	* noun 'in' / 'into' / 'on' / 'onto' noun -> A_pouring_it_into;
Verb 'empty' 
	*  noun=Noun_Filter26 'into'  noun=Noun_Filter27 -> A_pouring_it_into 
	* noun 'into' noun -> A_pouring_it_into;
Verb 'fill' 
	*  noun=Noun_Filter28 'with' / 'from'  noun=Noun_Filter29 -> A_pouring_it_into reverse 
	* noun 'with' / 'from' noun -> A_pouring_it_into reverse;
Verb 'hide' 'shove' 'conceal' 'stick' 
	* held 'under' noun -> A_hiding_it_under;
Verb 'hello' 
	* noun -> A_hi_speaking;
Verb 'hi' 
	* noun -> A_hi_speaking;
Verb 'xyzzy' 
	* -> A_casting_xyzzy;
Verb 'cast' 
	* 'xyzzy' -> A_casting_xyzzy 
	* 'plugh' -> A_casting_plugh;
Verb 'plugh' 
	* -> A_casting_plugh;
Verb 'talk' 
	* Mistake_Token4 'to' creature -> MistakeAction 
	* 'about' noun -> A_talking_about 
	* Mistake_Token5 'to' creature 'about' noun -> MistakeAction 
	* 'about' topic -> A_talking_randomly_abou;
Verb 'full' 
	* -> A_requesting_the_comple 
	* 'score' -> A_requesting_the_comple;
Verb 'bother' 'curses' 'drat' 'darn' 
	* -> Mild;
Verb 'fuck' 'screw' 'suck' 'sodomize' 'rape' 
	* creature -> A_fucking 
	* noun -> A_fucking;
Verb 'no.verb' 
	* GPR_Line1 -> Strong;
Verb 'toggle' 
	*  noun=Noun_Filter30 -> Push 
	*  noun=Noun_Filter31 -> Push;
Verb 'flip' 
	*  noun=Noun_Filter32 -> Push 
	*  noun=Noun_Filter33 -> Push 
	* held 'at' / 'on' noun -> A_tossing;
Verb 'place' 
	* noun 'on' noun -> PutOn;
Verb 'strike' 
	* noun -> A_hitting 
	* noun 'with' held -> A_hitting;
Verb 'toss' 
	* held 'at' / 'on' noun -> A_tossing;
Verb 'spin' 
	* noun 'to' DECIMAL_TOKEN -> A_spinning_it_to;
Verb 'credits' 
	* -> A_crediting;
Verb meta 'glklist' 
	* -> GlkList;
Verb meta 'abstract' 
	*  scope=testcommandnoun 'to'  scope=testcommandnoun -> XAbstract;
Verb meta 'actions' 
	* -> ActionsOn 
	* 'on' -> ActionsOn 
	* 'off' -> ActionsOff;
Verb meta 'gonear' 
	*  scope=testcommandnoun -> Gonear;
Verb meta 'purloin' 
	*  scope=testcommandnoun -> XPurloin;
Verb meta 'random' 
	* -> Predictable;
Verb meta 'relations' 
	* -> ShowRelations;
Verb meta 'responses' 
	* -> ShowResponses 
	* special -> ShowResponses 
	* 'now' special -> ShowResponses 
	* 'set' special -> ShowResponses;
Verb meta 'rules' 
	* -> RulesOn 
	* 'all' -> RulesAll 
	* 'on' -> RulesOn 
	* 'off' -> RulesOff;
Verb meta 'scenes' 
	* -> ScenesOn 
	* 'on' -> ScenesOn 
	* 'off' -> ScenesOff;
Verb meta 'scope' 
	* -> Scope 
	*  scope=testcommandnoun -> Scope;
Verb meta 'showheap' 
	* -> ShowHeap;
Verb meta 'showme' 
	* -> ShowMe 
	*  scope=testcommandnoun -> ShowMe;
Verb meta 'showverb' 
	* special -> ShowVerb;
Verb meta 'test' 
	* -> TestScript 
	* special -> TestScript;
Verb meta 'trace' 
	* -> TraceOn 
	* number -> TraceLevel 
	* 'on' -> TraceOn 
	* 'off' -> TraceOff;
Verb meta 'tree' 
	* -> XTree 
	*  scope=testcommandnoun -> XTree;
